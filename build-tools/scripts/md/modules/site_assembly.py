# build-tools/scripts/md/modules/modules/site_assembly.py
"""
Handles final site assembly, asset generation, and config generation.
"""
import logging
import shutil
import json
import re
from pathlib import Path
from typing import List, Dict, Any, Optional

try:
    import yaml
    HAS_YAML = True
except ImportError:
    HAS_YAML = False

current_dir = Path(__file__).parent.parent
if str(current_dir) not in __import__('sys').path:
    __import__('sys').path.insert(0, str(current_dir))

from config.build_config import BuildConfig

#=======================================================================
# Functions for asset generation
#=======================================================================

def generate_macros_json(sty_content: str) -> str:
    """
    Parses LaTeX .sty content to find Agda term macros and returns a JSON string.
    Args:
        sty_content: The string content of the macros.sty file.
    Returns:
        A JSON formatted string containing the macro definitions.
    """
    # Pattern to capture MacroName (1), AgdaCommand (2), and the argument (3).
    pattern = re.compile(
        r'^\\newcommand\{\\([a-zA-Z@]+)\}\s*\{\s*\\(Agda[a-zA-Z]+)\{(.*?)\}\s*\}',
        re.MULTILINE
    )
    agda_terms_dict = {}
    for match in pattern.finditer(sty_content):
        macro_name = match.group(1)
        agda_class = match.group(2)
        agda_terms_dict[macro_name] = {
            "basename": macro_name,
            "agda_class": agda_class
        }

    output_json = {
        "//": "Auto-generated by generate_macros_json from build pipeline",
        "agda_terms": dict(sorted(agda_terms_dict.items())),
        "placeholders": {}
    }
    return json.dumps(output_json, indent=2)



def extract_agda_class_rules(css_text: str) -> Dict[str, str]:
    """
    Extracts `.Agda .ClassName { ... }` rules from a CSS string.
    Returns a dict: { ClassName: "property: value; ..." }
    """
    pattern = re.compile(r"\.Agda\s+\.([\w-]+)\s*\{\s*([^}]*)\}")
    return {
        match.group(1): re.sub(r'\s+', ' ', match.group(2).strip())
        for match in pattern.finditer(css_text)
    }


def generate_custom_css_from_agda(
    agda_css_content: str,
    existing_custom_css: Optional[str] = None,
    agda_dark_css_content: Optional[str] = None
) -> str:
    """
    Generates custom.css content by extracting colors from Agda.css.
    Supports optional dark-mode overrides from a second Agda-dark.css.

    Args:
        agda_css_content: The string content of the light-theme Agda.css file.
        existing_custom_css: Optional string content of an existing custom.css.
        agda_dark_css_content: Optional string content of a dark-theme Agda-dark.css.

    Returns:
        A single CSS string containing all light/dark theme styles and project styles.
    """
    # Light theme Agda styles
    light_rules = extract_agda_class_rules(agda_css_content)

    css_parts = [
        "/*",
        " * Custom CSS for Formal Ledger Specifications",
        " *",
        " * This file contains auto-generated Agda class styles (from Agda.css)",
        " * and project-specific customizations.",
        " */",
        "",
        "/* ======================================================================= */",
        "/* AUTO-GENERATED AGDA CLASSES (from Agda.css)                            */",
        "/* ======================================================================= */",
        "[data-md-color-scheme=\"default\"] {"
    ]

    for class_name, properties in sorted(light_rules.items()):
        rule = f"pre.Agda .{class_name} {{ {properties} }}"
        css_parts.append(rule)

    # Optional dark-mode overrides
    if agda_dark_css_content:
        dark_rules = extract_agda_class_rules(agda_dark_css_content)
        css_parts.extend([
            "",
            "/* ======================================================================= */",
            "/* DARK MODE OVERRIDES (from Agda-dark.css)                              */",
            "/* ======================================================================= */",
            "[data-md-color-scheme=\"slate\"] {"
        ])
        for class_name, props in sorted(dark_rules.items()):
            css_parts.append(f"  pre.Agda .{class_name} {{ {props} }}")
        css_parts.append("}")

    css_parts.extend([
        "",
        "/* ======================================================================= */",
        "/* PROJECT-SPECIFIC STYLES                                                */",
        "/* ======================================================================= */",
        ""
    ])

    if existing_custom_css and existing_custom_css.strip():
        css_parts.append(existing_custom_css.strip())
    else:
        css_parts.append("""
/* Highlighting for \\hldiff{} content */
.highlight {
    background-color: yellow;
    padding: 2px 4px;
    border-radius: 3px;
}

/* Caption styling */
.caption-text {
    font-style: italic;
    color: #666;
    margin-top: 0.5em;
}

/* Conway admonition styling */
.conway-specifics {
    border-left: 4px solid #2196F3;
    padding: 1em;
    margin: 1em 0;
    background-color: #f8f9fa;
}
""".strip())

    return "\n".join(css_parts) + "\n"


#=======================================================================
# Functions for site assembly
#=======================================================================

def copy_staged_to_mkdocs(config: BuildConfig) -> List[str]:
    """Copies contents of the staging directory to the MkDocs docs directory."""
    staging_dir = config.build_paths.build_md_pp_dir
    target_dir = config.build_paths.mkdocs_docs_dir

    logging.info(f"‚ôªÔ∏èÔ∏è  Copying staged content to MkDocs...")
    if not staging_dir.exists():
        logging.warning("Staging directory does not exist. Nothing to copy.")
        return []

    try:
        shutil.copytree(staging_dir, target_dir, dirs_exist_ok=True)
        copied_files = [item.name for item in target_dir.glob("*.md")]
        logging.info(f"‚úÖ Copied {len(copied_files)} files to {target_dir.name}/")
        return sorted(copied_files)
    except Exception as e:
        logging.error(f"‚ùå Failed to copy staged directory: {e}", exc_info=True)
        return []

def deploy_mkdocs_assets(config: BuildConfig, nav_files: List[str]) -> List[str]:
    """Deploys all static and generated assets to the MkDocs source folder."""
    logging.info("üèóÔ∏è  Deploying assets for MkDocs site...")

    # 1. Deploy CSS
    agda_css_path = config.build_paths.build_md_pp_dir / "Agda.css"
    if config.run_agda_html and agda_css_path.exists():
        agda_css_content = agda_css_path.read_text('utf-8')
        template_css_content = config.source_paths.custom_css_path.read_text('utf-8')
        agda_dark_path = config.source_paths.md_css_dir / "Agda-dark.css"
        agda_dark_css = agda_dark_path.read_text('utf-8') if agda_dark_path.exists() else None
        final_css = generate_custom_css_from_agda(
            agda_css_content=agda_css_content,
            existing_custom_css=template_css_content,
            agda_dark_css_content=agda_dark_css
        )
        (config.build_paths.mkdocs_css_dir / "custom.css").write_text(final_css, 'utf-8')
        shutil.copy2(agda_css_path, config.build_paths.mkdocs_css_dir)
        logging.info("‚úÖ Deployed generated custom.css and Agda.css.")

    # 2. Deploy JS
    shutil.copy2(config.source_paths.custom_js_path, config.build_paths.mkdocs_js_dir)
    shutil.copy2(config.source_paths.katex_js_path, config.build_paths.mkdocs_js_dir)
    logging.info("‚úÖ Deployed custom.js and KaTeX config.")

    # 3. Deploy Bibliography
    bib_source = config.source_paths.references_bib_path
    bib_target_dir = config.build_paths.mkdocs_includes_dir
    if bib_source.exists():
        bib_target_dir.mkdir(parents=True, exist_ok=True)
        shutil.copy2(bib_source, bib_target_dir)
        logging.info(f"‚úÖ Deployed bibliography: {bib_source.name}.")

   # 4. Handle index.md and guide.md by copying from root repo files
    home_page = "index.md"
    guide_page = "guide.md"
    # Copy README.md to docs/index.md
    readme_source_path = config.source_paths.readme_md_path
    index_target_path = config.build_paths.mkdocs_docs_dir / home_page

    if readme_source_path.exists():
        shutil.copy2(readme_source_path, index_target_path)
        # Ensure index.md is in the list of files for navigation generation
        if home_page not in [f.lower() for f in nav_files]:
            nav_files.append(home_page)
        logging.info(f"‚úÖ Deployed root {readme_source_path.name} as site index.")
    else:
        logging.warning(f"Root README.md not found at {readme_source_path}. Cannot create site index.")

    # Copy CONTRIBUTING.md to docs/guide.md
    contrib_source_path = config.source_paths.contributing_md_path
    guide_target_path = config.build_paths.mkdocs_docs_dir / guide_page
    if contrib_source_path.exists():
        shutil.copy2(contrib_source_path, guide_target_path)
        if guide_page not in [f.lower() for f in nav_files]:
            nav_files.append(guide_page)
        logging.info(f"‚úÖ Deployed root {contrib_source_path.name} as interactive guide page.")
    else:
        logging.warning(f"Root CONTRIBUTING.md not found at {contrib_source_path}. Cannot create guide page.")

    return sorted(list(set(nav_files)), key=lambda f: (f.lower() != home_page.lower(), f.lower()))


#=======================================================================
# Functions for config generation
#=======================================================================

def _build_nav_from_files(files: List[str]) -> List[Dict[str, Any]]:
    """Helper to build a hierarchical navigation tree."""
    nav_tree, home_file = {}, "index.md"
    sorted_files = sorted(list(set(files)), key=lambda f: (f.lower() != home_file.lower(), f.lower()))
    home_entry = next(({'Home': f} for f in sorted_files if f.lower() == home_file.lower()), None)

    for file in (f for f in sorted_files if f.lower() != home_file.lower()):
        parts = Path(file).stem.split('.')
        level = nav_tree
        for i, part in enumerate(parts):
            if i == len(parts) - 1:
                level[part] = file
            else:
                if part not in level: level[part] = {}
                level = level[part]

    def format_nav(tree: Dict) -> List:
        return sorted([{k: format_nav(v) if isinstance(v, dict) else v} for k, v in tree.items()], key=lambda d: list(d.keys())[0])

    final_nav = format_nav(nav_tree)
    if home_entry: final_nav.insert(0, home_entry)
    return final_nav

def generate_mkdocs_config(config: BuildConfig, nav_files: List[str]):
    """Generates the final mkdocs.yml by merging a template with dynamic data."""
    logging.info("üèóÔ∏è  Generating mkdocs.yml configuration...")
    template_path = config.build_paths.mkdocs_dir / "mkdocs.yml"

    cfg = {}
    if template_path.exists() and HAS_YAML:
        cfg = yaml.safe_load(template_path.read_text('utf-8')) or {}
        logging.info(f"‚úÖ Loaded base configuration from {template_path.name}")

    # --- Explicitly set use_directory_urls to False ---
    # This ensures that MkDocs generates URLs like `page.html` instead of `page/`,
    # which is required for the Agda-generated links to work correctly.
    cfg['use_directory_urls'] = False

    # Merge CSS/JS lists, preserving template values
    template_css = cfg.get("extra_css", [])
    [template_css.append(css) for css in config.site_config.dynamic_css_files if css not in template_css]
    cfg['extra_css'] = template_css

    template_js = cfg.get("extra_javascript", [])
    [template_js.append(js) for js in config.site_config.dynamic_js_files if js not in template_js]
    cfg['extra_javascript'] = template_js

    # Build navigation
    nav_template_path = config.source_paths.mkdocs_nav_yml_path
    if nav_template_path.exists() and HAS_YAML:
        logging.info(f"üèóÔ∏è  Loading navigation from template: {nav_template_path.name}...")
        nav_structure = yaml.safe_load(nav_template_path.read_text('utf-8'))
    else:
        logging.info("Generating navigation from processed files.")
        nav_structure = _build_nav_from_files(nav_files)

    # --- Add References page to end of navigation ---
    if (config.build_paths.mkdocs_docs_dir / "references.md").exists():
        # Ensure it's not already there from a template
        if not any("references.md" in str(item) for item in nav_structure):
             nav_structure.append({'References': 'references.md'})

    cfg['nav'] = nav_structure

    with open(template_path, "w", encoding="utf-8") as f:
        yaml.dump(cfg, f, sort_keys=False, allow_unicode=True) if HAS_YAML else json.dump(cfg, f, indent=2)
    logging.info(f"‚úÖ Final configuration written to {template_path.name}")
