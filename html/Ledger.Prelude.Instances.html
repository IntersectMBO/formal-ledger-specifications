<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Ledger.Prelude.Instances</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css"><link rel="stylesheet" href="Agda.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"></script><script src="AgdaKaTeX.js" defer=""></script></head><body><pre class="Agda">
<a id="2" class="Symbol">{-#</a> <a id="6" class="Keyword">OPTIONS</a> <a id="14" class="Pragma">--safe</a> <a id="21" class="Symbol">#-}</a>

<a id="26" class="Keyword">module</a> <a id="33" href="Ledger.Prelude.Instances.html" class="Module">Ledger.Prelude.Instances</a> <a id="58" class="Keyword">where</a>

<a id="65" class="Keyword">open</a> <a id="70" class="Keyword">import</a> <a id="77" href="Prelude.html" class="Module">Prelude</a>
<a id="85" class="Keyword">open</a> <a id="90" class="Keyword">import</a> <a id="97" href="Ledger.Prelude.Base.html" class="Module">Ledger.Prelude.Base</a>
<a id="117" class="Keyword">open</a> <a id="122" class="Keyword">import</a> <a id="129" href="Ledger.Prelude.HasCoin.html" class="Module">Ledger.Prelude.HasCoin</a>
<a id="152" class="Keyword">open</a> <a id="157" class="Keyword">import</a> <a id="164" href="Interface.HasSubtract.html" class="Module">Interface.HasSubtract</a>
<a id="186" class="Keyword">open</a> <a id="191" class="Keyword">import</a> <a id="198" href="Interface.HasSubset.html" class="Module">Interface.HasSubset</a>

<a id="219" class="Keyword">open</a> <a id="224" class="Keyword">import</a> <a id="231" href="abstract-set-theory.FiniteSetTheory.html" class="Module">abstract-set-theory.FiniteSetTheory</a>
  <a id="269" class="Keyword">renaming</a> <a id="278" class="Symbol">(</a><a id="279" href="Axiom.Set.html#1998" class="Function Operator">_⊆_</a> <a id="283" class="Symbol">to</a> <a id="286" class="Function Operator">_⊆ˢ_</a><a id="290" class="Symbol">)</a>

<a id="293" class="Keyword">instance</a>
  <a id="CommMonoid-ℕ-+"></a><a id="304" href="Ledger.Prelude.Instances.html#304" class="Function">CommMonoid-ℕ-+</a> <a id="319" class="Symbol">=</a> <a id="321" href="Class.CommutativeMonoid.Instances.html#196" class="Function">NonUniqueInstances.CommMonoid-ℕ-+</a>

  <a id="HasCoin-Map"></a><a id="358" href="Ledger.Prelude.Instances.html#358" class="Function">HasCoin-Map</a> <a id="370" class="Symbol">:</a> <a id="372" class="Symbol">∀</a> <a id="374" class="Symbol">{</a><a id="375" href="Ledger.Prelude.Instances.html#375" class="Bound">A</a><a id="376" class="Symbol">}</a> <a id="378" class="Symbol">→</a> <a id="380" class="Symbol">⦃</a> <a id="382" href="Class.DecEq.Core.html#126" class="Record">DecEq</a> <a id="388" href="Ledger.Prelude.Instances.html#375" class="Bound">A</a> <a id="390" class="Symbol">⦄</a> <a id="392" class="Symbol">→</a> <a id="394" href="Ledger.Prelude.HasCoin.html#123" class="Record">HasCoin</a> <a id="402" class="Symbol">(</a><a id="403" href="Ledger.Prelude.Instances.html#375" class="Bound">A</a> <a id="405" href="abstract-set-theory.FiniteSetTheory.html#633" class="Function Operator">⇀</a> <a id="407" href="Ledger.Prelude.Base.html#154" class="Function">Coin</a><a id="411" class="Symbol">)</a>
  <a id="415" href="Ledger.Prelude.Instances.html#358" class="Function">HasCoin-Map</a> <a id="427" class="Symbol">.</a><a id="428" href="Ledger.Prelude.HasCoin.html#171" class="Field">getCoin</a> <a id="436" href="Ledger.Prelude.Instances.html#436" class="Bound">s</a> <a id="438" class="Symbol">=</a> <a id="440" href="abstract-set-theory.FiniteSetTheory.html#4312" class="Function">∑[</a> <a id="443" href="Ledger.Prelude.Instances.html#443" class="Bound">x</a> <a id="445" href="abstract-set-theory.FiniteSetTheory.html#4312" class="Function">←</a> <a id="447" href="Ledger.Prelude.Instances.html#436" class="Bound">s</a> <a id="449" href="abstract-set-theory.FiniteSetTheory.html#4312" class="Function">]</a> <a id="451" href="Ledger.Prelude.Instances.html#443" class="Bound">x</a>

  <a id="HasCoin-Set"></a><a id="456" href="Ledger.Prelude.Instances.html#456" class="Function">HasCoin-Set</a> <a id="468" class="Symbol">:</a> <a id="470" class="Symbol">∀</a> <a id="472" class="Symbol">{</a><a id="473" href="Ledger.Prelude.Instances.html#473" class="Bound">A</a><a id="474" class="Symbol">}</a> <a id="476" class="Symbol">→</a> <a id="478" class="Symbol">⦃</a> <a id="480" href="Class.DecEq.Core.html#126" class="Record">DecEq</a> <a id="486" href="Ledger.Prelude.Instances.html#473" class="Bound">A</a> <a id="488" class="Symbol">⦄</a> <a id="490" class="Symbol">→</a> <a id="492" href="Ledger.Prelude.HasCoin.html#123" class="Record">HasCoin</a> <a id="500" class="Symbol">(</a><a id="501" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="503" class="Symbol">(</a><a id="504" href="Ledger.Prelude.Instances.html#473" class="Bound">A</a> <a id="506" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="508" href="Ledger.Prelude.Base.html#154" class="Function">Coin</a><a id="512" class="Symbol">))</a>
  <a id="517" href="Ledger.Prelude.Instances.html#456" class="Function">HasCoin-Set</a> <a id="529" class="Symbol">.</a><a id="530" href="Ledger.Prelude.HasCoin.html#171" class="Field">getCoin</a> <a id="538" href="Ledger.Prelude.Instances.html#538" class="Bound">s</a> <a id="540" class="Symbol">=</a> <a id="542" href="abstract-set-theory.FiniteSetTheory.html#4448" class="Function">∑ˢ[</a> <a id="546" href="Ledger.Prelude.Instances.html#546" class="Bound">(</a><a id="547" href="Ledger.Prelude.Instances.html#547" class="Bound">a</a> <a id="549" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="551" href="Ledger.Prelude.Instances.html#551" class="Bound">c</a><a id="552" href="Ledger.Prelude.Instances.html#546" class="Bound">)</a> <a id="554" href="abstract-set-theory.FiniteSetTheory.html#4448" class="Function">←</a> <a id="556" href="Ledger.Prelude.Instances.html#538" class="Bound">s</a> <a id="558" href="abstract-set-theory.FiniteSetTheory.html#4448" class="Function">]</a> <a id="560" href="Ledger.Prelude.Instances.html#551" class="Bound">c</a>

  <a id="HasSubset-Set"></a><a id="565" href="Ledger.Prelude.Instances.html#565" class="Function">HasSubset-Set</a> <a id="579" class="Symbol">:</a> <a id="581" class="Symbol">∀</a> <a id="583" class="Symbol">{</a><a id="584" href="Ledger.Prelude.Instances.html#584" class="Bound">A</a><a id="585" class="Symbol">}</a> <a id="587" class="Symbol">→</a> <a id="589" href="Interface.HasSubset.html#105" class="Record">HasSubset</a> <a id="599" class="Symbol">(</a><a id="600" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="602" href="Ledger.Prelude.Instances.html#584" class="Bound">A</a><a id="603" class="Symbol">)</a>
  <a id="607" href="Ledger.Prelude.Instances.html#565" class="Function">HasSubset-Set</a> <a id="621" class="Symbol">.</a><a id="622" href="Interface.HasSubset.html#159" class="Field Operator">_⊆_</a> <a id="626" class="Symbol">=</a> <a id="628" href="Ledger.Prelude.Instances.html#286" class="Function Operator">_⊆ˢ_</a>

  <a id="HasSubtract-ℙ"></a><a id="636" href="Ledger.Prelude.Instances.html#636" class="Function">HasSubtract-ℙ</a> <a id="650" class="Symbol">:</a> <a id="652" class="Symbol">∀</a> <a id="654" class="Symbol">{</a><a id="655" href="Ledger.Prelude.Instances.html#655" class="Bound">A</a><a id="656" class="Symbol">}</a> <a id="658" class="Symbol">→</a> <a id="660" class="Symbol">⦃</a> <a id="662" href="Class.DecEq.Core.html#126" class="Record">DecEq</a> <a id="668" href="Ledger.Prelude.Instances.html#655" class="Bound">A</a> <a id="670" class="Symbol">⦄</a> <a id="672" class="Symbol">→</a> <a id="674" href="Interface.HasSubtract.html#149" class="Record">HasSubtract</a> <a id="686" class="Symbol">(</a><a id="687" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="689" href="Ledger.Prelude.Instances.html#655" class="Bound">A</a><a id="690" class="Symbol">)</a> <a id="692" class="Symbol">(</a><a id="693" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="695" href="Ledger.Prelude.Instances.html#655" class="Bound">A</a><a id="696" class="Symbol">)</a>
  <a id="700" href="Ledger.Prelude.Instances.html#636" class="Function">HasSubtract-ℙ</a> <a id="714" class="Symbol">{</a><a id="715" href="Ledger.Prelude.Instances.html#715" class="Bound">A</a><a id="716" class="Symbol">}</a> <a id="718" class="Symbol">.</a><a id="719" href="Interface.HasSubtract.html#210" class="Field Operator">_-_</a> <a id="723" class="Symbol">=</a> <a id="725" href="Axiom.Set.html#9839" class="Function Operator">_＼_</a>

  <a id="HasSubset-Map"></a><a id="732" href="Ledger.Prelude.Instances.html#732" class="Function">HasSubset-Map</a> <a id="746" class="Symbol">:</a> <a id="748" class="Symbol">{</a><a id="749" href="Ledger.Prelude.Instances.html#749" class="Bound">A</a> <a id="751" href="Ledger.Prelude.Instances.html#751" class="Bound">B</a> <a id="753" class="Symbol">:</a> <a id="755" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="758" class="Symbol">}</a> <a id="760" class="Symbol">→</a> <a id="762" href="Interface.HasSubset.html#105" class="Record">HasSubset</a> <a id="772" class="Symbol">(</a><a id="773" href="Ledger.Prelude.Instances.html#749" class="Bound">A</a> <a id="775" href="abstract-set-theory.FiniteSetTheory.html#633" class="Function Operator">⇀</a> <a id="777" href="Ledger.Prelude.Instances.html#751" class="Bound">B</a><a id="778" class="Symbol">)</a>
  <a id="782" href="Ledger.Prelude.Instances.html#732" class="Function">HasSubset-Map</a> <a id="796" class="Symbol">{</a><a id="797" href="Ledger.Prelude.Instances.html#797" class="Bound">A</a><a id="798" class="Symbol">}</a> <a id="800" class="Symbol">{</a><a id="801" href="Ledger.Prelude.Instances.html#801" class="Bound">B</a><a id="802" class="Symbol">}</a> <a id="804" class="Symbol">.</a><a id="805" href="Interface.HasSubset.html#159" class="Field Operator">_⊆_</a> <a id="809" href="Ledger.Prelude.Instances.html#809" class="Bound">m₁</a> <a id="812" href="Ledger.Prelude.Instances.html#812" class="Bound">m₂</a> <a id="815" class="Symbol">=</a> <a id="817" class="Symbol">{</a><a id="818" href="Ledger.Prelude.Instances.html#818" class="Bound">k</a> <a id="820" class="Symbol">:</a> <a id="822" href="Ledger.Prelude.Instances.html#797" class="Bound">A</a><a id="823" class="Symbol">}</a> <a id="825" class="Symbol">{</a><a id="826" href="Ledger.Prelude.Instances.html#826" class="Bound">v</a> <a id="828" class="Symbol">:</a> <a id="830" href="Ledger.Prelude.Instances.html#801" class="Bound">B</a><a id="831" class="Symbol">}</a> <a id="833" class="Symbol">→</a> <a id="835" class="Symbol">(</a><a id="836" href="Ledger.Prelude.Instances.html#818" class="Bound">k</a> <a id="838" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="840" href="Ledger.Prelude.Instances.html#826" class="Bound">v</a><a id="841" class="Symbol">)</a> <a id="843" href="Class.IsSet.html#458" class="Function Operator">∈</a> <a id="845" class="Symbol">(</a><a id="846" href="Ledger.Prelude.Instances.html#809" class="Bound">m₁</a> <a id="849" href="Axiom.Set.Map.html#2293" class="Function Operator">ˢ</a><a id="850" class="Symbol">)</a> <a id="852" class="Symbol">→</a> <a id="854" class="Symbol">(</a><a id="855" href="Ledger.Prelude.Instances.html#818" class="Bound">k</a> <a id="857" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="859" href="Ledger.Prelude.Instances.html#826" class="Bound">v</a><a id="860" class="Symbol">)</a> <a id="862" href="Class.IsSet.html#458" class="Function Operator">∈</a> <a id="864" class="Symbol">(</a><a id="865" href="Ledger.Prelude.Instances.html#812" class="Bound">m₂</a> <a id="868" href="Axiom.Set.Map.html#2293" class="Function Operator">ˢ</a><a id="869" class="Symbol">)</a>



</pre></body></html>