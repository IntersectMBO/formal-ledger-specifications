<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Ledger.Prelude.Instances</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css"><link rel="stylesheet" href="Agda.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"></script><script src="AgdaKaTeX.js" defer=""></script></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>

<a id="25" class="Keyword">module</a> <a id="32" href="Ledger.Prelude.Instances.html" class="Module">Ledger.Prelude.Instances</a> <a id="57" class="Keyword">where</a>

<a id="64" class="Keyword">open</a> <a id="69" class="Keyword">import</a> <a id="76" href="Prelude.html" class="Module">Prelude</a>
<a id="84" class="Keyword">open</a> <a id="89" class="Keyword">import</a> <a id="96" href="Ledger.Prelude.Base.html" class="Module">Ledger.Prelude.Base</a>
<a id="116" class="Keyword">open</a> <a id="121" class="Keyword">import</a> <a id="128" href="Ledger.Interface.HasCoin.html" class="Module">Ledger.Interface.HasCoin</a>
<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="Interface.HasSubtract.html" class="Module">Interface.HasSubtract</a>
<a id="187" class="Keyword">open</a> <a id="192" class="Keyword">import</a> <a id="199" href="Interface.HasSubset.html" class="Module">Interface.HasSubset</a>

<a id="220" class="Keyword">open</a> <a id="225" class="Keyword">import</a> <a id="232" href="abstract-set-theory.FiniteSetTheory.html" class="Module">abstract-set-theory.FiniteSetTheory</a>
  <a id="270" class="Keyword">renaming</a> <a id="279" class="Symbol">(</a><a id="280" href="Axiom.Set.html#1813" class="Function Operator">_⊆_</a> <a id="284" class="Symbol">to</a> <a id="287" class="Function Operator">_⊆ˢ_</a><a id="291" class="Symbol">)</a>

<a id="294" class="Keyword">instance</a>
  <a id="CommMonoid-ℕ-+"></a><a id="305" href="Ledger.Prelude.Instances.html#305" class="Function">CommMonoid-ℕ-+</a> <a id="320" class="Symbol">=</a> <a id="322" href="Class.CommutativeMonoid.Instances.html#196" class="Function">NonUniqueInstances.CommMonoid-ℕ-+</a>

  <a id="HasCoin-Map"></a><a id="359" href="Ledger.Prelude.Instances.html#359" class="Function">HasCoin-Map</a> <a id="371" class="Symbol">:</a> <a id="373" class="Symbol">∀</a> <a id="375" class="Symbol">{</a><a id="376" href="Ledger.Prelude.Instances.html#376" class="Bound">A</a><a id="377" class="Symbol">}</a> <a id="379" class="Symbol">→</a> <a id="381" class="Symbol">⦃</a> <a id="383" href="Class.DecEq.Core.html#117" class="Record">DecEq</a> <a id="389" href="Ledger.Prelude.Instances.html#376" class="Bound">A</a> <a id="391" class="Symbol">⦄</a> <a id="393" class="Symbol">→</a> <a id="395" href="Ledger.Interface.HasCoin.html#124" class="Record">HasCoin</a> <a id="403" class="Symbol">(</a><a id="404" href="Ledger.Prelude.Instances.html#376" class="Bound">A</a> <a id="406" href="abstract-set-theory.FiniteSetTheory.html#633" class="Function Operator">⇀</a> <a id="408" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a><a id="412" class="Symbol">)</a>
  <a id="416" href="Ledger.Prelude.Instances.html#359" class="Function">HasCoin-Map</a> <a id="428" class="Symbol">.</a><a id="429" href="Ledger.Interface.HasCoin.html#172" class="Field">getCoin</a> <a id="437" href="Ledger.Prelude.Instances.html#437" class="Bound">s</a> <a id="439" class="Symbol">=</a> <a id="441" href="abstract-set-theory.FiniteSetTheory.html#3166" class="Function">∑[</a> <a id="444" href="Ledger.Prelude.Instances.html#444" class="Bound">x</a> <a id="446" href="abstract-set-theory.FiniteSetTheory.html#3166" class="Function">←</a> <a id="448" href="Ledger.Prelude.Instances.html#437" class="Bound">s</a> <a id="450" href="abstract-set-theory.FiniteSetTheory.html#3166" class="Function">]</a> <a id="452" href="Ledger.Prelude.Instances.html#444" class="Bound">x</a>

  <a id="HasCoin-Set"></a><a id="457" href="Ledger.Prelude.Instances.html#457" class="Function">HasCoin-Set</a> <a id="469" class="Symbol">:</a> <a id="471" class="Symbol">∀</a> <a id="473" class="Symbol">{</a><a id="474" href="Ledger.Prelude.Instances.html#474" class="Bound">A</a><a id="475" class="Symbol">}</a> <a id="477" class="Symbol">→</a> <a id="479" class="Symbol">⦃</a> <a id="481" href="Class.DecEq.Core.html#117" class="Record">DecEq</a> <a id="487" href="Ledger.Prelude.Instances.html#474" class="Bound">A</a> <a id="489" class="Symbol">⦄</a> <a id="491" class="Symbol">→</a> <a id="493" href="Ledger.Interface.HasCoin.html#124" class="Record">HasCoin</a> <a id="501" class="Symbol">(</a><a id="502" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="504" class="Symbol">(</a><a id="505" href="Ledger.Prelude.Instances.html#474" class="Bound">A</a> <a id="507" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="509" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a><a id="513" class="Symbol">))</a>
  <a id="518" href="Ledger.Prelude.Instances.html#457" class="Function">HasCoin-Set</a> <a id="530" class="Symbol">.</a><a id="531" href="Ledger.Interface.HasCoin.html#172" class="Field">getCoin</a> <a id="539" href="Ledger.Prelude.Instances.html#539" class="Bound">s</a> <a id="541" class="Symbol">=</a> <a id="543" href="abstract-set-theory.FiniteSetTheory.html#3302" class="Function">∑ˢ[</a> <a id="547" href="Ledger.Prelude.Instances.html#547" class="Bound">(</a><a id="548" href="Ledger.Prelude.Instances.html#548" class="Bound">a</a> <a id="550" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="552" href="Ledger.Prelude.Instances.html#552" class="Bound">c</a><a id="553" href="Ledger.Prelude.Instances.html#547" class="Bound">)</a> <a id="555" href="abstract-set-theory.FiniteSetTheory.html#3302" class="Function">←</a> <a id="557" href="Ledger.Prelude.Instances.html#539" class="Bound">s</a> <a id="559" href="abstract-set-theory.FiniteSetTheory.html#3302" class="Function">]</a> <a id="561" href="Ledger.Prelude.Instances.html#552" class="Bound">c</a>

  <a id="HasSubset-Set"></a><a id="566" href="Ledger.Prelude.Instances.html#566" class="Function">HasSubset-Set</a> <a id="580" class="Symbol">:</a> <a id="582" class="Symbol">∀</a> <a id="584" class="Symbol">{</a><a id="585" href="Ledger.Prelude.Instances.html#585" class="Bound">A</a><a id="586" class="Symbol">}</a> <a id="588" class="Symbol">→</a> <a id="590" href="Interface.HasSubset.html#104" class="Record">HasSubset</a> <a id="600" class="Symbol">(</a><a id="601" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="603" href="Ledger.Prelude.Instances.html#585" class="Bound">A</a><a id="604" class="Symbol">)</a>
  <a id="608" href="Ledger.Prelude.Instances.html#566" class="Function">HasSubset-Set</a> <a id="622" class="Symbol">.</a><a id="623" href="Interface.HasSubset.html#158" class="Field Operator">_⊆_</a> <a id="627" class="Symbol">=</a> <a id="629" href="Ledger.Prelude.Instances.html#287" class="Function Operator">_⊆ˢ_</a>

  <a id="HasSubtract-ℙ"></a><a id="637" href="Ledger.Prelude.Instances.html#637" class="Function">HasSubtract-ℙ</a> <a id="651" class="Symbol">:</a> <a id="653" class="Symbol">∀</a> <a id="655" class="Symbol">{</a><a id="656" href="Ledger.Prelude.Instances.html#656" class="Bound">A</a><a id="657" class="Symbol">}</a> <a id="659" class="Symbol">→</a> <a id="661" class="Symbol">⦃</a> <a id="663" href="Class.DecEq.Core.html#117" class="Record">DecEq</a> <a id="669" href="Ledger.Prelude.Instances.html#656" class="Bound">A</a> <a id="671" class="Symbol">⦄</a> <a id="673" class="Symbol">→</a> <a id="675" href="Interface.HasSubtract.html#148" class="Record">HasSubtract</a> <a id="687" class="Symbol">(</a><a id="688" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="690" href="Ledger.Prelude.Instances.html#656" class="Bound">A</a><a id="691" class="Symbol">)</a> <a id="693" class="Symbol">(</a><a id="694" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="696" href="Ledger.Prelude.Instances.html#656" class="Bound">A</a><a id="697" class="Symbol">)</a>
  <a id="701" href="Ledger.Prelude.Instances.html#637" class="Function">HasSubtract-ℙ</a> <a id="715" class="Symbol">{</a><a id="716" href="Ledger.Prelude.Instances.html#716" class="Bound">A</a><a id="717" class="Symbol">}</a> <a id="719" class="Symbol">.</a><a id="720" href="Interface.HasSubtract.html#209" class="Field Operator">_-_</a> <a id="724" class="Symbol">=</a> <a id="726" href="Axiom.Set.html#9654" class="Function Operator">_＼_</a>

  <a id="HasSubset-Map"></a><a id="733" href="Ledger.Prelude.Instances.html#733" class="Function">HasSubset-Map</a> <a id="747" class="Symbol">:</a> <a id="749" class="Symbol">{</a><a id="750" href="Ledger.Prelude.Instances.html#750" class="Bound">A</a> <a id="752" href="Ledger.Prelude.Instances.html#752" class="Bound">B</a> <a id="754" class="Symbol">:</a> <a id="756" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="759" class="Symbol">}</a> <a id="761" class="Symbol">→</a> <a id="763" href="Interface.HasSubset.html#104" class="Record">HasSubset</a> <a id="773" class="Symbol">(</a><a id="774" href="Ledger.Prelude.Instances.html#750" class="Bound">A</a> <a id="776" href="abstract-set-theory.FiniteSetTheory.html#633" class="Function Operator">⇀</a> <a id="778" href="Ledger.Prelude.Instances.html#752" class="Bound">B</a><a id="779" class="Symbol">)</a>
  <a id="783" href="Ledger.Prelude.Instances.html#733" class="Function">HasSubset-Map</a> <a id="797" class="Symbol">{</a><a id="798" href="Ledger.Prelude.Instances.html#798" class="Bound">A</a><a id="799" class="Symbol">}</a> <a id="801" class="Symbol">{</a><a id="802" href="Ledger.Prelude.Instances.html#802" class="Bound">B</a><a id="803" class="Symbol">}</a> <a id="805" class="Symbol">.</a><a id="806" href="Interface.HasSubset.html#158" class="Field Operator">_⊆_</a> <a id="810" href="Ledger.Prelude.Instances.html#810" class="Bound">m₁</a> <a id="813" href="Ledger.Prelude.Instances.html#813" class="Bound">m₂</a> <a id="816" class="Symbol">=</a> <a id="818" class="Symbol">{</a><a id="819" href="Ledger.Prelude.Instances.html#819" class="Bound">k</a> <a id="821" class="Symbol">:</a> <a id="823" href="Ledger.Prelude.Instances.html#798" class="Bound">A</a><a id="824" class="Symbol">}</a> <a id="826" class="Symbol">{</a><a id="827" href="Ledger.Prelude.Instances.html#827" class="Bound">v</a> <a id="829" class="Symbol">:</a> <a id="831" href="Ledger.Prelude.Instances.html#802" class="Bound">B</a><a id="832" class="Symbol">}</a> <a id="834" class="Symbol">→</a> <a id="836" class="Symbol">(</a><a id="837" href="Ledger.Prelude.Instances.html#819" class="Bound">k</a> <a id="839" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="841" href="Ledger.Prelude.Instances.html#827" class="Bound">v</a><a id="842" class="Symbol">)</a> <a id="844" href="Class.IsSet.html#458" class="Function Operator">∈</a> <a id="846" class="Symbol">(</a><a id="847" href="Ledger.Prelude.Instances.html#810" class="Bound">m₁</a> <a id="850" href="Axiom.Set.Map.html#2293" class="Function Operator">ˢ</a><a id="851" class="Symbol">)</a> <a id="853" class="Symbol">→</a> <a id="855" class="Symbol">(</a><a id="856" href="Ledger.Prelude.Instances.html#819" class="Bound">k</a> <a id="858" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="860" href="Ledger.Prelude.Instances.html#827" class="Bound">v</a><a id="861" class="Symbol">)</a> <a id="863" href="Class.IsSet.html#458" class="Function Operator">∈</a> <a id="865" class="Symbol">(</a><a id="866" href="Ledger.Prelude.Instances.html#813" class="Bound">m₂</a> <a id="869" href="Axiom.Set.Map.html#2293" class="Function Operator">ˢ</a><a id="870" class="Symbol">)</a>


</pre></body></html>