<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Ledger.Prelude.Instances</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css"><link rel="stylesheet" href="Agda.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"></script><script src="AgdaKaTeX.js" defer=""></script></head><body><pre class="Agda">
<a id="2" class="Symbol">{-#</a> <a id="6" class="Keyword">OPTIONS</a> <a id="14" class="Pragma">--safe</a> <a id="21" class="Symbol">#-}</a>

<a id="26" class="Keyword">module</a> <a id="33" href="Ledger.Prelude.Instances.html" class="Module">Ledger.Prelude.Instances</a> <a id="58" class="Keyword">where</a>

<a id="65" class="Keyword">open</a> <a id="70" class="Keyword">import</a> <a id="77" href="Prelude.html" class="Module">Prelude</a>
<a id="85" class="Keyword">open</a> <a id="90" class="Keyword">import</a> <a id="97" href="Ledger.Prelude.Base.html" class="Module">Ledger.Prelude.Base</a>
<a id="117" class="Keyword">open</a> <a id="122" class="Keyword">import</a> <a id="129" href="Ledger.Prelude.HasCoin.html" class="Module">Ledger.Prelude.HasCoin</a>
<a id="152" class="Keyword">open</a> <a id="157" class="Keyword">import</a> <a id="164" href="Interface.TypeClasses.HasSubtract.html" class="Module">Interface.TypeClasses.HasSubtract</a>
<a id="198" class="Keyword">open</a> <a id="203" class="Keyword">import</a> <a id="210" href="Interface.TypeClasses.HasSubset.html" class="Module">Interface.TypeClasses.HasSubset</a>

<a id="243" class="Keyword">open</a> <a id="248" class="Keyword">import</a> <a id="255" href="abstract-set-theory.FiniteSetTheory.html" class="Module">abstract-set-theory.FiniteSetTheory</a>
  <a id="293" class="Keyword">renaming</a> <a id="302" class="Symbol">(</a><a id="303" href="Axiom.Set.html#1998" class="Function Operator">_⊆_</a> <a id="307" class="Symbol">to</a> <a id="310" class="Function Operator">_⊆ˢ_</a><a id="314" class="Symbol">)</a>

<a id="317" class="Keyword">instance</a>
  <a id="CommMonoid-ℕ-+"></a><a id="328" href="Ledger.Prelude.Instances.html#328" class="Function">CommMonoid-ℕ-+</a> <a id="343" class="Symbol">=</a> <a id="345" href="Class.CommutativeMonoid.Instances.html#196" class="Function">NonUniqueInstances.CommMonoid-ℕ-+</a>

  <a id="HasCoin-Map"></a><a id="382" href="Ledger.Prelude.Instances.html#382" class="Function">HasCoin-Map</a> <a id="394" class="Symbol">:</a> <a id="396" class="Symbol">∀</a> <a id="398" class="Symbol">{</a><a id="399" href="Ledger.Prelude.Instances.html#399" class="Bound">A</a><a id="400" class="Symbol">}</a> <a id="402" class="Symbol">→</a> <a id="404" class="Symbol">⦃</a> <a id="406" href="Class.DecEq.Core.html#126" class="Record">DecEq</a> <a id="412" href="Ledger.Prelude.Instances.html#399" class="Bound">A</a> <a id="414" class="Symbol">⦄</a> <a id="416" class="Symbol">→</a> <a id="418" href="Ledger.Prelude.HasCoin.html#123" class="Record">HasCoin</a> <a id="426" class="Symbol">(</a><a id="427" href="Ledger.Prelude.Instances.html#399" class="Bound">A</a> <a id="429" href="abstract-set-theory.FiniteSetTheory.html#633" class="Function Operator">⇀</a> <a id="431" href="Ledger.Prelude.Base.html#154" class="Function">Coin</a><a id="435" class="Symbol">)</a>
  <a id="439" href="Ledger.Prelude.Instances.html#382" class="Function">HasCoin-Map</a> <a id="451" class="Symbol">.</a><a id="452" href="Ledger.Prelude.HasCoin.html#171" class="Field">getCoin</a> <a id="460" href="Ledger.Prelude.Instances.html#460" class="Bound">s</a> <a id="462" class="Symbol">=</a> <a id="464" href="abstract-set-theory.FiniteSetTheory.html#4312" class="Function">∑[</a> <a id="467" href="Ledger.Prelude.Instances.html#467" class="Bound">x</a> <a id="469" href="abstract-set-theory.FiniteSetTheory.html#4312" class="Function">←</a> <a id="471" href="Ledger.Prelude.Instances.html#460" class="Bound">s</a> <a id="473" href="abstract-set-theory.FiniteSetTheory.html#4312" class="Function">]</a> <a id="475" href="Ledger.Prelude.Instances.html#467" class="Bound">x</a>

  <a id="HasCoin-Set"></a><a id="480" href="Ledger.Prelude.Instances.html#480" class="Function">HasCoin-Set</a> <a id="492" class="Symbol">:</a> <a id="494" class="Symbol">∀</a> <a id="496" class="Symbol">{</a><a id="497" href="Ledger.Prelude.Instances.html#497" class="Bound">A</a><a id="498" class="Symbol">}</a> <a id="500" class="Symbol">→</a> <a id="502" class="Symbol">⦃</a> <a id="504" href="Class.DecEq.Core.html#126" class="Record">DecEq</a> <a id="510" href="Ledger.Prelude.Instances.html#497" class="Bound">A</a> <a id="512" class="Symbol">⦄</a> <a id="514" class="Symbol">→</a> <a id="516" href="Ledger.Prelude.HasCoin.html#123" class="Record">HasCoin</a> <a id="524" class="Symbol">(</a><a id="525" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="527" class="Symbol">(</a><a id="528" href="Ledger.Prelude.Instances.html#497" class="Bound">A</a> <a id="530" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="532" href="Ledger.Prelude.Base.html#154" class="Function">Coin</a><a id="536" class="Symbol">))</a>
  <a id="541" href="Ledger.Prelude.Instances.html#480" class="Function">HasCoin-Set</a> <a id="553" class="Symbol">.</a><a id="554" href="Ledger.Prelude.HasCoin.html#171" class="Field">getCoin</a> <a id="562" href="Ledger.Prelude.Instances.html#562" class="Bound">s</a> <a id="564" class="Symbol">=</a> <a id="566" href="abstract-set-theory.FiniteSetTheory.html#4448" class="Function">∑ˢ[</a> <a id="570" href="Ledger.Prelude.Instances.html#570" class="Bound">(</a><a id="571" href="Ledger.Prelude.Instances.html#571" class="Bound">a</a> <a id="573" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="575" href="Ledger.Prelude.Instances.html#575" class="Bound">c</a><a id="576" href="Ledger.Prelude.Instances.html#570" class="Bound">)</a> <a id="578" href="abstract-set-theory.FiniteSetTheory.html#4448" class="Function">←</a> <a id="580" href="Ledger.Prelude.Instances.html#562" class="Bound">s</a> <a id="582" href="abstract-set-theory.FiniteSetTheory.html#4448" class="Function">]</a> <a id="584" href="Ledger.Prelude.Instances.html#575" class="Bound">c</a>

  <a id="HasSubset-Set"></a><a id="589" href="Ledger.Prelude.Instances.html#589" class="Function">HasSubset-Set</a> <a id="603" class="Symbol">:</a> <a id="605" class="Symbol">∀</a> <a id="607" class="Symbol">{</a><a id="608" href="Ledger.Prelude.Instances.html#608" class="Bound">A</a><a id="609" class="Symbol">}</a> <a id="611" class="Symbol">→</a> <a id="613" href="Interface.TypeClasses.HasSubset.html#118" class="Record">HasSubset</a> <a id="623" class="Symbol">(</a><a id="624" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="626" href="Ledger.Prelude.Instances.html#608" class="Bound">A</a><a id="627" class="Symbol">)</a>
  <a id="631" href="Ledger.Prelude.Instances.html#589" class="Function">HasSubset-Set</a> <a id="645" class="Symbol">.</a><a id="646" href="Interface.TypeClasses.HasSubset.html#172" class="Field Operator">_⊆_</a> <a id="650" class="Symbol">=</a> <a id="652" href="Ledger.Prelude.Instances.html#310" class="Function Operator">_⊆ˢ_</a>

  <a id="HasSubtract-ℙ"></a><a id="660" href="Ledger.Prelude.Instances.html#660" class="Function">HasSubtract-ℙ</a> <a id="674" class="Symbol">:</a> <a id="676" class="Symbol">∀</a> <a id="678" class="Symbol">{</a><a id="679" href="Ledger.Prelude.Instances.html#679" class="Bound">A</a><a id="680" class="Symbol">}</a> <a id="682" class="Symbol">→</a> <a id="684" class="Symbol">⦃</a> <a id="686" href="Class.DecEq.Core.html#126" class="Record">DecEq</a> <a id="692" href="Ledger.Prelude.Instances.html#679" class="Bound">A</a> <a id="694" class="Symbol">⦄</a> <a id="696" class="Symbol">→</a> <a id="698" href="Interface.TypeClasses.HasSubtract.html#162" class="Record">HasSubtract</a> <a id="710" class="Symbol">(</a><a id="711" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="713" href="Ledger.Prelude.Instances.html#679" class="Bound">A</a><a id="714" class="Symbol">)</a> <a id="716" class="Symbol">(</a><a id="717" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="719" href="Ledger.Prelude.Instances.html#679" class="Bound">A</a><a id="720" class="Symbol">)</a>
  <a id="724" href="Ledger.Prelude.Instances.html#660" class="Function">HasSubtract-ℙ</a> <a id="738" class="Symbol">{</a><a id="739" href="Ledger.Prelude.Instances.html#739" class="Bound">A</a><a id="740" class="Symbol">}</a> <a id="742" class="Symbol">.</a><a id="743" href="Interface.TypeClasses.HasSubtract.html#223" class="Field Operator">_-_</a> <a id="747" class="Symbol">=</a> <a id="749" href="Axiom.Set.html#9839" class="Function Operator">_＼_</a>

  <a id="HasSubset-Map"></a><a id="756" href="Ledger.Prelude.Instances.html#756" class="Function">HasSubset-Map</a> <a id="770" class="Symbol">:</a> <a id="772" class="Symbol">{</a><a id="773" href="Ledger.Prelude.Instances.html#773" class="Bound">A</a> <a id="775" href="Ledger.Prelude.Instances.html#775" class="Bound">B</a> <a id="777" class="Symbol">:</a> <a id="779" href="Agda.Primitive.html#388" class="Primitive">Set</a><a id="782" class="Symbol">}</a> <a id="784" class="Symbol">→</a> <a id="786" href="Interface.TypeClasses.HasSubset.html#118" class="Record">HasSubset</a> <a id="796" class="Symbol">(</a><a id="797" href="Ledger.Prelude.Instances.html#773" class="Bound">A</a> <a id="799" href="abstract-set-theory.FiniteSetTheory.html#633" class="Function Operator">⇀</a> <a id="801" href="Ledger.Prelude.Instances.html#775" class="Bound">B</a><a id="802" class="Symbol">)</a>
  <a id="806" href="Ledger.Prelude.Instances.html#756" class="Function">HasSubset-Map</a> <a id="820" class="Symbol">{</a><a id="821" href="Ledger.Prelude.Instances.html#821" class="Bound">A</a><a id="822" class="Symbol">}</a> <a id="824" class="Symbol">{</a><a id="825" href="Ledger.Prelude.Instances.html#825" class="Bound">B</a><a id="826" class="Symbol">}</a> <a id="828" class="Symbol">.</a><a id="829" href="Interface.TypeClasses.HasSubset.html#172" class="Field Operator">_⊆_</a> <a id="833" href="Ledger.Prelude.Instances.html#833" class="Bound">m₁</a> <a id="836" href="Ledger.Prelude.Instances.html#836" class="Bound">m₂</a> <a id="839" class="Symbol">=</a> <a id="841" class="Symbol">{</a><a id="842" href="Ledger.Prelude.Instances.html#842" class="Bound">k</a> <a id="844" class="Symbol">:</a> <a id="846" href="Ledger.Prelude.Instances.html#821" class="Bound">A</a><a id="847" class="Symbol">}</a> <a id="849" class="Symbol">{</a><a id="850" href="Ledger.Prelude.Instances.html#850" class="Bound">v</a> <a id="852" class="Symbol">:</a> <a id="854" href="Ledger.Prelude.Instances.html#825" class="Bound">B</a><a id="855" class="Symbol">}</a> <a id="857" class="Symbol">→</a> <a id="859" class="Symbol">(</a><a id="860" href="Ledger.Prelude.Instances.html#842" class="Bound">k</a> <a id="862" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="864" href="Ledger.Prelude.Instances.html#850" class="Bound">v</a><a id="865" class="Symbol">)</a> <a id="867" href="Class.IsSet.html#458" class="Function Operator">∈</a> <a id="869" class="Symbol">(</a><a id="870" href="Ledger.Prelude.Instances.html#833" class="Bound">m₁</a> <a id="873" href="Axiom.Set.Map.html#2293" class="Function Operator">ˢ</a><a id="874" class="Symbol">)</a> <a id="876" class="Symbol">→</a> <a id="878" class="Symbol">(</a><a id="879" href="Ledger.Prelude.Instances.html#842" class="Bound">k</a> <a id="881" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="883" href="Ledger.Prelude.Instances.html#850" class="Bound">v</a><a id="884" class="Symbol">)</a> <a id="886" href="Class.IsSet.html#458" class="Function Operator">∈</a> <a id="888" class="Symbol">(</a><a id="889" href="Ledger.Prelude.Instances.html#836" class="Bound">m₂</a> <a id="892" href="Axiom.Set.Map.html#2293" class="Function Operator">ˢ</a><a id="893" class="Symbol">)</a>



</pre></body></html>