<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Ledger.Prelude</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css"><link rel="stylesheet" href="Agda.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"></script><script src="AgdaKaTeX.js" defer=""></script></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>

<a id="25" class="Comment">--------------------------------------------------------------------------------</a>
<a id="106" class="Comment">-- Ledger prelude</a>
<a id="124" class="Comment">--</a>
<a id="127" class="Comment">-- Re-exports modules relating to STS, set theory and other</a>
<a id="187" class="Comment">-- miscellaneous things used to write the ledger rules. If something</a>
<a id="256" class="Comment">-- is used in more than two Ledger.* modules, it should probably go</a>
<a id="324" class="Comment">-- here.</a>
<a id="333" class="Comment">--------------------------------------------------------------------------------</a>

<a id="415" class="Keyword">module</a> <a id="422" href="Ledger.Prelude.html" class="Module">Ledger.Prelude</a> <a id="437" class="Keyword">where</a>

<a id="444" class="Keyword">open</a> <a id="449" class="Keyword">import</a> <a id="456" href="Prelude.html" class="Module">Prelude</a> <a id="464" class="Keyword">public</a>
  <a id="473" class="Keyword">hiding</a> <a id="480" class="Symbol">(</a><a id="481" href="Prelude.html#2163" class="Function">∃⁇</a><a id="483" class="Symbol">)</a>
<a id="485" class="Keyword">open</a> <a id="490" class="Keyword">import</a> <a id="497" href="iog-prelude.Prelude.Init.html" class="Module">iog-prelude.Prelude.Init</a> <a id="522" class="Keyword">public</a>
  <a id="531" class="Keyword">using</a> <a id="537" class="Symbol">(</a><a id="538" href="iog-prelude.Prelude.Init.html#125" class="Function">∃⁇</a><a id="540" class="Symbol">)</a>

<a id="543" class="Keyword">open</a> <a id="548" class="Keyword">import</a> <a id="555" href="Ledger.Prelude.Base.html" class="Module">Ledger.Prelude.Base</a> <a id="575" class="Keyword">public</a>
<a id="582" class="Keyword">import</a> <a id="589" href="Data.List.html" class="Module">Data.List</a>

<a id="600" class="Keyword">open</a> <a id="605" class="Keyword">import</a> <a id="612" href="Class.HasAdd.html" class="Module">Class.HasAdd</a> <a id="625" class="Keyword">public</a>
<a id="632" class="Keyword">open</a> <a id="637" class="Keyword">import</a> <a id="644" href="stdlib-classes.Class.HasCast.html" class="Module">stdlib-classes.Class.HasCast</a> <a id="673" class="Keyword">public</a>
<a id="680" class="Keyword">open</a> <a id="685" class="Keyword">import</a> <a id="692" href="Class.HasOrder.html" class="Module">Class.HasOrder</a> <a id="707" class="Keyword">public</a>
<a id="714" class="Keyword">open</a> <a id="719" class="Keyword">import</a> <a id="726" href="Class.ToBool.html" class="Module">Class.ToBool</a> <a id="739" class="Keyword">public</a>
<a id="746" class="Keyword">open</a> <a id="751" class="Keyword">import</a> <a id="758" href="Interface.ComputationalRelation.html" class="Module">Interface.ComputationalRelation</a> <a id="790" class="Keyword">public</a>
<a id="797" class="Keyword">open</a> <a id="802" class="Keyword">import</a> <a id="809" href="Interface.HasSubtract.html" class="Module">Interface.HasSubtract</a> <a id="831" class="Keyword">public</a>
<a id="838" class="Keyword">open</a> <a id="843" class="Keyword">import</a> <a id="850" href="Interface.HasSubtract.Instance.html" class="Module">Interface.HasSubtract.Instance</a> <a id="881" class="Keyword">public</a>
<a id="888" class="Keyword">open</a> <a id="893" class="Keyword">import</a> <a id="900" href="Interface.HasSubset.html" class="Module">Interface.HasSubset</a> <a id="920" class="Keyword">public</a>
<a id="927" class="Keyword">open</a> <a id="932" class="Keyword">import</a> <a id="939" href="Interface.HasSubset.Instance.html" class="Module">Interface.HasSubset.Instance</a> <a id="968" class="Keyword">public</a>
<a id="975" class="Keyword">open</a> <a id="980" class="Keyword">import</a> <a id="987" href="Interface.Hashable.html" class="Module">Interface.Hashable</a> <a id="1006" class="Keyword">public</a>
<a id="1013" class="Keyword">open</a> <a id="1018" class="Keyword">import</a> <a id="1025" href="Ledger.Interface.HasCoin.html" class="Module">Ledger.Interface.HasCoin</a> <a id="1050" class="Keyword">public</a>
<a id="1057" class="Keyword">open</a> <a id="1062" class="Keyword">import</a> <a id="1069" href="Tactic.Defaults.html" class="Module">Tactic.Defaults</a> <a id="1085" class="Keyword">public</a>
<a id="1092" class="Keyword">open</a> <a id="1097" class="Keyword">import</a> <a id="1104" href="MyDebugOptions.html" class="Module">MyDebugOptions</a> <a id="1119" class="Keyword">public</a>
<a id="1126" class="Keyword">open</a> <a id="1131" class="Keyword">import</a> <a id="1138" href="iog-prelude.Tactic.Premises.html" class="Module">iog-prelude.Tactic.Premises</a> <a id="1166" class="Keyword">public</a>

<a id="1174" class="Keyword">open</a> <a id="1179" class="Keyword">import</a> <a id="1186" href="abstract-set-theory.FiniteSetTheory.html" class="Module">abstract-set-theory.FiniteSetTheory</a> <a id="1222" class="Keyword">public</a>
  <a id="1231" class="Keyword">renaming</a> <a id="1240" class="Symbol">(</a><a id="1241" href="Axiom.Set.html#1813" class="Function Operator">_⊆_</a> <a id="1245" class="Symbol">to</a> <a id="1248" class="Function Operator">_⊆ˢ_</a><a id="1252" class="Symbol">)</a>

<a id="1255" class="Keyword">import</a> <a id="1262" href="Data.Integer.html" class="Module">Data.Integer</a> <a id="1275" class="Symbol">as</a> <a id="1278" class="Module">ℤ</a>
<a id="1280" class="Keyword">import</a> <a id="1287" href="Data.Rational.html" class="Module">Data.Rational</a> <a id="1301" class="Symbol">as</a> <a id="1304" class="Module">ℚ</a>
<a id="1306" class="Keyword">open</a> <a id="1311" class="Keyword">import</a> <a id="1318" href="Data.Rational.html" class="Module">Data.Rational</a> <a id="1332" class="Keyword">using</a> <a id="1338" class="Symbol">(</a><a id="1339" href="Data.Rational.Base.html#1342" class="Record">ℚ</a><a id="1340" class="Symbol">)</a>

<a id="dec-de-morgan"></a><a id="1343" href="Ledger.Prelude.html#1343" class="Function">dec-de-morgan</a> <a id="1357" class="Symbol">:</a> <a id="1359" class="Symbol">∀{</a><a id="1361" href="Ledger.Prelude.html#1361" class="Bound">P</a> <a id="1363" href="Ledger.Prelude.html#1363" class="Bound">Q</a> <a id="1365" class="Symbol">:</a> <a id="1367" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="1371" class="Symbol">}</a> <a id="1373" class="Symbol">→</a> <a id="1375" class="Symbol">⦃</a> <a id="1377" href="Ledger.Prelude.html#1361" class="Bound">P</a> <a id="1379" href="Class.Decidable.Core.html#208" class="Record Operator">⁇</a> <a id="1381" class="Symbol">⦄</a> <a id="1383" class="Symbol">→</a> <a id="1385" href="Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="1387" class="Symbol">(</a><a id="1388" href="Ledger.Prelude.html#1361" class="Bound">P</a> <a id="1390" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="1392" href="Ledger.Prelude.html#1363" class="Bound">Q</a><a id="1393" class="Symbol">)</a> <a id="1395" class="Symbol">→</a> <a id="1397" href="Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="1399" href="Ledger.Prelude.html#1361" class="Bound">P</a> <a id="1401" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="1403" href="Relation.Nullary.Negation.Core.html#658" class="Function Operator">¬</a> <a id="1405" href="Ledger.Prelude.html#1363" class="Bound">Q</a>
<a id="1407" href="Ledger.Prelude.html#1343" class="Function">dec-de-morgan</a> <a id="1421" class="Symbol">⦃</a> <a id="1423" href="Class.Decidable.Core.html#253" class="InductiveConstructor Operator">⁇</a> <a id="1425" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="1428" href="Ledger.Prelude.html#1428" class="Bound">¬p</a> <a id="1431" class="Symbol">⦄</a> <a id="1433" href="Ledger.Prelude.html#1433" class="Bound">¬pq</a> <a id="1437" class="Symbol">=</a> <a id="1439" href="Data.Sum.Base.html#675" class="InductiveConstructor">inj₁</a> <a id="1444" href="Ledger.Prelude.html#1428" class="Bound">¬p</a>
<a id="1447" href="Ledger.Prelude.html#1343" class="Function">dec-de-morgan</a> <a id="1461" class="Symbol">⦃</a> <a id="1463" href="Class.Decidable.Core.html#253" class="InductiveConstructor Operator">⁇</a> <a id="1465" href="Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="1469" href="Ledger.Prelude.html#1469" class="Bound">p</a> <a id="1471" class="Symbol">⦄</a> <a id="1473" href="Ledger.Prelude.html#1473" class="Bound">¬pq</a> <a id="1477" class="Symbol">=</a> <a id="1479" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="1484" class="Symbol">λ</a> <a id="1486" href="Ledger.Prelude.html#1486" class="Bound">q</a> <a id="1488" class="Symbol">→</a> <a id="1490" href="Ledger.Prelude.html#1473" class="Bound">¬pq</a> <a id="1494" class="Symbol">(</a><a id="1495" href="Ledger.Prelude.html#1469" class="Bound">p</a> <a id="1497" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1499" href="Ledger.Prelude.html#1486" class="Bound">q</a><a id="1500" class="Symbol">)</a>

<a id="1503" class="Keyword">instance</a>
  <a id="CommMonoid-ℕ-+"></a><a id="1514" href="Ledger.Prelude.html#1514" class="Function">CommMonoid-ℕ-+</a> <a id="1529" class="Symbol">=</a> <a id="1531" href="Class.CommutativeMonoid.Instances.html#196" class="Function">NonUniqueInstances.CommMonoid-ℕ-+</a>

  <a id="HasCoin-Map"></a><a id="1568" href="Ledger.Prelude.html#1568" class="Function">HasCoin-Map</a> <a id="1580" class="Symbol">:</a> <a id="1582" class="Symbol">∀</a> <a id="1584" class="Symbol">{</a><a id="1585" href="Ledger.Prelude.html#1585" class="Bound">A</a><a id="1586" class="Symbol">}</a> <a id="1588" class="Symbol">→</a> <a id="1590" class="Symbol">⦃</a> <a id="1592" href="Class.DecEq.Core.html#117" class="Record">DecEq</a> <a id="1598" href="Ledger.Prelude.html#1585" class="Bound">A</a> <a id="1600" class="Symbol">⦄</a> <a id="1602" class="Symbol">→</a> <a id="1604" href="Ledger.Interface.HasCoin.html#124" class="Record">HasCoin</a> <a id="1612" class="Symbol">(</a><a id="1613" href="Ledger.Prelude.html#1585" class="Bound">A</a> <a id="1615" href="abstract-set-theory.FiniteSetTheory.html#633" class="Function Operator">⇀</a> <a id="1617" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a><a id="1621" class="Symbol">)</a>
  <a id="1625" href="Ledger.Prelude.html#1568" class="Function">HasCoin-Map</a> <a id="1637" class="Symbol">.</a><a id="1638" href="Ledger.Interface.HasCoin.html#172" class="Field">getCoin</a> <a id="1646" href="Ledger.Prelude.html#1646" class="Bound">s</a> <a id="1648" class="Symbol">=</a> <a id="1650" href="abstract-set-theory.FiniteSetTheory.html#3166" class="Function">∑[</a> <a id="1653" href="Ledger.Prelude.html#1653" class="Bound">x</a> <a id="1655" href="abstract-set-theory.FiniteSetTheory.html#3166" class="Function">←</a> <a id="1657" href="Ledger.Prelude.html#1646" class="Bound">s</a> <a id="1659" href="abstract-set-theory.FiniteSetTheory.html#3166" class="Function">]</a> <a id="1661" href="Ledger.Prelude.html#1653" class="Bound">x</a>

  <a id="HasCoin-Set"></a><a id="1666" href="Ledger.Prelude.html#1666" class="Function">HasCoin-Set</a> <a id="1678" class="Symbol">:</a> <a id="1680" class="Symbol">∀</a> <a id="1682" class="Symbol">{</a><a id="1683" href="Ledger.Prelude.html#1683" class="Bound">A</a><a id="1684" class="Symbol">}</a> <a id="1686" class="Symbol">→</a> <a id="1688" class="Symbol">⦃</a> <a id="1690" href="Class.DecEq.Core.html#117" class="Record">DecEq</a> <a id="1696" href="Ledger.Prelude.html#1683" class="Bound">A</a> <a id="1698" class="Symbol">⦄</a> <a id="1700" class="Symbol">→</a> <a id="1702" href="Ledger.Interface.HasCoin.html#124" class="Record">HasCoin</a> <a id="1710" class="Symbol">(</a><a id="1711" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="1713" class="Symbol">(</a><a id="1714" href="Ledger.Prelude.html#1683" class="Bound">A</a> <a id="1716" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="1718" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a><a id="1722" class="Symbol">))</a>
  <a id="1727" href="Ledger.Prelude.html#1666" class="Function">HasCoin-Set</a> <a id="1739" class="Symbol">.</a><a id="1740" href="Ledger.Interface.HasCoin.html#172" class="Field">getCoin</a> <a id="1748" href="Ledger.Prelude.html#1748" class="Bound">s</a> <a id="1750" class="Symbol">=</a> <a id="1752" href="abstract-set-theory.FiniteSetTheory.html#3302" class="Function">∑ˢ[</a> <a id="1756" href="Ledger.Prelude.html#1756" class="Bound">(</a><a id="1757" href="Ledger.Prelude.html#1757" class="Bound">a</a> <a id="1759" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1761" href="Ledger.Prelude.html#1761" class="Bound">c</a><a id="1762" href="Ledger.Prelude.html#1756" class="Bound">)</a> <a id="1764" href="abstract-set-theory.FiniteSetTheory.html#3302" class="Function">←</a> <a id="1766" href="Ledger.Prelude.html#1748" class="Bound">s</a> <a id="1768" href="abstract-set-theory.FiniteSetTheory.html#3302" class="Function">]</a> <a id="1770" href="Ledger.Prelude.html#1761" class="Bound">c</a>

  <a id="HasSubset-Set"></a><a id="1775" href="Ledger.Prelude.html#1775" class="Function">HasSubset-Set</a> <a id="1789" class="Symbol">:</a> <a id="1791" class="Symbol">∀</a> <a id="1793" class="Symbol">{</a><a id="1794" href="Ledger.Prelude.html#1794" class="Bound">A</a><a id="1795" class="Symbol">}</a> <a id="1797" class="Symbol">→</a> <a id="1799" href="Interface.HasSubset.html#104" class="Record">HasSubset</a> <a id="1809" class="Symbol">(</a><a id="1810" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="1812" href="Ledger.Prelude.html#1794" class="Bound">A</a><a id="1813" class="Symbol">)</a>
  <a id="1817" href="Ledger.Prelude.html#1775" class="Function">HasSubset-Set</a> <a id="1831" class="Symbol">.</a><a id="1832" href="Interface.HasSubset.html#158" class="Field Operator">_⊆_</a> <a id="1836" class="Symbol">=</a> <a id="1838" href="Ledger.Prelude.html#1248" class="Function Operator">_⊆ˢ_</a>

<a id="≡ᵉ-getCoin"></a><a id="1844" href="Ledger.Prelude.html#1844" class="Function">≡ᵉ-getCoin</a> <a id="1855" class="Symbol">:</a> <a id="1857" class="Symbol">∀</a> <a id="1859" class="Symbol">{</a><a id="1860" href="Ledger.Prelude.html#1860" class="Bound">A</a><a id="1861" class="Symbol">}</a> <a id="1863" class="Symbol">→</a> <a id="1865" class="Symbol">⦃</a> <a id="1867" href="Ledger.Prelude.html#1867" class="Bound">_</a> <a id="1869" class="Symbol">:</a> <a id="1871" href="Class.DecEq.Core.html#117" class="Record">DecEq</a> <a id="1877" href="Ledger.Prelude.html#1860" class="Bound">A</a> <a id="1879" class="Symbol">⦄</a> <a id="1881" class="Symbol">→</a> <a id="1883" class="Symbol">(</a><a id="1884" href="Ledger.Prelude.html#1884" class="Bound">s</a> <a id="1886" href="Ledger.Prelude.html#1886" class="Bound">s&#39;</a> <a id="1889" class="Symbol">:</a> <a id="1891" href="Ledger.Prelude.html#1860" class="Bound">A</a> <a id="1893" href="abstract-set-theory.FiniteSetTheory.html#633" class="Function Operator">⇀</a> <a id="1895" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a><a id="1899" class="Symbol">)</a> <a id="1901" class="Symbol">→</a> <a id="1903" href="Ledger.Prelude.html#1884" class="Bound">s</a> <a id="1905" href="Axiom.Set.Map.html#2293" class="Function Operator">ˢ</a> <a id="1907" href="Axiom.Set.html#2587" class="Function Operator">≡ᵉ</a> <a id="1910" href="Ledger.Prelude.html#1886" class="Bound">s&#39;</a> <a id="1913" href="Axiom.Set.Map.html#2293" class="Function Operator">ˢ</a> <a id="1915" class="Symbol">→</a> <a id="1917" href="Ledger.Interface.HasCoin.html#172" class="Field">getCoin</a> <a id="1925" href="Ledger.Prelude.html#1884" class="Bound">s</a> <a id="1927" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="1929" href="Ledger.Interface.HasCoin.html#172" class="Field">getCoin</a> <a id="1937" href="Ledger.Prelude.html#1886" class="Bound">s&#39;</a>
<a id="1940" href="Ledger.Prelude.html#1844" class="Function">≡ᵉ-getCoin</a> <a id="1951" class="Symbol">{</a><a id="1952" href="Ledger.Prelude.html#1952" class="Bound">A</a><a id="1953" class="Symbol">}</a> <a id="1955" class="Symbol">⦃</a> <a id="1957" href="Ledger.Prelude.html#1957" class="Bound">decEqA</a> <a id="1964" class="Symbol">⦄</a> <a id="1966" href="Ledger.Prelude.html#1966" class="Bound">s</a> <a id="1968" href="Ledger.Prelude.html#1968" class="Bound">s&#39;</a> <a id="1971" href="Ledger.Prelude.html#1971" class="Bound">s≡s&#39;</a> <a id="1976" class="Symbol">=</a> <a id="1978" href="abstract-set-theory.FiniteSetTheory.html#3736" class="Function">indexedSumᵛ&#39;-cong</a> <a id="1996" class="Symbol">{</a><a id="1997" class="Argument">C</a> <a id="1999" class="Symbol">=</a> <a id="2001" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a><a id="2005" class="Symbol">}</a> <a id="2007" class="Symbol">{</a><a id="2008" class="Argument">x</a> <a id="2010" class="Symbol">=</a> <a id="2012" href="Ledger.Prelude.html#1966" class="Bound">s</a><a id="2013" class="Symbol">}</a> <a id="2015" class="Symbol">{</a><a id="2016" class="Argument">y</a> <a id="2018" class="Symbol">=</a> <a id="2020" href="Ledger.Prelude.html#1968" class="Bound">s&#39;</a><a id="2022" class="Symbol">}</a> <a id="2024" href="Ledger.Prelude.html#1971" class="Bound">s≡s&#39;</a>

<a id="setToMap"></a><a id="2030" href="Ledger.Prelude.html#2030" class="Function">setToMap</a> <a id="2039" class="Symbol">:</a> <a id="2041" class="Symbol">∀</a> <a id="2043" class="Symbol">{</a><a id="2044" href="Ledger.Prelude.html#2044" class="Bound">A</a> <a id="2046" href="Ledger.Prelude.html#2046" class="Bound">B</a> <a id="2048" class="Symbol">:</a> <a id="2050" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="2054" class="Symbol">}</a> <a id="2056" class="Symbol">→</a> <a id="2058" class="Symbol">⦃</a> <a id="2060" href="Class.DecEq.Core.html#117" class="Record">DecEq</a> <a id="2066" href="Ledger.Prelude.html#2044" class="Bound">A</a> <a id="2068" class="Symbol">⦄</a> <a id="2070" class="Symbol">→</a> <a id="2072" href="abstract-set-theory.FiniteSetTheory.html#488" class="Function Operator">ℙ</a> <a id="2074" class="Symbol">(</a><a id="2075" href="Ledger.Prelude.html#2044" class="Bound">A</a> <a id="2077" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="2079" href="Ledger.Prelude.html#2046" class="Bound">B</a><a id="2080" class="Symbol">)</a> <a id="2082" class="Symbol">→</a> <a id="2084" href="Ledger.Prelude.html#2044" class="Bound">A</a> <a id="2086" href="abstract-set-theory.FiniteSetTheory.html#633" class="Function Operator">⇀</a> <a id="2088" href="Ledger.Prelude.html#2046" class="Bound">B</a>
<a id="2090" href="Ledger.Prelude.html#2030" class="Function">setToMap</a> <a id="2099" class="Symbol">=</a> <a id="2101" href="Axiom.Set.Map.html#2713" class="Function">fromListᵐ</a> <a id="2111" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="2113" href="abstract-set-theory.FiniteSetTheory.html#2463" class="Function">setToList</a>

<a id="2124" class="Comment">-- division of natural numbers with completion by 0.</a>
<a id="2177" class="Keyword">opaque</a>
  <a id="_/₀_"></a><a id="2186" href="Ledger.Prelude.html#2186" class="Function Operator">_/₀_</a> <a id="2191" class="Symbol">:</a> <a id="2193" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2195" class="Symbol">→</a> <a id="2197" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="2199" class="Symbol">→</a> <a id="2201" href="Data.Rational.Base.html#1342" class="Record">ℚ</a>
  <a id="2205" href="Ledger.Prelude.html#2205" class="Bound">x</a> <a id="2207" href="Ledger.Prelude.html#2186" class="Function Operator">/₀</a> <a id="2210" class="Number">0</a> <a id="2212" class="Symbol">=</a> <a id="2214" href="Data.Rational.Base.html#4325" class="Function">ℚ.0ℚ</a>
  <a id="2221" href="Ledger.Prelude.html#2221" class="Bound">x</a> <a id="2223" href="Ledger.Prelude.html#2186" class="Function Operator">/₀</a> <a id="2226" href="Ledger.Prelude.html#2226" class="Bound">y</a><a id="2227" class="Symbol">@(</a><a id="2229" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a> <a id="2233" class="Symbol">_)</a> <a id="2236" class="Symbol">=</a> <a id="2238" href="Agda.Builtin.Int.html#263" class="InductiveConstructor Operator">ℤ.+</a> <a id="2242" href="Ledger.Prelude.html#2221" class="Bound">x</a> <a id="2244" href="Data.Rational.Base.html#3884" class="Function Operator">ℚ./</a> <a id="2248" href="Ledger.Prelude.html#2226" class="Bound">y</a>

<a id="2251" class="Comment">-- Division of rational numbers with completion by 0.</a>
<a id="_÷₀_"></a><a id="2305" href="Ledger.Prelude.html#2305" class="Function Operator">_÷₀_</a> <a id="2310" class="Symbol">:</a> <a id="2312" href="Data.Rational.Base.html#1342" class="Record">ℚ</a> <a id="2314" class="Symbol">→</a> <a id="2316" href="Data.Rational.Base.html#1342" class="Record">ℚ</a> <a id="2318" class="Symbol">→</a> <a id="2320" href="Data.Rational.Base.html#1342" class="Record">ℚ</a>
<a id="2322" href="Ledger.Prelude.html#2305" class="Function Operator">_÷₀_</a> <a id="2327" href="Ledger.Prelude.html#2327" class="Bound">x</a> <a id="2329" href="Ledger.Prelude.html#2329" class="Bound">y</a> <a id="2331" class="Symbol">=</a> <a id="2333" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="2338" href="Ledger.Prelude.html#2329" class="Bound">y</a> <a id="2340" href="Class.DecEq.Core.html#159" class="Field Operator">≟</a> <a id="2342" href="Data.Rational.Base.html#4325" class="Function">ℚ.0ℚ</a> <a id="2347" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="2350" class="Symbol">λ</a> <a id="2352" class="Keyword">where</a>
  <a id="2360" class="Symbol">(</a><a id="2361" href="Relation.Nullary.Decidable.Core.html#1994" class="InductiveConstructor">yes</a> <a id="2365" class="Symbol">_)</a> <a id="2368" class="Symbol">→</a> <a id="2370" href="Data.Rational.Base.html#4325" class="Function">ℚ.0ℚ</a>
  <a id="2377" class="Symbol">(</a><a id="2378" href="Relation.Nullary.Decidable.Core.html#2031" class="InductiveConstructor">no</a> <a id="2381" href="Ledger.Prelude.html#2381" class="Bound">y≢0</a><a id="2384" class="Symbol">)</a> <a id="2386" class="Symbol">→</a> <a id="2388" class="Keyword">let</a> <a id="2392" class="Keyword">instance</a> <a id="2401" href="Ledger.Prelude.html#2401" class="Bound">nonZero-y</a> <a id="2411" class="Symbol">=</a> <a id="2413" href="Data.Rational.Base.html#4892" class="Function">ℚ.≢-nonZero</a> <a id="2425" href="Ledger.Prelude.html#2381" class="Bound">y≢0</a> <a id="2429" class="Keyword">in</a> <a id="2432" href="Ledger.Prelude.html#2327" class="Bound">x</a> <a id="2434" href="Data.Rational.Base.html#6708" class="Function Operator">ℚ.÷</a> <a id="2438" href="Ledger.Prelude.html#2329" class="Bound">y</a>

<a id="⟦_⟧"></a><a id="2441" href="Ledger.Prelude.html#2441" class="Function Operator">⟦_⟧</a> <a id="2445" class="Symbol">:</a> <a id="2447" class="Symbol">∀</a> <a id="2449" class="Symbol">{</a><a id="2450" href="Ledger.Prelude.html#2450" class="Bound">A</a> <a id="2452" href="Ledger.Prelude.html#2452" class="Bound">B</a> <a id="2454" class="Symbol">:</a> <a id="2456" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="2460" class="Symbol">}</a> <a id="2462" class="Symbol">⦃</a> <a id="2464" href="Ledger.Prelude.html#2464" class="Bound">f</a> <a id="2466" class="Symbol">:</a> <a id="2468" href="stdlib-classes.Class.HasCast.Base.html#131" class="Record">HasCast</a> <a id="2476" href="Ledger.Prelude.html#2450" class="Bound">A</a> <a id="2478" href="Ledger.Prelude.html#2452" class="Bound">B</a> <a id="2480" class="Symbol">⦄</a> <a id="2482" class="Symbol">→</a> <a id="2484" href="Ledger.Prelude.html#2450" class="Bound">A</a> <a id="2486" class="Symbol">→</a> <a id="2488" href="Ledger.Prelude.html#2452" class="Bound">B</a>
<a id="2490" href="Ledger.Prelude.html#2441" class="Function Operator">⟦_⟧</a> <a id="2494" class="Symbol">⦃</a> <a id="2496" class="Argument">f</a> <a id="2498" class="Symbol">=</a> <a id="2500" href="Ledger.Prelude.html#2500" class="Bound">f</a> <a id="2502" class="Symbol">⦄</a> <a id="2504" class="Symbol">=</a> <a id="2506" href="stdlib-classes.Class.HasCast.Base.html#201" class="Field">f.cast</a>
  <a id="2515" class="Keyword">where</a> <a id="2521" class="Keyword">module</a> <a id="2528" href="Ledger.Prelude.html#2528" class="Module">f</a> <a id="2530" class="Symbol">=</a> <a id="2532" href="stdlib-classes.Class.HasCast.Base.html#131" class="Module">HasCast</a> <a id="2540" href="Ledger.Prelude.html#2500" class="Bound">f</a>

<a id="∣_∣"></a><a id="2543" href="Ledger.Prelude.html#2543" class="Function Operator">∣_∣</a> <a id="2547" class="Symbol">:</a> <a id="2549" class="Symbol">∀</a> <a id="2551" class="Symbol">{</a><a id="2552" href="Ledger.Prelude.html#2552" class="Bound">A</a> <a id="2554" href="Ledger.Prelude.html#2554" class="Bound">B</a> <a id="2556" class="Symbol">:</a> <a id="2558" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="2562" class="Symbol">}</a> <a id="2564" class="Symbol">⦃</a> <a id="2566" href="Ledger.Prelude.html#2566" class="Bound">f</a> <a id="2568" class="Symbol">:</a> <a id="2570" href="stdlib-classes.Class.HasCast.Base.html#131" class="Record">HasCast</a> <a id="2578" href="Ledger.Prelude.html#2552" class="Bound">A</a> <a id="2580" href="Ledger.Prelude.html#2554" class="Bound">B</a> <a id="2582" class="Symbol">⦄</a> <a id="2584" class="Symbol">→</a> <a id="2586" href="Ledger.Prelude.html#2552" class="Bound">A</a> <a id="2588" class="Symbol">→</a> <a id="2590" href="Ledger.Prelude.html#2554" class="Bound">B</a>
<a id="2592" href="Ledger.Prelude.html#2543" class="Function Operator">∣_∣</a> <a id="2596" class="Symbol">⦃</a> <a id="2598" class="Argument">f</a> <a id="2600" class="Symbol">=</a> <a id="2602" href="Ledger.Prelude.html#2602" class="Bound">f</a> <a id="2604" class="Symbol">⦄</a> <a id="2606" class="Symbol">=</a> <a id="2608" href="stdlib-classes.Class.HasCast.Base.html#201" class="Field">f.cast</a>
  <a id="2617" class="Keyword">where</a> <a id="2623" class="Keyword">module</a> <a id="2630" href="Ledger.Prelude.html#2630" class="Module">f</a> <a id="2632" class="Symbol">=</a> <a id="2634" href="stdlib-classes.Class.HasCast.Base.html#131" class="Module">HasCast</a> <a id="2642" href="Ledger.Prelude.html#2602" class="Bound">f</a>

<a id="2645" class="Keyword">infix</a> <a id="2651" class="Number">5</a> <a id="2653" href="Ledger.Prelude.html#2441" class="Function Operator">⟦_⟧</a>
<a id="2657" class="Keyword">infix</a> <a id="2663" class="Number">6</a> <a id="2665" href="Ledger.Prelude.html#2543" class="Function Operator">∣_∣</a>

<a id="2670" class="Keyword">module</a> <a id="Filter"></a><a id="2677" href="Ledger.Prelude.html#2677" class="Module">Filter</a> <a id="2684" class="Keyword">where</a>
  <a id="Filter.filter"></a><a id="2692" href="Ledger.Prelude.html#2692" class="Function">filter</a> <a id="2699" class="Symbol">:</a> <a id="2701" class="Symbol">∀</a> <a id="2703" class="Symbol">{</a><a id="2704" href="Ledger.Prelude.html#2704" class="Bound">a</a><a id="2705" class="Symbol">}</a> <a id="2707" class="Symbol">{</a><a id="2708" href="Ledger.Prelude.html#2708" class="Bound">p</a><a id="2709" class="Symbol">}</a> <a id="2711" class="Symbol">{</a><a id="2712" href="Ledger.Prelude.html#2712" class="Bound">A</a> <a id="2714" class="Symbol">:</a> <a id="2716" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="2721" href="Ledger.Prelude.html#2704" class="Bound">a</a><a id="2722" class="Symbol">}</a> <a id="2724" class="Symbol">→</a> <a id="2726" class="Symbol">(</a><a id="2727" href="Ledger.Prelude.html#2727" class="Bound">P</a> <a id="2729" class="Symbol">:</a> <a id="2731" href="Relation.Unary.html#1178" class="Function">Pred</a> <a id="2736" href="Ledger.Prelude.html#2712" class="Bound">A</a> <a id="2738" href="Ledger.Prelude.html#2708" class="Bound">p</a><a id="2739" class="Symbol">)</a> <a id="2741" class="Symbol">→</a> <a id="2743" class="Symbol">⦃</a> <a id="2745" href="Ledger.Prelude.html#2727" class="Bound">P</a> <a id="2747" href="Class.Decidable.Core.html#762" class="Function Operator">⁇¹</a> <a id="2750" class="Symbol">⦄</a> <a id="2752" class="Symbol">→</a> <a id="2754" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2759" href="Ledger.Prelude.html#2712" class="Bound">A</a> <a id="2761" class="Symbol">→</a> <a id="2763" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2768" href="Ledger.Prelude.html#2712" class="Bound">A</a>
  <a id="2772" href="Ledger.Prelude.html#2692" class="Function">filter</a> <a id="2779" href="Ledger.Prelude.html#2779" class="Bound">P</a> <a id="2781" class="Symbol">=</a> <a id="2783" href="Data.List.Base.html#10687" class="Function">Data.List.filter</a> <a id="2800" href="Class.Decidable.Core.html#966" class="Function Operator">¿</a> <a id="2802" href="Ledger.Prelude.html#2779" class="Bound">P</a> <a id="2804" href="Class.Decidable.Core.html#966" class="Function Operator">¿¹</a>
</pre></body></html>