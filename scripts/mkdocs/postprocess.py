# postprocess.py
# Purpose: Cleans up the intermediate Markdown file generated by Pandoc+Lua filter.
# Usage: This script is part of a four stage pipeline and is meant to be used in conjunction with
#        `generate_macros.py`, `preprocess.py`, `agda-filter.lua`, and pandoc.  For example,
#          $ python generate_macros_json.py macros.sty preprocess_macros.json
#          $ python preprocess.py Transaction.lagda preprocess_macros.json code_blocks.json > Transaction.lagda.temp
#          $ pandoc Transaction.lagda.temp -f latex -t gfm+attributes --lua-filter agda-filter.lua -o Transaction.lagda.intermediate
#          $ python postprocess.py Transaction.lagda.intermediate code_blocks.json Transaction.lagda
# Actions:
# 1. Replaces code block placeholders (@@CODEBLOCK_ID_n@@) with actual verbatim code.
# 2. Replaces admonition markers (@@ADMONITION_START/END@@) with MkDocs admonition syntax (??? note)
#    and indents the content within the admonition block.
# 3. Replaces figure block placeholders (@@FIGURE_BLOCK_TO_SUBSECTION@@) with Markdown H3 headings.
# 4. Replaces unlabelled figure caption placeholders (@@UNLABELLED_FIGURE_CAPTION@@) with Markdown H4 headings.
# 5. Replaces cross-reference placeholders (@@CROSS_REF@@) with Markdown links to the target files.
# # Notes/updates:
# 1.  `slugify_post` function (should be identical to `slugify` in `build.py`).
# 2.  `LABEL_TARGETS_MAP` Global: stores loaded map.
# 3.  New Argument Handling: `if __name__ == "__main__":` block now expects 5 arguments;
#     loads `labels_map.json` into `LABEL_TARGETS_MAP`; includes error handling for missing or malformed `labels_map.json`.
# 4.  `replace_figure_block_to_subsection_placeholder`:
#     +  takes placeholder generated by `preprocess.py`;
#     +  extracts caption text;
#     +  returns md H3 heading string (`### Actual Caption Text\n\n`); mkdocs generates ID from heading text.
# 5.  `replace_unlabelled_figure_caption_placeholder`: (Optional, if we implement in `preprocess.py` for figs
#     with captions but no labels); creates md heading.
# 6.  `replace_cross_ref_placeholder`:
#     +  extracts original LaTeX command (`Cref` or `cref`) and raw target label string(s);
#     +  splits comma-separated targets;
#     +  for each target label:
#        +  looks it up in `LABEL_TARGETS_MAP`;
#        +  if found, retrieves the target filename, pre-slugified anchor (like `#actual-caption-slug`), and original caption;
#        +  constructs descriptive link text (e.g., "Figure 'Actual Caption Text'", "section 'Some Section Title'") based on
#           original label prefix and `Cmd` (`Cref`/`cref`).
#        +  generates md link: `[Link Text](TargetFile.md#actual-caption-slug)`.
#        +  if not found, logs warning and generates placeholder italicized text.
#        +  handles multiple targets in `\Cref` with simplified "and" / "," separators.
# 7.  Order of Replacements. It's important to:
#     1.  replace `@@CODEBLOCK_ID_...@@`.
#     2.  replace `@@FIGURE_BLOCK_TO_SUBSECTION@@...@@` and `@@UNLABELLED_FIGURE_CAPTION@@...@@` to create md headings (link targets).
#     3.  replace `@@CROSS_REF@@...@@` to create links *to* targets.
#     4.  process admonitions.
#
import re
import json
import sys
import io # Used for robust line processing
import logging # For warnings about unresolved labels

# --- slugify function (should be identical to the one in build.py) ---
# (Or consider putting it in a shared utility .py file if used in multiple places)
import re as re_for_slugify_post # Use an alias

def slugify_post(text_to_slug):
    """
    Generates a slug from text, aiming for consistency with Python-Markdown's default.
    """
    if not text_to_slug: return "section"
    text_to_slug = str(text_to_slug)
    slug = text_to_slug.lower()
    slug = re_for_slugify_post.sub(r'[^\w\s-]', '', slug)
    slug = re_for_slugify_post.sub(r'[-\s]+', '-', slug)
    slug = slug.strip('-')
    return slug if slug else "section"

# --- Global variable to store the loaded labels map ---
LABEL_TARGETS_MAP = {}

# Helper function to indent a block of text consistently
def indent_block(text, prefix="    "):
    """
    Indents each non-blank line of the input text string. Also indents lines
    that contain only whitespace (to preserve relative spacing).
    Args:
        text (str): The text block to indent (potentially multi-line).
        prefix (str): The string to prepend to each applicable line.
    Returns:
        str: The indented text block.
    """
    lines = text.split('\n')
    indented_lines = [(prefix + line if line.strip() else line) for line in lines]
    return "\n".join(indented_lines)

# Code block replacer function used by re.sub
def replace_code_placeholder(match, code_blocks):
    """
    Callback function for re.sub to replace code placeholder IDs (@@CODEBLOCK_ID_n@@).
    Retrieves code from the code_blocks dict and formats it either
    as a visible code block (!!! note admonition) or a hidden one (??? note admonition).
    Args:
        match (re.Match): The regex match object for the placeholder ID.
        code_blocks (dict): The dictionary loaded from code_blocks.json.
    Returns:
        str: The formatted Markdown string for the code block/admonition.
    """
    placeholder_id = match.group(0) # The full placeholder string, e.g., "@@CODEBLOCK_ID_1@@"
    block_data = code_blocks.get(placeholder_id)

    # Safety check if ID not found in the JSON data
    if not block_data:
        print(f"Warning: Code block data not found for {placeholder_id}", file=sys.stderr)
        return placeholder_id # Return the placeholder itself if data is missing

    # Get the verbatim code content and hidden status
    content = block_data.get("content", "")
    is_hidden = block_data.get("hidden", False)

    # Ensure content ends with a newline (important before closing fence)
    # Use rstrip() to remove only trailing whitespace before check/add
    content_rstrip = content.rstrip()
    if content and not content_rstrip.endswith('\n'):
       content = content_rstrip + '\n'
    else:
       # If original content was empty or only whitespace, keep it empty maybe?
       # Or just use the rstrip version if it wasn't empty
       if content.strip(): # If there was non-whitespace content
           content = content_rstrip + '\n'
       else: # Handle case where content was purely whitespace/empty
           content = '\n' # Ensure at least a newline

    if is_hidden:
        return f'\n<div class="agda-hidden-source">\n\n```agda\n{content}```\n\n</div>\n'
        # title = "Supporting source code"
        # # Indent the code content itself by 4 spaces for nesting under ```agda
        # indented_code_content = indent_block(content, prefix="    ")
        # # Format as COLLAPSED admonition containing the code block (indented again)
        # replacement_str = f'\n??? note "{title}"\n\n    ```agda\n{indented_code_content}    ```\n' # Note final ``` is indented
        # return replacement_str
    else: # Visible code block
        return f"\n```agda\n{content}```\n"
        # Indent the code content itself by 4 spaces
        # indented_code_content = indent_block(content, prefix="    ")
        # Format as EXPANDED admonition (!!! note) containing the code block
        # replacement_str = f'\n!!! note\n\n    ```agda\n{indented_code_content}    ```\n' # Note final ``` is indented
        # return replacement_str


# --- New Placeholder Replacement Functions ---
def replace_figure_block_to_subsection_placeholder(match):
    # original_label_escaped = match.group(1) # Original LaTeX label (label=...)
    caption_text_escaped = match.group(2)   # Caption text (caption=...)

    # Unescape "@@" if you escaped it in preprocess.py (e.g., .replace("@ @", "@@"))
    caption_text = caption_text_escaped.replace("@ @", "@@")

    # Create a Markdown H3 subsection heading.
    # MkDocs (Python-Markdown with 'toc' extension) will auto-generate an ID for this.
    # This auto-generated ID should match the 'anchor' value stored in LABEL_TARGETS_MAP
    # (which was created by slugifying this same caption_text in build.py).
    # Add extra newlines for proper Markdown parsing.
    return f"\n### {caption_text}\n\n"

def replace_unlabelled_figure_caption_placeholder(match): # If you implemented this in preprocess.py
    caption_text_escaped = match.group(1)
    caption_text = caption_text_escaped.replace("@ @", "@@")
    # Maybe use H4 for these, or some other distinguishing feature
    return f"\n#### {caption_text} (Illustration)\n\n"

def replace_cross_ref_placeholder(match):
    global LABEL_TARGETS_MAP # Use the loaded map

    command_name = match.group(1).strip()       # "Cref" or "cref"
    targets_str_escaped = match.group(2).strip() # Raw comma-separated original LaTeX labels

    targets_str = targets_str_escaped.replace("@ @", "@@") # Unescape
    original_latex_labels = [t.strip() for t in targets_str.split(',')]

    output_link_parts = []
    for i, original_latex_label_id in enumerate(original_latex_labels):
        target_info = LABEL_TARGETS_MAP.get(original_latex_label_id)

        link_display_text = ""

        if target_info:
            # Use stored caption text for a more descriptive link
            linked_caption_text = target_info.get("caption_text", original_latex_label_id) # Fallback to label if caption somehow missing
            target_file = target_info["file"]
            target_anchor_slug_with_hash = target_info["anchor"] # This should already include '#'

            # Determine "Figure", "Section" prefix for display text
            prefix = "Ref." # Default prefix
            if original_latex_label_id.startswith("fig:"):
                prefix = "Figure"
            elif original_latex_label_id.startswith("sec:"):
                prefix = "Section"
            elif original_latex_label_id.startswith("tbl:"): # Example for tables
                prefix = "Table"
            elif original_latex_label_id.startswith("eq:"):  # Example for equations
                prefix = "Equation"

            # Capitalize prefix if command was "Cref"
            if command_name == "Cref":
                prefix = prefix.capitalize()
            else: # for "cref", use lowercase (common style)
                prefix = prefix.lower()

            link_display_text = f"{prefix} '{linked_caption_text}'"
            output_link_parts.append(f"[{link_display_text}]({target_file}{target_anchor_slug_with_hash})")
        else:
            # Label not found in the map - this reference is broken or to an unmapped label
            logging.warning( # Requires logging to be configured in postprocess.py if you want this
                f"Cross-reference target '{original_latex_label_id}' not found in label map. "
                f"Generating placeholder text for command '{command_name}'."
            )
            # Create a simple placeholder or a broken local link
            placeholder_text = f"{command_name} to '{original_latex_label_id}' (unresolved)"
            output_link_parts.append(f"*{placeholder_text}*") # Italicize unresolved references

        # Add separators like " and " or ", " for \Cref with multiple arguments
        if command_name == "Cref" and i < len(original_latex_labels) - 1:
            # Simplified separator logic; cleveref is more complex
            if len(original_latex_labels) > 1 and i == len(original_latex_labels) - 2:
                 output_link_parts.append(" and ")
            elif i < len(original_latex_labels) -1 :
                 output_link_parts.append(", ")

    return "".join(output_link_parts)




# Function to process Conway admonition markers and indent content
def process_conway_admonitions(content):
    """
    Finds Conway admonition markers (@@ADMONITION_START/END@@),
    converts the start marker to MkDocs admonition syntax (??? note),
    removes the end marker, and indents all content lines between the markers.
    Args:
        content (str): The Markdown content (string) after code blocks have been inserted.
    Returns:
        str: The processed Markdown content with admonitions formatted.
    """
    output_lines = []
    is_indenting_admonition = False # State flag: are we inside a Conway admonition?
    indent_prefix = "    " # Standard 4 spaces for admonition content

    # Regex to find the START marker at the beginning of a line (after optional whitespace)
    # Captures Title (Group 1). Matches literal \| escaped by Pandoc.
    admonition_start_pattern = re.compile(r'^\s*@@ADMONITION_START\\\|(.*?)\s*@@\s*$')
    # Regex to find the END marker (must be alone on line after optional whitespace)
    admonition_end_pattern = re.compile(r'^\s*@@ADMONITION_END@@\s*$')

    # print("\nDEBUG: Starting process_conway_admonitions...", file=sys.stderr)
    for i, line in enumerate(content.splitlines()):
        line_stripped = line.strip()

        # Use repr() for debugging if needed again
        # print(f"DEBUG: Line {i+1} (stripped): {repr(line_stripped)}", file=sys.stderr)

        start_match = admonition_start_pattern.match(line_stripped)
        end_match = admonition_end_pattern.match(line_stripped)

        if start_match:
            # Found the start marker
            title = start_match.group(1).strip() if start_match.group(1) else "Conway specifics"
            # print(f"DEBUG: Found START marker on line {i+1}. Title='{title}'", file=sys.stderr) # DEBUG
            output_lines.append(f'\n??? note "{title}"\n')
            is_indenting_admonition = True
        elif end_match and is_indenting_admonition:
             # print(f"DEBUG: Found END marker on line {i+1}.", file=sys.stderr) # DEBUG
             is_indenting_admonition = False
        elif is_indenting_admonition:
            # Indent content lines (same as before)
            if line.strip() or line.isspace():
                 output_lines.append(indent_prefix + line)
            else:
                 output_lines.append(line)
        else:
            output_lines.append(line)

    # print("DEBUG: Finished process_conway_admonitions.", file=sys.stderr) # DEBUG
    return "\n".join(output_lines) + "\n"


# --- Script Entry Point ---
if __name__ == "__main__":
    # Expects 4 arguments: intermediate MD file, code blocks JSON file, labels_map.json, final MD output file
    if len(sys.argv) != 5:
        print(f"Usage: python {sys.argv[0]} <input_md_intermediate> <input_code_blocks_json> <labels_map.json> <output_lagda_md>")
        sys.exit(1)

    input_md_file = sys.argv[1]
    input_code_blocks_file = sys.argv[2]
    labels_map_file = sys.argv[3]
    output_lagda_md_file = sys.argv[4] # was sys.argv[3]

    # basic logging for warnings
    logging.basicConfig(level=logging.WARNING, format='%(levelname)s (postprocess.py): %(message)s')

    global LABEL_TARGETS_MAP # allow mods of global map

    try:
        # load code block data from JSON
        print(f"Loading code blocks from {input_code_blocks_file}", file=sys.stderr)
        with open(input_code_blocks_file, 'r', encoding='utf-8') as f_code:
            code_blocks = json.load(f_code)
        print(f"Loaded {len(code_blocks)} code blocks.", file=sys.stderr)

        # load labels map from JSON
        print(f"Loading labels map from {labels_map_file}", file=sys.stderr)
        try:
            with open(labels_map_file, 'r', encoding='utf-8') as f_labels:
                LABEL_TARGETS_MAP = json.load(f_labels)
            print(f"Loaded {len(LABEL_TARGETS_MAP)} label mappings.", file=sys.stderr)
        except FileNotFoundError:
            print(f"Warning: Labels map file '{labels_map_file}' not found. Cross-references may not work.", file=sys.stderr)
            LABEL_TARGETS_MAP = {} # use empty map
        except json.JSONDecodeError as e:
            print(f"Error: Failed to parse JSON from labels map file {labels_map_file}: {e}", file=sys.stderr)
            LABEL_TARGETS_MAP = {} # use empty map on error


        # read intermediate markdown file generated by pandoc+lua
        print(f"Reading intermediate MD from {input_md_file}", file=sys.stderr)
        with open(input_md_file, 'r', encoding='utf-8') as f_md:
            intermediate_content = f_md.read()
        print(f"Read {len(intermediate_content)} chars from intermediate file.", file=sys.stderr)

        # --- REPLACEMENT ORDER ---
        # 1. Replace code block placeholders (@@CODEBLOCK_ID_n@@)
        print(f"Replacing code block placeholders...", file=sys.stderr)
        content_with_code = re.sub(
            r'@@CODEBLOCK_ID_\d+@@',
            lambda m: replace_code_placeholder(m, code_blocks),
            intermediate_content
        )

        # 2. Replace @@FIGURE_BLOCK_TO_SUBSECTION@@ (creates md headings)
        print(f"Converting figure blocks to subsections...", file=sys.stderr)
        content_after_figure_subsections = re.sub(
            r"@@FIGURE_BLOCK_TO_SUBSECTION@@label=(.*?)@@caption=(.*?)@@",
            replace_figure_block_to_subsection_placeholder,
            content_with_code,
            flags=re.DOTALL # DOTALL in case caption or label had newlines
        )

        # 2b. Replace @@UNLABELLED_FIGURE_CAPTION@@ (do we use them?)
        content_after_unlabelled_captions = re.sub(
            r"@@UNLABELLED_FIGURE_CAPTION@@caption=(.*?)@@",
            replace_unlabelled_figure_caption_placeholder,
            content_after_figure_subsections,
            flags=re.DOTALL
        )

        # 3. Replace @@CROSS_REF@@ placeholders (creates md links)
        print(f"Replacing cross-reference placeholders...", file=sys.stderr)
        content_with_cross_refs = re.sub(
            r"@@CROSS_REF@@command=(Cref|cref)@@targets=(.*?)@@",
            replace_cross_ref_placeholder,
            content_after_unlabelled_captions,
            flags=re.DOTALL # DOTALL for targets string containing newlines (unlikely)
        )

        # 4. Process Conway admonition markers (@@ADMONITION_...@@)
        print(f"Processing Conway admonitions...", file=sys.stderr)
        final_content = process_conway_admonitions(content_with_cross_refs)

        # Write fully processed final md file
        print(f"Writing final output to {output_lagda_md_file}", file=sys.stderr)
        with open(output_lagda_md_file, 'w', encoding='utf-8') as f_out:
            f_out.write(final_content)

        print(f"Successfully generated {output_lagda_md_file}")

    except FileNotFoundError as e:
        # This will catch if input_md_file or input_code_blocks_file missing
        print(f"Error: Input file not found: {e.filename}", file=sys.stderr)
        sys.exit(1)
    # JSONDecodeError for code_blocks handled separately from labels_map inside try block
    except Exception as e:
        print(f"An unexpected error occurred in postprocess.py: {e}", file=sys.stderr)
        sys.exit(1)
