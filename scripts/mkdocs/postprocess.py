# postprocess.py
# Purpose: Cleans up the intermediate Markdown file generated by Pandoc+Lua filter.
# Usage: This script is part of a four stage pipeline and is meant to be used in conjunction with
#        `generate_macros.py`, `preprocess.py`, `agda-filter.lua`, and pandoc.  For example,
#          $ python generate_macros_json.py macros.sty preprocess_macros.json
#          $ python preprocess.py Transaction.lagda preprocess_macros.json code_blocks.json > Transaction.lagda.temp
#          $ pandoc Transaction.lagda.temp -f latex -t gfm+attributes --lua-filter agda-filter.lua -o Transaction.lagda.intermediate
#          $ python postprocess.py Transaction.lagda.intermediate code_blocks.json labels_map.json Transaction.lagda.md
# Actions:
# 1. Replaces code block placeholders (@@CODEBLOCK_ID_n@@) with actual verbatim code.
# 2. Replaces admonition markers (@@ADMONITION_START/END@@) with MkDocs admonition syntax (??? note)
#    and indents the content within the admonition block.
# 3. Replaces figure block placeholders (@@FIGURE_BLOCK_TO_SUBSECTION@@) with Markdown H3 headings.
# 4. Replaces unlabelled figure caption placeholders (@@UNLABELLED_FIGURE_CAPTION@@) with Markdown H3 headings.
# 5. Replaces cross-reference placeholders (@@CROSS_REF@@) with Markdown links to the target files.
# # Notes/updates:
# 1.  `slugify_post` function (should be identical to `slugify` in `build.py`).
# 2.  `LABEL_TARGETS_MAP` Global: stores loaded map.
# 3.  New Argument Handling: `if __name__ == "__main__":` block now expects 5 arguments;
#     loads `labels_map.json` into `LABEL_TARGETS_MAP`; includes error handling for missing or malformed `labels_map.json`.
# 4.  `replace_figure_block_to_subsection_placeholder`:
#     +  takes placeholder generated by `preprocess.py`;
#     +  extracts caption text;
#     +  returns md H3 heading string (`### Actual Caption Text\n\n`); mkdocs generates ID from heading text.
# 5.  `replace_unlabelled_figure_caption_placeholder`: (Optional, if we implement in `preprocess.py` for figs
#     with captions but no labels); creates md heading.
# 6.  `replace_cross_ref_placeholder`:
#     +  extracts original LaTeX command (`Cref` or `cref`) and raw target label string(s);
#     +  splits comma-separated targets;
#     +  for each target label:
#        +  looks it up in `LABEL_TARGETS_MAP`;
#        +  if found, retrieves the target filename, pre-slugified anchor (like `#actual-caption-slug`), and original caption;
#        +  constructs descriptive link text (e.g., "Figure 'Actual Caption Text'", "section 'Some Section Title'") based on
#           original label prefix and `Cmd` (`Cref`/`cref`).
#        +  generates md link: `[Link Text](TargetFile.md#actual-caption-slug)`.
#        +  if not found, logs warning and generates placeholder italicized text.
#        +  handles multiple targets in `\Cref` with simplified "and" / "," separators.
# 7.  Order of Replacements. It's important to:
#     1.  replace `@@CODEBLOCK_ID_...@@`.
#     2.  replace `@@FIGURE_BLOCK_TO_SUBSECTION@@...@@` and `@@UNLABELLED_FIGURE_CAPTION@@...@@` to create md headings (link targets).
#     3.  replace `@@CROSS_REF@@...@@` to create links *to* targets.
#     4.  process admonitions.
#
# postprocess.py
import re
import json
import sys
import io
import logging # For warnings about unresolved labels

# --- Add slugify function (should be identical to the one in build.py) ---
import re as re_for_slugify_post # Use an alias for this script's re usage

def slugify_post(text_to_slug): # Renamed to avoid conflict if this script is imported elsewhere
    """
    Generates a slug from text, aiming for consistency with Python-Markdown's default.
    """
    if not text_to_slug: return "section" # Default slug for empty text
    text_to_slug = str(text_to_slug)
    slug = text_to_slug.lower()
    slug = re_for_slugify_post.sub(r'[^\w\s-]', '', slug) # Keep alphanumeric, whitespace, hyphens
    slug = re_for_slugify_post.sub(r'[-\s]+', '-', slug)  # Replace whitespace/multiple hyphens with one
    slug = slug.strip('-') # Remove leading/trailing hyphens
    return slug if slug else "section" # Ensure non-empty slug

# --- Global variable to store the loaded labels map ---
LABEL_TARGETS_MAP = {} # Populated from labels_map.json

# --- Existing Helper Functions ---
def indent_block(text, prefix="    "):
    """
    Indents each non-blank line of the input text string.
    """
    lines = text.split('\n')
    indented_lines = [(prefix + line if line.strip() else line) for line in lines]
    return "\n".join(indented_lines)

def replace_code_placeholder(match, code_blocks):
    """
    Callback function for re.sub to replace code placeholder IDs (@@CODEBLOCK_ID_n@@).
    """
    placeholder_id = match.group(0)
    block_data = code_blocks.get(placeholder_id)

    if not block_data:
        logging.warning(f"Code block data not found for {placeholder_id}")
        return placeholder_id

    content = block_data.get("content", "")
    is_hidden = block_data.get("hidden", False)

    content_rstrip = content.rstrip()
    if content and not content_rstrip.endswith('\n'):
       content = content_rstrip + '\n'
    elif content.strip():
       content = content_rstrip + '\n'
    else:
       content = '\n'

    if is_hidden:
        return f'\n<div class="agda-hidden-source">\n\n```agda\n{content}```\n\n</div>\n'
    else:
        return f"\n```agda\n{content}```\n"

# --- New Placeholder Replacement Functions ---
def replace_figure_block_to_subsection_placeholder(match):
    # Group 1: original_label_escaped (from label=...) (not directly used for HTML
    #          output here, but useful for debugging or other attributes).
    original_label_raw_potentially_escaped = match.group(1)

    # Group 2: caption_text_escaped (from caption=...)
    caption_text_raw = match.group(2)

    # Unescape "@@" if escaped in preprocess.py (e.g., .replace("@ @", "@@"))
    caption_text = caption_text_raw.replace("@ @", "@@")

    # remove newlines Pandoc may have introduced within caption attribute value
    caption_text_single_line = caption_text.replace("\r\n", " ").replace("\n", " ").replace("\r", " ")

    # squash multiple spaces
    caption_text_squashed = re.sub(r'\s+', ' ', caption_text_single_line).strip()

    return f"\n### {caption_text_squashed}\n\n" # using H3 for these

    # create md H3 subsection heading
    return f"\n### {caption_text}\n\n" # newlines around heading for proper md parsing

def replace_unlabelled_figure_caption_placeholder(match):
    caption_text_raw = match.group(1)
    caption_text = caption_text_raw.replace("@ @", "@@")
    # remove newlines pandoc may have introduced within caption attribute value
    caption_text_single_line = caption_text.replace("\r\n", " ").replace("\n", " ").replace("\r", " ")
    # squash multiple spaces
    caption_text_squashed = re.sub(r'\s+', ' ', caption_text_single_line).strip()

    return f"\n### {caption_text_squashed}\n\n"

def replace_cross_ref_placeholder(match):
    command_name = match.group(1).strip()       # Cref or cref
    targets_str_raw = match.group(2).strip()    # raw comma-separated original latex labels

    targets_str = targets_str_raw.replace("@ @", "@@") # unescape "@@"
    original_latex_labels = [t.strip() for t in targets_str.split(',') if t.strip()] # ensure no empty targets

    output_link_parts = []
    for i, original_latex_label_id in enumerate(original_latex_labels):
        # if not original_latex_label_id: # skip if a target is empty (e.g., due to trailing comma)
        #     continue
        target_info = LABEL_TARGETS_MAP.get(original_latex_label_id)
        link_display_text = ""
        if target_info:
            # use stored caption text for more descriptive link
            linked_caption_text = target_info.get("caption_text", original_latex_label_id)
            target_file = target_info.get("file", "")
            target_anchor_slug_with_hash = target_info.get("anchor", "") # should include '#'
            # determine "Figure", "Section" prefix for display text
            prefix = "Ref." # default prefix
            if original_latex_label_id.startswith("fig:"): prefix = "Figure"
            elif original_latex_label_id.startswith("sec:"): prefix = "Section"
            elif original_latex_label_id.startswith("tbl:"): prefix = "Table"
            elif original_latex_label_id.startswith("eq:"): prefix = "Equation"
            # could add more cases here if/as needed

            # Commenting since we should capitalize all prefixes:
            # # capitalize prefix if command was "Cref"
            # # if command_name == "Cref": prefix = prefix.capitalize()
            # # else: prefix = prefix.lower() # for "cref"

            link_display_text = f"{prefix} '{linked_caption_text}'"
            if target_file and target_anchor_slug_with_hash:
                output_link_parts.append(f"[{link_display_text}]({target_file}{target_anchor_slug_with_hash})")
            else: # should not happen if map well-formed
                logging.warning(f"Cross-reference target '{original_latex_label_id}' found in map but missing file/anchor. Fallback text.")
                output_link_parts.append(f"*{link_display_text} (link generation error)*")

        else:
            # Label not found in map; ref is broken or to unmapped label
            logging.warning(
                f"Cross-reference target '{original_latex_label_id}' NOT FOUND in label map. "
                f"Generating placeholder text for '{command_name}'."
            )
            # Create a simple placeholder or a "broken" local link attempt
            # For display text, try to make something reasonable
            default_prefix_for_unresolved = command_name.capitalize() if command_name == "Cref" else command_name
            unresolved_display_text = f"{default_prefix_for_unresolved} '{original_latex_label_id}'"
            output_link_parts.append(f"*{unresolved_display_text} (unresolved reference)*")

        # Add separators " and ", ", " for \Cref with multiple arguments
        if command_name == "Cref" and i < len(original_latex_labels) - 1:
            if len(original_latex_labels) > 1 and i == len(original_latex_labels) - 2:
                 output_link_parts.append(" and ")
            elif i < len(original_latex_labels) -1 : # avoid trailing comma if only two items
                 output_link_parts.append(", ")

    return "".join(output_link_parts)

# --- Function to process Conway admonition markers (Keep existing) ---
def process_conway_admonitions(content):
    # ... (your existing function from the uploaded postprocess.py) ...
    output_lines = []
    is_indenting_admonition = False
    indent_prefix = "    "
    admonition_start_pattern = re.compile(r'^\s*@@ADMONITION_START\\\|(.*?)\s*@@\s*$')
    admonition_end_pattern = re.compile(r'^\s*@@ADMONITION_END@@\s*$')
    for i, line in enumerate(content.splitlines()):
        line_stripped = line.strip()
        start_match = admonition_start_pattern.match(line_stripped)
        end_match = admonition_end_pattern.match(line_stripped)
        if start_match:
            title = start_match.group(1).strip() if start_match.group(1) else "Conway specifics"
            output_lines.append(f'\n??? note "{title}"\n')
            is_indenting_admonition = True
        elif end_match and is_indenting_admonition:
             is_indenting_admonition = False
        elif is_indenting_admonition:
            if line.strip() or line.isspace(): # Indent non-blank lines and lines with only whitespace
                 output_lines.append(indent_prefix + line)
            else: # Keep blank lines as they are (don't indent them)
                 output_lines.append(line)
        else:
            output_lines.append(line)
    return "\n".join(output_lines) + "\n" # Ensure trailing newline

# --- Script Entry Point ---
if __name__ == "__main__":
    # Expects 4 arguments now: md_intermediate, code_blocks_json, labels_map_json, output_lagda_md
    if len(sys.argv) != 5:
        print(f"Usage: python {sys.argv[0]} <input_md_intermediate> <input_code_blocks_json> <labels_map.json> <output_lagda_md>")
        sys.exit(1)

    input_md_file = sys.argv[1]
    input_code_blocks_file = sys.argv[2]
    labels_map_file = sys.argv[3]       # new arg for labels map
    output_lagda_md_file = sys.argv[4]  # output file

    # Configure basic logging for warnings from this script (e.g., unresolved labels)
    # Log to stderr so it's visible during build.py execution.
    logging.basicConfig(stream=sys.stderr, level=logging.WARNING, format='%(levelname)s (postprocess.py): %(message)s')

    # Load LABEL_TARGETS_MAP at the start of __main__
    # # global LABEL_TARGETS_MAP # Allow modification by loading the map

    try:
        print(f"Loading labels map from {labels_map_file}", file=sys.stderr) # use print for this initial feedback
        with open(labels_map_file, 'r', encoding='utf-8') as f_labels:
            # assign directly to module-level global variable
            #LABEL_TARGETS_MAP.update(json.load(f_labels)) # update or
            LABEL_TARGETS_MAP = json.load(f_labels)        # direct assignment
        print(f"Loaded {len(LABEL_TARGETS_MAP)} label mappings.", file=sys.stderr)
    except FileNotFoundError:
        logging.warning(f"Labels map file '{labels_map_file}' not found. Cross-references will be unresolved.")
        LABEL_TARGETS_MAP = {} # ensure it's an empty dict if file not found
    except json.JSONDecodeError as e:
        logging.error(f"Failed to parse JSON from labels map file {labels_map_file}: {e}. Cross-references may fail.")
        LABEL_TARGETS_MAP = {} # ensure it's an empty dict on error

    try:
        # Load code block data from JSON
        logging.info(f"Loading code blocks from {input_code_blocks_file}")
        # print(f"Loading code blocks from {input_code_blocks_file}", file=sys.stderr)
        with open(input_code_blocks_file, 'r', encoding='utf-8') as f_code:
            code_blocks = json.load(f_code)
        logging.info(f"Loaded {len(code_blocks)} code blocks.")
        # print(f"Loaded {len(code_blocks)} code blocks.", file=sys.stderr)

        # Load labels map from JSON
        logging.info(f"Reading intermediate MD from {input_md_file}")
        # print(f"Loading labels map from {labels_map_file}", file=sys.stderr)
        with open(input_md_file, 'r', encoding='utf-8') as f_md:
            intermediate_content = f_md.read()

        content_processed = re.sub(
            r'@@CODEBLOCK_ID_\d+@@',
            lambda m: replace_code_placeholder(m, code_blocks),
            intermediate_content
        )
        logging.info(f"Replaced code block placeholders.")

        content_processed = re.sub(
            r"@@FIGURE_BLOCK_TO_SUBSECTION@@label=(.*?)@@caption=(.*?)@@",
            replace_figure_block_to_subsection_placeholder,
            content_processed,
            flags=re.DOTALL  # ensures regex can span lines if placeholder split by Pandoc
        )
        logging.info(f"Converted figure blocks to subsections.")

        content_processed = re.sub(
            r"@@UNLABELLED_FIGURE_CAPTION@@caption=(.*?)@@",
            replace_unlabelled_figure_caption_placeholder,
            content_processed,
            flags=re.DOTALL  # ensure regex can span lines if placeholder split by pandoc
        )

        content_processed = re.sub(
            r"@@CROSS_REF@@command=(Cref|cref)@@targets=(.*?)@@",
            replace_cross_ref_placeholder,
            content_processed,
            flags=re.DOTALL
        )
        logging.info(f"Replaced cross-reference placeholders.")

        final_content = process_conway_admonitions(content_processed)
        logging.info(f"Processed Conway admonitions.")

        logging.info(f"Writing final output to {output_lagda_md_file}")
        with open(output_lagda_md_file, 'w', encoding='utf-8') as f_out:
            f_out.write(final_content)

        print(f"Successfully generated {output_lagda_md_file}") # to stdout for build.py

    except FileNotFoundError as e:
        logging.error(f"Input file not found: {e.filename}")
        sys.exit(1)
    except json.JSONDecodeError as e_json:
        # This will primarily catch errors from code_blocks.json now
        logging.error(f"Failed to parse JSON from code_blocks file {input_code_blocks_file}: {e_json}")
        sys.exit(1)
    except Exception as e:
        logging.error(f"An unexpected error occurred in postprocess.py: {e}", exc_info=True)
        sys.exit(1)
