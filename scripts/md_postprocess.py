# md_postprocess.py
# Purpose: Cleans up the intermediate Markdown file generated by Pandoc+Lua filter.
# Usage: This script is part of a four stage pipeline and is meant to be used in conjunction with
#        `generate_macros.py`, `md_preprocess.py`, `md_agda-filter.lua`, and pandoc.  For example,
#          $ python md_generate_macros_json.py macros.sty preprocess_macros.json
#          $ python md_preprocess.py Transaction.lagda preprocess_macros.json code_blocks.json > Transaction.lagda.temp
#          $ pandoc Transaction.lagda.temp -f latex -t gfm+attributes --lua-filter agda-filter.lua -o Transaction.lagda.intermediate
#          $ python postprocess.py Transaction.lagda.intermediate code_blocks.json Transaction.lagda
# Actions:
# 1. Replaces code block placeholders (@@CODEBLOCK_ID_n@@) with actual verbatim code.
# 2. Replaces admonition markers (@@ADMONITION_START/END@@) with MkDocs admonition syntax (??? note)
#    and indents the content within the admonition block.

import re
import json
import sys
import io # Used for robust line processing

# Helper function to indent a block of text consistently
def indent_block(text, prefix="    "):
    """
    Indents each non-blank line of the input text string. Also indents lines
    that contain only whitespace (to preserve relative spacing).
    Args:
        text (str): The text block to indent (potentially multi-line).
        prefix (str): The string to prepend to each applicable line.
    Returns:
        str: The indented text block.
    """
    lines = text.split('\n')
    indented_lines = [(prefix + line if line.strip() else line) for line in lines]
    return "\n".join(indented_lines)

# Code block replacer function used by re.sub
def replace_code_placeholder(match, code_blocks):
    """
    Callback function for re.sub to replace code placeholder IDs (@@CODEBLOCK_ID_n@@).
    Retrieves code from the code_blocks dict and formats it either
    as a visible code block (!!! note admonition) or a hidden one (??? note admonition).
    Args:
        match (re.Match): The regex match object for the placeholder ID.
        code_blocks (dict): The dictionary loaded from code_blocks.json.
    Returns:
        str: The formatted Markdown string for the code block/admonition.
    """
    placeholder_id = match.group(0) # The full placeholder string, e.g., "@@CODEBLOCK_ID_1@@"
    block_data = code_blocks.get(placeholder_id)

    # Safety check if ID not found in the JSON data
    if not block_data:
        print(f"Warning: Code block data not found for {placeholder_id}", file=sys.stderr)
        return placeholder_id # Return the placeholder itself if data is missing

    # Get the verbatim code content and hidden status
    content = block_data.get("content", "")
    is_hidden = block_data.get("hidden", False)

    # Ensure content ends with a newline (important before closing fence)
    # Use rstrip() to remove only trailing whitespace before check/add
    content_rstrip = content.rstrip()
    if content and not content_rstrip.endswith('\n'):
       content = content_rstrip + '\n'
    else:
       # If original content was empty or only whitespace, keep it empty maybe?
       # Or just use the rstrip version if it wasn't empty
       if content.strip(): # If there was non-whitespace content
           content = content_rstrip + '\n'
       else: # Handle case where content was purely whitespace/empty
           content = '\n' # Ensure at least a newline

    if is_hidden:
        return f'\n<div class="agda-hidden-source">\n\n```agda\n{content}```\n\n</div>\n'
        # title = "Supporting source code"
        # # Indent the code content itself by 4 spaces for nesting under ```agda
        # indented_code_content = indent_block(content, prefix="    ")
        # # Format as COLLAPSED admonition containing the code block (indented again)
        # replacement_str = f'\n??? note "{title}"\n\n    ```agda\n{indented_code_content}    ```\n' # Note final ``` is indented
        # return replacement_str
    else: # Visible code block
        return f"\n```agda\n{content}```\n"
        # Indent the code content itself by 4 spaces
        # indented_code_content = indent_block(content, prefix="    ")
        # Format as EXPANDED admonition (!!! note) containing the code block
        # replacement_str = f'\n!!! note\n\n    ```agda\n{indented_code_content}    ```\n' # Note final ``` is indented
        # return replacement_str

# Function to process Conway admonition markers and indent content
def process_conway_admonitions(content):
    """
    Finds Conway admonition markers (@@ADMONITION_START/END@@),
    converts the start marker to MkDocs admonition syntax (??? note),
    removes the end marker, and indents all content lines between the markers.
    Args:
        content (str): The Markdown content (string) after code blocks have been inserted.
    Returns:
        str: The processed Markdown content with admonitions formatted.
    """
    output_lines = []
    is_indenting_admonition = False # State flag: are we inside a Conway admonition?
    indent_prefix = "    " # Standard 4 spaces for admonition content

    # Regex to find the START marker at the beginning of a line (after optional whitespace)
    # Captures Title (Group 1). Matches literal \| escaped by Pandoc.
    admonition_start_pattern = re.compile(r'^\s*@@ADMONITION_START\\\|(.*?)\s*@@\s*$')
    # Regex to find the END marker (must be alone on line after optional whitespace)
    admonition_end_pattern = re.compile(r'^\s*@@ADMONITION_END@@\s*$')

    # print("\nDEBUG: Starting process_conway_admonitions...", file=sys.stderr)
    for i, line in enumerate(content.splitlines()):
        line_stripped = line.strip()

        # Use repr() for debugging if needed again
        # print(f"DEBUG: Line {i+1} (stripped): {repr(line_stripped)}", file=sys.stderr)

        start_match = admonition_start_pattern.match(line_stripped)
        end_match = admonition_end_pattern.match(line_stripped)

        if start_match:
            # Found the start marker
            title = start_match.group(1).strip() if start_match.group(1) else "Conway specifics"
            # print(f"DEBUG: Found START marker on line {i+1}. Title='{title}'", file=sys.stderr) # DEBUG
            output_lines.append(f'\n??? note "{title}"\n')
            is_indenting_admonition = True
        elif end_match and is_indenting_admonition:
             # print(f"DEBUG: Found END marker on line {i+1}.", file=sys.stderr) # DEBUG
             is_indenting_admonition = False
        elif is_indenting_admonition:
            # Indent content lines (same as before)
            if line.strip() or line.isspace():
                 output_lines.append(indent_prefix + line)
            else:
                 output_lines.append(line)
        else:
            output_lines.append(line)

    # print("DEBUG: Finished process_conway_admonitions.", file=sys.stderr) # DEBUG
    return "\n".join(output_lines) + "\n"


# --- Script Entry Point ---
if __name__ == "__main__":
    # Expects 3 arguments: intermediate MD file, code blocks JSON file, final MD file
    if len(sys.argv) != 4:
        print(f"Usage: python {sys.argv[0]} <input_md_intermediate> <input_code_blocks_json> <output_lagda_md>")
        sys.exit(1)

    input_md_file, input_code_blocks_file, output_lagda_md_file = sys.argv[1], sys.argv[2], sys.argv[3]

    try:
        # Load code block data from JSON
        print(f"Loading code blocks from {input_code_blocks_file}", file=sys.stderr)
        with open(input_code_blocks_file, 'r', encoding='utf-8') as f_code: code_blocks = json.load(f_code)
        print(f"Loaded {len(code_blocks)} code blocks.", file=sys.stderr)

        # Read intermediate markdown file generated by Pandoc+Lua
        print(f"Reading intermediate MD from {input_md_file}", file=sys.stderr)
        with open(input_md_file, 'r', encoding='utf-8') as f_md: intermediate_content = f_md.read()
        print(f"Read {len(intermediate_content)} chars from intermediate file.", file=sys.stderr)


        # Step 1: Replace code block placeholders (@@CODEBLOCK_ID_n@@)
        print(f"Replacing code block placeholders...", file=sys.stderr)
        content_with_code = re.sub(r'@@CODEBLOCK_ID_\d+@@', lambda m: replace_code_placeholder(m, code_blocks), intermediate_content)

        # Step 2: Process Conway admonition markers (@@ADMONITION_...@@) and indent content
        print(f"Processing Conway admonitions...", file=sys.stderr)
        final_content = process_conway_admonitions(content_with_code)

        # Write the fully processed final Markdown file
        print(f"Writing final output to {output_lagda_md_file}", file=sys.stderr)
        with open(output_lagda_md_file, 'w', encoding='utf-8') as f_out: f_out.write(final_content)

        # Final success message (to stdout for potential scripting)
        print(f"Successfully generated {output_lagda_md_file}")

    except FileNotFoundError as e:
        print(f"Error: Input file not found: {e.filename}", file=sys.stderr)
        sys.exit(1)

    except json.JSONDecodeError as e:
        print(f"Error: Failed to parse JSON file {input_code_blocks_file}: {e}", file=sys.stderr)
        sys.exit(1)

    except Exception as e:
        print(f"An error occurred: {e}", file=sys.stderr)
        sys.exit(1)
