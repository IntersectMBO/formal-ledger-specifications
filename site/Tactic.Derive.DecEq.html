<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.Derive.DecEq</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css"><link rel="stylesheet" href="Agda.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"></script><script src="AgdaKaTeX.js" defer=""></script></head><body><pre class="Agda"><a id="1" class="Comment">-- Deriving decidable equality. This works in several cases that use</a>
<a id="70" class="Comment">-- mutual recursion, examples are at the bottom.</a>
<a id="119" class="Comment">--</a>
<a id="122" class="Comment">-- TODO: This breaks with:</a>
<a id="149" class="Comment">-- - dependent records, e.g. Product</a>
<a id="186" class="Comment">-- - anything listed in Tactic.Derive</a>
<a id="224" class="Comment">-- - maybe more</a>

<a id="241" class="Symbol">{-#</a> <a id="245" class="Keyword">OPTIONS</a> <a id="253" class="Pragma">-v</a> <a id="256" class="Pragma">allTactics:100</a> <a id="271" class="Symbol">#-}</a>
<a id="275" class="Symbol">{-#</a> <a id="279" class="Keyword">OPTIONS</a> <a id="287" class="Pragma">--safe</a> <a id="294" class="Pragma">--with-K</a> <a id="303" class="Symbol">#-}</a>
<a id="307" class="Keyword">module</a> <a id="314" href="Tactic.Derive.DecEq.html" class="Module">Tactic.Derive.DecEq</a> <a id="334" class="Keyword">where</a>

<a id="341" class="Keyword">open</a> <a id="346" class="Keyword">import</a> <a id="353" href="Meta.Prelude.html" class="Module">Meta.Prelude</a>
<a id="366" class="Keyword">open</a> <a id="371" class="Keyword">import</a> <a id="378" href="Meta.Init.html" class="Module">Meta.Init</a>

<a id="389" class="Keyword">import</a> <a id="396" href="Data.List.html" class="Module">Data.List</a> <a id="406" class="Symbol">as</a> <a id="409" class="Module">L</a>
<a id="411" class="Keyword">import</a> <a id="418" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="437" class="Symbol">as</a> <a id="440" class="Module">NE</a>

<a id="444" class="Keyword">open</a> <a id="449" class="Keyword">import</a> <a id="456" href="Relation.Nullary.html" class="Module">Relation.Nullary</a>

<a id="474" class="Keyword">open</a> <a id="479" class="Keyword">import</a> <a id="486" href="Reflection.Tactic.html" class="Module">Reflection.Tactic</a>
<a id="504" class="Keyword">open</a> <a id="509" class="Keyword">import</a> <a id="516" href="Reflection.QuotedDefinitions.html" class="Module">Reflection.QuotedDefinitions</a>
<a id="545" class="Keyword">open</a> <a id="550" class="Keyword">import</a> <a id="557" href="Reflection.AST.DeBruijn.html" class="Module">Reflection.AST.DeBruijn</a>
<a id="581" class="Keyword">open</a> <a id="586" class="Keyword">import</a> <a id="593" href="Reflection.AST.Pattern.html" class="Module">Reflection.AST.Pattern</a> <a id="616" class="Keyword">using</a> <a id="622" class="Symbol">()</a> <a id="625" class="Keyword">renaming</a> <a id="634" class="Symbol">(</a><a id="635" href="Reflection.AST.Term.html#5585" class="Function Operator">_≟_</a> <a id="639" class="Symbol">to</a> <a id="642" class="Function Operator">_≟-Pattern_</a><a id="653" class="Symbol">)</a>

<a id="656" class="Keyword">open</a> <a id="661" class="Keyword">import</a> <a id="668" href="Class.DecEq.Core.html" class="Module">Class.DecEq.Core</a>
<a id="685" class="Keyword">open</a> <a id="690" class="Keyword">import</a> <a id="697" href="Class.Functor.html" class="Module">Class.Functor</a>
<a id="711" class="Keyword">open</a> <a id="716" class="Keyword">import</a> <a id="723" href="Class.MonadTC.Instances.html" class="Module">Class.MonadTC.Instances</a>
<a id="747" class="Keyword">open</a> <a id="752" class="Keyword">import</a> <a id="759" href="Class.Traversable.html" class="Module">Class.Traversable</a>

<a id="778" class="Keyword">open</a> <a id="783" class="Keyword">import</a> <a id="790" href="Tactic.ClauseBuilder.html" class="Module">Tactic.ClauseBuilder</a>
<a id="811" class="Keyword">open</a> <a id="816" class="Keyword">import</a> <a id="823" href="Tactic.Derive.html" class="Module">Tactic.Derive</a> <a id="837" class="Symbol">(</a><a id="838" class="Keyword">quote</a> <a id="844" href="Class.DecEq.Core.html#126" class="Record">DecEq</a><a id="849" class="Symbol">)</a> <a id="851" class="Symbol">(</a><a id="852" class="Keyword">quote</a> <a id="858" href="Class.DecEq.Core.html#168" class="Field Operator">_≟_</a><a id="861" class="Symbol">)</a>


<a id="865" class="Keyword">open</a> <a id="870" href="Tactic.ClauseBuilder.html#10815" class="Module">ClauseExprM</a>

<a id="883" class="Comment">-- simply typed annotated case_of_, giving better performance than without a type annotation</a>
<a id="976" class="Comment">-- the type annotation prevents elaboration time from doubling on every argument to a constructor</a>
<a id="`case_returning_of_"></a><a id="1074" href="Tactic.Derive.DecEq.html#1074" class="Function Operator">`case_returning_of_</a> <a id="1094" class="Symbol">:</a> <a id="1096" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1101" class="Symbol">→</a> <a id="1103" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1108" class="Symbol">→</a> <a id="1110" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="1115" class="Symbol">→</a> <a id="1117" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="1122" href="Tactic.Derive.DecEq.html#1074" class="Function Operator">`case</a> <a id="1128" href="Tactic.Derive.DecEq.html#1128" class="Bound">t</a> <a id="1130" href="Tactic.Derive.DecEq.html#1074" class="Function Operator">returning</a> <a id="1140" href="Tactic.Derive.DecEq.html#1140" class="Bound">t&#39;</a> <a id="1143" href="Tactic.Derive.DecEq.html#1074" class="Function Operator">of</a> <a id="1146" href="Tactic.Derive.DecEq.html#1146" class="Bound">t&#39;&#39;</a> <a id="1150" class="Symbol">=</a> <a id="1152" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="1156" class="Symbol">(</a><a id="1157" class="Keyword">quote</a> <a id="1163" href="Function.Base.html#4061" class="Function Operator">case_of_</a><a id="1171" class="Symbol">)</a> <a id="1173" class="Symbol">(</a><a id="1174" href="Reflection.Syntax.html#1475" class="InductiveConstructor">hArg?</a> <a id="1180" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1182" href="Reflection.Syntax.html#1475" class="InductiveConstructor">hArg?</a> <a id="1188" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1190" href="Reflection.Syntax.html#1475" class="InductiveConstructor">hArg?</a> <a id="1196" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1198" href="Reflection.AST.Argument.html#1333" class="InductiveConstructor">hArg</a> <a id="1203" href="Tactic.Derive.DecEq.html#1140" class="Bound">t&#39;</a> <a id="1206" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1208" href="Reflection.AST.Argument.html#1271" class="InductiveConstructor">vArg</a> <a id="1213" href="Tactic.Derive.DecEq.html#1128" class="Bound">t</a> <a id="1215" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1217" href="Reflection.AST.Argument.html#1271" class="InductiveConstructor">vArg</a> <a id="1222" href="Tactic.Derive.DecEq.html#1146" class="Bound">t&#39;&#39;</a> <a id="1226" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="1228" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="1230" class="Symbol">)</a>

<a id="1233" class="Keyword">private</a>
  <a id="1243" class="Keyword">instance</a> <a id="1252" href="Tactic.Derive.DecEq.html#1252" class="Function">_</a> <a id="1254" class="Symbol">=</a> <a id="1256" href="Tactic.ClauseBuilder.html#10571" class="Function">ContextMonad-MonadTC</a>

  <a id="1280" class="Comment">-- Here&#39;s an example of what code this generates, here for a record R with 3 fields:</a>
  <a id="1367" class="Comment">-- DecEq : DecEq R</a>
  <a id="1388" class="Comment">-- DecEq ._≟_ ⟪ x₁ , x₂ , x₃ ⟫ ⟪ y₁ , y₂ , y₃ ⟫ =</a>
  <a id="1440" class="Comment">--   case (x₁ ≟ y₁) of λ where</a>
  <a id="1473" class="Comment">--     (false because ¬p) → no (case ¬p of λ where (ofⁿ ¬p) refl → ¬p refl)</a>
  <a id="1551" class="Comment">--     (true because p₁) → case (x₂ ≟ y₂) of λ where</a>
  <a id="1606" class="Comment">--       (false because ¬p) → no (case ¬p of λ where (ofⁿ ¬p) refl → ¬p refl)</a>
  <a id="1686" class="Comment">--       (true because p₂) → case (x₃ ≟ y₃) of λ where</a>
  <a id="1743" class="Comment">--         (false because ¬p) → no (case ¬p of λ where (ofⁿ ¬p) refl → ¬p refl)</a>
  <a id="1825" class="Comment">--         (true because p₃) →  yes (case p₁ , p₂ , p₃ of λ where (ofʸ refl , ofʸ refl , ofʸ refl) → refl)</a>

  <a id="1935" class="Comment">-- patterns almost like `yes` and `no`, except that they don&#39;t match the `Reflects` proof</a>
  <a id="2027" class="Comment">-- delaying maching on the `Reflects` proof as late as possible results in a major speed increase</a>
  <a id="2127" class="Keyword">pattern</a> <a id="``yes&#39;"></a><a id="2135" href="Tactic.Derive.DecEq.html#2135" class="InductiveConstructor">``yes&#39;</a> <a id="2142" href="Tactic.Derive.DecEq.html#2181" class="Bound">x</a> <a id="2144" class="Symbol">=</a> <a id="2146" class="Keyword">quote</a> <a id="2152" href="Relation.Nullary.Decidable.Core.html#2010" class="InductiveConstructor Operator">_because_</a> <a id="2162" href="Reflection.Syntax.html#3484" class="InductiveConstructor Operator">◇⟦</a> <a id="2165" class="Keyword">quote</a> <a id="2171" href="Agda.Builtin.Bool.html#198" class="InductiveConstructor">true</a>  <a id="2177" href="Reflection.Syntax.html#3404" class="InductiveConstructor Operator">◇</a> <a id="2179" href="Reflection.Syntax.html#3484" class="InductiveConstructor Operator">∣</a> <a id="2181" href="Tactic.Derive.DecEq.html#2181" class="Bound">x</a> <a id="2183" href="Reflection.Syntax.html#3484" class="InductiveConstructor Operator">⟧</a>
  <a id="2187" class="Keyword">pattern</a> <a id="``no&#39;"></a><a id="2195" href="Tactic.Derive.DecEq.html#2195" class="InductiveConstructor">``no&#39;</a>  <a id="2202" href="Tactic.Derive.DecEq.html#2241" class="Bound">x</a> <a id="2204" class="Symbol">=</a> <a id="2206" class="Keyword">quote</a> <a id="2212" href="Relation.Nullary.Decidable.Core.html#2010" class="InductiveConstructor Operator">_because_</a> <a id="2222" href="Reflection.Syntax.html#3484" class="InductiveConstructor Operator">◇⟦</a> <a id="2225" class="Keyword">quote</a> <a id="2231" href="Agda.Builtin.Bool.html#192" class="InductiveConstructor">false</a> <a id="2237" href="Reflection.Syntax.html#3404" class="InductiveConstructor Operator">◇</a> <a id="2239" href="Reflection.Syntax.html#3484" class="InductiveConstructor Operator">∣</a> <a id="2241" href="Tactic.Derive.DecEq.html#2241" class="Bound">x</a> <a id="2243" href="Reflection.Syntax.html#3484" class="InductiveConstructor Operator">⟧</a>

  <a id="2248" class="Keyword">module</a> <a id="2255" href="Tactic.Derive.DecEq.html#2255" class="Module">_</a> <a id="2257" class="Symbol">(</a><a id="2258" href="Tactic.Derive.DecEq.html#2258" class="Bound">transName</a> <a id="2268" class="Symbol">:</a> <a id="2270" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="2275" class="Symbol">→</a> <a id="2277" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2283" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="2287" class="Symbol">)</a> <a id="2289" class="Keyword">where</a>

    <a id="2300" href="Tactic.Derive.DecEq.html#2300" class="Function">eqFromTerm</a> <a id="2311" class="Symbol">:</a> <a id="2313" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2318" class="Symbol">→</a> <a id="2320" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2325" class="Symbol">→</a> <a id="2327" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="2332" class="Symbol">→</a> <a id="2334" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="2343" href="Tactic.Derive.DecEq.html#2300" class="Function">eqFromTerm</a> <a id="2354" class="Symbol">(</a><a id="2355" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="2359" href="Tactic.Derive.DecEq.html#2359" class="Bound">n</a> <a id="2361" class="Symbol">_)</a> <a id="2364" href="Tactic.Derive.DecEq.html#2364" class="Bound">t</a> <a id="2366" href="Tactic.Derive.DecEq.html#2366" class="Bound">t&#39;</a> <a id="2369" class="Keyword">with</a> <a id="2374" href="Tactic.Derive.DecEq.html#2258" class="Bound">transName</a> <a id="2384" href="Tactic.Derive.DecEq.html#2359" class="Bound">n</a>
    <a id="2390" class="Symbol">...</a> <a id="2394" class="Symbol">|</a> <a id="2396" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2401" href="Tactic.Derive.DecEq.html#2401" class="Bound">n&#39;</a>     <a id="2408" class="Symbol">=</a> <a id="2410" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="2414" class="Symbol">(</a><a id="2415" class="Keyword">quote</a> <a id="2421" href="Class.DecEq.Core.html#168" class="Field Operator">_≟_</a><a id="2424" class="Symbol">)</a> <a id="2426" class="Symbol">(</a><a id="2427" href="Reflection.AST.Argument.html#1395" class="InductiveConstructor">iArg</a> <a id="2432" class="Symbol">(</a><a id="2433" href="Tactic.Derive.DecEq.html#2401" class="Bound">n&#39;</a> <a id="2436" href="Reflection.Syntax.html#3023" class="InductiveConstructor Operator">∙</a><a id="2437" class="Symbol">)</a> <a id="2439" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2441" href="Reflection.AST.Argument.html#1271" class="InductiveConstructor">vArg</a> <a id="2446" class="Bound">t</a> <a id="2448" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2450" href="Reflection.AST.Argument.html#1271" class="InductiveConstructor">vArg</a> <a id="2455" class="Bound">t&#39;</a> <a id="2458" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2460" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="2462" class="Symbol">)</a>
    <a id="2468" class="Symbol">...</a> <a id="2472" class="Symbol">|</a> <a id="2474" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>     <a id="2486" class="Symbol">=</a> <a id="2488" class="Keyword">quote</a> <a id="2494" href="Class.DecEq.Core.html#168" class="Field Operator">_≟_</a> <a id="2498" href="Reflection.Syntax.html#3087" class="InductiveConstructor Operator">∙⟦</a> <a id="2501" class="Bound">t</a> <a id="2503" href="Reflection.Syntax.html#3087" class="InductiveConstructor Operator">∣</a> <a id="2505" class="Bound">t&#39;</a> <a id="2508" href="Reflection.Syntax.html#3087" class="InductiveConstructor Operator">⟧</a>
    <a id="2514" href="Tactic.Derive.DecEq.html#2300" class="CatchallClause Function">eqFromTerm</a><a id="2524" class="CatchallClause"> </a><a id="2525" class="CatchallClause Symbol">_</a><a id="2526" class="CatchallClause"> </a><a id="2527" href="Tactic.Derive.DecEq.html#2527" class="CatchallClause Bound">t</a><a id="2528" class="CatchallClause"> </a><a id="2529" href="Tactic.Derive.DecEq.html#2529" class="CatchallClause Bound">t&#39;</a> <a id="2532" class="Symbol">=</a> <a id="2534" class="Keyword">quote</a> <a id="2540" href="Class.DecEq.Core.html#168" class="Field Operator">_≟_</a> <a id="2544" href="Reflection.Syntax.html#3087" class="InductiveConstructor Operator">∙⟦</a> <a id="2547" href="Tactic.Derive.DecEq.html#2527" class="Bound">t</a> <a id="2549" href="Reflection.Syntax.html#3087" class="InductiveConstructor Operator">∣</a> <a id="2551" href="Tactic.Derive.DecEq.html#2529" class="Bound">t&#39;</a> <a id="2554" href="Reflection.Syntax.html#3087" class="InductiveConstructor Operator">⟧</a>

    <a id="2561" class="Comment">-- `nothing`: outside of the diagonal, not equal</a>
    <a id="2614" class="Comment">-- `just`: on the diagonal, with that pattern, could be equal</a>
    <a id="2680" class="Comment">-- assume that the types in the pattern are properly normalized</a>
    <a id="2748" href="Tactic.Derive.DecEq.html#2748" class="Function">genBranch</a> <a id="2758" class="Symbol">:</a> <a id="2760" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2766" href="Tactic.ClauseBuilder.html#1303" class="Function">SinglePattern</a> <a id="2780" class="Symbol">→</a> <a id="2782" href="Reflection.TCI.html#554" class="Function">TC</a> <a id="2785" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
    <a id="2794" href="Tactic.Derive.DecEq.html#2748" class="Function">genBranch</a> <a id="2804" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>         <a id="2820" class="Symbol">=</a> <a id="2822" href="Class.Monad.Core.html#316" class="Field">return</a> <a id="2829" href="Function.Base.html#1993" class="Function Operator">$</a> <a id="2831" href="Reflection.QuotedDefinitions.html#498" class="Function">`no</a> <a id="2835" href="Reflection.Syntax.html#2608" class="InductiveConstructor Operator">`λ⦅</a> <a id="2839" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="2841" class="Symbol">(</a><a id="2842" class="String">&quot;&quot;</a> <a id="2845" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2847" href="Reflection.Syntax.html#1504" class="InductiveConstructor">vArg?</a><a id="2852" class="Symbol">)</a> <a id="2854" href="Data.List.Base.html#4907" class="Function Operator">]</a> <a id="2856" href="Reflection.Syntax.html#2608" class="InductiveConstructor Operator">⦆∅</a>
    <a id="2863" href="Tactic.Derive.DecEq.html#2748" class="Function">genBranch</a> <a id="2873" class="Symbol">(</a><a id="2874" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2879" class="Symbol">(</a><a id="2880" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="2883" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2885" class="Symbol">_))</a> <a id="2889" class="Symbol">=</a> <a id="2891" href="Class.Monad.Core.html#316" class="Field">return</a> <a id="2898" href="Function.Base.html#1993" class="Function Operator">$</a> <a id="2900" href="Reflection.QuotedDefinitions.html#493" class="Function">`yes</a> <a id="2905" href="Reflection.QuotedDefinitions.html#285" class="Function">`refl</a>
    <a id="2915" href="Tactic.Derive.DecEq.html#2748" class="Function">genBranch</a> <a id="2925" class="Symbol">(</a><a id="2926" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="2931" href="Tactic.Derive.DecEq.html#2931" class="Bound">p</a><a id="2932" class="Symbol">@(</a><a id="2934" href="Tactic.Derive.DecEq.html#2934" class="Bound">l</a><a id="2935" class="Symbol">@(</a><a id="2937" href="Tactic.Derive.DecEq.html#2937" class="Bound">x</a> <a id="2939" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="2941" href="Tactic.Derive.DecEq.html#2941" class="Bound">xs</a><a id="2943" class="Symbol">)</a> <a id="2945" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="2947" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="2951" class="Symbol">_</a> <a id="2953" href="Tactic.Derive.DecEq.html#2953" class="Bound">pat</a><a id="2956" class="Symbol">))</a> <a id="2959" class="Symbol">=</a> <a id="2961" class="Keyword">do</a>
      <a id="2970" class="Symbol">(</a><a id="2971" href="Agda.Builtin.Reflection.html#5814" class="InductiveConstructor">con</a> <a id="2975" href="Tactic.Derive.DecEq.html#2975" class="Bound">n</a> <a id="2977" href="Tactic.Derive.DecEq.html#2977" class="Bound">args</a><a id="2981" class="Symbol">)</a> <a id="2983" href="Class.Monad.Core.html#337" class="Field Operator">←</a> <a id="2985" href="Class.Monad.Core.html#316" class="Field">return</a> <a id="2992" href="Tactic.Derive.DecEq.html#2953" class="Bound">pat</a>
        <a id="3004" class="Keyword">where</a> <a id="3010" class="CatchallClause Symbol">_</a> <a id="3012" class="Symbol">→</a> <a id="3014" href="Class.MonadTC.html#11131" class="Function">error1</a> <a id="3021" class="String">&quot;BUG: genBranch&quot;</a>
      <a id="3044" href="Tactic.Derive.DecEq.html#3044" class="Bound">typeList</a> <a id="3053" href="Class.Monad.Core.html#337" class="Field Operator">←</a> <a id="3055" href="Class.Traversable.Core.html#587" class="Function">traverse</a> <a id="3064" href="Class.MonadTC.html#1736" class="Field">inferType</a> <a id="3074" class="Symbol">(</a><a id="3075" href="Data.List.Base.html#5910" class="Function">applyUpTo</a> <a id="3085" href="Reflection.Syntax.html#1576" class="InductiveConstructor">♯</a> <a id="3087" class="Symbol">(</a><a id="3088" href="Data.List.Base.html#4746" class="Function">length</a> <a id="3095" href="Tactic.Derive.DecEq.html#2934" class="Bound">l</a><a id="3096" class="Symbol">))</a>
      <a id="3105" class="Keyword">let</a> <a id="3109" href="Tactic.Derive.DecEq.html#3109" class="Bound">info</a> <a id="3114" class="Symbol">=</a> <a id="3116" href="Data.List.Base.html#3484" class="Function">L.zip</a> <a id="3122" href="Tactic.Derive.DecEq.html#3044" class="Bound">typeList</a> <a id="3131" class="Symbol">(</a><a id="3132" href="Data.List.Base.html#6430" class="Function">downFrom</a> <a id="3141" class="Symbol">(</a><a id="3142" href="Data.List.Base.html#4746" class="Function">length</a> <a id="3149" href="Tactic.Derive.DecEq.html#2934" class="Bound">l</a><a id="3150" class="Symbol">))</a>
      <a id="3159" class="Keyword">let</a> <a id="3163" href="Tactic.Derive.DecEq.html#3163" class="Bound">ty</a> <a id="3166" class="Symbol">=</a> <a id="3168" class="Keyword">quote</a> <a id="3174" href="Relation.Nullary.Decidable.Core.html#1966" class="Record">Dec</a> <a id="3178" href="Reflection.Syntax.html#3047" class="InductiveConstructor Operator">∙⟦</a> <a id="3181" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="3185" href="Tactic.Derive.DecEq.html#2975" class="Bound">n</a> <a id="3187" class="Symbol">(</a><a id="3188" href="Data.List.Base.html#6022" class="Function">applyDownFrom</a> <a id="3202" class="Symbol">(</a><a id="3203" href="Reflection.AST.Argument.html#1271" class="InductiveConstructor">vArg</a> <a id="3208" href="Function.Base.html#1134" class="Function Operator">∘</a> <a id="3210" href="Reflection.Syntax.html#1576" class="InductiveConstructor">♯</a> <a id="3212" href="Function.Base.html#1134" class="Function Operator">∘</a> <a id="3214" class="Symbol">(</a><a id="3215" href="Agda.Builtin.Nat.html#336" class="Primitive Operator">_+</a> <a id="3218" href="Data.List.Base.html#4746" class="Function">length</a> <a id="3225" href="Tactic.Derive.DecEq.html#2934" class="Bound">l</a><a id="3226" class="Symbol">))</a> <a id="3229" class="Symbol">(</a><a id="3230" href="Data.List.Base.html#4746" class="Function">length</a> <a id="3237" href="Tactic.Derive.DecEq.html#2934" class="Bound">l</a><a id="3238" class="Symbol">))</a>
                         <a id="3266" href="Reflection.QuotedDefinitions.html#156" class="Function Operator">`≡</a> <a id="3269" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="3273" href="Tactic.Derive.DecEq.html#2975" class="Bound">n</a> <a id="3275" class="Symbol">(</a><a id="3276" href="Data.List.Base.html#6022" class="Function">applyDownFrom</a> <a id="3290" class="Symbol">(</a><a id="3291" href="Reflection.AST.Argument.html#1271" class="InductiveConstructor">vArg</a> <a id="3296" href="Function.Base.html#1134" class="Function Operator">∘</a> <a id="3298" href="Reflection.Syntax.html#1576" class="InductiveConstructor">♯</a><a id="3299" class="Symbol">)</a> <a id="3301" class="Symbol">(</a><a id="3302" href="Data.List.Base.html#4746" class="Function">length</a> <a id="3309" href="Tactic.Derive.DecEq.html#2934" class="Bound">l</a><a id="3310" class="Symbol">))</a> <a id="3313" href="Reflection.Syntax.html#3047" class="InductiveConstructor Operator">⟧</a>
      <a id="3321" href="Class.Monad.Core.html#316" class="Field">return</a> <a id="3328" href="Function.Base.html#1993" class="Function Operator">$</a> <a id="3330" href="Data.List.Base.html#4227" class="Function">foldl</a> <a id="3336" class="Symbol">(λ</a> <a id="3339" href="Tactic.Derive.DecEq.html#3339" class="Bound">t</a> <a id="3341" class="Symbol">(</a><a id="3342" href="Tactic.Derive.DecEq.html#3342" class="Bound">eq</a> <a id="3345" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3347" href="Tactic.Derive.DecEq.html#3347" class="Bound">k</a><a id="3348" class="Symbol">)</a> <a id="3350" class="Symbol">→</a> <a id="3352" href="Tactic.Derive.DecEq.html#3750" class="Function">genCase</a> <a id="3360" class="Symbol">(</a><a id="3361" href="Reflection.AST.DeBruijn.html#1515" class="Function">weaken</a> <a id="3368" href="Tactic.Derive.DecEq.html#3347" class="Bound">k</a> <a id="3370" href="Tactic.Derive.DecEq.html#3163" class="Bound">ty</a><a id="3372" class="Symbol">)</a> <a id="3374" class="Symbol">(</a><a id="3375" href="Tactic.Derive.DecEq.html#2300" class="Function">eqFromTerm</a> <a id="3386" href="Tactic.Derive.DecEq.html#3342" class="Bound">eq</a><a id="3388" class="Symbol">)</a> <a id="3390" href="Tactic.Derive.DecEq.html#3339" class="Bound">t</a><a id="3391" class="Symbol">)</a> <a id="3393" href="Tactic.Derive.DecEq.html#4521" class="Function">genTrueCase</a> <a id="3405" href="Tactic.Derive.DecEq.html#3109" class="Bound">info</a>
      <a id="3416" class="Keyword">where</a>
        <a id="3430" href="Tactic.Derive.DecEq.html#3430" class="Function">k</a> <a id="3432" class="Symbol">=</a> <a id="3434" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">ℕ.suc</a> <a id="3440" class="Symbol">(</a><a id="3441" href="Data.List.Base.html#4746" class="Function">length</a> <a id="3448" href="Tactic.Derive.DecEq.html#2941" class="Bound">xs</a><a id="3450" class="Symbol">)</a>

        <a id="3461" href="Tactic.Derive.DecEq.html#3461" class="Function">vars</a> <a id="3466" class="Symbol">:</a> <a id="3468" href="Data.List.NonEmpty.Base.html#1285" class="Record">NE.List⁺</a> <a id="3477" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a>
        <a id="3487" href="Tactic.Derive.DecEq.html#3461" class="Function">vars</a> <a id="3492" class="Symbol">=</a> <a id="3494" class="Number">0</a> <a id="3496" href="Data.List.NonEmpty.Base.html#1331" class="InductiveConstructor Operator">NE.∷</a> <a id="3501" href="Data.List.Base.html#5910" class="Function">applyUpTo</a> <a id="3511" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">ℕ.suc</a> <a id="3517" class="Symbol">(</a><a id="3518" href="Data.List.Base.html#4746" class="Function">length</a> <a id="3525" href="Tactic.Derive.DecEq.html#2941" class="Bound">xs</a><a id="3527" class="Symbol">)</a>

        <a id="3538" class="Comment">-- case (xᵢ ≟ yᵢ) of λ { (false because ...) → no ... ; (true because p) → t }</a>
        <a id="3625" class="Comment">-- since we always add one variable to the scope of t the uncompared terms</a>
        <a id="3708" class="Comment">-- are always at index 2k+1 and k</a>
        <a id="3750" href="Tactic.Derive.DecEq.html#3750" class="Function">genCase</a> <a id="3758" class="Symbol">:</a> <a id="3760" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3765" class="Symbol">→</a> <a id="3767" class="Symbol">(</a><a id="3768" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3773" class="Symbol">→</a> <a id="3775" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3780" class="Symbol">→</a> <a id="3782" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="3786" class="Symbol">)</a> <a id="3788" class="Symbol">→</a> <a id="3790" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="3795" class="Symbol">→</a> <a id="3797" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
        <a id="3810" href="Tactic.Derive.DecEq.html#3750" class="Function">genCase</a> <a id="3818" href="Tactic.Derive.DecEq.html#3818" class="Bound">goalTy</a> <a id="3825" href="Tactic.Derive.DecEq.html#3825" class="Bound Operator">_`≟_</a> <a id="3830" href="Tactic.Derive.DecEq.html#3830" class="Bound">t</a> <a id="3832" class="Symbol">=</a> <a id="3834" href="Tactic.Derive.DecEq.html#1074" class="Function Operator">`case</a> <a id="3840" href="Reflection.Syntax.html#1576" class="InductiveConstructor">♯</a> <a id="3842" class="Symbol">(</a><a id="3843" class="Number">2</a> <a id="3845" href="Agda.Builtin.Nat.html#539" class="Primitive Operator">*</a> <a id="3847" href="Tactic.Derive.DecEq.html#3430" class="Function">k</a> <a id="3849" href="Data.Nat.Base.html#4462" class="Primitive Operator">∸</a> <a id="3851" class="Number">1</a><a id="3852" class="Symbol">)</a> <a id="3854" href="Tactic.Derive.DecEq.html#3825" class="Bound Operator">`≟</a> <a id="3857" href="Reflection.Syntax.html#1576" class="InductiveConstructor">♯</a> <a id="3859" class="Symbol">(</a><a id="3860" href="Tactic.Derive.DecEq.html#3430" class="Function">k</a> <a id="3862" href="Data.Nat.Base.html#4462" class="Primitive Operator">∸</a> <a id="3864" class="Number">1</a><a id="3865" class="Symbol">)</a>
          <a id="3877" href="Tactic.Derive.DecEq.html#1074" class="Function Operator">returning</a> <a id="3887" href="Tactic.Derive.DecEq.html#3818" class="Bound">goalTy</a>
          <a id="3904" href="Tactic.Derive.DecEq.html#1074" class="Function Operator">of</a> <a id="3907" href="Tactic.ClauseBuilder.html#7595" class="Function">clauseExprToPatLam</a> <a id="3926" class="Symbol">(</a><a id="3927" href="Tactic.ClauseBuilder.html#5786" class="InductiveConstructor">MatchExpr</a>
          <a id="3947" class="Symbol">(</a> <a id="3949" class="Symbol">(</a><a id="3950" href="Tactic.ClauseBuilder.html#1900" class="Function">singlePatternFromPattern</a> <a id="3975" class="Symbol">(</a><a id="3976" href="Reflection.AST.Argument.html#1271" class="InductiveConstructor">vArg</a> <a id="3981" class="Symbol">(</a><a id="3982" href="Tactic.Derive.DecEq.html#2135" class="InductiveConstructor">``yes&#39;</a> <a id="3989" class="Symbol">(</a><a id="3990" href="Reflection.Syntax.html#1705" class="InductiveConstructor Operator">`</a> <a id="3992" class="Number">0</a><a id="3993" class="Symbol">)))</a> <a id="3997" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3999" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="4004" class="Symbol">(</a><a id="4005" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="4010" href="Tactic.Derive.DecEq.html#3830" class="Bound">t</a><a id="4011" class="Symbol">))</a>
          <a id="4024" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4026" class="Symbol">(</a><a id="4027" href="Tactic.ClauseBuilder.html#1900" class="Function">singlePatternFromPattern</a> <a id="4052" class="Symbol">(</a><a id="4053" href="Reflection.AST.Argument.html#1271" class="InductiveConstructor">vArg</a> <a id="4058" class="Symbol">(</a><a id="4059" href="Tactic.Derive.DecEq.html#2195" class="InductiveConstructor">``no&#39;</a>  <a id="4066" class="Symbol">(</a><a id="4067" href="Reflection.Syntax.html#1705" class="InductiveConstructor Operator">`</a> <a id="4069" class="Number">0</a><a id="4070" class="Symbol">)))</a> <a id="4074" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4076" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="4081" class="Symbol">(</a><a id="4082" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="4087" class="Symbol">(</a><a id="4088" href="Reflection.QuotedDefinitions.html#498" class="Function">`no</a> <a id="4092" href="Function.Base.html#1993" class="Function Operator">$</a>
              <a id="4108" class="Comment">-- case ¬p of λ where (ofⁿ ¬p) refl → ¬p refl</a>
              <a id="4168" href="Reflection.QuotedDefinitions.html#351" class="Function Operator">`case</a> <a id="4174" href="Reflection.Syntax.html#1576" class="InductiveConstructor">♯</a> <a id="4176" class="Number">0</a> <a id="4178" href="Reflection.QuotedDefinitions.html#351" class="Function Operator">of</a> <a id="4181" href="Tactic.ClauseBuilder.html#7595" class="Function">clauseExprToPatLam</a> <a id="4200" class="Symbol">(</a><a id="4201" href="Tactic.ClauseBuilder.html#5861" class="Function">multiClauseExpr</a>
                <a id="4233" href="Data.List.Base.html#4907" class="Function Operator">[</a><a id="4234" class="Symbol">(</a>     <a id="4240" href="Tactic.ClauseBuilder.html#1900" class="Function">singlePatternFromPattern</a> <a id="4265" class="Symbol">(</a><a id="4266" href="Reflection.AST.Argument.html#1271" class="InductiveConstructor">vArg</a> <a id="4271" class="Symbol">(</a><a id="4272" class="Keyword">quote</a> <a id="4278" href="Relation.Nullary.Reflects.html#1185" class="InductiveConstructor">ofⁿ</a> <a id="4282" href="Reflection.Syntax.html#3436" class="InductiveConstructor Operator">◇⟦</a> <a id="4285" href="Reflection.Syntax.html#1705" class="InductiveConstructor Operator">`</a> <a id="4287" class="Number">0</a> <a id="4289" href="Reflection.Syntax.html#3436" class="InductiveConstructor Operator">⟧</a><a id="4290" class="Symbol">))</a>
                  <a id="4311" href="Data.List.NonEmpty.Base.html#1331" class="InductiveConstructor Operator">NE.∷</a> <a id="4316" href="Tactic.ClauseBuilder.html#1900" class="Function">singlePatternFromPattern</a> <a id="4341" class="Symbol">(</a><a id="4342" href="Reflection.AST.Argument.html#1271" class="InductiveConstructor">vArg</a> <a id="4347" href="Reflection.QuotedDefinitions.html#328" class="InductiveConstructor">``refl</a><a id="4353" class="Symbol">)</a> <a id="4355" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4357" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
                  <a id="4378" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4380" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="4385" class="Symbol">(</a><a id="4386" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="4391" href="Reflection.Syntax.html#1599" class="InductiveConstructor Operator">♯</a> <a id="4393" class="Number">0</a> <a class="AgdaKaTeX">$\begin{pmatrix} \,\href{Reflection.QuotedDefinitions.html#285}{\htmlId{4397}{\htmlClass{Function}{\text{`refl}}}}\, \end{pmatrix}$</a><a id="4404" class="Symbol">))</a> <a id="4407" href="Data.List.Base.html#4907" class="Function Operator">]</a><a id="4408" class="Symbol">))))</a>
          <a id="4423" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4425" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="4427" class="Symbol">))</a>

        <a id="4439" class="Comment">-- yes (case p₁ , ... , pₖ of λ where (ofʸ refl , ... , ofʸ refl) → refl)</a>
        <a id="4521" href="Tactic.Derive.DecEq.html#4521" class="Function">genTrueCase</a> <a id="4533" class="Symbol">:</a> <a id="4535" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
        <a id="4548" href="Tactic.Derive.DecEq.html#4521" class="Function">genTrueCase</a> <a id="4560" class="Symbol">=</a> <a id="4562" href="Reflection.QuotedDefinitions.html#493" class="Function">`yes</a> <a id="4567" href="Function.Base.html#1993" class="Function Operator">$</a>
          <a id="4579" href="Reflection.QuotedDefinitions.html#351" class="Function Operator">`case</a> <a id="4585" href="Data.List.NonEmpty.Base.html#3288" class="Function">NE.foldl₁</a> <a id="4595" class="Symbol">(</a><a id="4596" class="Keyword">quote</a> <a id="4602" href="Data.Product.Base.html#1686" class="Function Operator">_,′_</a> <a id="4607" href="Reflection.Syntax.html#3087" class="InductiveConstructor Operator">∙⟦_∣_⟧</a><a id="4613" class="Symbol">)</a> <a id="4615" class="Symbol">(</a><a id="4616" href="Data.List.NonEmpty.Base.html#2332" class="Function">NE.map</a> <a id="4623" href="Reflection.Syntax.html#1576" class="InductiveConstructor">♯</a> <a id="4625" href="Tactic.Derive.DecEq.html#3461" class="Function">vars</a><a id="4629" class="Symbol">)</a>
           <a id="4642" href="Reflection.QuotedDefinitions.html#351" class="Function Operator">of</a> <a id="4645" href="Tactic.ClauseBuilder.html#7595" class="Function">clauseExprToPatLam</a> <a id="4664" class="Symbol">(</a><a id="4665" href="Tactic.ClauseBuilder.html#5786" class="InductiveConstructor">MatchExpr</a>
             <a id="4688" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="4690" class="Symbol">(</a><a id="4691" href="Tactic.ClauseBuilder.html#1900" class="Function">singlePatternFromPattern</a>
                 <a id="4733" class="Symbol">(</a><a id="4734" href="Reflection.AST.Argument.html#1271" class="InductiveConstructor">vArg</a> <a id="4739" class="Symbol">(</a><a id="4740" href="Data.List.NonEmpty.Base.html#3288" class="Function">NE.foldl₁</a> <a id="4750" class="Symbol">(</a><a id="4751" class="Keyword">quote</a> <a id="4757" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a> <a id="4761" href="Reflection.Syntax.html#3484" class="InductiveConstructor Operator">◇⟦_∣_⟧</a><a id="4767" class="Symbol">)</a> <a id="4769" class="Symbol">(</a><a id="4770" href="Data.List.NonEmpty.Base.html#2332" class="Function">NE.map</a> <a id="4777" class="Symbol">(λ</a> <a id="4780" href="Tactic.Derive.DecEq.html#4780" class="Bound">_</a> <a id="4782" class="Symbol">→</a> <a id="4784" class="Keyword">quote</a> <a id="4790" href="Relation.Nullary.Reflects.html#1148" class="InductiveConstructor">ofʸ</a> <a id="4794" href="Reflection.Syntax.html#3436" class="InductiveConstructor Operator">◇⟦</a> <a id="4797" href="Reflection.QuotedDefinitions.html#328" class="InductiveConstructor">``refl</a> <a id="4804" href="Reflection.Syntax.html#3436" class="InductiveConstructor Operator">⟧</a><a id="4805" class="Symbol">)</a> <a id="4807" href="Tactic.Derive.DecEq.html#3461" class="Function">vars</a><a id="4811" class="Symbol">)))</a>
             <a id="4828" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4830" href="Data.Sum.Base.html#700" class="InductiveConstructor">inj₂</a> <a id="4835" class="Symbol">(</a><a id="4836" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="4841" href="Reflection.QuotedDefinitions.html#285" class="Function">`refl</a><a id="4846" class="Symbol">))</a> <a id="4849" href="Data.List.Base.html#4907" class="Function Operator">]</a><a id="4850" class="Symbol">)</a>

    <a id="4857" href="Tactic.Derive.DecEq.html#4857" class="Function">toMapDiag</a> <a id="4867" class="Symbol">:</a> <a id="4869" href="Tactic.ClauseBuilder.html#1303" class="Function">SinglePattern</a> <a id="4883" class="Symbol">→</a> <a id="4885" href="Tactic.ClauseBuilder.html#1303" class="Function">SinglePattern</a> <a id="4899" class="Symbol">→</a> <a id="4901" href="Data.List.NonEmpty.Base.html#1285" class="Record">NE.List⁺</a> <a id="4910" href="Tactic.ClauseBuilder.html#1303" class="Function">SinglePattern</a> <a id="4924" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="4926" href="Reflection.TCI.html#554" class="Function">TC</a> <a id="4929" class="Symbol">(</a><a id="4930" href="Tactic.ClauseBuilder.html#5761" class="Datatype">ClauseExpr</a> <a id="4941" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="4943" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="4949" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="4953" class="Symbol">)</a>
    <a id="4959" href="Tactic.Derive.DecEq.html#4857" class="Function">toMapDiag</a> <a id="4969" href="Tactic.Derive.DecEq.html#4969" class="Bound">p</a><a id="4970" class="Symbol">@(_</a> <a id="4974" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4976" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="4980" class="Symbol">_</a> <a id="4982" href="Tactic.Derive.DecEq.html#4982" class="Bound">p₁</a><a id="4984" class="Symbol">)</a> <a id="4986" href="Tactic.Derive.DecEq.html#4986" class="Bound">p&#39;</a><a id="4988" class="Symbol">@(_</a> <a id="4992" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4994" href="Agda.Builtin.Reflection.html#3732" class="InductiveConstructor">arg</a> <a id="4998" class="Symbol">_</a> <a id="5000" href="Tactic.Derive.DecEq.html#5000" class="Bound">p₂</a><a id="5002" class="Symbol">)</a> <a id="5004" class="Symbol">=</a>
      <a id="5012" class="Symbol">(</a><a id="5013" href="Tactic.Derive.DecEq.html#4969" class="Bound">p</a> <a id="5015" href="Data.List.NonEmpty.Base.html#1331" class="InductiveConstructor Operator">NE.∷</a> <a id="5020" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="5022" href="Tactic.Derive.DecEq.html#4986" class="Bound">p&#39;</a> <a id="5025" href="Data.List.Base.html#4907" class="Function Operator">]</a> <a id="5027" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5029" href="Tactic.ClauseBuilder.html#12723" class="Function">finishMatch</a> <a id="5041" class="Symbol">(</a><a id="5042" href="Data.Bool.Base.html#1515" class="Function Operator">if</a> <a id="5045" href="Relation.Nullary.Decidable.Core.html#5031" class="Function Operator">⌊</a> <a id="5047" href="Tactic.Derive.DecEq.html#4982" class="Bound">p₁</a> <a id="5050" href="Tactic.Derive.DecEq.html#642" class="Function Operator">≟-Pattern</a> <a id="5060" href="Tactic.Derive.DecEq.html#5000" class="Bound">p₂</a> <a id="5063" href="Relation.Nullary.Decidable.Core.html#5031" class="Function Operator">⌋</a> <a id="5065" href="Data.Bool.Base.html#1515" class="Function Operator">then</a> <a id="5070" href="Tactic.Derive.DecEq.html#2748" class="Function">genBranch</a> <a id="5080" class="Symbol">(</a><a id="5081" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="5086" href="Tactic.Derive.DecEq.html#4969" class="Bound">p</a><a id="5087" class="Symbol">)</a> <a id="5089" href="Data.Bool.Base.html#1515" class="Function Operator">else</a> <a id="5094" href="Tactic.Derive.DecEq.html#2748" class="Function">genBranch</a> <a id="5104" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a><a id="5111" class="Symbol">))</a>

<a id="5115" class="Keyword">module</a> <a id="5122" href="Tactic.Derive.DecEq.html#5122" class="Module">_</a> <a id="5124" class="Symbol">⦃</a> <a id="5126" href="Tactic.Derive.DecEq.html#5126" class="Bound">_</a> <a id="5128" class="Symbol">:</a> <a id="5130" href="Class.MonadTC.html#620" class="Record">TCOptions</a> <a id="5140" class="Symbol">⦄</a> <a id="5142" class="Keyword">where</a>
  <a id="5150" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="5163" class="Symbol">:</a> <a id="5165" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5170" class="Symbol">(</a><a id="5171" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="5176" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="5178" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a><a id="5182" class="Symbol">)</a> <a id="5184" class="Symbol">→</a> <a id="5186" href="Reflection.Tactic.html#476" class="Function">UnquoteDecl</a>
  <a id="5200" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="5213" class="Symbol">=</a> <a id="5215" href="Tactic.Derive.html#5830" class="Function">derive-Class</a> <a id="5228" class="Number">0</a> <a id="5230" class="Symbol">(λ</a> <a id="5233" href="Tactic.Derive.DecEq.html#5233" class="Bound">transName</a> <a id="5243" href="Tactic.Derive.DecEq.html#5243" class="Bound">ps</a> <a id="5246" class="Symbol">→</a> <a id="5248" href="Data.List.Base.html#2110" class="Function">cartesianProductWith</a> <a id="5269" class="Symbol">(</a><a id="5270" href="Tactic.Derive.DecEq.html#4857" class="Function">toMapDiag</a> <a id="5280" href="Tactic.Derive.DecEq.html#5233" class="Bound">transName</a><a id="5289" class="Symbol">)</a> <a id="5291" href="Tactic.Derive.DecEq.html#5243" class="Bound">ps</a> <a id="5294" href="Tactic.Derive.DecEq.html#5243" class="Bound">ps</a><a id="5296" class="Symbol">)</a>

<a id="5299" class="Keyword">private</a>
  <a id="5309" class="Keyword">open</a> <a id="5314" class="Keyword">import</a> <a id="5321" href="Tactic.Derive.TestTypes.html" class="Module">Tactic.Derive.TestTypes</a>
  <a id="5347" class="Keyword">open</a> <a id="5352" class="Keyword">import</a> <a id="5359" href="Tactic.Defaults.html" class="Module">Tactic.Defaults</a>

  <a id="5378" class="Keyword">unquoteDecl</a> <a id="DecEq-These"></a><a id="5390" href="Tactic.Derive.DecEq.html#5390" class="Function">DecEq-These</a> <a id="5402" class="Symbol">=</a> <a id="5404" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="5417" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="5419" class="Symbol">(</a><a id="5420" class="Keyword">quote</a> <a id="5426" href="Data.These.Base.html#573" class="Datatype">These</a> <a id="5432" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5434" href="Tactic.Derive.DecEq.html#5390" class="Function">DecEq-These</a><a id="5445" class="Symbol">)</a> <a id="5447" href="Data.List.Base.html#4907" class="Function Operator">]</a>

  <a id="5452" class="Keyword">unquoteDecl</a> <a id="DecEq-⊎"></a><a id="5464" href="Tactic.Derive.DecEq.html#5464" class="Function">DecEq-⊎</a> <a id="5472" class="Symbol">=</a> <a id="5474" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="5487" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="5489" class="Symbol">(</a><a id="5490" class="Keyword">quote</a> <a id="5496" href="Data.Sum.Base.html#625" class="Datatype Operator">_⊎_</a> <a id="5500" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5502" href="Tactic.Derive.DecEq.html#5464" class="Function">DecEq-⊎</a><a id="5509" class="Symbol">)</a> <a id="5511" href="Data.List.Base.html#4907" class="Function Operator">]</a>

  <a id="5516" class="Keyword">unquoteDecl</a> <a id="DecEq-Bool"></a><a id="5528" href="Tactic.Derive.DecEq.html#5528" class="Function">DecEq-Bool</a> <a id="DecEq-ℤ"></a><a id="5539" href="Tactic.Derive.DecEq.html#5539" class="Function">DecEq-ℤ</a> <a id="DecEq-List"></a><a id="5547" href="Tactic.Derive.DecEq.html#5547" class="Function">DecEq-List</a> <a id="DecEq-Maybe"></a><a id="5558" href="Tactic.Derive.DecEq.html#5558" class="Function">DecEq-Maybe</a> <a id="DecEq-ℕ"></a><a id="5570" href="Tactic.Derive.DecEq.html#5570" class="Function">DecEq-ℕ</a> <a id="DecEq-Sign"></a><a id="5578" href="Tactic.Derive.DecEq.html#5578" class="Function">DecEq-Sign</a> <a id="DecEq-⊤"></a><a id="5589" href="Tactic.Derive.DecEq.html#5589" class="Function">DecEq-⊤</a> <a id="5597" class="Symbol">=</a> <a id="5599" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="5612" class="Symbol">((</a><a id="5614" class="Keyword">quote</a> <a id="5620" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a> <a id="5625" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5627" href="Tactic.Derive.DecEq.html#5528" class="Function">DecEq-Bool</a><a id="5637" class="Symbol">)</a> <a id="5639" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5641" class="Symbol">(</a><a id="5642" class="Keyword">quote</a> <a id="5648" href="Agda.Builtin.Int.html#245" class="Datatype">ℤ</a> <a id="5650" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5652" href="Tactic.Derive.DecEq.html#5539" class="Function">DecEq-ℤ</a><a id="5659" class="Symbol">)</a> <a id="5661" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5663" class="Symbol">(</a><a id="5664" class="Keyword">quote</a> <a id="5670" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="5675" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5677" href="Tactic.Derive.DecEq.html#5547" class="Function">DecEq-List</a><a id="5687" class="Symbol">)</a> <a id="5689" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5691" class="Symbol">(</a><a id="5692" class="Keyword">quote</a> <a id="5698" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="5704" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5706" href="Tactic.Derive.DecEq.html#5558" class="Function">DecEq-Maybe</a><a id="5717" class="Symbol">)</a> <a id="5719" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5721" class="Symbol">(</a><a id="5722" class="Keyword">quote</a> <a id="5728" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a> <a id="5730" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5732" href="Tactic.Derive.DecEq.html#5570" class="Function">DecEq-ℕ</a><a id="5739" class="Symbol">)</a> <a id="5741" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5743" class="Symbol">(</a><a id="5744" class="Keyword">quote</a> <a id="5750" href="Data.Sign.Base.html#523" class="Datatype">Sign</a> <a id="5755" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5757" href="Tactic.Derive.DecEq.html#5578" class="Function">DecEq-Sign</a><a id="5767" class="Symbol">)</a> <a id="5769" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5771" class="Symbol">(</a><a id="5772" class="Keyword">quote</a> <a id="5778" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="5780" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5782" href="Tactic.Derive.DecEq.html#5589" class="Function">DecEq-⊤</a><a id="5789" class="Symbol">)</a> <a id="5791" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="5793" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="5795" class="Symbol">)</a>

  <a id="5800" class="Keyword">unquoteDecl</a> <a id="DecEq-Fin"></a><a id="5812" href="Tactic.Derive.DecEq.html#5812" class="Function">DecEq-Fin</a> <a id="5822" class="Symbol">=</a> <a id="5824" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="5837" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="5839" class="Symbol">(</a><a id="5840" class="Keyword">quote</a> <a id="5846" href="Data.Fin.Base.html#1132" class="Datatype">Fin</a> <a id="5850" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="5852" href="Tactic.Derive.DecEq.html#5812" class="Function">DecEq-Fin</a><a id="5861" class="Symbol">)</a> <a id="5863" href="Data.List.Base.html#4907" class="Function Operator">]</a>

  <a id="5868" class="Comment">-- this doesn&#39;t work since the clause builder machinery doesn&#39;t deal</a>
  <a id="5939" class="Comment">-- with absurd patterns yet</a>

  <a id="5970" class="Comment">--unquoteDecl DecEq-Vec = derive-DecEq [ (quote Vec , DecEq-Vec) ]</a>

  <a id="6040" class="Keyword">unquoteDecl</a> <a id="DecEq-E1"></a><a id="6052" href="Tactic.Derive.DecEq.html#6052" class="Function">DecEq-E1</a> <a id="6061" class="Symbol">=</a> <a id="6063" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="6076" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="6078" class="Symbol">(</a><a id="6079" class="Keyword">quote</a> <a id="6085" href="Tactic.Derive.TestTypes.html#204" class="Datatype">E1</a> <a id="6088" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6090" href="Tactic.Derive.DecEq.html#6052" class="Function">DecEq-E1</a><a id="6098" class="Symbol">)</a> <a id="6100" href="Data.List.Base.html#4907" class="Function Operator">]</a>
  <a id="6104" class="Keyword">unquoteDecl</a> <a id="DecEq-E2"></a><a id="6116" href="Tactic.Derive.DecEq.html#6116" class="Function">DecEq-E2</a> <a id="6125" class="Symbol">=</a> <a id="6127" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="6140" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="6142" class="Symbol">(</a><a id="6143" class="Keyword">quote</a> <a id="6149" href="Tactic.Derive.TestTypes.html#309" class="Datatype">E2</a> <a id="6152" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6154" href="Tactic.Derive.DecEq.html#6116" class="Function">DecEq-E2</a><a id="6162" class="Symbol">)</a> <a id="6164" href="Data.List.Base.html#4907" class="Function Operator">]</a>

  <a id="6169" class="Comment">-- this uses mutual recursion with List E3</a>
  <a id="6214" class="Keyword">unquoteDecl</a> <a id="DecEq-E3"></a><a id="6226" href="Tactic.Derive.DecEq.html#6226" class="Function">DecEq-E3</a> <a id="6235" class="Symbol">=</a> <a id="6237" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="6250" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="6252" class="Symbol">(</a><a id="6253" class="Keyword">quote</a> <a id="6259" href="Tactic.Derive.TestTypes.html#387" class="Datatype">E3</a> <a id="6262" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6264" href="Tactic.Derive.DecEq.html#6226" class="Function">DecEq-E3</a><a id="6272" class="Symbol">)</a> <a id="6274" href="Data.List.Base.html#4907" class="Function Operator">]</a>
  <a id="6278" class="Comment">-- unquoteDecl DecEq-E4 = derive-DecEq [ (quote E4 , DecEq-E4) ]</a>

  <a id="6346" class="Keyword">unquoteDecl</a> <a id="DecEq-R1"></a><a id="6358" href="Tactic.Derive.DecEq.html#6358" class="Function">DecEq-R1</a> <a id="6367" class="Symbol">=</a> <a id="6369" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="6382" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="6384" class="Symbol">(</a><a id="6385" class="Keyword">quote</a> <a id="6391" href="Tactic.Derive.TestTypes.html#597" class="Record">R1</a> <a id="6394" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6396" href="Tactic.Derive.DecEq.html#6358" class="Function">DecEq-R1</a><a id="6404" class="Symbol">)</a> <a id="6406" href="Data.List.Base.html#4907" class="Function Operator">]</a>
  <a id="6410" class="Keyword">unquoteDecl</a> <a id="DecEq-R2"></a><a id="6422" href="Tactic.Derive.DecEq.html#6422" class="Function">DecEq-R2</a> <a id="6431" class="Symbol">=</a> <a id="6433" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="6446" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="6448" class="Symbol">(</a><a id="6449" class="Keyword">quote</a> <a id="6455" href="Tactic.Derive.TestTypes.html#658" class="Record">R2</a> <a id="6458" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6460" href="Tactic.Derive.DecEq.html#6422" class="Function">DecEq-R2</a><a id="6468" class="Symbol">)</a> <a id="6470" href="Data.List.Base.html#4907" class="Function Operator">]</a>
  <a id="6474" class="Keyword">unquoteDecl</a> <a id="DecEq-R20"></a><a id="6486" href="Tactic.Derive.DecEq.html#6486" class="Function">DecEq-R20</a> <a id="6496" class="Symbol">=</a> <a id="6498" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="6511" href="Data.List.Base.html#4907" class="Function Operator">[</a> <a id="6513" class="Symbol">(</a><a id="6514" class="Keyword">quote</a> <a id="6520" href="Tactic.Derive.TestTypes.html#807" class="Record">R20</a> <a id="6524" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6526" href="Tactic.Derive.DecEq.html#6486" class="Function">DecEq-R20</a><a id="6535" class="Symbol">)</a> <a id="6537" href="Data.List.Base.html#4907" class="Function Operator">]</a>

  <a id="6542" class="Keyword">unquoteDecl</a> <a id="DecEq-M₁"></a><a id="6554" href="Tactic.Derive.DecEq.html#6554" class="Function">DecEq-M₁</a> <a id="DecEq-M₂"></a><a id="6563" href="Tactic.Derive.DecEq.html#6563" class="Function">DecEq-M₂</a> <a id="6572" class="Symbol">=</a> <a id="6574" href="Tactic.Derive.DecEq.html#5150" class="Function">derive-DecEq</a> <a id="6587" href="Function.Base.html#1993" class="Function Operator">$</a> <a id="6589" class="Symbol">(</a><a id="6590" class="Keyword">quote</a> <a id="6596" href="Tactic.Derive.TestTypes.html#914" class="Datatype">M₁</a> <a id="6599" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6601" href="Tactic.Derive.DecEq.html#6554" class="Function">DecEq-M₁</a><a id="6609" class="Symbol">)</a> <a id="6611" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6613" class="Symbol">(</a><a id="6614" class="Keyword">quote</a> <a id="6620" href="Tactic.Derive.TestTypes.html#928" class="Datatype">M₂</a> <a id="6623" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6625" href="Tactic.Derive.DecEq.html#6563" class="Function">DecEq-M₂</a><a id="6633" class="Symbol">)</a> <a id="6635" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6637" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

  <a id="6643" class="Comment">-- Expected: DecEq-Term DecEq-Product</a>
</pre></body></html>