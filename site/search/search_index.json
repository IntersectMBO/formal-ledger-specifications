{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"The Cardano Formal Ledger Specification","text":"<p>This is the formal ledger specifications for the Cardano blockchain. It is written in Agda and is executable; Haskell code can be extracted and run for conformance testing.</p> <p>The project consists entirely of literate Agda code from which the HTML documentation is generated.  Thus the latest human-readable Cardano ledger specification is a collection of HTML files; these replace the PDF documents of previous eras.</p> <p>The formal ledger GitHub repository contains formal ledger specifications for all eras, starting with Shelley, up to and including the Conway era. While the Agda formalization of the Conway era is complete, some pieces of the ledgers from previous eras have yet to be formalized.  We hope to finish formalizing the outstanding pieces in the near future.</p>"},{"location":"index.html#where-to-go-from-here","title":"Where to go from here?","text":"<p>You can</p> <ul> <li> <p>read the Introduction module of the HTML version of the formal specification</p> </li> <li> <p>dive into one of the modules in the Conway/ &gt; Specification/ section of the website; for instance, you can read about how rewards are calculated in the Conway/Specification/Rewards module</p> </li> <li> <p>view the HTML version of the Agda source code</p> </li> <li> <p>interact with and/or contribute to the formal specification; instructions for    building the artifacts, generating Haskell source code for conformance testing, or    exploring the literate Agda files in a development environment are available in    the Contributing Guide.</p> </li> </ul>"},{"location":"index.html#published-artifacts","title":"\ud83d\udcdc Published Artifacts","text":"<p>The table below provides links to the full formal ledger specification (as browsable HTML), as well as the legacy PDF artifacts.</p> Artifact Link Description Source Code HTML Interactive, hyperlinked version of the Agda source code Formal Specification HTML cardano-ledger.pdf<sup>\u2020</sup> Complete specification of the Cardano Ledger Conway-Era PDF conway-ledger.pdf<sup>\u2020</sup> Covers what's new in the Conway era <p>\u2020 As we are migrating from a LaTeX-based to a Markdown-based documentation workflow, building PDFs from source is currently deprecated and unsupported.  Please use the links above to access the pre-built PDF documents.</p>"},{"location":"index.html#contributions-and-feedback","title":"\ud83e\udd1d Contributions and Feedback","text":"<p>We welcome contributions and feedback!</p> <p>For detailed instructions on setting up a development environment, running tests, and understanding the project structure, please see our Contributing Guide.</p> <p>If you encounter any issues, please check the Troubleshooting Guide or submit a new issue in this repository.</p>"},{"location":"ConwayBootstrap.html","title":"Bootstrapping the Governance System","text":"<p>As described in CIP-1694, the governance system needs to be bootstrapped.  During the bootstrap period, the following changes will be made to the ledger described in this document.</p> <ul> <li> <p>Transactions containing any proposal except <code>TriggerHardFork</code>, <code>ChangePParams</code>, or <code>Info</code> will be rejected.</p> </li> <li> <p>Transactions containing a vote other than a <code>CC</code> vote, a <code>SPO</code> vote on a <code>TriggerHardFork</code> action, or any vote on an <code>Info</code> action will be rejected.</p> </li> <li> <p><code>Q4</code>, <code>P5</code>, and <code>Q5e</code> are set to \\(0\\).</p> </li> <li> <p>An SPO that does not vote is assumed to have voted <code>abstain</code>.</p> </li> </ul> <p>This allows for a governance mechanism similar to the old, Shelley-era governance during the bootstrap phase, where the constitutional committee is mostly in charge (Team18, ). These restrictions will be removed during a subsequent hard fork, once enough DRep stake is present in the system to properly govern and secure itself.</p> <p>[Team18]  IOHK Formal Methods Team. Design Specification for Delegation and Incentives in Cardano, IOHK Deliverable SL-D1. 2018.</p>"},{"location":"ConwayBootstrapEnact.html","title":"Bootstrapping EnactState","text":"<p>To form an <code>EnactState</code>, some governance action IDs need to be provided. However, at the time of the initial hard fork into Conway there are no such previous actions. There are effectively two ways to solve this issue:</p> <ul> <li> <p>populate those fields with IDs chosen in some manner (e.g. random, all zeros, etc.), or</p> </li> <li> <p>add a special value to the types to indicate this situation.</p> </li> </ul> <p>In the Haskell implementation the latter solution was chosen. This means that everything that deals with <code>GovActionID</code> needs to be aware of this special case and handle it properly.</p> <p>This specification could have mirrored this choice, but it is not necessary here: since it is already necessary to assume the absence of hash-collisions (specifically first pre-image resistance) for various properties, we could pick arbitrary initial values to mirror this situation. Then, since <code>GovActionID</code> contains a hash, that arbitrary initial value behaves just like a special case.</p>"},{"location":"Definitions.html","title":"Definitions","text":"<p>To keep this site somewhat self-contained, we define some technical terms that arise when defining and describing the Cardano blockchain and ledger. This is not meant to be comprehensive and the reader may wish to consult online resources to fill in any gaps. Here are a few such resources that might be helpful.</p> <ul> <li> <p>https://docs.cardano.org/;</p> </li> <li> <p>https://cardano.org/docs/glossary#cardano-glossary;</p> </li> <li> <p>https://www.ledger.com/academy/glossary;</p> </li> <li> <p>https://www.essentialcardano.io/glossary;</p> </li> <li> <p>(Re)introduction to Cardano, by Eduardo Garrido and the Cardano community;</p> </li> <li> <p>Ouroboros Chronos blog post, by Olga Hryniuk;</p> </li> <li> <p>Cardano Staking: How To Stake ADA.</p> </li> </ul>"},{"location":"Definitions.html#sec:cardano-time-handling","title":"Cardano Time Handling","text":"<p>For more details, see the Time handling on Cardano section of https://docs.cardano.org.</p> <p>In Cardano, the Ouroboros proof-of-stake (PoS) consensus protocol models the passage of physical time as an infinite sequence of time slots and epochs.</p> <ul> <li> <p>The actual time interval between blocks, or block time, is the     slot length (in seconds) divided by the block coefficient f, which     is the expected block frequency (blocks per second). For example, if     f is 0.05, then on average 5% of slots contain blocks. If the slot     length is 1 second, then the block time is 20 seconds.</p> </li> <li> <p>An epoch is a period of time, containing some number of slots,     used to select block-producing nodes. For example, in Shelley and     later eras, an epoch consists of roughly 432,000 slots (or five days     if we assume a slot length of 1 second).</p> </li> <li> <p>The genesis block of Cardano was created on the 23rd of     September 2017. As the first block in the blockchain, it set the     foundation for the network, it does not reference any previous     blocks, and it generated the initial supply of Ada.</p> </li> <li> <p>A slot is a discrete time interval in which a single block may be     produced; it is the fundamental time unit within the blockchain's     consensus protocol. Slots should be long enough for a new block to     have a good chance to reach the next slot leader in time. For     example, the slot length in the Byron era was 20 seconds, while in     Shelley and later eras it is 1 second. Not every slot results in a     new block. Indeed, in any given slot, one or more block-producing     nodes are nominated (probabilistically based on stake distribution)     to be slot leaders and given the opportunity to produce a new     block. For example, in Shelley and later eras, on average only 0.05     of slots will produce a block (resulting in 20-second intervals     between blocks). Slot number may refer to a slot's position within     the current epoch or it may mean the absolute slot count since the     genesis block. The context should make clear which meaning is     intended.</p> </li> </ul> <p>The parameter values mentioned in the examples above,</p> <ul> <li> <p>block time = 20 seconds,</p> </li> <li> <p>slot length = 1 second,</p> </li> <li> <p>block coefficient = 0.05,</p> </li> <li> <p>slots/epoch = 432,000,</p> </li> </ul> <p>are unlikely to change in the short-term. However, the longer term plan is to replace the current Ouroboros protocol with Ouroboros Chronos, which addresses timekeeping challenges by providing the first high-resilience cryptographic time source based on blockchain technology (see the Ouroboros Chronos blog post).</p>"},{"location":"Foreign.Convertible.Deriving.html","title":"Deriving","text":"<pre><code>module Foreign.Convertible.Deriving where\n\nopen import Level\nopen import Meta.Prelude\nopen import Meta.Init\n\nimport Data.List as L\nimport Data.List.NonEmpty as NE\nimport Data.String as S\nimport Data.Product as P\n\nopen import Relation.Nullary\nopen import Relation.Nullary.Decidable\n\nopen import Reflection.Tactic\nopen import Reflection.AST.Term\nopen import Reflection.AST.DeBruijn\nimport Reflection.TCM as R\nopen import Reflection.Utils\nopen import Reflection.Utils.TCI\nopen import Reflection.Utils.Substitute\nimport Function.Identity.Effectful as Identity\n\nopen import Class.DecEq\nopen import Class.DecEq\nopen import Class.Functor\nopen import Class.Monad\nopen import Class.MonadTC.Instances\nopen import Class.Traversable\nopen import Class.Show\nopen import Class.MonadReader\n\nopen import Foreign.Convertible\nopen import Foreign.HaskellTypes\nopen import Foreign.HaskellTypes.Deriving\n\nprivate instance\n  _ = Functor-M {TC}\n\nprivate\n\n  open MonadReader \u2983...\u2984\n\n  TyViewTel = List (Abs (Arg Type))\n\n  substTel : Subst TyViewTel\n  substTel x s [] = []\n  substTel x s (abs z t \u2237 tel) = abs z (substArg x s t) \u2237 (substTel (\u2115.suc x) s tel)\n    -- Note: `abs` is abused in TyViewTel and doesn't actually scope over the `t`\n\n  -- Substitute leading level parameters with lzero\n  smashLevels : TyViewTel \u2192 \u2115 \u00d7 TyViewTel\n  smashLevels (abs s (arg i (def (quote Level) [])) \u2237 tel) =\n    P.map \u2115.suc (substTel 0 (quote 0\u2113 \u2219)) $ smashLevels tel\n  smashLevels tel = (0 , tel)\n\n  tyViewToTel : TyViewTel \u2192 Telescope\n  tyViewToTel = L.map \u03bb where (abs s a) \u2192 s , a\n\n  hideTyView : Abs (Arg A) \u2192 Abs (Arg A)\n  hideTyView (abs s (arg (arg-info _ m) x)) = abs s (arg (arg-info hidden m) x)\n\n  -- The type of a Convertible instance. For parameterised types adds the appropriate instance\n  -- arguments and instantiates level arguments to lzero. For instance,\n  -- instanceType _\u228e_ Hs.Either = {A B : Set} {a b : Set} \u2192 \u2983 Convertible A a \u2984 \u2192 \u2983 Convertible B b \u2984\n  --                              Convertible (A \u228e B) (Hs.Either a b)\n  instanceType : (agdaName hsName : Name) \u2192 TC TypeView\n  instanceType agdaName hsName = do\n    aLvls , agdaParams \u2190 smashLevels &lt;$&gt; getParamsAndIndices agdaName\n    hLvls , hsParams   \u2190 smashLevels &lt;$&gt; getParamsAndIndices hsName\n    true \u2190 return (length agdaParams == length hsParams)\n      where false \u2192 liftTC $ R.typeErrorFmt \"%q and %q have different number of parameters\" agdaName hsName\n    let n = length agdaParams\n        l\u2080 = quote 0\u2113 \u2219\n    agdaTy \u2190 applyWithVisibility agdaName $ L.replicate aLvls l\u2080 ++ L.map \u266f (take n (downFrom (n + n)))\n    hsTy   \u2190 applyWithVisibility hsName   $ L.replicate hLvls l\u2080 ++ L.map \u266f (downFrom n)\n    let instHead = weaken n $ quote Convertible \u2219\u27e6 agdaTy \u2223 hsTy \u27e7\n        tel      = L.map hideTyView (agdaParams ++ hsParams) ++\n                   L.replicate n (abs \"_\" (iArg (quote Convertible \u2219\u27e6 \u266f (n + n \u2238 1) \u2223 \u266f (n \u2238 1) \u27e7)))\n    return $ tel , instHead\n\n  -- Compute one clause of the Convertible instance. For instance,\n  -- conversionClause Convertible.to to ((c\u2081 , _) , (c\u2082 , _)) generates\n  -- .to (c\u2081 x\u2081 .. xn) = c\u2082 (to x\u2081) .. (to xn)\n  -- where the xi are the visible constructor arguments.\n  conversionClause : Name \u2192 Name \u2192 (Name \u00d7 Type) \u00d7 (Name \u00d7 Type) \u2192 TC Clause\n  conversionClause prjP prjE ((fromC , fromTy) , (toC , toTy)) = do\n    let isVis   = \u03bb { (abs _ (arg (arg-info visible _) _)) \u2192 true; _ \u2192 false }\n        fromTel = L.filter\u1d47 isVis (proj\u2081 (viewTy fromTy))\n        toTel   = L.filter\u1d47 isVis (proj\u2081 (viewTy toTy))\n        n       = length fromTel\n        mkCon  c mkArg = Term.con c    $ L.map (vArg \u2218 mkArg \u2218 \u266f)  (downFrom n)\n        mkConP c mkArg = Pattern.con c $ L.map (vArg \u2218 mkArg \u2218 `_) (downFrom n)\n    true \u2190 return (n == length toTel)\n      where false \u2192 liftTC $ R.typeErrorFmt \"%q and %q have different number of arguments\" fromC toC\n    return $ clause (tyViewToTel $ L.map (\u03bb where (abs x (arg i _)) \u2192 abs x (arg i unknown)) fromTel)\n                    (vArg (proj prjP) \u2237 vArg (mkConP fromC id) \u2237 [])\n                    (mkCon toC (prjE \u2219\u27e6_\u27e7))\n\n  -- Compute the clauses of a convertible instance.\n  instanceClauses : (agdaName hsName : Name) \u2192 TC (List Clause)\n  instanceClauses agdaName hsName = do\n    agdaCons \u2190 getConstrs agdaName\n    hsCons   \u2190 getConstrs hsName\n    agdaPars \u2190 length &lt;$&gt; getParamsAndIndices agdaName\n    hsPars   \u2190 length &lt;$&gt; getParamsAndIndices hsName\n    true \u2190 return (length agdaCons == length hsCons)\n      where false \u2192 liftTC $ R.typeErrorFmt \"%q and %q have different number of constructors\" agdaName hsName\n    toClauses   \u2190 mapM (conversionClause (quote Convertible.to)   (quote to)  ) (L.zip agdaCons hsCons)\n    fromClauses \u2190 mapM (conversionClause (quote Convertible.from) (quote from)) (L.zip hsCons agdaCons)\n    return $ toClauses ++ fromClauses\n\n  absurdClause : Name \u2192 Clause\n  absurdClause prj = absurd-clause ((\"x\" , vArg unknown) \u2237 []) (vArg (proj prj) \u2237 vArg (absurd 0) \u2237 [])\n\n  -- Compute conversion clauses for the current goal and wrap them in a pattern lambda.\n  patternLambda : TC Term\n  patternLambda = do\n    quote Convertible \u2219\u27e6 `A \u2223 `B \u27e7 \u2190 reduce =&lt;&lt; goalTy\n      where t \u2192 liftTC $ R.typeErrorFmt \"Expected Convertible A B, got %t\" t\n    agdaCons \u2190 getConstrsForType `A\n    hsCons   \u2190 getConstrsForType `B\n    toClauses   \u2190 mapM (conversionClause (quote Convertible.to)   (quote to)  ) (L.zip agdaCons hsCons)\n    fromClauses \u2190 mapM (conversionClause (quote Convertible.from) (quote from)) (L.zip hsCons agdaCons)\n    case toClauses ++ fromClauses of \u03bb where\n      []  \u2192 return $ pat-lam (absurdClause (quote Convertible.to) \u2237 absurdClause (quote Convertible.from) \u2237 []) []\n      cls \u2192 return $ pat-lam cls []\n\ndoPatternLambda : Term \u2192 R.TC Term\ndoPatternLambda hole = patternLambda =&lt;&lt; initTCEnvWithGoal hole\n\n-- Deriving a Convertible instance. Usage\n--   unquoteDecl iName = deriveConvertible iName (quote AgdaTy) (quote HsTy)\nderiveConvertible : Name \u2192 Name \u2192 Name \u2192 R.TC \u22a4\nderiveConvertible instName agdaName hsName = initUnquoteWithGoal \u2983 defaultTCOptions \u2984 (sort (lit 0)) do\n  agdaDef \u2190 getDefinition agdaName\n  hsDef   \u2190 getDefinition hsName\n  -- instName \u2190 freshName $ \"Convertible\" S.++ show hsName\n  instTel , instTy \u2190 instanceType agdaName hsName\n  inst    \u2190 declareDef (iArg instName) (tyView (instTel , instTy))\n  clauses \u2190 instanceClauses agdaName hsName\n  defineFun instName clauses\n  return _\n\n-- Macros providing an alternative interface. Usage\n--   iName : ConvertibleType AgdaTy HsTy\n--   iName = autoConvertible\n-- or\n--   iName = autoConvert AgdaTy\nmacro\n  ConvertibleType : Name \u2192 Name \u2192 Tactic\n  ConvertibleType agdaName hsName = initTac \u2983 defaultTCOptions \u2984 $\n    unifyWithGoal \u2218 tyView =&lt;&lt; instanceType agdaName hsName\n\n  autoConvertible : Tactic\n  autoConvertible = initTac \u2983 defaultTCOptions \u2984 $\n    unifyWithGoal =&lt;&lt; patternLambda\n\n  autoConvert : Name \u2192 Tactic\n  autoConvert d hole = do\n    hsTyMeta \u2190 R.newMeta `Set\n    R.checkType hole $ quote Convertible \u2219\u27e6 d \u2219 \u2223 hsTyMeta \u27e7\n    hsTy \u2190 solveHsType (d \u2219)\n    R.unify hsTyMeta hsTy\n    R.unify hole =&lt;&lt; doPatternLambda hole\n</code></pre>"},{"location":"Foreign.Convertible.DerivingTest.html","title":"DerivingTest","text":"<pre><code>module Foreign.Convertible.DerivingTest where\n\nopen import Level\nopen import Meta.Prelude\nopen import Meta.Init\n\nimport Data.List as L\nimport Data.List.NonEmpty as NE\nimport Data.String as S\nimport Data.Product as P\n\nopen import Relation.Nullary\nopen import Relation.Nullary.Decidable\n\nopen import Reflection.Tactic\nopen import Reflection.AST.Term\nopen import Reflection.AST.DeBruijn\nimport Reflection.TCM as R\nopen import Reflection.Utils\nopen import Reflection.Utils.TCI\nimport Function.Identity.Effectful as Identity\n\nopen import Class.DecEq\nopen import Class.DecEq\nopen import Class.Functor\nopen import Class.Monad\nopen import Class.MonadTC.Instances\nopen import Class.Traversable\nopen import Class.Show\nopen import Class.MonadReader\n\nopen import Foreign.Convertible\nopen import Foreign.Convertible.Deriving\n\n-- Tests\n\nopen import Data.Maybe.Base\nopen import Data.Sum.Base\n\ndata HsMaybe (a : Set) : Set where\n  just    : (x : a) \u2192 HsMaybe a\n  nothing : HsMaybe a\n\ndata HsEither (a b : Set) : Set where\n  left : a \u2192 HsEither a b\n  right : b \u2192 HsEither a b\n\n-- We should be able to generate this\nConvertibleMaybe : \u2200 {a a'} \u2192 \u2983 Convertible a a' \u2984 \u2192 Convertible (Maybe a) (HsMaybe a')\nConvertibleMaybe .to (just x)   = just (to x)\nConvertibleMaybe .to nothing    = nothing\nConvertibleMaybe .from (just x) = just (from x)\nConvertibleMaybe .from nothing  = nothing\n\n-- With deriveConvertible\nunquoteDecl iConvertMaybe  = deriveConvertible iConvertMaybe (quote Maybe) (quote HsMaybe)\n\n-- or with ConvertibleType and autoConvertible\ninstance\n  iConvertEither : ConvertibleType _\u228e_ HsEither\n  iConvertEither = autoConvertible\n\ninstance\n  ConvertibleNat = Convertible-Refl {\u2115}\n\ntest : \u2115 \u228e Maybe \u2115 \u2192 HsEither \u2115 (HsMaybe \u2115)\ntest = to\n\n_ : test (inj\u2082 (just 5)) \u2261 right (just 5)\n_ = refl\n\n-- There was a problem due to Agda#7182 with record types in parameterised modules.\n\nmodule Param (A : Set) where\n  record AgdaThing : Set where\n    field theThing : A\n\nrecord HsThing : Set where\n  field theThing : \u2115\n\nopen Param \u2115\nunquoteDecl iConvertThing = deriveConvertible iConvertThing (quote AgdaThing) (quote HsThing)\n\nconvThing : Convertible AgdaThing HsThing\nconvThing = autoConvertible\n</code></pre>"},{"location":"Foreign.Convertible.html","title":"Convertible","text":"<pre><code>module Foreign.Convertible where\n\nopen import Ledger.Prelude\nopen import Foreign.HaskellTypes\n\nrecord Convertible (A B : Type) : Type where\n  field to   : A \u2192 B\n        from : B \u2192 A\nopen Convertible \u2983...\u2984 public\n\nHsConvertible : (A : Set) \u2192 \u2983 HasHsType A \u2984 \u2192 Set\nHsConvertible A = Convertible A (HsType A)\n\nConvertible-Refl : \u2200 {A} \u2192 Convertible A A\nConvertible-Refl = \u03bb where .to \u2192 id; .from \u2192 id\n\nConvertible\u2081 : (Type \u2192 Type) \u2192 (Type \u2192 Type) \u2192 Type\u2081\nConvertible\u2081 T U = \u2200 {A B} \u2192 \u2983 Convertible A B \u2984 \u2192 Convertible (T A) (U B)\n\nConvertible\u2082 : (Type \u2192 Type \u2192 Type) \u2192 (Type \u2192 Type \u2192 Type) \u2192 Type\u2081\nConvertible\u2082 T U = \u2200 {A B} \u2192 \u2983 Convertible A B \u2984 \u2192 Convertible\u2081 (T A) (U B)\n\nFunctor\u21d2Convertible : \u2200 {F : Type\u2191} \u2192 \u2983 Functor F \u2984 \u2192 Convertible\u2081 F F\nFunctor\u21d2Convertible = \u03bb where\n  .to   \u2192 map to\n  .from \u2192 map from\n\nBifunctor\u21d2Convertible : \u2200 {F} \u2192 \u2983 Bifunctor F \u2984 \u2192 Convertible\u2082 F F\nBifunctor\u21d2Convertible = \u03bb where\n  .to   \u2192 bimap to to\n  .from \u2192 bimap from from\n\n_\u2a3e_ : \u2200 {A B C} \u2192 Convertible A B \u2192 Convertible B C \u2192 Convertible A C\n(c \u2a3e c') .to   = c' .to   \u2218 c  .to\n(c \u2a3e c') .from = c  .from \u2218 c' .from\n\n-- ** instances\n\nopen import Foreign.Haskell\nopen import Foreign.Haskell.Coerce using (coerce)\n\ninstance\n  Convertible-Maybe : Convertible\u2081 Maybe Maybe\n  Convertible-Maybe = Functor\u21d2Convertible\n\n  Convertible-\u00d7 : Convertible\u2082 _\u00d7_ _\u00d7_\n  Convertible-\u00d7 = Bifunctor\u21d2Convertible\n\n  Convertible-Pair : Convertible\u2082 _\u00d7_ Pair\n  Convertible-Pair = \u03bb where\n    .to   \u2192 coerce \u2218 bimap to to\n    .from \u2192 bimap from from \u2218 coerce\n\n  Convertible-\u228e : Convertible\u2082 _\u228e_ _\u228e_\n  Convertible-\u228e = Bifunctor\u21d2Convertible\n\n  Convertible-Either : Convertible\u2082 _\u228e_ Either\n  Convertible-Either = \u03bb where\n    .to   \u2192 coerce \u2218 bimap to to\n    .from \u2192 bimap from from \u2218 coerce\n\n  Convertible-FinSet : Convertible\u2081 \u2119_ List\n  Convertible-FinSet = \u03bb where\n    .to   \u2192 map to   \u2218 setToList\n    .from \u2192 fromList \u2218 map from\n\n  Convertible-Map : \u2200 {K K' V V'} \u2192 \u2983 DecEq K \u2984\n    \u2192 \u2983 Convertible K K' \u2984 \u2192 \u2983 Convertible V V' \u2984\n    \u2192 Convertible (K \u21c0 V) (List $ Pair K' V')\n  Convertible-Map = \u03bb where\n    .to   \u2192 to        \u2218 proj\u2081\n    .from \u2192 fromList\u1d50 \u2218 map from\n\n  Convertible-List : Convertible\u2081 List List\n  Convertible-List = \u03bb where\n    .to   \u2192 map to\n    .from \u2192 map from\n\n  Convertible-Fun : \u2200 {A A' B B'} \u2192 \u2983 Convertible A A' \u2984 \u2192 \u2983 Convertible B B' \u2984 \u2192 Convertible (A \u2192 B) (A' \u2192 B')\n  Convertible-Fun = \u03bb where\n    .to   \u2192 \u03bb f \u2192 to   \u2218 f \u2218 from\n    .from \u2192 \u03bb f \u2192 from \u2218 f \u2218 to\n</code></pre>"},{"location":"Foreign.HaskellTypes.Deriving.html","title":"Deriving","text":"<pre><code>module Foreign.HaskellTypes.Deriving where\n\nopen import Meta.Init hiding (TC; Monad-TC; MonadError-TC)\n\nopen import Level using (Level; 0\u2113)\nopen import Agda.Builtin.Reflection using (declareData; defineData; pragmaForeign; pragmaCompile;\n                                           solveInstanceConstraints)\nopen import Reflection as R hiding (showName; _&gt;&gt;=_; _&gt;&gt;_)\nopen import Reflection.AST hiding (showName)\nopen import Reflection.AST.DeBruijn\nopen import Data.Maybe using (Maybe; nothing; just; fromMaybe; maybe\u2032; _&lt;\u2223&gt;_)\nopen import Data.Unit using (\u22a4; tt)\nopen import Data.Integer.Base using (\u2124)\nopen import Data.Sum using (_\u228e_; inj\u2081; inj\u2082)\nopen import Data.String using (String) renaming (_++_ to _&amp;_)\nopen import Data.Product hiding (map; zip; zipWith)\nimport Data.String as String\nopen import Data.Bool\nopen import Data.Nat\nopen import Data.List hiding (lookup; fromMaybe)\nopen import Data.Char using (toUpper; toLower)\nopen import Foreign.Haskell\nopen import Function\nopen import Text.Printf\n\nopen import Class.DecEq\nopen import Class.Functor\nopen import Class.Monad\nopen import Class.MonadError\nopen import Class.MonadReader\nopen import Class.Show\nopen import Class.Show.Instances\nopen import Class.MonadTC using (TCEnv; dontReduce; defaultTCOptions)\nopen import Tactic.Derive.Show using (showName)\n\nopen import Reflection.Utils\nopen import Reflection.Utils.TCI\nopen import Foreign.HaskellTypes\nopen import Foreign.Haskell.Pair using (Pair)\n\n{-\nNeed to generate:\n  - a data type that can be compiled to a Haskell data type\n  - the corresponding Haskell type (in a FOREIGN pragma)\n  - the COMPILE pragma binding them together\n-}\n\nprivate variable\n  l : Level\n  A B : Set l\n\n-- * Controlling the names of the generated types\n\nrecord NameEnv : Set where\n  field\n    customNames : List (Name \u00d7 String)\n    tName       : Name \u2192 Maybe String\n    cName       : Name \u2192 Maybe String\n    fName       : Name \u2192 Maybe String\n\nprivate\n  mapHead : (A \u2192 A) \u2192 List A \u2192 List A\n  mapHead f []       = []\n  mapHead f (x \u2237 xs) = f x \u2237 xs\n\ncapitalize : String \u2192 String\ncapitalize = String.fromList \u2218 mapHead toUpper \u2218 String.toList\n\nuncapitalize : String \u2192 String\nuncapitalize = String.fromList \u2218 mapHead toLower \u2218 String.toList\n\nprivate\n  lookup : \u2983 DecEq A \u2984 \u2192 A \u2192 List (A \u00d7 B) \u2192 Maybe B\n  lookup x xs = proj\u2082 &lt;$&gt; find\u1d47 ((x ==_) \u2218 proj\u2081) xs\n\n  lookupEnv : (NameEnv \u2192 Name \u2192 Maybe String) \u2192 NameEnv \u2192 Name \u2192 Maybe String\n  lookupEnv fn env x = lookup x (NameEnv.customNames env) &lt;\u2223&gt; fn env x\n\n  lookupTypeName  = lookupEnv NameEnv.tName\n  lookupConName   = lookupEnv NameEnv.cName\n  lookupFieldName = lookupEnv NameEnv.fName\n\n  emptyEnv : NameEnv\n  emptyEnv = record{ customNames = []\n                   ; tName = const nothing\n                   ; cName = const nothing\n                   ; fName = const nothing }\n\n  customName : Name \u2192 String \u2192 NameEnv\n  customName x s = record emptyEnv { customNames = (x , s) \u2237 [] }\n\nonTypes : (String \u2192 String) \u2192 NameEnv\nonTypes f = record emptyEnv { tName = just \u2218 f \u2218 showName }\n\nonConstructors : (String \u2192 String) \u2192 NameEnv\nonConstructors f = record emptyEnv { cName = just \u2218 f \u2218 showName }\n\nwithName : String \u2192 NameEnv\nwithName t = onTypes (const t)\n\n-- Only use for single constructor types obviously\nwithConstructor : String \u2192 NameEnv\nwithConstructor c = onConstructors (const c)\n\nonFields : (String \u2192 String) \u2192 NameEnv\nonFields f = record emptyEnv { fName = just \u2218 f \u2218 showName }\n\nfieldPrefix : String \u2192 NameEnv\nfieldPrefix pre = onFields $ (pre String.++_) \u2218 capitalize\n\ninfixr 5 _\u2022_\n_\u2022_ : NameEnv \u2192 NameEnv \u2192 NameEnv\nenv \u2022 env\u2081 = record\n  { customNames = env.customNames ++ env\u2081.customNames\n  ; tName       = \u03bb x \u2192 env.tName x &lt;\u2223&gt; env\u2081.tName x\n  ; cName       = \u03bb x \u2192 env.cName x &lt;\u2223&gt; env\u2081.cName x\n  ; fName       = \u03bb x \u2192 env.fName x &lt;\u2223&gt; env\u2081.fName x\n  }\n  where\n    module env  = NameEnv env\n    module env\u2081 = NameEnv env\u2081\n\n\n-- * The inner workings\n\nsolveHsType : Term \u2192 TC Term\nsolveHsType tm = do\n  hsTy \u2190 checkType (quote HsType \u2219\u27e6 tm \u27e7) `Set\n  solveInstanceConstraints\n  normalise hsTy &gt;&gt;= \u03bb where\n    (def (quote HsType) _) \u2192 typeErrorFmt \"Failed to solve HsType %t\" tm\n    hsTy                   \u2192 return hsTy\n\nprivate\n  debug = debugPrintFmt \"tactic.hs-types\"\n\n  _\u203c_ : List A \u2192 \u2115 \u2192 Maybe A\n  []       \u203c i     = nothing\n  (x \u2237 xs) \u203c zero  = just x\n  (x \u2237 xs) \u203c suc i = xs \u203c i\n\n  specialHsTypes : List (Name \u00d7 String)\n  specialHsTypes = (quote \u22a4      , \"()\")\n                 \u2237 (quote \u2115      , \"Integer\")\n                 \u2237 (quote \u2124      , \"Integer\")\n                 \u2237 (quote Bool   , \"Bool\")\n                 \u2237 (quote List   , \"[]\")\n                 \u2237 (quote Pair   , \"(,)\")\n                 \u2237 (quote Maybe  , \"Maybe\")\n                 \u2237 (quote Either , \"Either\")\n                 \u2237 (quote String , \"Data.Text.Text\")\n                 \u2237 []\n\n  hsTypeName : NameEnv \u2192 Name \u2192 String\n  hsTypeName env d = fromMaybe (capitalize $ showName d) (lookupTypeName env d)\n\n  freshHsTypeName : NameEnv \u2192 Name \u2192 TC Name\n  freshHsTypeName env d = freshName (hsTypeName env d)\n\n  hsConName : NameEnv \u2192 Name \u2192 String\n  hsConName env c = fromMaybe (capitalize $ showName c) (lookupConName env c)\n\n  hsFieldName : NameEnv \u2192 Name \u2192 String\n  hsFieldName env f = fromMaybe (uncapitalize $ showName f) (lookupFieldName env f)\n\n  freshHsConName : NameEnv \u2192 Name \u2192 Name \u2192 TC Name\n  freshHsConName env tyName c =\n    if showName c == \"constructor\"\n    then freshName (hsConName env tyName) -- Unnamed record constructor: use type name\n    else freshName (hsConName env c)\n\n  isThis : Name \u2192 Term \u2192 Bool\n  isThis f (def g _) = f == g\n  isThis _ _ = false\n\n  computeHsType : Name \u2192 Name \u2192 Term \u2192 TC Term\n  computeHsType aThis hThis tm with isThis aThis tm\n  ... | true = pure (hThis \u2219)\n  computeHsType aThis hThis (\u03a0[ x \u2236 arg (arg-info visible _) a ] b) | false = do\n    dom \u2190 computeHsType aThis hThis a\n    rng \u2190 extendContext x (vArg a) $ computeHsType aThis hThis b\n    pure (v\u03a0[ x \u2236 dom ] rng)\n  computeHsType aThis hThis (\u03a0[ x \u2236 a ] b) | false = do\n    ty \u2190 extendContext x a $ computeHsType aThis hThis b\n    just ty\u2032 \u2190 pure (strengthen ty)\n      where nothing \u2192 extendContext x a $ typeErrorFmt \"%s free in computed HsType %t\" x ty\n    pure ty\u2032\n  -- Hack to get recursive occurrences under lists to work\n  computeHsType aThis hThis (def (quote List) (_ \u2237 vArg a \u2237 [])) | false = do\n    ty \u2190 computeHsType aThis hThis a\n    pure (quote List \u2219\u27e6 ty \u27e7)\n  computeHsType _ _ tm | false = do\n    debug 10 \"solving HsType %t\" tm\n    ty \u2190 solveHsType tm\n    debug 10 \"HsType %t = %t\" tm ty\n    pure ty\n\n  makeHsCon : NameEnv \u2192 Name \u2192 Name \u2192 Name \u2192 TC (Name \u00d7 Agda.Builtin.Reflection.Quantity \u00d7 Type)\n  makeHsCon env agdaName hsName c = do\n    debug 10 \"Making constructor %q : %q\" c agdaName\n    def agdaName' _ \u2190 normalise (def agdaName [])\n      where _ \u2192 typeErrorFmt \"Failed to compute source type for %q\" agdaName\n    hsC  \u2190 freshHsConName env hsName c\n    cTy  \u2190 getType c\n    debug 10 \"cTy = %t\" cTy\n    hsTy \u2190 computeHsType agdaName' hsName cTy\n    debug 10 \"hsTy = %t\" hsTy\n    pure (hsC , quantity-\u03c9 , hsTy)\n\n  makeHsData : NameEnv \u2192 Name \u2192 \u2115 \u2192 List Name \u2192 TC Name\n  makeHsData env agdaName nPars constrs = do\n    hsName \u2190 freshHsTypeName env agdaName\n    declareData hsName 0 `Set\n    hsCons \u2190 mapM (makeHsCon env agdaName hsName) constrs\n    defineData hsName hsCons\n    pure hsName\n\n  makeHsType : NameEnv \u2192 Name \u2192 TC Name\n  makeHsType env d = getDefinition d &gt;&gt;= \u03bb where\n      (data-type pars cs) \u2192 makeHsData env d pars cs\n      (record-type c fs)  \u2192 makeHsData env d 0 (c \u2237 [])\n      _                   \u2192 typeErrorFmt \"%q is not a data or record type\" d\n\n  joinStrings : String \u2192 List String \u2192 String\n  joinStrings sep ss = foldr _&amp;_ \"\" $ intersperse sep ss\n\n  compilePragma : Name \u2192 List Name \u2192 String\n  compilePragma d cs = printf \"= data %s (%s)\" (showName d) (joinStrings \" | \" (map showName cs))\n\n  renderHsTypeName : Name \u2192 String\n  renderHsTypeName d = fromMaybe (\"MAlonzo.Code.\" String.++ R.showName d) (lookup d specialHsTypes)\n\n  renderHsType : Term \u2192 String\n  renderHsArgs : List (Arg Term) \u2192 List String\n\n  renderHsType (def (quote List) (_ \u2237 vArg a \u2237 [])) = printf \"[%s]\" (renderHsType a)\n  renderHsType (def (quote Pair) (_ \u2237 _ \u2237 vArg a \u2237 vArg b \u2237 [])) = printf \"(%s, %s)\" (renderHsType a) (renderHsType b)\n  renderHsType (def d []) = renderHsTypeName d\n  renderHsType (def d vs) = printf \"(%s %s)\" (renderHsTypeName d) (joinStrings \" \" (renderHsArgs vs))\n  renderHsType t = printf \"(TODO: renderHsType %s)\" (show t)\n\n  renderHsArgs [] = []\n  renderHsArgs (vArg a \u2237 as) = renderHsType a \u2237 renderHsArgs as\n  renderHsArgs (_ \u2237 as) = renderHsArgs as\n\n  foreignPragma : Name \u2192 List Name \u2192 TC String\n  foreignPragma d cs = do\n    cons \u2190 forM cs \u03bb c \u2192 do\n            tel , _ \u2190 viewTy &lt;$&gt; getType c\n            let args = map unAbs tel\n            pure $ printf \"%s %s\" (showName c) (joinStrings \" \" $ renderHsArgs args)\n    pure $ printf \"data %s = %s\\n  deriving (Show, Eq, Generic)\"\n                  (showName d) (joinStrings \" | \" cons)\n\n  -- Record types\n  foreignPragmaRec : NameEnv \u2192 Name \u2192 List Name \u2192 List Name \u2192 TC String\n  foreignPragmaRec _ d [] _ = typeErrorFmt \"impossible: %q is a record type with no constructors\" d\n  foreignPragmaRec env d (c \u2237 _) fs = do\n    tel , _ \u2190 viewTy &lt;$&gt; withNormalisation true (getType c)\n    let fNames = map (hsFieldName env) fs\n    let args = map unAbs tel\n        renderField f ty = printf \"%s :: %s\" f (renderHsType $ unArg ty)\n        con = printf \"%s {%s}\" (showName c) (joinStrings \", \" $ zipWith renderField fNames args)\n    pure $ printf \"data %s = %s\\n  deriving (Show, Eq, Generic)\"\n                  (showName d) con\n\n  hsImports : String\n  hsImports = \"import GHC.Generics (Generic)\"\n\n  -- Take the name of a simple data type and generate the COMPILE and\n  -- FOREIGN pragmas to bind to Haskell.\n  bindHsType : NameEnv \u2192 Name \u2192 Name \u2192 TC \u22a4\n  bindHsType env agdaName hsName = getDefinition hsName &gt;&gt;= \u03bb where\n    (data-type pars cs) \u2192 do\n      pragmaForeign \"GHC\" hsImports\n      pragmaCompile \"GHC\" hsName $ compilePragma hsName cs\n      getDefinition agdaName &gt;&gt;= \u03bb where\n        (data-type _ _)    \u2192 pragmaForeign \"GHC\" =&lt;&lt; foreignPragma hsName cs\n        (record-type _ fs) \u2192 pragmaForeign \"GHC\" =&lt;&lt; foreignPragmaRec env hsName cs (map unArg fs)\n        _ \u2192 typeErrorFmt \"%q is not a data or record type\" agdaName\n    _ \u2192 typeErrorFmt \"%q is not a data type (impossible)\" hsName\n\n  computeProjections : \u2115 \u2192 Name \u2192 TC (List Term)\n  computeProjections npars c = do\n    argTys , _ \u2190 viewTy &lt;$&gt; getType c\n    let is  = downFrom (length argTys)\n        tel = map (\u03bb where (abs x ty) \u2192 x , ty) argTys\n        lhs = vArg (con c (map (\u03bb where (i , abs x (arg info _)) \u2192 arg info (var i))\n                               (drop npars (zip is argTys)))) \u2237 []\n    return $ map (\u03bb i \u2192 pat-lam (clause tel lhs (var i []) \u2237 []) []) (drop npars is)\n\n  makeTypeAlias : Name \u2192 NameEnv \u2192 Term \u2192 TC \u22a4\n  makeTypeAlias agdaName env hole = do\n    hsTy \u2190 solveHsType (def agdaName [])\n    pragmaForeign \"GHC\" $ printf \"type %s = %s\" (hsTypeName env agdaName) (renderHsType hsTy)\n    unify hole (quote return \u2219\u27e6 con (quote tt) [] \u27e7)\n\n-- * Exported macros\n\ndoAutoHsType : NameEnv \u2192 Name \u2192 Term \u2192 TC Term\ndoAutoHsType env d hole = do\n  checkType hole (quote HasHsType \u2219\u27e6 d \u2219 \u27e7)\n  hs \u2190 makeHsType env d\n  debug 50 \"  HsType %q = %q\" d hs\n  bindHsType env d hs\n  unify hole (`\u03bb\u27e6 proj (quote HasHsType.HsType) \u21d2 hs \u2219 \u27e7)\n  pure (hs \u2219)\n\nmacro\n  autoHsType : Name \u2192 Term \u2192 TC \u22a4\n  autoHsType d hole = _ &lt;$ doAutoHsType emptyEnv d hole\n\n  infix 0 autoHsType_\u22a3_\n  autoHsType_\u22a3_ : Name \u2192 NameEnv \u2192 Term \u2192 TC \u22a4\n  autoHsType_\u22a3_ d env hole = _ &lt;$ doAutoHsType env d hole\n\n  infix 9 _\u21a6_\n  _\u21a6_ : Name \u2192 String \u2192 Term \u2192 TC \u22a4\n  x \u21a6 s = unify (quote customName \u2219\u27e6 lit (name x) \u2223 lit (string s) \u27e7)\n\n  -- Generate a Haskell type synonym for the HsType of the given type\n  -- Usage `unquoteDecl = do hsTypeSynonym Foo; hsTypeSynonym Bar`\n  hsTypeAlias : Name \u2192 Term \u2192 TC \u22a4\n  hsTypeAlias agdaName = makeTypeAlias agdaName emptyEnv\n\n  -- The only NameEnv that's useful here is `withName`.\n  hsTypeAlias_\u22a3_ : Name \u2192 NameEnv \u2192 Term \u2192 TC \u22a4\n  hsTypeAlias agdaName \u22a3 env = makeTypeAlias agdaName env\n\n  -- * Macros for constructing and deconstructing generated types\n\n  hsCon : Term \u2192 \u2115 \u2192 Term \u2192 TC \u22a4\n  hsCon agdaTy i hole = do\n    hsTy@(def hsName _) \u2190 solveHsType agdaTy\n      where _ \u2192 typeErrorFmt \"Failed to compute HsType of %t\" agdaTy\n    cs \u2190 getDefinition hsName &gt;&gt;= \u03bb where\n      (data-type _ cs)  \u2192 return cs\n      _ \u2192 typeErrorFmt \"Expected HsType %t to be a data type, but got %t\" agdaTy hsTy\n    c \u2190 maybe\u2032 return  (typeErrorFmt \"%q has only %u constructors\" hsName (length cs)) (cs \u203c i)\n    unify hole (con c [])\n\n  hsProj : Term \u2192 \u2115 \u2192 Term \u2192 TC \u22a4\n  hsProj agdaTy i hole = do\n    hsTy@(def hsName _) \u2190 solveHsType agdaTy\n      where _ \u2192 typeErrorFmt \"Failed to compute HsType of %t\" agdaTy\n    prjs \u2190 getDefinition hsName &gt;&gt;= \u03bb where\n      (data-type npars (c \u2237 [])) \u2192 computeProjections npars c\n      _ \u2192 typeErrorFmt \"Expected HsType %t to be a single constructor data type, but got %t\" agdaTy hsTy\n    prj \u2190 maybe\u2032 return (typeErrorFmt \"%q has only %u fields\" hsName (length prjs)) (prjs \u203c i)\n    target \u2190 newMeta `Set\n    checkType hole (pi (vArg hsTy) (abs \"_\" target))\n    unify hole prj\n\n  hsTyName : Term \u2192 Term \u2192 TC \u22a4\n  hsTyName agdaTy hole = do\n    hsTy@(def hsName _) \u2190 solveHsType agdaTy\n      where _ \u2192 typeErrorFmt \"Failed to compute HsType of %t\" agdaTy\n    unify hole (lit (name hsName))\n</code></pre>"},{"location":"Foreign.HaskellTypes.html","title":"HaskellTypes","text":"<pre><code>module Foreign.HaskellTypes where\n\nopen import Level using (Level)\nopen import Data.Bool.Base using (Bool)\nopen import Data.Nat.Base using (\u2115)\nopen import Data.String.Base using (String)\nopen import Data.List.Base using (List)\nopen import Data.Maybe.Base using (Maybe)\nopen import Data.Sum.Base using (_\u228e_)\nopen import Data.Product.Base using (_\u00d7_)\nopen import Data.Unit using (\u22a4)\n\nopen import Foreign.Haskell.Pair using (Pair)\nopen import Foreign.Haskell.Either using (Either)\n\nprivate variable\n  l : Level\n  A B : Set l\n\nrecord HasHsType (A : Set l) : Set\u2081 where\n  field\n    HsType : Set\n\nHsType : (A : Set l) \u2192 \u2983 HasHsType A \u2984 \u2192 Set\nHsType _ \u2983 i \u2984 = i .HasHsType.HsType\n\nMkHsType : (A : Set l) (Hs : Set) \u2192 HasHsType A\nMkHsType A Hs .HasHsType.HsType = Hs\n\ninstance\n\n  iHsTy-\u2115      = MkHsType \u2115 \u2115\n  iHsTy-Bool   = MkHsType Bool Bool\n  iHsTy-\u22a4      = MkHsType \u22a4 \u22a4\n  iHsTy-String = MkHsType String String\n\n  -- Could make a macro for these kind of congruence instances.\n  iHsTy-List : \u2983 HasHsType A \u2984 \u2192 HasHsType (List A)\n  iHsTy-List {A = A} .HasHsType.HsType = List (HsType A)\n\n  iHsTy-Maybe : \u2983 HasHsType A \u2984 \u2192 HasHsType (Maybe A)\n  iHsTy-Maybe {A = A} .HasHsType.HsType = Maybe (HsType A)\n\n  iHsTy-Fun : \u2983 HasHsType A \u2984 \u2192 \u2983 HasHsType B \u2984 \u2192 HasHsType (A \u2192 B)\n  iHsTy-Fun {A = A} {B = B} .HasHsType.HsType = HsType A \u2192 HsType B\n\n  iHsTy-Sum : \u2983 HasHsType A \u2984 \u2192 \u2983 HasHsType B \u2984 \u2192 HasHsType (A \u228e B)\n  iHsTy-Sum {A = A} {B = B} .HasHsType.HsType = Either (HsType A) (HsType B)\n\n  iHsTy-Pair : \u2983 HasHsType A \u2984 \u2192 \u2983 HasHsType B \u2984 \u2192 HasHsType (A \u00d7 B)\n  iHsTy-Pair {A = A} {B = B} .HasHsType.HsType = Pair (HsType A) (HsType B)\n</code></pre>"},{"location":"Interface.ComputationalRelation.html","title":"Computational Relations for Trace Semantics","text":"<p>This module provides a generic computational interface for relations of the form <code>C \u2192 S \u2192 B \u2192 S \u2192 Type</code> where</p> <ul> <li><code>C</code> is an environment,</li> <li><code>S</code> is the state type,</li> <li><code>B</code> is the signal type (e.g., a single signal,    <code>Sig</code>, or a trace, <code>List Sig</code>).</li> </ul> <p>The interface supplies</p> <ol> <li> <p>a result type <code>ComputationResult</code> and its Functor/Applicative/Monad instances;</p> </li> <li> <p>a <code>Computational</code> record that captures an executable interpreter     (<code>compute</code>/<code>computeProof</code>) and a correctness     equivalence relating the interpreter to the relational specification;</p> </li> <li> <p>derived properties (right\u2011uniqueness, a decidability principle under     <code>DecEq S</code>, and an extensionality lemma for two implementations), and</p> </li> <li> <p>instances that lift a small\u2011step computational specification to our     trace runners from <code>Interface.STS</code>:</p> <ul> <li><code>RunTraceAndThen</code> for lists of signals,</li> <li><code>RunTraceAfterAndThen</code> for a one\u2011off init step then a trace, then a final step.</li> </ul> </li> </ol> <p>The intent is that once we define a <code>Computational</code> instance for the single step relation (and, in the second case, the init and final steps), we automatically obtain computational instances for the trace semantics.</p> More Details <p>Big Picture.</p> <ul> <li> <p><code>STS</code> <code>\u0393</code> <code>s</code> <code>b</code> <code>s'</code>    is a specification; it's a logical relation that says,    \"Under environment <code>\u0393</code>, states <code>s</code> and <code>s'</code>    are related via <code>b</code>.\"  By itself this is not executable; it's just a    type (proposition) that may or may not be inhabited (by a proof).</p> </li> <li> <p><code>Computational</code> <code>STS</code> <code>Err</code>    is the executable counterpart; it packages a program (<code>compute</code>) that attempts    to produce the next state, together with facts that connect that program back to    the spec (<code>STS</code>).    Think: spec + interpreter + proof the interpreter is correct.</p> </li> <li> <p><code>ComputationResult</code> <code>Err</code> <code>R</code>    = <code>success</code> <code>R</code> <code>|</code> <code>failure</code> <code>Err</code> is just a    \"Maybe-with-error\" wrapper.  We use it as the return type of    <code>compute</code> and <code>computeProof</code> so we can represent    either \"I found a next state\" or \"this step is impossible/failed and here's why.\"</p> </li> </ul> <p>What each field really means.</p> <ol> <li> <p>Functor, Applicative, Monad of <code>ComputationResult</code></p> <p>These are small but very useful conveniences.</p> <ul> <li>Functor lets us map a pure function over a successful result without   touching failures.  In our code, we use it to define:</li> </ul> <p><code>compute</code> <code>\u0393</code> <code>s</code> <code>b</code>   = <code>map proj\u2081</code> (<code>computeProof</code> <code>\u0393</code> <code>s</code> <code>b</code>)</p> <p>Here, <code>computeProof</code> gives</p> <p><code>success</code> (<code>s'</code> , <code>proof</code>) or</p> <p><code>failure</code> <code>e</code>.</p> <p>Mapping <code>proj\u2081</code> turns that into   <code>success</code> <code>s'</code>   or keeps the same <code>failure</code> <code>e</code>.   Without this functor, we'd have to pattern-match every time.</p> <ul> <li> <p>Applicative lets us combine independent computations. We're not leaning on    this much here, but it's standard to provide it with a functor and monad.</p> </li> <li> <p>Monad lets us sequence computations where later steps depend on earlier    results.  This is the key when we run a trace: do a step, if it succeeds get the    new state, then continue on the rest of the list; if it fails, stop with that    failure.  Our <code>computeProof</code> for <code>RunTraceAndThen</code>    essentially implements a monadic fold (left-to-right) by pattern matching; having    a monad means we can express and reason about that sequencing uniformly, without    awkward error/exception handling.</p> </li> </ul> <p>So these instances are not cases of \"category theory for its own sake;\" they let us write and prove things about the interpreter more cleanly.</p> <ul> <li><code>map proj\u2081</code> keeps proofs around when we need them, but derives a state-only    function when we don't.</li> <li>Monadic sequencing matches the structure of trace execution.</li> </ul> </li> <li> <p>Executable Interpreter</p> <ul> <li><code>computeProof</code> : (<code>\u0393</code> <code>s</code> <code>b</code>)    <code>\u2192</code> <code>ComputationResult</code> <code>Err</code>    (<code>\u03a3</code> <code>s'</code> . <code>STS</code> <code>\u0393</code> <code>s</code> <code>b</code> <code>s'</code>)</li> </ul> <p>This is an interpreter that tries to run the spec and, if successful, returns both</p> <ol> <li>the output state <code>s'</code>, and</li> <li>a proof that        <code>STS</code> <code>\u0393</code> <code>s</code> <code>b</code> <code>s'</code> holds.</li> </ol> <p>If it can't run (the step is impossible for those inputs), it returns    <code>failure</code> <code>e</code>.</p> <p>Think: a function that either says, \"I can't do this for reason <code>e</code>\",    or, \"I can do this and here's the state and a proof it's correct.\"</p> <ul> <li><code>compute</code> : (<code>\u0393</code> <code>s</code> <code>b</code>)    <code>\u2192</code> <code>ComputationResult</code> <code>Err</code> <code>S</code></li> </ul> <p>This is the plain executable version.  It throws away the proof and just returns   the state, via the functor mapping discussed above.  We use it when all we need is the   state for execution code paths; we keep <code>computeProof</code> when a proof is helpful   downstream.</p> </li> <li> <p>Correctness Equivalence</p> <p>We want our interpreter to exactly match the spec. There are two directions:</p> <ul> <li>Completeness (what we provide as a field)</li> </ul> <p>If the spec says <code>STS \u0393 s b s'</code>, then the interpreter must return that same state:</p> <p><code>completeness</code>    : <code>STS</code> <code>\u0393</code> <code>s</code> <code>b</code> <code>s'</code>    \u2192 <code>compute</code> <code>\u0393</code> <code>s</code> <code>b</code>    \u2261 <code>success</code> <code>s'</code></p> <p>This prevents two different outputs for the same input; the spec and the    interpreter are aligned at least in this direction. (It also implies functional    determinism of the relation, via a standard argument we will see below.)</p> <ul> <li>Soundness (the converse)</li> </ul> <p>If the interpreter returns <code>success</code> <code>s'</code><code>, then</code>STS<code>{.AgdaBound}</code>\u0393<code>{.AgdaBound}</code>s<code>{.AgdaBound}</code>b<code>{.AgdaBound}</code>s'`{.AgdaBound} must hold.</p> <p>We derive this from <code>computeProof</code> because    <code>computeProof</code> returns not only the state, <code>s'</code>, but also    the proof, <code>proofOfSTS</code>. From that, we build</p> <p><code>compute</code> <code>\u0393</code> <code>s</code> <code>b</code> <code>\u2261</code> <code>success</code> <code>s'</code><code></code>\u21d4<code></code>STS<code>{.AgdaBound}</code>\u0393<code>{.AgdaBound}</code>s<code>{.AgdaBound}</code>b<code>{.AgdaBound}</code>s'`{.AgdaBound}</p> <p>in our code as <code>\u2261-success\u21d4STS</code>, by combining    <code>completeness</code> (the \u2192 direction) with the witness from    <code>computeProof</code> (the \u2190 direction).</p> <p>Intuition. The function and the relation say the exact same thing. One is executable, one is declarative; the equivalence ties them together.</p> </li> </ol> <p>How this plays out for traces.</p> <p>Given a <code>Computational</code> instance for the step relation <code>Step</code> : <code>C</code> \u2192 <code>S</code> \u2192 <code>Sig</code> \u2192 <code>S</code> \u2192 <code>Type</code>, the instances for:</p> <ul> <li><code>RunTraceAndThen</code> <code>Step</code> <code>Last</code></li> <li><code>RunTraceAfterAndThen</code> <code>Init</code> <code>Step</code> <code>Last</code></li> <li><code>RunIndexedTrace</code> <code>Step\u1d62</code></li> </ul> <p>are all just folds.</p> <ul> <li> <p>If the list is empty: succeed (via a initial step).</p> </li> <li> <p>If the list is <code>sig \u2237 sigs</code>, run one step</p> </li> </ul> <p><code>computeProof</code> <code>\u0393</code> <code>s</code> <code>sig</code></p> <ul> <li>if failure \u2192 whole run fails</li> <li> <p>if success <code>(s\u2081 , step-proof)</code> \u2192 recurse on <code>sigs</code> from <code>s\u2081</code>, and then stitch       the proofs with the corresponding constructor (e.g., <code>run-\u2237</code>).</p> </li> <li> <p>Completeness for traces is a structural induction using the single-step    completeness and the induction hypothesis.</p> </li> </ul> <p>Toy Example</p> <p>Suppose <code>S = \u2115</code>, <code>Sig = Bool</code>, and the spec says:</p> <p>if <code>sig = true</code>, increment the state, otherwise leave it alone:</p> <p><code>Step \u0393 s sig s'  \u225c  (sig \u2261 true \u00d7 s' \u2261 suc s) \u228e (sig \u2261 false \u00d7 s' \u2261 s)</code></p> <p>A <code>Computational Step Err</code> could implement:</p> <p><code>compute</code> <code>\u0393</code> <code>s</code> <code>true</code> = <code>success</code>  (suc s)`</p> <p><code>compute</code> <code>\u0393</code> <code>s</code> <code>false</code> = <code>success</code> <code>s</code></p> <p>and <code>computeProof</code> returns (<code>s'</code>, <code>proof</code>) with the obvious proof term.</p> <p>Then <code>Computational-RunTraceAndThen</code> just runs that function over the list of booleans; its completeness proof is the standard list induction: head step complete by <code>completeness</code> for <code>Step</code>, tail by inductive hypothesis.</p>"},{"location":"Interface.ComputationalRelation.html#a-computation-result-type","title":"A Computation Result Type","text":"<pre><code>data ComputationResult {a : Level} (Err : Type) (R : Type a) : Type a where\n  success : R   \u2192 ComputationResult Err R\n  failure : Err \u2192 ComputationResult Err R\n\nisFailure : \u2200 {A : Type a} \u2192 ComputationResult Err A \u2192 Type a\nisFailure x = \u2203[ e ] x \u2261 failure e\n\nmodule _ {a b} {E : Type} {A : Type a} {B : Type b} where\n  caseCR_\u2223_\u2223_ : (ma : ComputationResult E A) \u2192 (\u2200 {a} \u2192 ma \u2261 success a \u2192 B) \u2192 (isFailure ma \u2192 B) \u2192 B\n  caseCR ma \u2223 f \u2223 g with ma\n  ... | success _ = f refl\n  ... | failure e = g (e , refl)\n\n  caseCR-success : \u2200 {a} {ma : ComputationResult E A} {f : \u2200 {a} \u2192 ma \u2261 success a \u2192 B} {g : isFailure ma \u2192 B}\n    \u2192 (eq : ma \u2261 success a)\n    \u2192 caseCR ma \u2223 f \u2223 g \u2261 f eq\n  caseCR-success refl = refl\n\n  caseCR-failure : {ma : ComputationResult E A} {f : \u2200 {a} \u2192 ma \u2261 success a \u2192 B} {g : isFailure ma \u2192 B}\n    \u2192 (eq : isFailure ma)\n    \u2192 caseCR ma \u2223 f \u2223 g \u2261 g eq\n  caseCR-failure (_ , refl) = refl\n\ninstance\n  Bifunctor-ComputationResult : \u2200 {a : Level} \u2192 Bifunctor {_} {a} ComputationResult\n  Bifunctor-ComputationResult .bimap _ f (success x) = success $ f x\n  Bifunctor-ComputationResult .bimap f _ (failure x) = failure $ f x\n\n  Functor-ComputationResult : \u2200 {E : Type} \u2192 Functor (ComputationResult E)\n  Functor-ComputationResult ._&lt;$&gt;_ f (success x) = success $ f x\n  Functor-ComputationResult ._&lt;$&gt;_ _ (failure x) = failure x\n\n  Applicative-ComputationResult : \u2200 {E : Type} \u2192 Applicative (ComputationResult E)\n  Applicative-ComputationResult .pure = success\n  Applicative-ComputationResult ._&lt;*&gt;_ (success f) x = f &lt;$&gt; x\n  Applicative-ComputationResult ._&lt;*&gt;_ (failure e) _ = failure e\n\n  Monad-ComputationResult : \u2200 {E : Type} \u2192 Monad (ComputationResult E)\n  Monad-ComputationResult .return = success\n  Monad-ComputationResult ._&gt;&gt;=_ (success a) m = m a\n  Monad-ComputationResult ._&gt;&gt;=_ (failure e) _ = failure e\n\nmap-failure : \u2200 {A B C : Type} {f : A \u2192 B} {x : C} {ma} \u2192 ma \u2261 failure x \u2192 map f ma \u2261 failure x\nmap-failure refl = refl\n\nsuccess-maybe : \u2200 {R : Type} \u2192 ComputationResult Err R \u2192 Maybe R\nsuccess-maybe (success x) = just x\nsuccess-maybe (failure _) = nothing\n\nfailure-maybe : \u2200 {R : Type} \u2192 ComputationResult Err R \u2192 Maybe Err\nfailure-maybe (success _) = nothing\nfailure-maybe (failure x) = just x\n\n_\u2248\u1d9c\u02b3_ : \u2200 {A} \u2192 ComputationResult Err A \u2192 ComputationResult Err A \u2192 Type\nx \u2248\u1d9c\u02b3 y = success-maybe x \u2261 success-maybe y\n</code></pre>"},{"location":"Interface.ComputationalRelation.html#computational-interface","title":"Computational Interface","text":"<p>We parametrize the interface by a relation <code>STS : C \u2192 S \u2192 B \u2192 S \u2192 Type</code>. The record provides both an executable <code>compute</code> and a two\u2011way equivalence between <code>compute</code> returning <code>success s'</code> and the relational judgment.</p> <pre><code>module _ (STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type) where\n\n  ExtendedRel : C \u2192 S \u2192 Sig \u2192 ComputationResult Err S \u2192 Type\n  ExtendedRel c s sig (success s') = STS c s sig s'\n  ExtendedRel c s sig (failure _ ) = \u2200 s' \u2192 \u00ac STS c s sig s'\n\n  record Computational Err : Type\u2081 where\n    constructor MkComputational\n    field\n      computeProof : (c : C) (s : S) (sig : Sig) \u2192 ComputationResult Err (\u2203[ s' ] STS c s sig s')\n\n    compute : C \u2192 S \u2192 Sig \u2192 ComputationResult Err S\n    compute c s sig = map proj\u2081 $ computeProof c s sig\n\n    field\n      completeness : (c : C) (s : S) (sig : Sig) (s' : S)\n        \u2192 STS c s sig s' \u2192 compute c s sig \u2261 success s'\n\n    open \u2261-Reasoning\n\n    computeFail : C \u2192 S \u2192 Sig \u2192 Type\n    computeFail c s sig = isFailure $ compute c s sig\n\n    \u2261-success\u21d4STS : compute c s sig \u2261 success s' \u21d4 STS c s sig s'\n    \u2261-success\u21d4STS {c} {s} {sig} {s'} with computeProof c s sig in eq\n    ... | success (s'' , h) = mk\u21d4 (\u03bb where refl \u2192 h) \u03bb h' \u2192\n      begin success s''     \u2261\u02d8\u27e8 completeness _ _ _ _ h \u27e9\n            compute c s sig \u2261\u27e8 completeness _ _ _ _ h' \u27e9\n            success s'      \u220e\n    ... | failure y = mk\u21d4 (\u03bb ()) \u03bb h \u2192\n      begin failure _       \u2261\u02d8\u27e8 map-failure eq \u27e9\n            compute c s sig \u2261\u27e8 completeness _ _ _ _ h \u27e9\n            success s'      \u220e\n\n    failure\u21d2\u2200\u00acSTS : computeFail c s sig \u2192 \u2200 s' \u2192 \u00ac STS c s sig s'\n    failure\u21d2\u2200\u00acSTS comp\u2261nothing s' h rewrite \u2261-success\u21d4STS .Equivalence.from h =\n      case comp\u2261nothing of \u03bb ()\n\n    \u2200\u00acSTS\u21d2failure : (\u2200 s' \u2192 \u00ac STS c s sig s') \u2192 computeFail c s sig\n    \u2200\u00acSTS\u21d2failure {c = c} {s} {sig} \u00acsts with computeProof c s sig\n    ... | success (x , y) = \u22a5-elim (\u00acsts x y)\n    ... | failure y = (y , refl)\n\n    failure\u21d4\u2200\u00acSTS : computeFail c s sig \u21d4 \u2200 s' \u2192 \u00ac STS c s sig s'\n    failure\u21d4\u2200\u00acSTS = mk\u21d4 failure\u21d2\u2200\u00acSTS \u2200\u00acSTS\u21d2failure\n\n    recomputeProof : \u2200 {\u0393 s sig s'} \u2192 STS \u0393 s sig s' \u2192 ComputationResult Err (\u2203[ s'' ] STS \u0393 s sig s'')\n    recomputeProof _ = computeProof _ _ _\n</code></pre>"},{"location":"Interface.ComputationalRelation.html#consequences-of-the-interface","title":"Consequences of the Interface","text":"<p>From a <code>Computational STS Err</code>, we get:</p> <pre><code>module _ {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} (comp : Computational STS Err) where\n\n  open Computational comp\n\n  ExtendedRelSTS = ExtendedRel STS\n\n  ExtendedRel-compute : ExtendedRelSTS c s sig (compute c s sig)\n  ExtendedRel-compute {c} {s} {sig} with compute c s sig in eq\n  ... | success s' = Equivalence.to \u2261-success\u21d4STS eq\n  ... | failure _  = \u03bb s' h \u2192 case trans (sym $ Equivalence.from \u2261-success\u21d4STS h) eq of \u03bb ()\n\n  open \u2261-Reasoning\n\n  ExtendedRel-rightUnique : ExtendedRelSTS c s sig s' \u2192 ExtendedRelSTS c s sig s'' \u2192 _\u2248\u1d9c\u02b3_ {Err = Err} s' s''\n  ExtendedRel-rightUnique {s' = success x}  {success x'} h h'\n    with trans (sym $ Equivalence.from \u2261-success\u21d4STS h) (Equivalence.from \u2261-success\u21d4STS h')\n  ... | refl = refl\n\n  ExtendedRel-rightUnique {s' = success x} {failure _}  h h' = \u22a5-elim $ h' x h\n  ExtendedRel-rightUnique {s' = failure _} {success x'} h h' = \u22a5-elim $ h x' h'\n  ExtendedRel-rightUnique {s' = failure a} {failure b}  h h' = refl\n\n  computational\u21d2rightUnique : STS c s sig s' \u2192 STS c s sig s'' \u2192 s' \u2261 s''\n  computational\u21d2rightUnique h h' with ExtendedRel-rightUnique h h'\n  ... | refl = refl\n\n  Computational\u21d2Dec : \u2983 _ : DecEq S \u2984 \u2192 Dec (STS c s sig s')\n  Computational\u21d2Dec {c} {s} {sig} {s'}\n    with compute c s sig | ExtendedRel-compute {c} {s} {sig}\n  ... | failure _ | ExSTS = no (ExSTS s')\n  ... | success x  | ExSTS with x \u225f s'\n  ... | no \u00acp    = no  \u03bb h \u2192 \u00acp $ sym $ computational\u21d2rightUnique h ExSTS\n  ... | yes refl = yes ExSTS\n</code></pre> <p>Two computational instances for the same relation are extensionally equal on successful results.</p> <pre><code>module _ {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} (comp comp' : Computational STS Err) where\n\n  open Computational comp  renaming (compute to compute\u2081)\n  open Computational comp' renaming (compute to compute\u2082)\n\n  compute-ext\u2261 : compute\u2081 c s sig \u2248\u1d9c\u02b3 compute\u2082 c s sig\n  compute-ext\u2261 = ExtendedRel-rightUnique comp\n    (ExtendedRel-compute comp) (ExtendedRel-compute comp')\n\nopen Computational \u2983...\u2984\n\nComputational\u21d2Dec' :\n  {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2983 comp : Computational STS Err \u2984 \u2192 Dec (\u2203[ s' ] STS c s sig s')\nComputational\u21d2Dec' with computeProof _ _ _ in eq\n... | success x = yes x\n... | failure x = no \u03bb (_ , h) \u2192 failure\u21d2\u2200\u00acSTS (-, cong (map proj\u2081) eq) _ h\n</code></pre>"},{"location":"Interface.ComputationalRelation.html#error-injection-helper","title":"Error Injection Helper","text":"<p>When combining a base interpreter with a step interpreter, their error spaces may differ.  We provide a tiny class to inject either error into a common sum-like error used by the combined interpreter.</p> <pre><code>record InjectError Err\u2081 Err\u2082 : Type where\n  field injectError : Err\u2081 \u2192 Err\u2082\n\nopen InjectError\n\ninstance\n  InjectError-\u22a5 : InjectError \u22a5 Err\n  InjectError-\u22a5 = \u03bb where\n    .injectError ()\n\n  InjectError-Id : InjectError Err Err\n  InjectError-Id = \u03bb where\n    .injectError \u2192 id\n</code></pre>"},{"location":"Interface.ComputationalRelation.html#basic-instance-identity-relation","title":"Basic Instance: identity relation","text":"<p>For the identity relation <code>IdSTS</code> (from <code>Interface.STS</code>), computing always succeeds with the input state.</p> <pre><code>instance\n  Computational-Id : {C S : Type} \u2192 Computational (IdSTS {C} {S}) \u22a5\n  Computational-Id .computeProof _ s _ = success (s , Id-nop)\n  Computational-Id .completeness _ _ _ _ Id-nop = refl\n</code></pre>"},{"location":"Interface.ComputationalRelation.html#computational-instances-for-the-original-reflexive-transitive-closure-relations","title":"Computational Instances for the Original \"Reflexive Transitive Closure\" Relations","text":"<pre><code>module _ {BSTS : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} \u2983 _ : Computational BSTS Err\u2081 \u2984 where\n  module _ {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2983 _ : Computational STS Err\u2082 \u2984\n     \u2983 _ : InjectError Err\u2081 Err \u2984 \u2983 _ : InjectError Err\u2082 Err \u2984 where instance\n    Computational-ReflexiveTransitiveClosure\u1d47 : Computational (ReflexiveTransitiveClosure\u1d47 {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = BSTS}{STS}) (Err)\n    Computational-ReflexiveTransitiveClosure\u1d47 .computeProof c s [] = bimap (injectError it) (map\u2082\u2032 BS-base) (computeProof c s tt)\n    Computational-ReflexiveTransitiveClosure\u1d47 .computeProof c s (sig \u2237 sigs) with computeProof c s sig\n    ... | success (s\u2081 , h) with computeProof c s\u2081 sigs\n    ...   | success (s\u2082 , hs) = success (s\u2082 , BS-ind h hs)\n    ...   | failure a = failure (injectError it a)\n    Computational-ReflexiveTransitiveClosure\u1d47 .computeProof c s (sig \u2237 sigs) | failure a = failure (injectError it a)\n    Computational-ReflexiveTransitiveClosure\u1d47 .completeness c s [] s' (BS-base p)\n      with computeProof {STS = BSTS} c s tt | completeness _ _ _ _ p\n    ... | success x | refl = refl\n    Computational-ReflexiveTransitiveClosure\u1d47 .completeness c s (sig \u2237 sigs) s' (BS-ind h hs)\n      with computeProof c s sig | completeness _ _ _ _ h\n    ... | success (s\u2081 , _) | refl\n      with computeProof \u2983 Computational-ReflexiveTransitiveClosure\u1d47 \u2984 c s\u2081 sigs | completeness _ _ _ _ hs\n    ... | success (s\u2082 , _) | p = p\n\n  module _ {STS : C \u00d7 \u2115 \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2983 Computational-STS : Computational STS Err\u2082 \u2984\n    \u2983 InjectError-Err\u2081 : InjectError Err\u2081 Err \u2984 \u2983 InjectError-Err\u2082 : InjectError Err\u2082 Err \u2984\n    where instance\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' : Computational (_\u22a2_\u21c0\u27e6_\u27e7\u1d62*'_ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = BSTS}{STS}) Err\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .computeProof c s [] =\n      bimap (injectError it) (map\u2082\u2032 BS-base) (computeProof (proj\u2081 c) s tt)\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .computeProof c s (sig \u2237 sigs) with computeProof c s sig\n    ... | success (s\u2081 , h) with computeProof (proj\u2081 c , suc (proj\u2082 c)) s\u2081 sigs\n    ... | success (s\u2082 , hs) = success (s\u2082 , BS-ind h hs)\n    ... | failure a = failure a\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .computeProof c s (sig \u2237 sigs) | failure a = failure (injectError it a)\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .completeness c s [] s' (BS-base p)\n      with computeProof {STS = BSTS} (proj\u2081 c) s tt | completeness _ _ _ _ p\n    ... | success x | refl = refl\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .completeness c s (sig \u2237 sigs) s' (BS-ind h hs)\n      with computeProof {STS = STS} {Err = Err\u2082} c s sig | completeness _ _ _ _ h\n    ... | success (s\u2081 , _) | refl\n      with computeProof (proj\u2081 c , suc (proj\u2082 c)) s\u2081 sigs | completeness _ _ _ _ hs\n    ...   | success (s\u2082 , _) | p = p\n\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47 : Computational (ReflexiveTransitiveClosure\u1d62\u1d47 {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = BSTS}{STS}) Err\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47 .computeProof c =\n      Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .computeProof (c , 0)\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47 .completeness c =\n      Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .completeness (c , 0)\n</code></pre>"},{"location":"Interface.ComputationalRelation.html#convenience-exports","title":"Convenience exports","text":"<p>For projects that still use the historical names, the following shims maintain compatibility with the new definitions in <code>Interface.STS</code>:</p> <pre><code>Computational-ReflexiveTransitiveClosure : {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2192 \u2983 Computational STS Err \u2984\n  \u2192 Computational (ReflexiveTransitiveClosure {sts = STS}) Err\nComputational-ReflexiveTransitiveClosure = it\n\nComputational-ReflexiveTransitiveClosure\u1d62 : {STS : C \u00d7 \u2115 \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2192 \u2983 Computational STS Err \u2984\n  \u2192 Computational (ReflexiveTransitiveClosure\u1d62 {sts = STS}) Err\nComputational-ReflexiveTransitiveClosure\u1d62 = it\n</code></pre>"},{"location":"Interface.ComputationalRelation.html#lifting-a-step-interpreter-to-traces","title":"Lifting a Step Interpreter to Traces","text":"<p>Given a <code>Computational</code> instance for a single-step relations <code>Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type</code> (and instances for <code>Init : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type</code> and <code>Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type</code>, as needed), we execute traces in two flavors.</p>"},{"location":"Interface.ComputationalRelation.html#1-trace-with-final-step-runtraceandthen","title":"1. Trace with Final Step: RunTraceAndThen","text":"<pre><code>module _ {Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2983 serr : Computational Step Err\u2081 \u2984 where\n  module _  {Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} \u2983 lerr : Computational Last Err\u2082 \u2984\n            \u2983 _ : InjectError Err\u2081 Err \u2984 \u2983 _ : InjectError Err\u2082 Err \u2984\n    where\n\n    instance\n\n      Computational-RunTraceAndThen : Computational (RunTraceAndThen Step Last) Err\n\n      Computational-RunTraceAndThen .computeProof \u0393 s []\n        with computeProof {STS = Last} \u0393 s tt\n      ... | failure e = failure (injectError it e)\n      ... | success (s' , h) = success (s' , run-[] h)\n\n\n      Computational-RunTraceAndThen .computeProof \u0393 s (sig \u2237 sigs)\n        with computeProof {STS = Step} \u0393 s sig\n      ... | failure e = failure (injectError it e)\n      ... | success (s\u2081 , h) with computeProof {STS = RunTraceAndThen Step Last} \u0393 s\u2081 sigs\n      ... | failure e = failure (injectError it e)\n      ... | success (s\u2082 , hs) = success (s\u2082 , run-\u2237 h hs)\n\n      Computational-RunTraceAndThen .completeness \u0393 s sigs s'' (run-[] x)\n        with computeProof {STS = Last} \u0393 s tt | completeness _ _ _ _ x\n      ... | success (s' , h) | refl = refl\n\n      Computational-RunTraceAndThen .completeness \u0393 s (sig \u2237 sigs) s'' (run-\u2237 x x\u2081)\n        with computeProof {STS = Step} \u0393 s sig | completeness _ _ _ _ x\n      ... | success (s\u2081 , _) | refl\n        with computeProof {STS = RunTraceAndThen Step Last} \u0393 s\u2081 sigs | completeness _ _ _ _ x\u2081\n      ... | success (s\u2082 , _) | p = p\n</code></pre>"},{"location":"Interface.ComputationalRelation.html#2-seeded-trace-with-final-step-runtraceafterandthen","title":"2. Seeded Trace with Final Step: RunTraceAfterAndThen","text":"<pre><code>module _ {Init : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} \u2983 _ : Computational Init Err\u2082 \u2984 where\n  module _ {Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2983 _ : Computational Step Err\u2081 \u2984 where\n    module _ {Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} \u2983 _ : Computational Last Err\u2082 \u2984\n             \u2983 _ : InjectError Err\u2081 Err \u2984 \u2983 _ : InjectError Err\u2082 Err \u2984 where\n\n      instance\n        Computational-RunTraceAfterAndThen : Computational (RunTraceAfterAndThen Init Step Last) Err\n\n        Computational-RunTraceAfterAndThen .computeProof \u0393 s sigs\n          with computeProof {STS = Init} \u0393 s tt\n        ... | failure e = failure (injectError it e)\n        ... | success (s' , h)\n              with computeProof {STS = RunTraceAndThen Step Last} {Err = Err} \u0393 s' sigs\n        ...   | failure e = failure (injectError it e)\n        ...   | success (t , r) = success (t , run (h , r))\n\n        Computational-RunTraceAfterAndThen .completeness \u0393 s sigs t (run (init , rtat))\n          with computeProof {STS = Init} \u0393 s tt | completeness _ _ _ _ init\n        ... | success (s' , h) | refl\n              with computeProof {STS = RunTraceAndThen Step Last} {Err = Err} \u0393 s' sigs\n              | completeness {Err = Err} _ _ _ _ rtat\n        ...   | success (t' , r) | refl = refl\n</code></pre>"},{"location":"Interface.HasSubset.html","title":"HasSubset","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Interface.HasSubset where\n\nopen import Level using (Level; suc)\n\nrecord HasSubset {a} (A : Set a) : Set (suc a) where\n  field _\u2286_ : A \u2192 A \u2192 Set a\n  infix 4 _\u2286_\n\nopen HasSubset \u2983...\u2984 public\n</code></pre>"},{"location":"Interface.HasSubtract.Instances.html","title":"Instance","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Interface.HasSubtract.Instances where\n\nopen import Interface.HasSubtract\n\nopen import Data.Integer as \u2124 using (\u2124)\nopen import Data.Nat     as \u2115 using (\u2115)\n\ninstance\n  HasSubtract-\u2115 : HasSubtract \u2115 \u2115\n  HasSubtract-\u2115 ._-_ = \u2115._\u2238_\n\n  HasSubtract-\u2124 : HasSubtract \u2124 \u2124\n  HasSubtract-\u2124 ._-_ = \u2124._-_\n\n  HasSubtract-\u2115-\u2124 : HasSubtract \u2115 \u2124\n  HasSubtract-\u2115-\u2124 ._-_ = \u2124._\u2296_\n</code></pre>"},{"location":"Interface.HasSubtract.html","title":"HasSubtract","text":"<pre><code>{-# OPTIONS --safe --cubical-compatible #-}\nmodule Interface.HasSubtract where\n\nopen import Agda.Primitive using () renaming (Set to Type)\n\nrecord HasSubtract (A B : Type) : Type where\n  infixl 6 _-_\n  field _-_ : A \u2192 A \u2192 B\n\nopen HasSubtract \u2983 ... \u2984 public\n</code></pre>"},{"location":"Interface.Hashable.html","title":"Hashable","text":"<pre><code>{-# OPTIONS --safe #-}\nmodule Interface.Hashable where\n\nopen import Agda.Builtin.Equality\nopen import Agda.Primitive using () renaming (Set to Type)\n\nrecord Hashable (T THash : Type) : Type where\n  field hash    : T \u2192 THash\n\nopen Hashable \u2983...\u2984 public\n\nHashable\u2081 : (Type \u2192 Type) \u2192 Type \u2192 Type\u2081\nHashable\u2081 F THash = {A : Type} \u2192 \u2983 Hashable A THash \u2984 \u2192 Hashable (F A) THash\n\nHashable\u2082 : (Type \u2192 Type \u2192 Type) \u2192 Type \u2192 Type\u2081\nHashable\u2082 F THash = {A B : Type} \u2192 \u2983 Hashable A THash \u2984 \u2192 \u2983 Hashable B THash \u2984 \u2192 Hashable (F A B) THash\n</code></pre>"},{"location":"Interface.STS.html","title":"State Transition System","text":"<p>This module introduces the abstract types we use to define a generic state transition system (STS) along with reusable trace runners (folds over lists of signals) and standard properties (totality and invariant preservation).</p>"},{"location":"Interface.STS.html#a-note-on-recent-changes","title":"A Note on Recent Changes","text":"<p>We refactored the <code>STS</code> module to reflect what the code actually does---it processes a list of signals, transforming state.</p> <ul> <li> <p>Clearer names</p> </li> <li> <p><code>RunTraceAndThen</code>: run a given transition (<code>Step</code>) on a list of signals and       then, once the list is empty, run a final transition (<code>Last</code>).</p> </li> <li><code>RunTraceAfterAndThen</code>: run a given transition (<code>Init</code>), then run a transition       (<code>Step</code>) for a each signal in a given list, then, once the list is empty, run a       final (<code>Last</code>) transition.</li> </ul>"},{"location":"Interface.STS.html#high-level-picture","title":"High-level picture","text":"<ul> <li>A trace is a list of signals <code>sigs : List Sig</code>.</li> <li>Let <code>Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type</code> be a step relation and <code>Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type</code> a relation.</li> <li><code>RunTraceAndThen Step Last \u0393 s sigs s'</code> means: starting in <code>s</code>, running <code>sigs</code>    (left-to-right) under environment <code>\u0393</code>, then perform <code>Last</code>, to yield <code>s'</code>.</li> </ul> <p>A variation that is sometimes useful involves indexed steps---that is, it allows the step relation to depend on the position in the trace via an index <code>n : \u2115</code>.</p>"},{"location":"Interface.STS.html#state-transition-sytem-types","title":"State Transition Sytem Types","text":"<pre><code>data RunTraceAndThen (Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type) (Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type) :\n  C \u2192 S \u2192 List Sig \u2192 S \u2192 Type where\n\n    run-[] : Last \u0393 s tt s' \u2192 RunTraceAndThen Step Last \u0393 s [] s'\n\n    run-\u2237 :  Step \u0393 s sig s'\n             \u2192 RunTraceAndThen Step Last \u0393 s' sigs s''\n             \u2192 RunTraceAndThen Step Last \u0393 s (sig \u2237 sigs) s''\n\ndata RunTraceAfterAndThen (Init : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type)\n                          (Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type)\n                          (Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type) :\n  C \u2192 S \u2192 List Sig \u2192 S \u2192 Type where\n\n    run :\n        \u2219 Init \u0393 s tt s'\n        \u2219 RunTraceAndThen Step Last \u0393 s' sigs s''\n        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        RunTraceAfterAndThen Init Step Last \u0393 s sigs s''\n</code></pre>"},{"location":"Interface.STS.html#the-original-transition-relation-types","title":"The Original Transition Relation Types","text":"<p>The transition relations defined in this subsection are used in various places in the ledger formalization.</p> <pre><code>module _ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} {_\u22a2_\u21c0\u27e6_\u27e7_ : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} where\n  data _\u22a2_\u21c0\u27e6_\u27e7*_ : C \u2192 S \u2192 List Sig \u2192 S \u2192 Type where\n\n    BS-base :\n      \u0393 \u22a2 s \u21c0\u27e6 _ \u27e7\u1d47 s'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 s \u21c0\u27e6 [] \u27e7* s'\n\n    BS-ind :\n        \u0393 \u22a2 s  \u21c0\u27e6 sig  \u27e7  s'\n      \u2192 \u0393 \u22a2 s' \u21c0\u27e6 sigs \u27e7* s''\n        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u0393 \u22a2 s  \u21c0\u27e6 sig \u2237 sigs \u27e7* s''\n</code></pre>"},{"location":"Interface.STS.html#indexed-variant","title":"Indexed Variant","text":"<p>An indexed variant of the <code>_\u22a2_\u21c0\u27e6_\u27e7*_</code> type allows the step relation to depend on the position in the trace by threading an index through the environment. The index counts how many elements have already been consumed.</p> <pre><code>module _ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} {_\u22a2_\u21c0\u27e6_\u27e7_ : C \u00d7 \u2115 \u2192 S \u2192 Sig \u2192 S \u2192 Type} where\n  data _\u22a2_\u21c0\u27e6_\u27e7\u1d62*'_ : C \u00d7 \u2115 \u2192 S \u2192 List Sig \u2192 S \u2192 Type where\n\n    BS-base :\n      \u0393 \u22a2 s \u21c0\u27e6 _ \u27e7\u1d47 s'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      (\u0393 , n) \u22a2 s \u21c0\u27e6 [] \u27e7\u1d62*' s'\n\n    BS-ind :\n        (\u0393 , n)     \u22a2 s  \u21c0\u27e6 sig  \u27e7  s'\n      \u2192 (\u0393 , suc n) \u22a2 s' \u21c0\u27e6 sigs \u27e7\u1d62*' s''\n        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        (\u0393 , n)     \u22a2 s  \u21c0\u27e6 sig \u2237 sigs \u27e7\u1d62*' s''\n</code></pre> <p>The following defines a convenience wrapper that starts at index <code>0</code>.</p> <pre><code>  _\u22a2_\u21c0\u27e6_\u27e7\u1d62*_ : C \u2192 S \u2192 List Sig \u2192 S \u2192 Type\n  _\u22a2_\u21c0\u27e6_\u27e7\u1d62*_ \u0393 = _\u22a2_\u21c0\u27e6_\u27e7\u1d62*'_ (\u0393 , 0)\n</code></pre> <p>Other convenience wrappers are defined, as follows:</p> <pre><code>-- with a trivial base case\ndata IdSTS {C S} : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type where\n  Id-nop : IdSTS \u0393 s _ s\n\nReflexiveTransitiveClosure : {sts : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2192 C \u2192 S \u2192 List Sig \u2192 S \u2192 Type\nReflexiveTransitiveClosure {sts = sts} = _\u22a2_\u21c0\u27e6_\u27e7*_ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = IdSTS}{sts}\n\nReflexiveTransitiveClosure\u1d62 : {sts : C \u00d7 \u2115 \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2192 C \u2192 S \u2192 List Sig \u2192 S \u2192 Type\nReflexiveTransitiveClosure\u1d62 {sts = sts} = _\u22a2_\u21c0\u27e6_\u27e7\u1d62*_ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = IdSTS}{sts}\n\nReflexiveTransitiveClosure\u1d62\u1d47 = _\u22a2_\u21c0\u27e6_\u27e7\u1d62*_\nReflexiveTransitiveClosure\u1d47 = _\u22a2_\u21c0\u27e6_\u27e7*_\n</code></pre>"},{"location":"Interface.STS.html#totality","title":"Totality","text":"<p>We say a single-step relation is total if every input has some output.</p> <pre><code>STS-total : (C \u2192 S \u2192 Sig \u2192 S \u2192 Type) \u2192 Type\nSTS-total _\u22a2_\u21c0\u27e6_\u27e7_ = \u2200 {\u0393 s sig} \u2192 \u2203[ s' ] \u0393 \u22a2 s \u21c0\u27e6 sig \u27e7 s'\n\nReflexiveTransitiveClosure-total : {_\u22a2_\u21c0\u27e6_\u27e7_ : C \u2192 S \u2192 Sig \u2192 S \u2192 Type}\n  \u2192 STS-total _\u22a2_\u21c0\u27e6_\u27e7_ \u2192 STS-total (ReflexiveTransitiveClosure {sts = _\u22a2_\u21c0\u27e6_\u27e7_})\nReflexiveTransitiveClosure-total SS-total {\u0393} {s} {[]} = s , BS-base Id-nop\nReflexiveTransitiveClosure-total SS-total {\u0393} {s} {x \u2237 sig} =\n  case SS-total of \u03bb where\n    (s' , Ps') \u2192 map\u2082\u2032 (BS-ind Ps') $ ReflexiveTransitiveClosure-total SS-total\n</code></pre>"},{"location":"Interface.STS.html#invariants","title":"Invariants","text":"<p>A predicate <code>P : S \u2192 Type</code> is an invariant of a step relation <code>STS</code> if it is preserved by every step.</p> <p>```agda LedgerInvariant : (C \u2192 S \u2192 Sig \u2192 S \u2192 Type) \u2192 (S \u2192 Type) \u2192 Type LedgerInvariant STS P = \u2200 {c s sig s'} \u2192 STS c s sig s' \u2192 P s \u2192 P s'</p> <p>RTC-preserves-inv : \u2200 {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} {P}                   \u2192 LedgerInvariant STS P \u2192 LedgerInvariant (ReflexiveTransitiveClosure {sts = STS}) P RTC-preserves-inv inv (BS-base Id-nop) = id RTC-preserves-inv inv (BS-ind p\u2081 p\u2082)   = RTC-preserves-inv inv p\u2082 \u2218 inv p\u2081</p>"},{"location":"Ledger.Conway.Conformance.Certs.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Gov.Base using (GovStructure)\n\nmodule Ledger.Conway.Conformance.Certs.Properties (gs : _) (open GovStructure gs) where\n\nopen import Data.Maybe.Properties\nopen import Relation.Nullary.Decidable\n\nopen import Ledger.Conway.Specification.Gov.Actions gs hiding (yes; no)\nopen import Ledger.Conway.Conformance.Certs gs\n\nopen Computational \u2983...\u2984\n\nopen import stdlib-meta.Tactic.GenError using (genErrors)\n\nopen DCert ; open PState\nopen GovVote\n\nlookupDeposit :\n  (dep : DepositPurpose \u21c0 Coin) (c : DepositPurpose) \u2192\n  Dec (Any (\u03bb (c' , _) \u2192 c \u2261 c') (dep \u02e2))\nlookupDeposit dep c = any? (\u03bb { _ \u2192 \u00bf _ \u00bf }) (dep \u02e2)\n\ninstance\n  Computational-DELEG : Computational _\u22a2_\u21c0\u2987_,DELEG\u2988_ String\n  Computational-DELEG .computeProof de ds =\n    let open DelegEnv de; open DState ds in\n    \u03bb where\n    (delegate c mv mc d) \u2192 case \u00bf (c \u2209 dom rewards \u2192 d \u2261 pparams .PParams.keyDeposit)\n                                \u00d7 (c \u2208 dom rewards \u2192 d \u2261 0)\n                                \u00d7 mv \u2208 map\u02e2 (just \u2218 vDelegCredential) delegatees \u222a\n                                    fromList ( nothing \u2237 just vDelegAbstain \u2237 just vDelegNoConfidence \u2237 [] )\n                                \u00d7 mc \u2208 map\u02e2 just (dom (DelegEnv.pools de)) \u222a \u2774 nothing \u2775 \u00bf of \u03bb where\n      (yes p) \u2192 success (-, DELEG-delegate p )\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    (dereg c md) \u2192 case lookupDeposit deposits (CredentialDeposit c) of \u03bb where\n      (yes ((k , d) , _)) \u2192\n        case\n          \u00bf (c , 0) \u2208 rewards \n          \u00d7 (CredentialDeposit c , d) \u2208 deposits\n          \u00d7 (md \u2261 nothing \u228e md \u2261 just d)\n          \u00bf of \u03bb where\n            (yes q) \u2192 success (-, DELEG-dereg q)\n            (no \u00acq) \u2192 failure (genErrors \u00acq)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    (reg c d) \u2192 case \u00bf c \u2209 dom rewards \u00d7 (d \u2261 pparams .PParams.keyDeposit \u228e d \u2261 0) \u00bf of \u03bb where\n      (yes p) \u2192 success (-, DELEG-reg p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    _ \u2192 failure \"Unexpected certificate in DELEG\"\n\n  Computational-DELEG .completeness de ds (delegate c mv mc d)\n    s' (DELEG-delegate p) rewrite dec-yes (\u00bf (c \u2209 dom (DState.rewards ds) \u2192 d \u2261 DelegEnv.pparams de .PParams.keyDeposit)\n                                           \u00d7 (c \u2208 dom (DState.rewards ds) \u2192 d \u2261 0)\n                                           \u00d7 mv \u2208 map\u02e2 (just \u2218 vDelegCredential) (DelegEnv.delegatees de) \u222a\n                                               fromList ( nothing \u2237 just vDelegAbstain \u2237 just vDelegNoConfidence \u2237 [] )\n                                           \u00d7 mc \u2208 map\u02e2 just (dom (DelegEnv.pools de)) \u222a \u2774 nothing \u2775 \u00bf) p .proj\u2082 = refl\n  Computational-DELEG .completeness _ ds (dereg c nothing) _ (DELEG-dereg h@(p , q , r))\n    with lookupDeposit (DState.deposits ds) (CredentialDeposit c)\n  ... | (yes ((_ , d') , s\u2082 , refl)) rewrite dec-yes\n          (\u00bf (c , 0) \u2208 (DState.rewards ds)\n           \u00d7 (CredentialDeposit c , d') \u2208 (DState.deposits ds)\n           \u00d7 (nothing \u2261 nothing {A = \u2115} \u228e nothing \u2261 just d')\n           \u00bf) (p , s\u2082 , inj\u2081 refl) .proj\u2082 = refl\n  Computational-DELEG .completeness _ ds (dereg c nothing) _ (DELEG-dereg h@(p , q , r))\n      | (no \u00acs) = \u22a5-elim (\u00acs (_ , q , refl))\n  Computational-DELEG .completeness _ ds (dereg c (just d)) _ (DELEG-dereg h@(p , q , inj\u2082 refl))\n    with lookupDeposit (DState.deposits ds) (CredentialDeposit c)\n  ... | (yes ((_ , d') , q' , refl)) rewrite dec-yes\n          (\u00bf (c , 0) \u2208 (DState.rewards ds)\n           \u00d7 (CredentialDeposit c , d') \u2208 (DState.deposits ds)\n           \u00d7 (just d \u2261 nothing {A = \u2115} \u228e just d \u2261 just d')\n           \u00bf) (p , q' , inj\u2082 (cong just (proj\u2082 (DState.deposits ds) q q'))) .proj\u2082 = refl\n  ... | (no \u00acs) = \u22a5-elim (\u00acs (_ , q , refl))\n  Computational-DELEG .completeness de ds (reg c d) _ (DELEG-reg p)\n    rewrite dec-yes (\u00bf c \u2209 dom (DState.rewards ds) \u00d7 (d \u2261 DelegEnv.pparams de .PParams.keyDeposit \u228e d \u2261 0) \u00bf) p .proj\u2082 = refl\n\n  Computational-POOL : Computational _\u22a2_\u21c0\u2987_,POOL\u2988_ String\n  Computational-POOL .computeProof _ ps (regpool c _) =\n    case \u00ac? (c \u2208? dom (pools ps)) of \u03bb where\n      (yes p) \u2192 success (-, POOL-regpool p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-POOL .computeProof _ _ (retirepool c e) = success (-, POOL-retirepool)\n  Computational-POOL .computeProof _ _ _ = failure \"Unexpected certificate in POOL\"\n  Computational-POOL .completeness _ ps (regpool c _) _ (POOL-regpool \u00acp)\n    rewrite dec-no (c \u2208? dom (pools ps)) \u00acp = refl\n  Computational-POOL .completeness _ _ (retirepool _ _) _ POOL-retirepool = refl\n\n  Computational-GOVCERT : Computational _\u22a2_\u21c0\u2987_,GOVCERT\u2988_ String\n  Computational-GOVCERT .computeProof ce gs (regdrep c d _) =\n    let open CertEnv ce; open GState gs; open PParams pp in\n    case \u00bf (d \u2261 drepDeposit \u00d7 c \u2209 dom dreps)\n         \u228e (d \u2261 0 \u00d7 c \u2208 dom dreps) \u00bf of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-regdrep p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof ce gs (deregdrep c d) =\n    case \u00bf c \u2208 dom (GState.dreps gs) \u00d7 (DRepDeposit c , d) \u2208  (GState.deposits gs) \u00bf of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-deregdrep p)\n      (no \u00acp)  \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof ce gs (ccreghot c _) =\n    let open CertEnv ce; open GState gs in\n    case \u00bf ((c , nothing) \u2209 ccHotKeys \u02e2) \u00d7 c \u2208 coldCreds \u00bf of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-ccreghot p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof _ _ _ = failure \"Unexpected certificate in GOVCERT\"\n  Computational-GOVCERT .completeness ce gs\n    (regdrep c d _) _ (GOVCERT-regdrep p)\n    rewrite dec-yes\n      \u00bf (let open CertEnv ce; open PParams pp in\n        (d \u2261 drepDeposit \u00d7 c \u2209 dom (GState.dreps gs)) \u228e (d \u2261 0 \u00d7 c \u2208 dom (GState.dreps gs)))\n      \u00bf p .proj\u2082 = refl\n  Computational-GOVCERT .completeness _ gs\n    (deregdrep c d) _ (GOVCERT-deregdrep p)\n    rewrite dec-yes \u00bf c \u2208 dom (GState.dreps gs) \u00d7 (DRepDeposit c , d) \u2208 (GState.deposits gs) \u00bf p .proj\u2082 = refl\n  Computational-GOVCERT .completeness ce gs\n    (ccreghot c _) _ (GOVCERT-ccreghot p)\n    rewrite dec-yes (\u00bf (((c , nothing) \u2209 (GState.ccHotKeys gs) \u02e2) \u00d7 c \u2208 CertEnv.coldCreds ce) \u00bf) p .proj\u2082 = refl\n\n  Computational-CERT : Computational _\u22a2_\u21c0\u2987_,CERT\u2988_ String\n  Computational-CERT .computeProof ce cs dCert\n    with computeProof \u27e6 CertEnv.pp ce , PState.pools (CertState.pState cs) , dom (GState.dreps (CertState.gState cs)) \u27e7\n                      (CertState.dState cs) dCert\n         | computeProof (CertEnv.pp ce) (CertState.pState cs) dCert\n         | computeProof ce (CertState.gState cs) dCert\n  ... | success (_ , h) | _               | _               = success (-, CERT-deleg h)\n  ... | failure _       | success (_ , h) | _               = success (-, CERT-pool h)\n  ... | failure _       | failure _       | success (_ , h) = success (-, CERT-vdel h)\n  ... | failure e\u2081      | failure e\u2082      | failure e\u2083      = failure $\n    \"DELEG: \" &lt;&gt; e\u2081 &lt;&gt; \"\\nPOOL: \" &lt;&gt; e\u2082 &lt;&gt; \"\\nVDEL: \" &lt;&gt; e\u2083\n  Computational-CERT .completeness ce cs\n    dCert@(delegate c mv mc d) cs' (CERT-deleg h)\n    with computeProof \u27e6 CertEnv.pp ce , PState.pools (CertState.pState cs) , dom (GState.dreps (CertState.gState cs)) \u27e7\n                      (CertState.dState cs) dCert\n         | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(reg c d) cs' (CERT-deleg h)\n    with computeProof \u27e6 CertEnv.pp ce , PState.pools (CertState.pState cs) , dom (GState.dreps (CertState.gState cs)) \u27e7\n                      (CertState.dState cs) dCert\n         | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(dereg c _) cs' (CERT-deleg h)\n    with computeProof \u27e6 CertEnv.pp ce , PState.pools (CertState.pState cs) , dom (GState.dreps (CertState.gState cs)) \u27e7\n                      (CertState.dState cs) dCert\n         | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(regpool c poolParams) cs' (CERT-pool h)\n    with computeProof (CertEnv.pp ce) (CertState.pState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(retirepool c e) cs' (CERT-pool h)\n    with completeness _ _ _ _ h\n  ... | refl = refl\n  Computational-CERT .completeness \u0393 cs\n    dCert@(regdrep c d an)\n    cs' (CERT-vdel h)\n    with computeProof \u0393 (CertState.gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness \u0393 cs\n    dCert@(deregdrep c _) cs' (CERT-vdel h)\n    with computeProof \u0393 (CertState.gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness \u0393 cs\n    dCert@(ccreghot c mkh) cs' (CERT-vdel h)\n    with computeProof \u0393 (CertState.gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n\n\n  Computational-PRE-CERT : Computational _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ String\n  Computational-PRE-CERT .computeProof ce cs _ =\n    let open CertEnv ce; open PParams pp\n        open GState (CertState.gState cs); open DState (CertState.dState cs)\n        refresh = mapPartial (isGovVoterDRep \u2218 voter) (fromList votes)\n        refreshedDReps  = mapValueRestricted (const (CertEnv.epoch ce + drepActivity)) dreps refresh\n    in case \u00bf filter\u02e2 isKeyHash (map\u02e2 RwdAddr.stake (dom wdrls)) \u2286 dom voteDelegs\n              \u00d7 map\u02e2 (map\u2081 RwdAddr.stake) (wdrls \u02e2) \u2286 rewards \u02e2 \u00bf of \u03bb where\n      (yes p) \u2192 success (-, CERT-pre p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-PRE-CERT .completeness ce st _ st' (CERT-pre p)\n    rewrite let dState = CertState.dState st; open DState dState in\n      dec-yes \u00bf filter\u02e2 isKeyHash (map\u02e2 RwdAddr.stake (dom (CertEnv.wdrls ce))) \u2286 dom voteDelegs\n                \u00d7 map\u02e2 (map\u2081 RwdAddr.stake) (CertEnv.wdrls ce \u02e2) \u2286 rewards \u02e2 \u00bf\n        p .proj\u2082 = refl\n\n  -- POST-CERT has no premises, so computing always succeeds\n  -- with the unique post-state and proof CERT-post.\n  Computational-POST-CERT : Computational _\u22a2_\u21c0\u2987_,POST-CERT\u2988_ String\n  Computational-POST-CERT .computeProof ce cs tt = success ( cs' , CERT-post)\n    where\n      dreps : DReps\n      dreps = GState.dreps (CertState.gState cs)\n      validVoteDelegs : VoteDelegs\n      validVoteDelegs = (DState.voteDelegs (CertState.dState cs)) \u2223^ ( map\u02e2 vDelegCredential (dom dreps) \u222a fromList (vDelegNoConfidence \u2237 vDelegAbstain \u2237 []) )\n      cs' : CertState\n      cs' = \u27e6 \u27e6 validVoteDelegs , _ , _ \u27e7 , CertState.pState cs , CertState.gState cs \u27e7\n\n  -- Completeness: the relational proof pins s' to exactly `post`,\n  -- and computeProof returns success at that same state; so refl.\n  Computational-POST-CERT .completeness ce cs _ cs' CERT-post = refl\n\n\nComputational-CERTS : Computational _\u22a2_\u21c0\u2987_,CERTS\u2988_ String\nComputational-CERTS = it\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Certs.html","title":"Certs","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Gov.Base\nimport Ledger.Conway.Specification.Certs\n\nmodule Ledger.Conway.Conformance.Certs\n  (gs : _) (open GovStructure gs)\n  where\n\n\nopen import Ledger.Conway.Specification.Gov.Actions gs\nprivate module Certs = Ledger.Conway.Specification.Certs gs\nopen Certs public\n  hiding (DState; GState; CertState; HasCast-DState; HasCast-GState; HasCast-CertState;\n          _\u22a2_\u21c0\u2987_,POOL\u2988_; _\u22a2_\u21c0\u2987_,DELEG\u2988_; _\u22a2_\u21c0\u2987_,GOVCERT\u2988_;\n          _\u22a2_\u21c0\u2987_,CERT\u2988_; _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_; _\u22a2_\u21c0\u2987_,POST-CERT\u2988_; _\u22a2_\u21c0\u2987_,CERTS\u2988_; \u27e6_,_,_\u27e7\u1d48)\nopen RwdAddr\n\nrecord DState : Type where\n  constructor \u27e6_,_,_,_\u27e7\u1d48\n  field\n    voteDelegs   : VoteDelegs\n    stakeDelegs  : Credential \u21c0 KeyHash\n    rewards      : Rewards\n    deposits     : Deposits\n\nrecord GState : Type where\n  constructor \u27e6_,_,_\u27e7\u1d5b\n  field\n    dreps      : Credential \u21c0 Epoch\n    ccHotKeys  : Credential \u21c0 Maybe Credential\n    deposits   : Deposits\n\nrecord CertState : Type where\n  constructor \u27e6_,_,_\u27e7\u1d9c\u02e2\n  field\n    dState : DState\n    pState : PState\n    gState : GState\n\ninstance\n  unquoteDecl HasCast-DState HasCast-GState HasCast-CertState = derive-HasCast\n    (   (quote DState , HasCast-DState)\n    \u2237   (quote GState , HasCast-GState)\n    \u2237 [ (quote CertState , HasCast-CertState) ])\n\ncertDeposit : DCert \u2192 PParams \u2192 Deposits\ncertDeposit (delegate c _ _ v) _   = \u2774 CredentialDeposit c , v \u2775\ncertDeposit (regdrep c v _)    _   = \u2774 DRepDeposit c , v \u2775\ncertDeposit (reg c v)          pp  = \u2774 CredentialDeposit c , pp .PParams.keyDeposit \u2775\ncertDeposit _                  _   = \u2205\n-- handled in the Utxo module:\n-- certDeposit (regpool kh _)     pp  = \u2774 PoolDeposit kh , pp .poolDeposit \u2775\n\ncertRefund : DCert \u2192 \u2119 DepositPurpose\ncertRefund (dereg c _)      = \u2774 CredentialDeposit c \u2775\ncertRefund (deregdrep c _)  = \u2774 DRepDeposit c \u2775\ncertRefund _                = \u2205\n\nupdateCertDeposit  : PParams \u2192 DCert \u2192 Deposits \u2192 Deposits\nupdateCertDeposit pp (delegate c _ _ v) deposits = deposits \u222a\u207a \u2774 CredentialDeposit c , v \u2775\nupdateCertDeposit pp (reg c _)          deposits = deposits \u222a\u207a \u2774 CredentialDeposit c , pp .PParams.keyDeposit \u2775\nupdateCertDeposit pp (regdrep c v _)    deposits = deposits \u222a\u207a \u2774 DRepDeposit c , v \u2775\nupdateCertDeposit pp (dereg c _)        deposits = deposits \u2223 \u2774 CredentialDeposit c \u2775 \u1d9c\nupdateCertDeposit pp (deregdrep c _)    deposits = deposits \u2223 \u2774 DRepDeposit c \u2775 \u1d9c\nupdateCertDeposit pp (regpool kh _)     deposits = deposits \u222a\u207a \u2774 PoolDeposit kh , pp .PParams.poolDeposit \u2775\nupdateCertDeposit _ (retirepool _ _)    deposits = deposits\nupdateCertDeposit _ (ccreghot _ _)      deposits = deposits\n-- updateCertDeposit pp cert deposits\n--   = (deposits \u222a\u207a certDeposit cert pp) \u2223 certRefund cert \u1d9c\n\nprivate variable\n  rwds rewards           : Rewards\n  dReps                  : Credential \u21c0 Epoch\n  sDelegs stakeDelegs    : Credential \u21c0 KeyHash\n  ccKeys ccHotKeys       : Credential \u21c0 Maybe Credential\n  vDelegs voteDelegs     : VoteDelegs\n  pools                  : Pools\n  retiring               : KeyHash \u21c0 Epoch\n  wdrls                  : Withdrawals\n\n  an             : Anchor\n  \u0393              : CertEnv\n  d              : Coin\n  md             : Maybe Coin\n  c              : Credential\n  mc             : Maybe Credential\n  delegatees cc  : \u2119 Credential\n  dCert          : DCert\n  dep ddep gdep  : Deposits\n  e              : Epoch\n  vs             : List GovVote\n  kh             : KeyHash\n  mkh            : Maybe KeyHash\n  poolParams     : StakePoolParams\n  pp             : PParams\n  mv             : Maybe VDeleg\n\n  st\u1d48 st\u1d48' : DState\n  st\u1d4d st\u1d4d' : GState\n  st\u1d56 st\u1d56' : PState\n\nopen GovVote\n\ndata _\u22a2_\u21c0\u2987_,POOL\u2988_  : PoolEnv \u2192 PState \u2192 DCert \u2192 PState \u2192 Type\ndata _\u22a2_\u21c0\u2987_,DELEG\u2988_ : DelegEnv \u2192 DState \u2192 DCert \u2192 DState \u2192 Type\n\ndata _\u22a2_\u21c0\u2987_,POOL\u2988_ where\n  POOL-regpool :\n    \u2219 kh \u2209 dom pools\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      pp \u22a2  \u27e6 pools , retiring \u27e7 \u21c0\u2987 regpool kh poolParams ,POOL\u2988\n            \u27e6 \u2774 kh , poolParams \u2775 \u222a\u02e1 pools , retiring \u27e7\n\n  POOL-retirepool :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    pp \u22a2 \u27e6 pools , retiring \u27e7 \u21c0\u2987 retirepool kh e ,POOL\u2988 \u27e6 pools , \u2774 kh , e \u2775 \u222a\u02e1 retiring \u27e7\n\ndata _\u22a2_\u21c0\u2987_,DELEG\u2988_ where\n  DELEG-delegate : let open PParams pp in\n    \u2219 (c \u2209 dom rwds \u2192 d \u2261 keyDeposit)\n    \u2219 (c \u2208 dom rwds \u2192 d \u2261 0)\n    \u2219 mv \u2208 map\u02e2 (just \u2218 vDelegCredential) delegatees \u222a\n        fromList\n          ( nothing\n          \u2237 just vDelegAbstain\n          \u2237 just vDelegNoConfidence\n          \u2237 []\n          )\n    \u2219 mkh \u2208 map\u02e2 just (dom pools) \u222a \u2774 nothing \u2775\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 pp , pools , delegatees \u27e7 \u22a2\n      \u27e6 vDelegs , sDelegs , rwds , dep \u27e7\n      \u21c0\u2987 delegate c mv mkh d ,DELEG\u2988\n      \u27e6 insertIfJust c mv vDelegs , insertIfJust c mkh sDelegs , rwds \u222a\u02e1 \u2774 c , 0 \u2775\n      , updateCertDeposit pp (delegate c mv mkh d) dep \u27e7\n\n  DELEG-dereg :\n    \u2219 (c , 0) \u2208 rwds\n    \u2219 (CredentialDeposit c , d) \u2208 dep\n    \u2219 md \u2261 nothing \u228e md \u2261 just d\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 pp , pools , delegatees \u27e7 \u22a2\n      \u27e6 vDelegs , sDelegs , rwds , dep \u27e7\n      \u21c0\u2987 dereg c md ,DELEG\u2988\n      \u27e6 vDelegs \u2223 \u2774 c \u2775 \u1d9c , sDelegs \u2223 \u2774 c \u2775 \u1d9c , rwds \u2223 \u2774 c \u2775 \u1d9c\n      , updateCertDeposit pp (dereg c md) dep \u27e7\n\n  DELEG-reg : let open PParams pp in\n    \u2219 c \u2209 dom rwds\n    \u2219 d \u2261 keyDeposit \u228e d \u2261 0\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 pp , pools , delegatees \u27e7 \u22a2\n        \u27e6 vDelegs , sDelegs , rwds , dep \u27e7 \u21c0\u2987 reg c d ,DELEG\u2988\n        \u27e6 vDelegs , sDelegs , rwds \u222a\u02e1 \u2774 c , 0 \u2775\n        , updateCertDeposit pp (reg c d) dep \u27e7\n\ndata _\u22a2_\u21c0\u2987_,GOVCERT\u2988_ : CertEnv \u2192 GState \u2192 DCert \u2192 GState \u2192 Type where\n  GOVCERT-regdrep : \u2200 {pp} \u2192 let open PParams pp in\n    \u2219 (d \u2261 drepDeposit \u00d7 c \u2209 dom dReps) \u228e (d \u2261 0 \u00d7 c \u2208 dom dReps)\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2\n      \u27e6 dReps , ccKeys , dep \u27e7\n        \u21c0\u2987 regdrep c d an ,GOVCERT\u2988\n      \u27e6 \u2774 c , e + drepActivity \u2775 \u222a\u02e1 dReps , ccKeys\n      , updateCertDeposit pp (regdrep c d an ) dep \u27e7\n\n  GOVCERT-deregdrep :\n    \u2219 c \u2208 dom dReps\n    \u2219 (DRepDeposit c , d) \u2208 dep\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 dReps , ccKeys , dep \u27e7\n          \u21c0\u2987 deregdrep c d ,GOVCERT\u2988\n          \u27e6 dReps \u2223 \u2774 c \u2775 \u1d9c , ccKeys , updateCertDeposit pp (deregdrep c d) dep \u27e7\n\n  GOVCERT-ccreghot :\n    \u2219 (c , nothing) \u2209 ccKeys\n    \u2219 c \u2208 cc\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 dReps , ccKeys , dep \u27e7\n          \u21c0\u2987 ccreghot c mc ,GOVCERT\u2988\n          \u27e6 dReps , \u2774 c , mc \u2775 \u222a\u02e1 ccKeys , updateCertDeposit pp (ccreghot c mc) dep \u27e7\n\ndata _\u22a2_\u21c0\u2987_,CERT\u2988_ : CertEnv \u2192 CertState \u2192 DCert \u2192 CertState \u2192 Type where\n  CERT-deleg :\n    \u2219 \u27e6 pp , PState.pools st\u1d56 , dom (GState.dreps st\u1d4d) \u27e7 \u22a2 st\u1d48 \u21c0\u2987 dCert ,DELEG\u2988 st\u1d48'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 st\u1d48 , st\u1d56 , st\u1d4d \u27e7 \u21c0\u2987 dCert ,CERT\u2988 \u27e6 st\u1d48' , st\u1d56 , st\u1d4d \u27e7\n\n  CERT-pool :\n    \u2219 pp \u22a2 st\u1d56 \u21c0\u2987 dCert ,POOL\u2988 st\u1d56'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 st\u1d48 , st\u1d56 , st\u1d4d \u27e7 \u21c0\u2987 dCert ,CERT\u2988 \u27e6 st\u1d48 , st\u1d56' , st\u1d4d \u27e7\n\n  CERT-vdel :\n    \u2219 \u0393 \u22a2 st\u1d4d \u21c0\u2987 dCert ,GOVCERT\u2988 st\u1d4d'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 \u27e6 st\u1d48 , st\u1d56 , st\u1d4d \u27e7 \u21c0\u2987 dCert ,CERT\u2988 \u27e6 st\u1d48 , st\u1d56 , st\u1d4d' \u27e7\n\ndata _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ : CertEnv \u2192 CertState \u2192 \u22a4 \u2192 CertState \u2192 Type where\n\n  CERT-pre :\n    let open PParams pp\n        refresh         = mapPartial (isGovVoterDRep \u2218 voter) (fromList vs)\n        refreshedDReps  = mapValueRestricted (const (e + drepActivity)) dReps refresh\n        wdrlCreds       = map\u02e2 stake (dom wdrls)\n    in\n    \u2219 filter\u02e2 isKeyHash wdrlCreds \u2286 dom voteDelegs\n    \u2219 map\u02e2 (map\u2081 stake) (wdrls \u02e2) \u2286 rewards \u02e2\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 \u27e6 voteDelegs , stakeDelegs , rewards , ddep \u27e7 , st\u1d56 , \u27e6 dReps , ccHotKeys , gdep \u27e7 \u27e7\n      \u21c0\u2987 _ ,PRE-CERT\u2988\n      \u27e6 \u27e6 voteDelegs , stakeDelegs , constMap wdrlCreds 0 \u222a\u02e1 rewards , ddep \u27e7 , st\u1d56 , \u27e6 refreshedDReps , ccHotKeys , gdep \u27e7 \u27e7\n\ndata _\u22a2_\u21c0\u2987_,POST-CERT\u2988_ : CertEnv \u2192 CertState \u2192 \u22a4 \u2192 CertState \u2192 Type where\n\n  CERT-post :\n      \u27e6 e , pp , vs , wdrls , cc \u27e7\n      \u22a2 \u27e6 \u27e6 voteDelegs , stakeDelegs , rewards , ddep \u27e7 , st\u1d56 , st\u1d4d \u27e7\n        \u21c0\u2987 _ ,POST-CERT\u2988\n        \u27e6 \u27e6 voteDelegs \u2223^ (map\u02e2 vDelegCredential (dom (GState.dreps st\u1d4d)) \u222a fromList (vDelegNoConfidence \u2237 vDelegAbstain \u2237 []))\n          , stakeDelegs , rewards , ddep \u27e7 , st\u1d56 , st\u1d4d \u27e7\n\n_\u22a2_\u21c0\u2987_,CERTS\u2988_  : CertEnv \u2192 CertState  \u2192 List DCert  \u2192 CertState  \u2192 Type\n_\u22a2_\u21c0\u2987_,CERTS\u2988_ = RunTraceAfterAndThen _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ _\u22a2_\u21c0\u2987_,CERT\u2988_ _\u22a2_\u21c0\u2987_,POST-CERT\u2988_\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Chain.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Conformance.Chain.Properties\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Conformance.Chain txs abs\nopen import Ledger.Conway.Conformance.Epoch txs abs\nopen import Ledger.Conway.Conformance.Epoch.Properties txs abs\nopen import Ledger.Conway.Conformance.Ledger.Properties txs abs\n\nopen Computational \u2983...\u2984\n\nmodule _ {nes : NewEpochState} {e : Epoch} where\n\ninstance\n  Computational-CHAIN : Computational _\u22a2_\u21c0\u2987_,CHAIN\u2988_ String\n  Computational-CHAIN .computeProof \u0393 s b = do\n    _ , neStep \u2190 map\u2081 \u22a5-elim $ computeProof {STS = _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_} _ _ _\n    _ , lsStep \u2190 computeProof _ _ _\n    success (_ , CHAIN neStep lsStep)\n  Computational-CHAIN .completeness \u0393 s b s' (CHAIN neStep lsStep)\n    with recomputeProof neStep | completeness _ _ _ _ neStep\n  ... | _         | refl\n    with recomputeProof lsStep | completeness _ _ _ _ lsStep\n  ... | success _ | refl = refl\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Chain.html","title":"Chain","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Algebra\nopen import Data.Nat.Properties using (+-0-monoid)\n\nopen import Ledger.Prelude; open Equivalence\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Conformance.Chain\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Epoch txs abs\nopen import Ledger.Conway.Conformance.Certs govStructure\n\nrecord ChainState : Type where\n\n  field\n\n    newEpochState  : NewEpochState\n\nrecord Block : Type where\n\n  field\n\n    ts    : List Tx\n    slot  : Slot\n\nprivate variable\n  s : ChainState\n  b : Block\n  ls' : LState\n  nes : NewEpochState\n\ninstance _ = +-0-monoid\n\n-- TODO: do we still need this for anything?\nmaybePurpose : DepositPurpose \u2192 (DepositPurpose \u00d7 Credential) \u2192 Coin \u2192 Maybe Coin\nmaybePurpose prps (prps' , _) c with prps \u225f prps'\n... | yes _ = just c\n... | no _ = nothing\n\nmaybePurpose-prop : \u2200 {prps} {x} {y}\n  \u2192 (m : (DepositPurpose \u00d7 Credential) \u21c0 Coin)\n  \u2192 (x , y) \u2208 dom ((mapMaybeWithKey\u1d50 (maybePurpose prps) m) \u02e2)\n  \u2192 x \u2261 prps\nmaybePurpose-prop {prps = prps} {x} {y} _ xy\u2208dom with from dom\u2208 xy\u2208dom\n... | z , \u2208mmwk with prps \u225f x | \u2208-mapMaybeWithKey {f = maybePurpose prps} \u2208mmwk\n... | yes refl | _ = refl\n\nfilterPurpose : DepositPurpose \u2192 (DepositPurpose \u00d7 Credential) \u21c0 Coin \u2192 Credential \u21c0 Coin\nfilterPurpose prps m = mapKeys proj\u2082 (mapMaybeWithKey\u1d50 (maybePurpose prps) m)\n  {\u03bb where x\u2208dom y\u2208dom refl \u2192 cong (_, _)\n                            $ trans (maybePurpose-prop {prps = prps} m x\u2208dom)\n                            $ sym   (maybePurpose-prop {prps = prps} m y\u2208dom)}\n\ngovActionDeposits : LState \u2192 VDeleg \u21c0 Coin\ngovActionDeposits ls =\n  let open LState ls; open CertState certState; open PState pState\n      open UTxOState utxoSt; open DState dState\n   in foldl _\u222a\u207a_ \u2205 $ setToList $\n    mapPartial\n      (\u03bb where (gaid , record { returnAddr = record {stake = c} }) \u2192 do\n        vd \u2190 lookup\u1d50? voteDelegs c\n        dep \u2190 lookup\u1d50? (DState.deposits dState) (GovActionDeposit gaid)\n        just \u2774 vd , dep \u2775 )\n      (fromList govSt)\n\ndata\n\n  _\u22a2_\u21c0\u2987_,CHAIN\u2988_ : \u22a4 \u2192 ChainState \u2192 Block \u2192 ChainState \u2192 Type\n\n  where\n\n  CHAIN :\n    let open ChainState s; open Block b; open NewEpochState nes\n        open EpochState epochState; open EnactState es\n    in\n       _ \u22a2 newEpochState \u21c0\u2987 epoch slot ,NEWEPOCH\u2988 nes\n    \u2192  \u27e6 slot , \u2223 constitution \u2223 , \u2223 pparams \u2223 , es , Acnt.treasury acnt\n       \u27e7 \u22a2 ls \u21c0\u2987 ts ,LEDGERS\u2988 ls'\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    _ \u22a2 s \u21c0\u2987 b ,CHAIN\u2988\n        record s { newEpochState = record nes { epochState = record epochState { ls = ls'} } }\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Epoch.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nopen import Agda.Builtin.FromNat\n\nmodule Ledger.Conway.Conformance.Epoch.Properties\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Conformance.Epoch txs abs\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Specification.Ratify.Properties.Computational txs\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Ledger.Conway.Conformance.Rewards txs abs\n\nopen import Data.List using (filter)\nimport Relation.Binary.PropositionalEquality as PE\n\nopen Computational \u2983...\u2984\n\nmodule _ {lstate : LState} {ss : Snapshots} where\n  SNAP-total : \u2203[ ss' ] lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n  SNAP-total = -, SNAP\n\n  SNAP-complete : \u2200 ss' \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss' \u2192 proj\u2081 SNAP-total \u2261 ss'\n  SNAP-complete ss' SNAP = refl\n\n  SNAP-deterministic : \u2200 {ss' ss''}\n                     \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n                     \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'' \u2192 ss' \u2261 ss''\n  SNAP-deterministic SNAP SNAP = refl\n\n\nmodule _ {eps : EpochState} {e : Epoch} where\n\n  open EpochState eps hiding (es)\n  open RatifyState fut using (removed) renaming (es to esW)\n  open LState ls; open CertState certState; open Acnt acnt\n  es         = record esW { withdrawals = \u2205 }\n  govSt'     = filter (\u03bb x \u2192 \u00bf \u00ac proj\u2081 x \u2208 map\u02e2 proj\u2081 removed \u00bf) govSt\n\n  EPOCH-total : \u2203[ eps' ] _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n  EPOCH-total = -, EPOCH (RATIFIES-total' .proj\u2082) (SNAP-total .proj\u2082)\n\n  EPOCH-deterministic : \u2200 eps' eps''\n                      \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n                      \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps''\n                      \u2192 eps' \u2261 eps''\n  EPOCH-deterministic eps' eps'' (EPOCH p\u2081 p\u2082) (EPOCH p\u2081' p\u2082') =\n    cong\u2082 (\u03bb ss fut \u2192 record { acnt = _ ; ss = ss ; ls = _ ; es = _ ; fut = fut })\n          ss'\u2261ss''\n          fut'\u2261fut''\n    where\n      ss'\u2261ss'' : EpochState.ss eps' \u2261 EpochState.ss eps''\n      ss'\u2261ss'' = SNAP-deterministic p\u2082 p\u2082'\n\n      fut'\u2261fut'' : EpochState.fut eps' \u2261 EpochState.fut eps''\n      fut'\u2261fut'' = RATIFIES-deterministic-\u2261\n                    (cong (\u03bb x \u2192 record\n                                   { stakeDistrs = _\n                                   ; currentEpoch = _\n                                   ; dreps = _\n                                   ; ccHotKeys = _\n                                   ; treasury = _\n                                   }) ss'\u2261ss'')\n                                   refl refl p\u2081 p\u2081'\n\n\n  EPOCH-complete : \u2200 eps' \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps' \u2192 proj\u2081 EPOCH-total \u2261 eps'\n  EPOCH-complete eps' p = EPOCH-deterministic (proj\u2081 EPOCH-total) eps' (proj\u2082 EPOCH-total) p\n\n  abstract\n    EPOCH-total' : \u2203[ eps' ] _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n    EPOCH-total' = EPOCH-total\n\n    EPOCH-complete' : \u2200 eps' \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps' \u2192 proj\u2081 EPOCH-total' \u2261 eps'\n    EPOCH-complete' = EPOCH-complete\n\ninstance\n  Computational-EPOCH : Computational _\u22a2_\u21c0\u2987_,EPOCH\u2988_ \u22a5\n  Computational-EPOCH .computeProof \u0393 s sig = success EPOCH-total'\n  Computational-EPOCH .completeness \u0393 s sig s' h = cong success (EPOCH-complete' s' h)\n\nmodule _ {e : Epoch} where\n\n  NEWEPOCH-total : \u2200 nes'' \u2192 \u2203[ nes' ] _ \u22a2 nes'' \u21c0\u2987 e ,NEWEPOCH\u2988 nes'\n  NEWEPOCH-total nes with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | inspect NewEpochState.ru nes\n  ... | yes p | just ru | PE.[ refl ] =  \u27e6 e , EPOCH-total' .proj\u2081 , nothing \u27e7\n                                      , NEWEPOCH-New (p , EPOCH-total' .proj\u2082)\n  ... | yes p | nothing | PE.[ refl ] = \u27e6 e , proj\u2081 EPOCH-total' , nothing \u27e7\n                                      , NEWEPOCH-No-Reward-Update (p , EPOCH-total' .proj\u2082)\n  ... | no \u00acp | _ | _ = -, NEWEPOCH-Not-New \u00acp\n\n  NEWEPOCH-complete : \u2200 nes nes' \u2192 _ \u22a2 nes \u21c0\u2987 e ,NEWEPOCH\u2988 nes' \u2192 proj\u2081 (NEWEPOCH-total nes) \u2261 nes'\n  -- NEWEPOCH-complete nes nes' h with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | h\n  NEWEPOCH-complete nes nes' h with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | inspect NewEpochState.ru nes | h \n  ... | yes p | just ru | PE.[ refl ] | NEWEPOCH-New (x , x\u2081) rewrite EPOCH-complete' _ x\u2081 = refl\n  ... | yes p | ru | PE.[ refl ] | NEWEPOCH-Not-New x = \u22a5-elim $ x p\n  ... | yes p | nothing | PE.[ refl ] | NEWEPOCH-No-Reward-Update (x , x\u2081) rewrite EPOCH-complete' _ x\u2081 = refl\n  ... | no \u00acp | ru | PE.[ refl ] | NEWEPOCH-New (x , x\u2081)  = \u22a5-elim $ \u00acp x\n  ... | no \u00acp | ru | PE.[ refl ] | NEWEPOCH-Not-New x = refl\n  ... | no \u00acp | nothing | PE.[ refl ] | NEWEPOCH-No-Reward-Update (x , x\u2081) = \u22a5-elim $ \u00acp x\n\ninstance\n  Computational-NEWEPOCH : Computational _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_ \u22a5\n  Computational-NEWEPOCH .computeProof \u0393 s sig = success (NEWEPOCH-total _)\n  Computational-NEWEPOCH .completeness \u0393 s sig s' h = cong success (NEWEPOCH-complete _ s' h)\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Epoch.html","title":"Epoch","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Epoch\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Prelude\nopen import Data.Integer using () renaming (+_ to pos)\nimport Data.Integer as \u2124\n\nopen import Data.Nat.Properties using (+-0-monoid; +-0-commutativeMonoid)\nopen import Data.List using (filter)\n\nopen import Agda.Builtin.FromNat\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Ledger.Conway.Conformance.Rewards txs abs\nopen import Ledger.Conway.Specification.Epoch txs abs\n  using (getStakeCred; getOrphans; mkStakeDistrs; toRwdAddr) public\n\nrecord EpochState : Type where\n  constructor \u27e6_,_,_,_,_\u27e7\u1d49'\n  field\n    acnt       : Acnt\n    ss         : Snapshots\n    ls         : LState\n    es         : EnactState\n    fut        : RatifyState\n\nrecord NewEpochState : Type where\n  field\n    lastEpoch   : Epoch\n    epochState  : EpochState\n    ru          : Maybe RewardUpdate\n\ninstance\n  unquoteDecl HasCast-EpochState HasCast-NewEpochState = derive-HasCast\n    ( (quote EpochState     , HasCast-EpochState)\n    \u2237 [ (quote NewEpochState  , HasCast-NewEpochState)])\n\napplyRUpd : RewardUpdate \u2192 EpochState \u2192 EpochState\napplyRUpd rewardUpdate\n  \u27e6 \u27e6 treasury , reserves \u27e7\u1d43\n  , ss\n  , \u27e6 \u27e6 utxo , fees , deposits , donations \u27e7\u1d58\n    , govSt\n    , \u27e6 \u27e6 voteDelegs , stakeDelegs , rewards , deposits' \u27e7\u1d48 , pState , gState \u27e7\u1d9c\u02e2 \u27e7\u02e1\n  , es\n  , fut\n  \u27e7\u1d49' =\n  \u27e6 \u27e6 posPart (pos treasury + \u0394t + pos unregRU')\n    , posPart (pos reserves + \u0394r) \u27e7\n  , ss\n  , \u27e6 \u27e6 utxo , posPart (pos fees + \u0394f) , deposits , donations \u27e7\n    , govSt\n    , \u27e6 \u27e6 voteDelegs , stakeDelegs , rewards \u222a\u207a regRU , deposits' \u27e7 , pState , gState \u27e7 \u27e7\n  , es\n  , fut \u27e7\n  where\n    open RewardUpdate rewardUpdate using (\u0394t; \u0394r; \u0394f; rs)\n    regRU     = rs \u2223 dom rewards\n    unregRU   = rs \u2223 dom rewards \u1d9c\n    unregRU'  = \u2211[ x \u2190 unregRU ] x\n\nprivate variable\n  nes nes' : NewEpochState\n  e lastEpoch : Epoch\n  fut fut' : RatifyState\n  eps eps' eps'' : EpochState\n  ls : LState\n  acnt : Acnt\n  es\u2080 : EnactState\n  mark set go : Snapshot\n  feeSS : Coin\n  lstate : LState\n  ss ss' : Snapshots\n  ru : RewardUpdate\n  mru : Maybe RewardUpdate\n  certState' : CertState\n\ndata _\u22a2_\u21c0\u2987_,EPOCH\u2988_ : \u22a4 \u2192 EpochState \u2192 Epoch \u2192 EpochState \u2192 Type where\n\n  EPOCH : let\n      open LState ls\n      open CertState certState\n      open RatifyState fut renaming (es to esW)\n      open UTxOState\n      open PState; open DState; open GState\n      open Acnt; open EnactState; open GovActionState\n\n      es : EnactState\n      es = record esW { withdrawals = \u2205 }\n\n      tmpGovSt = filter (\u03bb x \u2192 \u00bf proj\u2081 x \u2209 map\u02e2 proj\u2081 removed \u00bf) govSt\n\n      orphans : \u2119 (GovActionID \u00d7 GovActionState)\n      orphans  = fromList (getOrphans es tmpGovSt)\n\n      removed' : \u2119 (GovActionID \u00d7 GovActionState)\n      removed' = removed \u222a orphans\n\n      govSt' = filter (\u03bb x \u2192 \u00bf proj\u2081 x \u2209 map\u02e2 proj\u2081 removed' \u00bf) govSt\n\n      removedGovActions : \u2119 (RwdAddr \u00d7 DepositPurpose \u00d7 Coin)\n      removedGovActions =\n        flip concatMap\u02e2 removed' \u03bb (gaid , gaSt) \u2192\n          map\u02e2\n            (returnAddr gaSt ,_)\n            ((utxoSt .deposits \u2223 \u2774 GovActionDeposit gaid \u2775) \u02e2)\n\n      govActionReturns : RwdAddr \u21c0 Coin\n      govActionReturns =\n        aggregate\u208a (map\u02e2 (\u03bb (a , _ , d) \u2192 a , d) removedGovActions \u1da0\u02e2)\n\n      trWithdrawals   = esW .withdrawals\n      totWithdrawals  = \u2211[ x \u2190 trWithdrawals ] x\n\n      retired    = (pState .retiring) \u207b\u00b9 e\n      payout     = govActionReturns \u222a\u207a trWithdrawals\n      refunds    = pullbackMap payout toRwdAddr (dom (dState .rewards))\n      unclaimed  = getCoin payout - getCoin refunds\n      vDeposits  = gState .deposits\n\n      dState' : DState\n      dState' = record dState { rewards = dState .rewards \u222a\u207a refunds }\n\n      pState' : PState\n      pState' = \u27e6 (pState .pools) \u2223 retired \u1d9c , (pState .retiring) \u2223 retired \u1d9c \u27e7\n\n      gState' : GState\n      gState' = \u27e6 (if null govSt' then mapValues (1 +_) (gState .dreps) else (gState .dreps))\n                , (gState .ccHotKeys) \u2223 ccCreds (es .cc)\n                , vDeposits\n                \u27e7\n\n      certState' : CertState\n      certState' = record { dState = dState' ; pState = pState' ; gState = gState' }\n\n      utxoSt' = \u27e6 utxoSt .utxo , utxoSt .fees , utxoSt .deposits \u2223 map\u02e2 (proj\u2081 \u2218 proj\u2082) removedGovActions \u1d9c , 0 \u27e7\n\n      acnt' = record acnt\n        { treasury  = acnt .treasury \u2238 totWithdrawals + utxoSt .donations + unclaimed }\n\n      stakeDistrs : StakeDistrs\n      stakeDistrs = mkStakeDistrs (Snapshots.mark ss') e utxoSt' govSt' (record { GState (CertState.gState (LState.certState ls)) })\n                                                                        (record { DState (CertState.dState (LState.certState ls)) })\n\n    in\n    record { currentEpoch = e\n           ; stakeDistrs = stakeDistrs\n           ; treasury = acnt .treasury ; GState gState\n           ; pools = pState .pools ; delegatees = dState .voteDelegs }\n        \u22a2 \u27e6 es , \u2205 , false \u27e7 \u21c0\u2987 govSt' ,RATIFIES\u2988 fut'\n      \u2192 ls \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    _ \u22a2 \u27e6 acnt , ss , ls , es\u2080 , fut \u27e7 \u21c0\u2987 e ,EPOCH\u2988\n        \u27e6 acnt' , ss' , \u27e6 utxoSt' , govSt' , certState' \u27e7 , es , fut' \u27e7\n\ndata _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_ : \u22a4 \u2192 NewEpochState \u2192 Epoch \u2192 NewEpochState \u2192 Type where\n\n  NEWEPOCH-New : let\n      eps' = applyRUpd ru eps\n    in\n    \u2219 e \u2261 lastEpoch + 1\n    \u2219 _ \u22a2 eps' \u21c0\u2987 e ,EPOCH\u2988 eps''\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 \u27e6 lastEpoch , eps , just ru \u27e7 \u21c0\u2987 e ,NEWEPOCH\u2988 \u27e6 e , eps'' , nothing \u27e7\n\n  NEWEPOCH-Not-New :\n    \u2219 e \u2262 lastEpoch + 1\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 \u27e6 lastEpoch , eps , mru \u27e7 \u21c0\u2987 e ,NEWEPOCH\u2988 \u27e6 lastEpoch , eps , mru \u27e7\n\n  NEWEPOCH-No-Reward-Update :\n    \u2219 e \u2261 lastEpoch + 1\n    \u2219 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 \u27e6 lastEpoch , eps , nothing \u27e7 \u21c0\u2987 e ,NEWEPOCH\u2988 \u27e6 e , eps' , nothing \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Bisimilarity.html","title":"Bisimilarity","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Conformance.Equivalence.Bisimilarity where\n\nopen import Data.Product.Base\n\nrecord Bisimilar {C Sig S\u2081 S\u2082 : Set} (_\u22a2_\u21c0\u2987_\u2988\u2081_ : C \u2192 S\u2081 \u2192 Sig \u2192 S\u2081 \u2192 Set) (_\u22a2_\u21c0\u2987_\u2988\u2082_ : C \u2192 S\u2082 \u2192 Sig \u2192 S\u2082 \u2192 Set) : Set\u2081 where\n  field\n    _\u2248_  : S\u2081 \u2192 S\u2082 \u2192 Set\n    to   : \u2200 {\u0393 sig s\u2081 s\u2081' s\u2082}\n         \u2192 s\u2081 \u2248 s\u2082\n         \u2192 \u0393 \u22a2 s\u2081 \u21c0\u2987 sig \u2988\u2081 s\u2081'\n         \u2192 \u2203[ s\u2082' ] s\u2081' \u2248 s\u2082' \u00d7 \u0393 \u22a2 s\u2082 \u21c0\u2987 sig \u2988\u2082 s\u2082'\n    from : \u2200 {\u0393 sig s\u2081 s\u2082 s\u2082'}\n         \u2192 s\u2081 \u2248 s\u2082\n         \u2192 \u0393 \u22a2 s\u2082 \u21c0\u2987 sig \u2988\u2082 s\u2082'\n         \u2192 \u2203[ s\u2081' ] s\u2081' \u2248 s\u2082' \u00d7 \u0393 \u22a2 s\u2081 \u21c0\u2987 sig \u2988\u2081 s\u2081'\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Certs.html","title":"Certs","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Data.Product using (_\u00d7_; _,_)\nopen import Relation.Binary.PropositionalEquality\n\nopen import Ledger.Conway.Conformance.Equivalence.Convert\n\nmodule Ledger.Conway.Conformance.Equivalence.Certs\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Certs govStructure public\n\n  module C where\n    open import Ledger.Conway.Conformance.Certs govStructure public\n\ninstance\n\n  DStateToConf : L.Deposits \u22a2 L.DState \u2b46 C.DState\n  DStateToConf .conv\u2071 deposits st\u1d48 =\n    let open L.DState st\u1d48 in\n    \u27e6 voteDelegs , stakeDelegs , rewards , deposits \u27e7\n\n  DStateFromConf : C.DState \u2b46 L.DState\n  DStateFromConf .conv\u2071 _ dState =\n    let open C.DState dState in\n    \u27e6 voteDelegs , stakeDelegs , rewards \u27e7\n\n  GStateToConf : L.Deposits \u22a2 L.GState \u2b46 C.GState\n  GStateToConf .conv\u2071 deposits st\u1d4d =\n    let open L.GState st\u1d4d in\n    \u27e6 dreps , ccHotKeys , deposits \u27e7\n\n  GStateFromConf : C.GState \u2b46 L.GState\n  GStateFromConf .conv\u2071 deposits gState =\n    let open C.GState gState in\n    \u27e6 dreps , ccHotKeys \u27e7\n\ndata ValidDeps\u1d48 (pp : PParams) (deps : L.Deposits) : List L.DCert \u2192 Set where\n  []         : ValidDeps\u1d48 pp deps []\n  delegate   : \u2200 {c del kh v certs}\n             \u2192 ValidDeps\u1d48 pp (C.updateCertDeposit pp (L.delegate c del kh v) deps) certs\n             \u2192 ValidDeps\u1d48 pp deps (L.delegate c del kh v \u2237 certs)\n  dereg      : \u2200 {c md d certs}\n             \u2192 (L.CredentialDeposit c , d) \u2208 deps\n             \u2192 md \u2261 nothing \u228e md \u2261 just d\n             \u2192 ValidDeps\u1d48 pp (C.updateCertDeposit pp (L.dereg c md) deps) certs\n             \u2192 ValidDeps\u1d48 pp deps (L.dereg c md \u2237 certs)\n  regdrep    : \u2200 {c v a certs}\n             \u2192 ValidDeps\u1d48 pp deps certs\n             \u2192 ValidDeps\u1d48 pp deps (L.regdrep c v a \u2237 certs)\n  deregdrep  : \u2200 {c d certs}\n             \u2192 ValidDeps\u1d48 pp deps certs\n             \u2192 ValidDeps\u1d48 pp deps (L.deregdrep c d \u2237 certs)\n  regpool    : \u2200 {kh p certs}\n             \u2192 ValidDeps\u1d48 pp deps certs\n             \u2192 ValidDeps\u1d48 pp deps (L.regpool kh p \u2237 certs)\n  retirepool : \u2200 {kh e certs}\n             \u2192 ValidDeps\u1d48 pp deps certs\n             \u2192 ValidDeps\u1d48 pp deps (L.retirepool kh e  \u2237 certs)\n  ccreghot   : \u2200 {c v certs}\n             \u2192 ValidDeps\u1d48 pp deps certs\n             \u2192 ValidDeps\u1d48 pp deps (L.ccreghot c v \u2237 certs)\n  reg        : \u2200 {c d certs}\n             \u2192 ValidDeps\u1d48 pp (C.updateCertDeposit pp (L.reg c d) deps) certs\n             \u2192 ValidDeps\u1d48 pp deps (L.reg c d \u2237 certs)\n\ndata ValidDeps\u1d4d (pp : PParams) (deps : L.Deposits) : List L.DCert \u2192 Set where\n  []         : ValidDeps\u1d4d pp deps []\n  regdrep    : \u2200 {c v a certs}\n             \u2192 ValidDeps\u1d4d pp (C.updateCertDeposit pp (L.regdrep c v a) deps) certs\n             \u2192 ValidDeps\u1d4d pp deps (L.regdrep c v a \u2237 certs)\n  deregdrep  : \u2200 {c d certs}\n             \u2192 (L.DRepDeposit c , d) \u2208 deps\n             \u2192 ValidDeps\u1d4d pp (C.updateCertDeposit pp (L.deregdrep c d) deps) certs\n             \u2192 ValidDeps\u1d4d pp deps (L.deregdrep c d \u2237 certs)\n  delegate   : \u2200 {c del kh v certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.delegate c del kh v \u2237 certs)\n  dereg      : \u2200 {c d certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.dereg c d \u2237 certs)\n  regpool    : \u2200 {kh p certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.regpool kh p \u2237 certs)\n  retirepool : \u2200 {kh e certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.retirepool kh e  \u2237 certs)\n  ccreghot   : \u2200 {c v certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.ccreghot c v \u2237 certs)\n  reg        : \u2200 {c d certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.reg c d \u2237 certs)\n\nrecord CertDeps* (pp : PParams) (dcerts : List L.DCert) : Set where\n  constructor \u27e6_,_,_,_\u27e7*\n  field\n    deps\u1d48 : L.Deposits\n    deps\u1d4d : L.Deposits\n    -- Invariants\n    valid\u1d48 : ValidDeps\u1d48 pp deps\u1d48 dcerts\n    valid\u1d4d : ValidDeps\u1d4d pp deps\u1d4d dcerts\n\npattern delegate*    ddeps gdeps = \u27e6 _ , _ , delegate   ddeps , delegate    gdeps \u27e7*\npattern dereg*  v w  ddeps gdeps = \u27e6 _ , _ , dereg v w  ddeps , dereg       gdeps \u27e7*\npattern regpool*     ddeps gdeps = \u27e6 _ , _ , regpool    ddeps , regpool     gdeps \u27e7*\npattern retirepool*  ddeps gdeps = \u27e6 _ , _ , retirepool ddeps , retirepool  gdeps \u27e7*\npattern regdrep*     ddeps gdeps = \u27e6 _ , _ , regdrep    ddeps , regdrep     gdeps \u27e7*\npattern deregdrep* v ddeps gdeps = \u27e6 _ , _ , deregdrep  ddeps , deregdrep v gdeps \u27e7*\npattern ccreghot*    ddeps gdeps = \u27e6 _ , _ , ccreghot   ddeps , ccreghot    gdeps \u27e7*\npattern reg*         ddeps gdeps = \u27e6 _ , _ , reg        ddeps , reg         gdeps \u27e7*\n\nopen CertDeps*\n\ngetCertDeps* : \u2200 {pp dcert} \u2192 CertDeps* pp dcert \u2192 L.Deposits \u00d7 L.Deposits\ngetCertDeps* deps = deps .deps\u1d48 , deps .deps\u1d4d\n\nupdateCertDeps : \u2200 {pp dcert dcerts} \u2192 CertDeps* pp (dcert \u2237 dcerts) \u2192 CertDeps* pp dcerts\nupdateCertDeps (delegate*    ddeps gdeps) = \u27e6 _ , _ , ddeps , gdeps \u27e7*\nupdateCertDeps (dereg* _ _   ddeps gdeps) = \u27e6 _ , _ , ddeps , gdeps \u27e7*\nupdateCertDeps (regpool*     ddeps gdeps) = \u27e6 _ , _ , ddeps , gdeps \u27e7*\nupdateCertDeps (retirepool*  ddeps gdeps) = \u27e6 _ , _ , ddeps , gdeps \u27e7*\nupdateCertDeps (regdrep*     ddeps gdeps) = \u27e6 _ , _ , ddeps , gdeps \u27e7*\nupdateCertDeps (deregdrep* _ ddeps gdeps) = \u27e6 _ , _ , ddeps , gdeps \u27e7*\nupdateCertDeps (ccreghot*    ddeps gdeps) = \u27e6 _ , _ , ddeps , gdeps \u27e7*\nupdateCertDeps (reg*         ddeps gdeps) = \u27e6 _ , _ , ddeps , gdeps \u27e7*\n\nupdateCertDeps* : \u2200 {pp} dcerts \u2192 CertDeps* pp dcerts \u2192 CertDeps* pp []\nupdateCertDeps* []               deps = deps\nupdateCertDeps* (dcert \u2237 dcerts) deps = updateCertDeps* dcerts (updateCertDeps deps)\n\ninstance\n\n  CertStToConf : L.Deposits \u00d7 L.Deposits \u22a2 L.CertState \u2b46 C.CertState\n  CertStToConf .conv\u2071 (ddeps , gdeps) certState =\n    let open L.CertState certState in\n    \u27e6 ddeps \u22a2conv dState , pState , gdeps \u22a2conv gState \u27e7\n\n  CertStFromConf : C.CertState \u2b46 L.CertState\n  CertStFromConf .conv\u2071 _ certState =\n    let open C.CertState certState in\n    \u27e6 conv dState , pState , conv gState \u27e7\n\n  PRE-CERTToConf : \u2200 {\u0393 s s'}\n                 \u2192 L.Deposits \u00d7 L.Deposits\n                   \u22a2 \u0393 L.\u22a2 s \u21c0\u2987 _ ,PRE-CERT\u2988 s' \u2b46\u2071 \u03bb deposits _ \u2192\n                     \u0393 C.\u22a2 (deposits \u22a2conv s) \u21c0\u2987 _ ,PRE-CERT\u2988 (deposits \u22a2conv s')\n  PRE-CERTToConf .conv\u2071 deposits (L.CERT-pre h) = C.CERT-pre h\n\n  POST-CERTToConf : \u2200 {\u0393 s s'}\n                 \u2192 L.Deposits \u00d7 L.Deposits\n                   \u22a2 \u0393 L.\u22a2 s \u21c0\u2987 _ ,POST-CERT\u2988 s' \u2b46\u2071 \u03bb deposits _ \u2192\n                     \u0393 C.\u22a2 (deposits \u22a2conv s) \u21c0\u2987 _ ,POST-CERT\u2988 (deposits \u22a2conv s')\n  POST-CERTToConf .conv\u2071 deposits L.CERT-post = C.CERT-post\n\n  DELEGToConf : \u2200 {\u0393 s dcert dcerts s'}\n                  (open L.DelegEnv \u0393 renaming (pparams to pp))\n              \u2192 CertDeps* pp (dcert \u2237 dcerts) \u22a2\n                 \u0393 L.\u22a2 s \u21c0\u2987 dcert ,DELEG\u2988 s' \u2b46\u2071 \u03bb deposits _ \u2192\n                 \u0393 C.\u22a2 (deposits .deps\u1d48 \u22a2conv s) \u21c0\u2987 dcert ,DELEG\u2988 (updateCertDeps deposits .deps\u1d48 \u22a2conv s')\n  DELEGToConf .conv\u2071 (delegate* _ _) (L.DELEG-delegate h) = C.DELEG-delegate h\n  DELEGToConf .conv\u2071 (dereg* v w _ _)  (L.DELEG-dereg h)    = C.DELEG-dereg (h , v , w)\n  DELEGToConf .conv\u2071 (reg* _ _) (L.DELEG-reg h) = C.DELEG-reg h\n\n  POOLToConf : \u2200 {pp s dcert s'} \u2192 pp L.\u22a2 s \u21c0\u2987 dcert ,POOL\u2988 s' \u2b46 pp C.\u22a2 s \u21c0\u2987 dcert ,POOL\u2988 s'\n  POOLToConf .conv\u2071 _ (L.POOL-regpool h) = C.POOL-regpool h\n  POOLToConf .conv\u2071 _ L.POOL-retirepool  = C.POOL-retirepool\n\n  GOVCERTToConf : \u2200 {\u0393 s dcert dcerts s'}\n                  (open L.CertEnv \u0393 using (pp))\n                \u2192 CertDeps* pp (dcert \u2237 dcerts) \u22a2\n                   \u0393 L.\u22a2 s \u21c0\u2987 dcert ,GOVCERT\u2988 s' \u2b46\u2071 \u03bb deposits _ \u2192\n                   \u0393 C.\u22a2 (deposits .deps\u1d4d \u22a2conv s) \u21c0\u2987 dcert ,GOVCERT\u2988 (updateCertDeps deposits .deps\u1d4d \u22a2conv s')\n  GOVCERTToConf .conv\u2071 (regdrep* _ _)     (L.GOVCERT-regdrep h) = C.GOVCERT-regdrep h\n  GOVCERTToConf .conv\u2071 (deregdrep* v _ _) (L.GOVCERT-deregdrep h) = C.GOVCERT-deregdrep (h , v)\n  GOVCERTToConf .conv\u2071 (ccreghot* _ _)    (L.GOVCERT-ccreghot h)  = C.GOVCERT-ccreghot h\n\n  CERTToConf : \u2200 {\u0393 s dcert dcerts s'} (open L.CertEnv \u0393 using (pp))\n             \u2192 CertDeps* pp (dcert \u2237 dcerts) \u22a2\n                \u0393 L.\u22a2 s \u21c0\u2987 dcert ,CERT\u2988 s' \u2b46\u2071 \u03bb deposits _ \u2192\n                \u0393 C.\u22a2 (getCertDeps* deposits \u22a2conv s) \u21c0\u2987 dcert ,CERT\u2988 (getCertDeps* (updateCertDeps deposits) \u22a2conv s')\n  CERTToConf .conv\u2071 deposits@(delegate* _ _)    (L.CERT-deleg deleg)  = C.CERT-deleg (deposits \u22a2conv deleg)\n  CERTToConf .conv\u2071 deposits@(dereg* _ _ _ _)   (L.CERT-deleg deleg)  = C.CERT-deleg (deposits \u22a2conv deleg)\n  CERTToConf .conv\u2071 deposits@(regpool* _ _)     (L.CERT-pool pool)    = C.CERT-pool (conv pool)\n  CERTToConf .conv\u2071 deposits@(retirepool* _ _)  (L.CERT-pool pool)    = C.CERT-pool (conv pool)\n  CERTToConf .conv\u2071 deposits@(regdrep* _ _)     (L.CERT-vdel govcert) = C.CERT-vdel (deposits \u22a2conv govcert)\n  CERTToConf .conv\u2071 deposits@(deregdrep* _ _ _) (L.CERT-vdel govcert) = C.CERT-vdel (deposits \u22a2conv govcert)\n  CERTToConf .conv\u2071 deposits@(ccreghot* _ _)    (L.CERT-vdel govcert) = C.CERT-vdel (deposits \u22a2conv govcert)\n  CERTToConf .conv\u2071 deposits@(reg* _ _)         (L.CERT-deleg deleg)  = C.CERT-deleg (deposits \u22a2conv deleg)\n\n  CERT-POST-CERTToConf : \u2200 {\u0393 s dcerts s'} (let open L.CertEnv \u0393)\n    \u2192 CertDeps* pp dcerts\n      \u22a2 RunTraceAndThen L._\u22a2_\u21c0\u2987_,CERT\u2988_ L._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s dcerts s'\n        \u2b46\u2071 \u03bb deposits _ \u2192 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_\n                            \u0393 (getCertDeps* deposits \u22a2conv s) dcerts\n                              (getCertDeps* (updateCertDeps* dcerts deposits) \u22a2conv s')\n  CERT-POST-CERTToConf .conv\u2071 deposits (run-[] x) = run-[] ((deposits .deps\u1d48 , deposits .deps\u1d4d) \u22a2conv x)\n  CERT-POST-CERTToConf .conv\u2071 deposits (run-\u2237 x x\u2081) = run-\u2237 (deposits \u22a2conv x) (updateCertDeps deposits \u22a2conv x\u2081)\n\n\n  CERTSToConf : \u2200 {\u0393 s dcerts s'} (let open L.CertEnv \u0393)\n    \u2192 CertDeps* pp dcerts\n      \u22a2 RunTraceAfterAndThen L._\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ L._\u22a2_\u21c0\u2987_,CERT\u2988_ L._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s dcerts s'\n      \u2b46\u2071 \u03bb deposits _ \u2192 RunTraceAfterAndThen C._\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_\n                          \u0393 (getCertDeps* deposits \u22a2conv s) dcerts\n                            (getCertDeps* (updateCertDeps* dcerts deposits) \u22a2conv s')\n  CERTSToConf .conv\u2071 deposits (run (pre , cert-post)) = run (getCertDeps* deposits \u22a2conv pre , deposits \u22a2conv cert-post)\n\n-- Converting form Conformance is easier since the deposit tracking disappears.\ninstance\n  DELEGFromConf : \u2200 {\u0393 s dcert s'}\n                \u2192 \u0393 C.\u22a2 s \u21c0\u2987 dcert ,DELEG\u2988 s' \u2b46\n                  \u0393 L.\u22a2 conv s \u21c0\u2987 dcert ,DELEG\u2988 conv s'\n  DELEGFromConf .conv\u2071 _ (C.DELEG-delegate h)    = L.DELEG-delegate h\n  DELEGFromConf .conv\u2071 _ (C.DELEG-dereg (h , _)) = L.DELEG-dereg h\n  DELEGFromConf .conv\u2071 _ (C.DELEG-reg h)         = L.DELEG-reg h\n\n  POOLFromConf : \u2200 {pp s dcert s'} \u2192 pp C.\u22a2 s \u21c0\u2987 dcert ,POOL\u2988 s' \u2b46 pp L.\u22a2 s \u21c0\u2987 dcert ,POOL\u2988 s'\n  POOLFromConf .conv\u2071 _ (C.POOL-regpool h) = L.POOL-regpool h\n  POOLFromConf .conv\u2071 _ C.POOL-retirepool  = L.POOL-retirepool\n\n  GOVCERTFromConf : \u2200 {\u0393 s dcert s'}\n                  \u2192 \u0393 C.\u22a2 s \u21c0\u2987 dcert ,GOVCERT\u2988 s' \u2b46\n                    \u0393 L.\u22a2 conv s \u21c0\u2987 dcert ,GOVCERT\u2988 conv s'\n  GOVCERTFromConf .conv\u2071 _ (C.GOVCERT-regdrep h)   = C.GOVCERT-regdrep h\n  GOVCERTFromConf .conv\u2071 _ (C.GOVCERT-deregdrep (h , _)) = C.GOVCERT-deregdrep h\n  GOVCERTFromConf .conv\u2071 _ (C.GOVCERT-ccreghot h)  = C.GOVCERT-ccreghot h\n\n  CERTFromConf : \u2200 {\u0393 s dcert s'} \u2192 \u0393 C.\u22a2 s \u21c0\u2987 dcert ,CERT\u2988 s' \u2b46 \u0393 L.\u22a2 conv s \u21c0\u2987 dcert ,CERT\u2988 conv s'\n  CERTFromConf .conv\u2071 _ (C.CERT-deleg deleg)  = L.CERT-deleg (conv deleg)\n  CERTFromConf .conv\u2071 _ (C.CERT-pool pool)    = L.CERT-pool (conv pool)\n  CERTFromConf .conv\u2071 _ (C.CERT-vdel govcert) = L.CERT-vdel (conv govcert)\n\n  PRE-CERTFromConf : \u2200 {\u0393 s s'}\n                   \u2192 \u0393 C.\u22a2 s \u21c0\u2987 _ ,PRE-CERT\u2988 s' \u2b46\n                     \u0393 L.\u22a2 (conv s) \u21c0\u2987 _ ,PRE-CERT\u2988 (conv s')\n  PRE-CERTFromConf .conv\u2071 _ (C.CERT-pre h) = L.CERT-pre h\n\n  POST-CERTFromConf : \u2200 {\u0393 s s'}\n                   \u2192 \u0393 C.\u22a2 s \u21c0\u2987 _ ,POST-CERT\u2988 s' \u2b46\n                     \u0393 L.\u22a2 (conv s) \u21c0\u2987 _ ,POST-CERT\u2988 (conv s')\n  POST-CERTFromConf .conv\u2071 _ C.CERT-post = L.CERT-post\n\n\n  CERT-POST-CERTFromConf : \u2200 {\u0393 s dcerts s'}\n    \u2192 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s dcerts s'\n      \u2b46 RunTraceAndThen L._\u22a2_\u21c0\u2987_,CERT\u2988_ L._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 (conv s) dcerts (conv s')\n  CERT-POST-CERTFromConf .conv\u2071 _ (run-[] x) = run-[] (conv x)\n  CERT-POST-CERTFromConf .conv\u2071 _ (run-\u2237 x xs) = run-\u2237 (conv x) (conv xs)\n\n\n  CERTSFromConf : \u2200 {\u0393 s dcerts s'}\n                 \u2192 RunTraceAfterAndThen C._\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s dcerts s' \u2b46\n                   RunTraceAfterAndThen L._\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ L._\u22a2_\u21c0\u2987_,CERT\u2988_ L._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 (conv s) dcerts (conv s')\n  CERTSFromConf .conv\u2071 _ (run (pre , cert-post)) = run ((conv pre) , conv cert-post)\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Convert.html","title":"Convert","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Conformance.Equivalence.Convert where\n\nopen import Data.Unit.Base using (\u22a4)\n\ninfixr 1 _\u22a2_\u2b46\u2071_ _\u22a2_\u2b46_ _\u2b46_\nrecord _\u22a2_\u2b46\u2071_ (I L : Set) (C : I \u2192 L \u2192 Set) : Set where\n  field\n    conv\u2071 : (i : I) (l : L) \u2192 C i l\n\nopen _\u22a2_\u2b46\u2071_ public\n\n_\u22a2conv_ : \u2200 {I L C} \u2192 \u2983 I \u22a2 L \u2b46\u2071 C \u2984 \u2192 \u2200 i l \u2192 C i l\n_\u22a2conv_ \u2983 c \u2984 = c .conv\u2071\n\n_\u22a2_\u2b46_ : (I L C : Set) \u2192 Set\nI \u22a2 L \u2b46 C = I \u22a2 L \u2b46\u2071 \u03bb _ _ \u2192 C\n\n_\u2b46_ : (L C : Set) \u2192 Set\nL \u2b46 C = \u22a4 \u22a2 L \u2b46 C\n\nconv : \u2200 {L C} \u2192 \u2983 \u22a4 \u22a2 L \u2b46\u2071 C \u2984 \u2192 \u2200 l \u2192 C _ l\nconv l = _ \u22a2conv l\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Deposits.html","title":"Deposits","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Data.Unit using (\u22a4)\nopen import Data.Product using (_\u00d7_; _,_)\nopen import Data.Product.Relation.Binary.Pointwise.NonDependent using (Pointwise)\nopen import Relation.Binary.PropositionalEquality\nimport Relation.Binary.Reasoning.Setoid as SetoidReasoning\nopen import Relation.Binary using (Setoid; IsEquivalence)\nimport Algebra.Structures as AlgStruct\n\nmodule Ledger.Conway.Conformance.Equivalence.Deposits\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Ledger txs abs public\n    open import Ledger.Conway.Specification.Utxo txs abs public\n    open import Ledger.Conway.Specification.Certs govStructure public\n\n  module C where\n    open import Ledger.Conway.Conformance.Ledger txs abs public\n    open import Ledger.Conway.Conformance.Utxo txs abs public\n    open import Ledger.Conway.Conformance.Certs govStructure public\n\nopen Tx\nopen import Ledger.Conway.Conformance.Equivalence.Map\nopen import Ledger.Conway.Conformance.Equivalence.Certs txs abs\nopen import Axiom.Set.Properties th using (\u2261\u1d49-Setoid; \u2261\u1d49-isEquivalence)\n\n-- TODO: some hoop-jumping required since the Map proofs needs the\n-- stdlib IsCommutativeSemigroup for Coin.\nopen AlgStruct {A = Coin} _\u2261_ using (IsCommutativeSemigroup)\nopen import Data.Nat.Properties using (+-isCommutativeSemigroup)\ninstance\n  Coin-Semigroup : IsCommutativeSemigroup _+_\n  Coin-Semigroup = +-isCommutativeSemigroup\n\n-- TODO: The proofs in this module are kind of a mess! They've grown organically based on\n--       the specific needs of the equivalence proof and could really use some cleaning up.\n--       Both when it comes to naming and when it comes to not proving the same thing several\n--       times.\n\nupdateDDep : PParams \u2192 L.DCert \u2192 L.Deposits \u2192 L.Deposits\nupdateDDep pp cert@(L.delegate _ _ _ _) deps = C.updateCertDeposit pp cert deps\nupdateDDep pp cert@(L.dereg _ _)        deps = C.updateCertDeposit pp cert deps\nupdateDDep pp cert@(L.reg _ _)          deps = C.updateCertDeposit pp cert deps\nupdateDDep pp cert                      deps = deps\n\nupdateDDeps : PParams \u2192 List L.DCert \u2192 L.Deposits \u2192 L.Deposits\nupdateDDeps pp []             deps = deps\nupdateDDeps pp (cert \u2237 certs) deps = updateDDeps pp certs (updateDDep pp cert deps)\n\nupdateGDep : PParams \u2192 L.DCert \u2192 L.Deposits \u2192 L.Deposits\nupdateGDep pp cert@(L.regdrep _ _ _) deps = C.updateCertDeposit pp cert deps\nupdateGDep pp cert@(L.deregdrep _ _) deps = C.updateCertDeposit pp cert deps\nupdateGDep pp cert                   deps = deps\n\nupdateGDeps : PParams \u2192 List L.DCert \u2192 L.Deposits \u2192 L.Deposits\nupdateGDeps pp []             deps = deps\nupdateGDeps pp (cert \u2237 certs) deps = updateGDeps pp certs (updateGDep pp cert deps)\n\nupdateLedgerDeps : PParams \u2192 Tx \u2192 L.Deposits \u00d7 L.Deposits \u2192 L.Deposits \u00d7 L.Deposits\nupdateLedgerDeps pp tx deps@(ddeps , gdeps) = updateDDeps pp certs ddeps , updateGDeps pp certs gdeps\n  where\n    certs = DCertsOf tx\n\ndata DPurpose : L.DepositPurpose \u2192 Set where\n  CredentialDeposit : \u2200 {c} \u2192 DPurpose (L.CredentialDeposit c)\n\ndata GPurpose : L.DepositPurpose \u2192 Set where\n  DRepDeposit : \u2200 {c} \u2192 GPurpose (L.DRepDeposit c)\n\ninstance\n  Dec-DPurpose? : \u2200 {p} \u2192 DPurpose p \u2047\n  Dec-DPurpose? {L.CredentialDeposit _} = \u2047 yes CredentialDeposit\n  Dec-DPurpose? {L.PoolDeposit       _} = \u2047 no \u03bb ()\n  Dec-DPurpose? {L.DRepDeposit       _} = \u2047 no \u03bb ()\n  Dec-DPurpose? {L.GovActionDeposit  _} = \u2047 no \u03bb ()\n\n  Dec-GPurpose? : \u2200 {p} \u2192 GPurpose p \u2047\n  Dec-GPurpose? {L.CredentialDeposit _} = \u2047 no \u03bb ()\n  Dec-GPurpose? {L.PoolDeposit       _} = \u2047 no \u03bb ()\n  Dec-GPurpose? {L.DRepDeposit       _} = \u2047 yes DRepDeposit\n  Dec-GPurpose? {L.GovActionDeposit  _} = \u2047 no \u03bb ()\n\n-- Compute DDeps for the CertState from full Deposits\ncertDDeps : L.Deposits \u2192 L.Deposits\ncertDDeps deps = filter\u1d50 (\u03bb (k , _) \u2192 DPurpose k) deps\n\n-- Compute GDeps for the CertState from full Deposits\ncertGDeps : L.Deposits \u2192 L.Deposits\ncertGDeps deps = filter\u1d50 (\u03bb (k , _) \u2192 GPurpose k) deps\n\ncong-updateCertDeposit : \u2200 pp cert {deps\u2081 deps\u2082}\n                       \u2192 deps\u2081 \u2261\u1d50 deps\u2082\n                       \u2192 C.updateCertDeposit pp cert deps\u2081 \u2261\u1d50 C.updateCertDeposit pp cert deps\u2082\ncong-updateCertDeposit pp (L.delegate c kh del v)            eq = \u222a\u207a-cong-r eq\ncong-updateCertDeposit pp (L.dereg x x\u2081) {deps\u2081} {deps\u2082}     eq = restrict-cong deps\u2081 deps\u2082 eq\ncong-updateCertDeposit pp (L.regpool x x\u2081)                   eq = \u222a\u207a-cong-r eq\ncong-updateCertDeposit pp (L.retirepool x x\u2081)                eq = eq\ncong-updateCertDeposit pp (L.regdrep x x\u2081 x\u2082)                eq = \u222a\u207a-cong-r eq\ncong-updateCertDeposit pp (L.deregdrep x x\u2081) {deps\u2081} {deps\u2082} eq = restrict-cong deps\u2081 deps\u2082 eq\ncong-updateCertDeposit pp (L.ccreghot x x\u2081)                  eq = eq\ncong-updateCertDeposit pp (L.reg x x\u2081)                       eq = \u222a\u207a-cong-r eq\n\ncong-certDDeps : \u2200 deps\u2081 deps\u2082 \u2192 deps\u2081 \u2261\u1d50 deps\u2082 \u2192 certDDeps deps\u2081 \u2261\u1d50 certDDeps deps\u2082\ncong-certDDeps = cong-filter\u1d50\n\ncong-certGDeps : \u2200 deps\u2081 deps\u2082 \u2192 deps\u2081 \u2261\u1d50 deps\u2082 \u2192 certGDeps deps\u2081 \u2261\u1d50 certGDeps deps\u2082\ncong-certGDeps = cong-filter\u1d50\n\ncastValidDeps\u1d48 : \u2200 {pp deps\u2081 deps\u2082 certs} \u2192 deps\u2081 \u2261\u1d50 deps\u2082 \u2192 ValidDeps\u1d48 pp deps\u2081 certs \u2192 ValidDeps\u1d48 pp deps\u2082 certs\ncastValidDeps\u1d48                         eq [] = []\ncastValidDeps\u1d48 {pp} {certs = cert \u2237 _} eq (delegate   deps) = delegate           (castValidDeps\u1d48 (cong-updateCertDeposit pp cert eq) deps)\ncastValidDeps\u1d48 {pp} {deps\u2081} {deps\u2082} {certs = cert \u2237 _} eq (dereg h h' deps) = \n  dereg (proj\u2081 eq h) h' \n        (castValidDeps\u1d48 (cong-updateCertDeposit pp cert {deps\u2081} {deps\u2082} eq) deps)\n--castValidDeps\u1d48 {pp} {deps\u2081} {deps\u2082}\n--                    {certs = cert \u2237 _} eq (dereg h    deps) = dereg (map\u2082 (proj\u2081 eq) h) (castValidDeps\u1d48 (cong-updateCertDeposit\n--                                                                                                    pp cert {deps\u2081} {deps\u2082} eq) deps)\ncastValidDeps\u1d48 {pp} {certs = cert \u2237 _} eq (reg        deps) = reg (castValidDeps\u1d48 (cong-updateCertDeposit pp cert eq) deps)\ncastValidDeps\u1d48                         eq (regdrep    deps) = regdrep            (castValidDeps\u1d48 eq deps)\ncastValidDeps\u1d48                         eq (deregdrep  deps) = deregdrep          (castValidDeps\u1d48 eq deps)\ncastValidDeps\u1d48                         eq (regpool    deps) = regpool            (castValidDeps\u1d48 eq deps)\ncastValidDeps\u1d48                         eq (retirepool deps) = retirepool         (castValidDeps\u1d48 eq deps)\ncastValidDeps\u1d48                         eq (ccreghot   deps) = ccreghot           (castValidDeps\u1d48 eq deps)\n\ncastValidDeps\u1d4d : \u2200 {pp deps\u2081 deps\u2082 certs} \u2192 deps\u2081 \u2261\u1d50 deps\u2082 \u2192 ValidDeps\u1d4d pp deps\u2081 certs \u2192 ValidDeps\u1d4d pp deps\u2082 certs\ncastValidDeps\u1d4d   eq [] = []\ncastValidDeps\u1d4d   eq (delegate    deps) = delegate   (castValidDeps\u1d4d eq deps)\ncastValidDeps\u1d4d   eq (dereg       deps) = dereg      (castValidDeps\u1d4d eq deps)\ncastValidDeps\u1d4d {pp} {certs = cert \u2237 _}\n                 eq (regdrep     deps) = regdrep    (castValidDeps\u1d4d (cong-updateCertDeposit pp cert eq) deps)\ncastValidDeps\u1d4d {pp} {deps\u2081} {deps\u2082} {certs = cert \u2237 _}\n  eq (deregdrep h deps) = deregdrep (proj\u2081 eq h)    (castValidDeps\u1d4d (cong-updateCertDeposit pp cert {deps\u2081} {deps\u2082} eq) deps)\ncastValidDeps\u1d4d   eq (regpool     deps) = regpool    (castValidDeps\u1d4d eq deps)\ncastValidDeps\u1d4d   eq (retirepool  deps) = retirepool (castValidDeps\u1d4d eq deps)\ncastValidDeps\u1d4d   eq (ccreghot    deps) = ccreghot   (castValidDeps\u1d4d eq deps)\ncastValidDeps\u1d4d   eq (reg         deps) = reg        (castValidDeps\u1d4d eq deps)\n\nvalidDDeps : \u2200 {pp certs deps} \u2192 L.ValidCertDeposits pp deps certs \u2192 ValidDeps\u1d48 pp (certDDeps deps) certs\nvalidDDeps                L.[]             = []\nvalidDDeps               (L.delegate    v) = delegate   (castValidDeps\u1d48 (lem-add-included CredentialDeposit) (validDDeps v))\nvalidDDeps               (L.regpool     v) = regpool    (castValidDeps\u1d48 (lem-add-excluded \u03bb ()) (validDDeps v))\nvalidDDeps               (L.regdrep     v) = regdrep    (castValidDeps\u1d48 (lem-add-excluded \u03bb ()) (validDDeps v))\nvalidDDeps {deps = deps} (L.dereg h h'  v) = dereg      (filter\u1d50-\u2208 deps CredentialDeposit h) h'\n                                                        (castValidDeps\u1d48 (filter\u1d50-restrict deps) (validDDeps v))\nvalidDDeps {deps = deps} (L.deregdrep _ v) = deregdrep  (castValidDeps\u1d48 (lem-del-excluded deps \u03bb ()) (validDDeps v))\nvalidDDeps               (L.ccreghot    v) = ccreghot   (validDDeps v)\nvalidDDeps               (L.retirepool  v) = retirepool (validDDeps v)\nvalidDDeps {deps = deps} (L.reg         v) = reg (castValidDeps\u1d48 (lem-add-included CredentialDeposit) (validDDeps v))\n\nvalidGDeps : \u2200 {pp certs deps} \u2192 L.ValidCertDeposits pp deps certs \u2192 ValidDeps\u1d4d pp (certGDeps deps) certs\nvalidGDeps                L.[]             = []\nvalidGDeps               (L.delegate    v) = delegate   (castValidDeps\u1d4d (lem-add-excluded \u03bb ()) (validGDeps v))\nvalidGDeps               (L.regpool     v) = regpool    (castValidDeps\u1d4d (lem-add-excluded \u03bb ()) (validGDeps v))\nvalidGDeps               (L.regdrep     v) = regdrep    (castValidDeps\u1d4d (lem-add-included DRepDeposit) (validGDeps v))\nvalidGDeps {deps = deps} (L.dereg _ _   v) = dereg      (castValidDeps\u1d4d (lem-del-excluded deps \u03bb ()) (validGDeps v))\nvalidGDeps {deps = deps} (L.deregdrep h v) = deregdrep  (filter\u1d50-\u2208 deps DRepDeposit h)\n                                                        (castValidDeps\u1d4d (filter\u1d50-restrict deps) (validGDeps v))\nvalidGDeps               (L.ccreghot    v) = ccreghot   (validGDeps v)\nvalidGDeps               (L.retirepool  v) = retirepool (validGDeps v)\nvalidGDeps               (L.reg         v) = reg (castValidDeps\u1d4d (lem-add-excluded \u03bb ()) (validGDeps v))\n\nlem-upd-prop-ddeps : \u2200 {txid} {gaDep} props deps\n                   \u2192 certDDeps deps \u2261\u1d50 certDDeps (L.updateProposalDeposits props txid gaDep deps)\nlem-upd-prop-ddeps [] deps = id , id\nlem-upd-prop-ddeps {txid} {gaDep} (_ \u2237 props) deps = begin\n    certDDeps deps \u02e2\n      \u2248\u27e8 lem-upd-prop-ddeps props deps \u27e9\n    certDDeps (L.updateProposalDeposits props txid gaDep deps) \u02e2\n      \u2248\u27e8 lem-add-excluded (\u03bb ()) \u27e8\n    certDDeps (L.updateProposalDeposits props txid gaDep deps \u222a\u207a \u2774 L.GovActionDeposit _ , _ \u2775) \u02e2\n      \u220e\n  where\n    open module R {A} = SetoidReasoning (\u2261\u1d49-Setoid {A = A})\n\nlem-upd-prop-gdeps : \u2200 {txid} {gaDep} props deps\n                   \u2192 certGDeps deps \u2261\u1d50 certGDeps (L.updateProposalDeposits props txid gaDep deps)\nlem-upd-prop-gdeps [] deps = id , id\nlem-upd-prop-gdeps {txid} {gaDep} (_ \u2237 props) deps = begin\n    certGDeps deps \u02e2\n      \u2248\u27e8 lem-upd-prop-gdeps props deps \u27e9\n    certGDeps (L.updateProposalDeposits props txid gaDep deps) \u02e2\n      \u2248\u27e8 lem-add-excluded (\u03bb ()) \u27e8\n    certGDeps (L.updateProposalDeposits props txid gaDep deps \u222a\u207a \u2774 L.GovActionDeposit _ , _ \u2775) \u02e2\n      \u220e\n  where\n    open module R {A} = SetoidReasoning (\u2261\u1d49-Setoid {A = A})\n\nlem-ddeps : \u2200 {pp certs} (deposits : CertDeps* pp certs)\n          \u2192 updateCertDeps* certs deposits .CertDeps*.deps\u1d48 \u2261 updateDDeps pp certs (deposits .CertDeps*.deps\u1d48)\nlem-ddeps {certs = []} _ = refl\nlem-ddeps (delegate*    ddeps gdeps) rewrite lem-ddeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-ddeps (dereg* v v'  ddeps gdeps) rewrite lem-ddeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-ddeps (regpool*     ddeps gdeps) rewrite lem-ddeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-ddeps (retirepool*  ddeps gdeps) rewrite lem-ddeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-ddeps (regdrep*     ddeps gdeps) rewrite lem-ddeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-ddeps (deregdrep* v ddeps gdeps) rewrite lem-ddeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-ddeps (ccreghot*    ddeps gdeps) rewrite lem-ddeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-ddeps (reg*         ddeps gdeps) rewrite lem-ddeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\n\nlem-gdeps : \u2200 {pp certs} (deposits : CertDeps* pp certs)\n          \u2192 updateCertDeps* certs deposits .CertDeps*.deps\u1d4d \u2261 updateGDeps pp certs (deposits .CertDeps*.deps\u1d4d)\nlem-gdeps {certs = []} _ = refl\nlem-gdeps (delegate*    ddeps gdeps) rewrite lem-gdeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-gdeps (dereg* v v'  ddeps gdeps) rewrite lem-gdeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-gdeps (regpool*     ddeps gdeps) rewrite lem-gdeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-gdeps (retirepool*  ddeps gdeps) rewrite lem-gdeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-gdeps (regdrep*     ddeps gdeps) rewrite lem-gdeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-gdeps (deregdrep* v ddeps gdeps) rewrite lem-gdeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-gdeps (ccreghot*    ddeps gdeps) rewrite lem-gdeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\nlem-gdeps (reg*         ddeps gdeps) rewrite lem-gdeps \u27e6 _ , _ , ddeps , gdeps \u27e7* = refl\n\ncertDeposits : L.LState \u2192 L.Deposits \u00d7 L.Deposits\ncertDeposits s = certDDeps deps , certGDeps deps\n  where deps = s .L.LState.utxoSt .L.UTxOState.deposits\n\n_\u2261\u1d48_ : (x y : L.Deposits \u00d7 L.Deposits) \u2192 Type\n_\u2261\u1d48_ = Pointwise _\u2261\u1d50_ _\u2261\u1d50_\n{-# INJECTIVE_FOR_INFERENCE _\u2261\u1d48_ #-}\n\n\u2261\u1d48-isEquivalence : IsEquivalence _\u2261\u1d48_\n\u2261\u1d48-isEquivalence .IsEquivalence.refl = (id , id) , (id , id)\n\u2261\u1d48-isEquivalence .IsEquivalence.sym (deq , geq) = \u2261\u1d49-isEquivalence .IsEquivalence.sym deq , \u2261\u1d49-isEquivalence .IsEquivalence.sym geq\n\u2261\u1d48-isEquivalence .IsEquivalence.trans (deq\u2081 , geq\u2081) (deq\u2082 , geq\u2082) =\n  \u2261\u1d49-isEquivalence .IsEquivalence.trans deq\u2081 deq\u2082 ,\n  \u2261\u1d49-isEquivalence .IsEquivalence.trans geq\u2081 geq\u2082\n\ncong-updateDDep : \u2200 {pp} cert {deps\u2081 deps\u2082}\n                \u2192 deps\u2081 \u2261\u1d50 deps\u2082\n                \u2192 updateDDep pp cert deps\u2081 \u2261\u1d50 updateDDep pp cert deps\u2082\ncong-updateDDep {pp} cert@(L.delegate c del kh v)\n                                        eq = cong-updateCertDeposit pp cert eq\ncong-updateDDep {pp} cert@(L.dereg c v) {deps\u2081} {deps\u2082}\n                                        eq = cong-updateCertDeposit pp cert {deps\u2081} {deps\u2082} eq\ncong-updateDDep {pp} cert@(L.reg c v)   eq = cong-updateCertDeposit pp cert eq\ncong-updateDDep      (L.regpool _ _)    eq = eq\ncong-updateDDep      (L.regdrep _ _ _)  eq = eq\ncong-updateDDep      (L.deregdrep _ _)  eq = eq\ncong-updateDDep      (L.retirepool _ _) eq = eq\ncong-updateDDep      (L.ccreghot _ _)   eq = eq\n\ncong-updateDDeps : \u2200 {pp} certs {deps\u2081 deps\u2082}\n                 \u2192 deps\u2081 \u2261\u1d50 deps\u2082\n                 \u2192 updateDDeps pp certs deps\u2081 \u2261\u1d50 updateDDeps pp certs deps\u2082\ncong-updateDDeps []             eq = eq\ncong-updateDDeps (cert \u2237 certs) eq = cong-updateDDeps certs (cong-updateDDep cert eq)\n\ncong-updateGDep : \u2200 {pp} cert {deps\u2081 deps\u2082}\n                \u2192 deps\u2081 \u2261\u1d50 deps\u2082\n                \u2192 updateGDep pp cert deps\u2081 \u2261\u1d50 updateGDep pp cert deps\u2082\ncong-updateGDep      (L.delegate _ _ _ _)   eq = eq\ncong-updateGDep      (L.dereg _ _)          eq = eq\ncong-updateGDep      (L.reg _ _)            eq = eq\ncong-updateGDep      (L.regpool _ _)        eq = eq\ncong-updateGDep {pp} cert@(L.regdrep _ _ _) eq = cong-updateCertDeposit pp cert eq\ncong-updateGDep {pp} cert@(L.deregdrep _ _) {deps\u2081} {deps\u2082}\n                                            eq = cong-updateCertDeposit pp cert {deps\u2081} {deps\u2082} eq\ncong-updateGDep      (L.retirepool _ _)     eq = eq\ncong-updateGDep      (L.ccreghot _ _  )     eq = eq\n\ncong-updateGDeps : \u2200 {pp} certs {deps\u2081 deps\u2082}\n                 \u2192 deps\u2081 \u2261\u1d50 deps\u2082\n                 \u2192 updateGDeps pp certs deps\u2081 \u2261\u1d50 updateGDeps pp certs deps\u2082\ncong-updateGDeps []             eq = eq\ncong-updateGDeps (cert \u2237 certs) eq = cong-updateGDeps certs (cong-updateGDep cert eq)\n\nprivate open module S {A} = Setoid (\u2261\u1d49-Setoid {A = A}) using () renaming (sym to \u2248-sym; trans to _\u27e8\u2248\u27e9_)\n\n-- This proof takes quite a long time to check. Way longer if we tried to use nice equational reasoning.\n-- I suspect making filter\u1d50 and _\u222a\u207a_ opaque would speed things up a million times.\nlem-upd-cert-ddeps : \u2200 {pp} deps certs\n                  \u2192 updateDDeps pp certs (certDDeps deps) \u2261\u1d50 certDDeps (L.updateCertDeposits pp certs deps)\nlem-upd-cert-ddeps deps [] = id , id\nlem-upd-cert-ddeps {pp} deps (L.delegate c del kh v \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (lem-add-included CredentialDeposit)) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.CredentialDeposit c , v \u2775\nlem-upd-cert-ddeps {pp} deps (L.dereg c v \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (filter\u1d50-restrict deps)) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u2223 cs \u1d9c) certs\n  where cs = \u2774 L.CredentialDeposit c \u2775\nlem-upd-cert-ddeps {pp} deps (L.reg c v \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (lem-add-included CredentialDeposit)) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.CredentialDeposit c , pp .PParams.keyDeposit \u2775\nlem-upd-cert-ddeps {pp} deps (L.regpool kh p \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (lem-add-excluded \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.PoolDeposit kh , pp .PParams.poolDeposit \u2775\nlem-upd-cert-ddeps {pp} deps (L.regdrep c v a \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (lem-add-excluded \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.DRepDeposit c , v \u2775\nlem-upd-cert-ddeps {pp} deps (L.deregdrep c v \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (lem-del-excluded deps \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u2223 cs \u1d9c) certs\n  where cs = \u2774 L.DRepDeposit c \u2775\nlem-upd-cert-ddeps deps (L.retirepool _ _ \u2237 certs) = lem-upd-cert-ddeps deps certs\nlem-upd-cert-ddeps deps (L.ccreghot _ _ \u2237 certs) = lem-upd-cert-ddeps deps certs\n\nlem-upd-cert-gdeps : \u2200 {pp} deps certs\n                  \u2192 updateGDeps pp certs (certGDeps deps) \u2261\u1d50 certGDeps (L.updateCertDeposits pp certs deps)\nlem-upd-cert-gdeps deps [] = id , id\nlem-upd-cert-gdeps {pp} deps (L.delegate c del kh v \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (lem-add-excluded \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.CredentialDeposit c , v \u2775\nlem-upd-cert-gdeps {pp} deps (L.dereg c v \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (lem-del-excluded deps \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u2223 cs \u1d9c) certs\n  where cs = \u2774 L.CredentialDeposit c \u2775\nlem-upd-cert-gdeps {pp} deps (L.reg c v \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (lem-add-excluded \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.CredentialDeposit c , pp .PParams.keyDeposit \u2775\nlem-upd-cert-gdeps {pp} deps (L.regpool kh p \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (lem-add-excluded \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.PoolDeposit kh , pp .PParams.poolDeposit \u2775\nlem-upd-cert-gdeps {pp} deps (L.regdrep c v a \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (lem-add-included DRepDeposit)) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.DRepDeposit c , v \u2775\nlem-upd-cert-gdeps {pp} deps (L.deregdrep c v \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (filter\u1d50-restrict deps)) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u2223 cs \u1d9c) certs\n  where cs = \u2774 L.DRepDeposit c \u2775\nlem-upd-cert-gdeps deps (L.retirepool _ _ \u2237 certs) = lem-upd-cert-gdeps deps certs\nlem-upd-cert-gdeps deps (L.ccreghot _ _ \u2237 certs) = lem-upd-cert-gdeps deps certs\n\nlem-upd-ddeps : \u2200 pparams deps tx (open TxBody (body tx) using (txCerts))\n              \u2192 updateDDeps pparams txCerts (certDDeps deps) \u2261\u1d50 certDDeps (L.updateDeposits pparams (body tx) deps)\nlem-upd-ddeps pparams deps tx = begin\n    updateDDeps pparams txCerts (certDDeps deps) \u02e2\n      \u2248\u27e8 cong-updateDDeps txCerts (lem-upd-prop-ddeps txGovProposals deps) \u27e9\n    updateDDeps pparams txCerts (certDDeps (updateProp deps)) \u02e2\n      \u2248\u27e8 lem-upd-cert-ddeps (updateProp deps) txCerts \u27e9\n    certDDeps (L.updateDeposits pparams (body tx) deps) \u02e2\n      \u220e\n  where\n    open TxBody (body tx)\n    open module R {A} = SetoidReasoning (\u2261\u1d49-Setoid {A = A})\n    updateCert = L.updateCertDeposits pparams txCerts\n    updateProp = L.updateProposalDeposits txGovProposals txId (pparams .PParams.govActionDeposit)\n\nlem-upd-gdeps  :   \u2200 pparams deps tx (open TxBody (body tx) using (txCerts))\n               \u2192   updateGDeps pparams txCerts (certGDeps deps)\n               \u2261\u1d50  certGDeps (L.updateDeposits pparams (body tx) deps)\nlem-upd-gdeps pparams deps tx = begin\n    updateGDeps pparams txCerts (certGDeps deps) \u02e2\n      \u2248\u27e8 cong-updateGDeps txCerts (lem-upd-prop-gdeps txGovProposals deps) \u27e9\n    updateGDeps pparams txCerts (certGDeps (updateProp deps)) \u02e2\n      \u2248\u27e8 lem-upd-cert-gdeps (updateProp deps) txCerts \u27e9\n    certGDeps (L.updateDeposits pparams (body tx) deps) \u02e2\n      \u220e\n  where\n    open TxBody (body tx)\n    open module R {A} = SetoidReasoning (\u2261\u1d49-Setoid {A = A})\n    updateCert = L.updateCertDeposits pparams txCerts\n    updateProp = L.updateProposalDeposits txGovProposals txId (pparams .PParams.govActionDeposit)\n\nlemUpdCert : \u2200 pp ((ddeps , gdeps) : L.Deposits \u00d7 L.Deposits) deps cert\n           \u2192 (ddeps , gdeps) \u2261\u1d48 (certDDeps deps , certGDeps deps)\n           \u2192 (updateDDep pp cert ddeps , updateGDep pp cert gdeps) \u2261\u1d48\n             (certDDeps (C.updateCertDeposit pp cert deps) , certGDeps (C.updateCertDeposit pp cert deps))\nlemUpdCert pp (ddeps , gdeps) deps (L.delegate _ _ _ _) (deq , geq) = \u222a\u207a-cong-r deq\n                                                                      \u27e8\u2248\u27e9 \u2248-sym (lem-add-included CredentialDeposit)\n                                                                    , geq \u27e8\u2248\u27e9 \u2248-sym (lem-add-excluded \u03bb ())\nlemUpdCert pp (ddeps , gdeps) deps (L.dereg _ _)        (deq , geq) = restrict-cong ddeps (certDDeps deps) deq\n                                                                      \u27e8\u2248\u27e9 \u2248-sym (filter\u1d50-restrict deps)\n                                                                    , geq \u27e8\u2248\u27e9 \u2248-sym (lem-del-excluded deps \u03bb ())\nlemUpdCert pp (ddeps , gdeps) deps (L.reg _ _)          (deq , geq) = (\u222a\u207a-cong-r deq\n                                                                      \u27e8\u2248\u27e9 \u2248-sym (lem-add-included CredentialDeposit))\n                                                                    , geq \u27e8\u2248\u27e9 \u2248-sym (lem-add-excluded \u03bb ())\nlemUpdCert pp (ddeps , gdeps) deps (L.regpool x x\u2081)     (deq , geq) = deq \u27e8\u2248\u27e9 \u2248-sym (lem-add-excluded \u03bb ())\n                                                                    , geq \u27e8\u2248\u27e9 \u2248-sym (lem-add-excluded \u03bb ())\nlemUpdCert pp (ddeps , gdeps) deps (L.regdrep _ _ _)    (deq , geq) = deq \u27e8\u2248\u27e9 \u2248-sym (lem-add-excluded \u03bb ())\n                                                                    , \u222a\u207a-cong-r geq\n                                                                      \u27e8\u2248\u27e9 \u2248-sym (lem-add-included DRepDeposit)\nlemUpdCert pp (ddeps , gdeps) deps (L.deregdrep _ _)    (deq , geq) = deq \u27e8\u2248\u27e9 \u2248-sym (lem-del-excluded deps \u03bb ())\n                                                                    , (restrict-cong gdeps (certGDeps deps) geq\n                                                                      \u27e8\u2248\u27e9 \u2248-sym (filter\u1d50-restrict deps))\nlemUpdCert pp (ddeps , gdeps) deps (L.retirepool _ _)   (deq , geq) = deq , geq\nlemUpdCert pp (ddeps , gdeps) deps (L.ccreghot _ _)     (deq , geq) = deq , geq\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Map.html","title":"Map","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Conformance.Equivalence.Map where\n\nopen import Ledger.Prelude\nopen import Axiom.Set.Properties th\nopen import Axiom.Set.Map.Dec\n\nimport Algebra as Alg\nimport Algebra.Definitions as AlgDefs\nimport Algebra.Structures as AlgStrucs\n\nopen import Data.List.Relation.Unary.Any using (Any)\nopen import Data.These as These using (These; this; that; these; fold)\nopen import Data.Product using (swap)\nopen import Data.Sum using () renaming (map to map-\u228e)\nimport Relation.Binary.Reasoning.Setoid as SetoidReasoning\nopen import Relation.Binary using (IsEquivalence; _Preserves_\u27f6_)\nopen import Relation.Binary.Bundles\nopen module SetSetoid {A} = Setoid (\u2261\u1d49-Setoid {A}) using () renaming (refl to \u2248-refl; trans to infixr 1 _\u27e8\u2248\u27e9_)\nopen import Data.Product.Properties using (\u00d7-\u2261,\u2261\u2190\u2261; \u00d7-\u2261,\u2261\u2192\u2261)\n\nopen Any\n\nimport Axiom.Set\nimport Axiom.Set.Rel\n{-# DISPLAY Axiom.Set.Theory._\u2208_ _ a b = a \u2208 b #-}\n{-# DISPLAY Axiom.Set.Rel.dom _ a = dom a #-}\n\nmodule _  {A B : Type}\n  (open AlgStrucs {A = B} _\u2261_)\n  \u2983 _ : DecEq A \u2984 \u2983 _ : DecEq B \u2984\n  \u2983 _ : CommutativeMonoid _ _ B \u2984\n  \u2983 csg : IsCommutativeSemigroup _\u25c7_ \u2984\n\n  where\n  private\n    variable\n      k : A\n      v : B\n      m m\u2081 m\u2082 : A \u21c0 B\n\n  \u25c7comm : Alg.Commutative {A = B} _\u2261_ _\u25c7_\n  \u25c7comm = IsCommutativeSemigroup.comm csg\n  -- TODO: fix this (if possible)\n  -- We should probably use the `\u25c7-comm` property of the `\u2983 _ : CommutativeMonoid _ _ B \u2984`\n  -- instance here, but I don't see how to set the instance's `_\u2248_` to be `_\u2261_`, so here\n  -- I instead use the standard library's commutative semigroup.\n\n  open Equivalence\n\n  -- Properties of domains of maps of type m\u2081 \u222a\u207a m\u2082 ---------------------\n\n  -- 1. If `k \u2208 dom m\u2081 \u222a dom m\u2082` (for m\u2081, m\u2082 maps), then `(k , v) \u2208 m\u2081 \u222a\u207a m\u2082` for some `v`.\n  dom\u222a-\u2203\u222a\u207a : {m\u2081 m\u2082 : A \u21c0 B} \u2192 k \u2208 dom m\u2081 \u222a dom m\u2082 \u2192 \u03a3 B (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081 \u222a\u207a m\u2082)\n  dom\u222a-\u2203\u222a\u207a k\u2208 = from dom\u2208 (\u222adom\u2286dom\u222a\u207a k\u2208)\n\n  -- 2. If `(k , v) \u2208 m\u2081 \u222a\u207a m\u2082`, then `k \u2208 dom m\u2081 \u222a dom m\u2082`.\n  \u222a\u207a-dom\u222a : {m\u2081 m\u2082 : A \u21c0 B}{k : A} {v : B} \u2192 (k , v) \u2208 m\u2081 \u222a\u207a m\u2082 \u2192 k \u2208 dom m\u2081 \u222a dom m\u2082\n  \u222a\u207a-dom\u222a {v = v} kv\u2208 = dom\u222a\u207a\u2286\u222adom (to dom\u2208 (v , kv\u2208))\n\n  -- 3. The image of a key `k \u2208 dom m\u2081 \u222a dom m\u2082` under the map `m\u2081 \u222a\u207a m\u2082` is\n  --    `fold id id _\u25c7_ (unionThese m\u2081 m\u2082 k p)`.\n  \u2225_\u222a\u207a_\u2225 : (m\u2081 m\u2082 : A \u21c0 B) \u2192 k \u2208 dom m\u2081 \u222a dom m\u2082 \u2192 B\n  \u2225_\u222a\u207a_\u2225 {k} m\u2081 m\u2082 p = fold id id _\u25c7_ (unionThese m\u2081 m\u2082 k p)\n\n  -- 4. F[ m\u2081 , m\u2082 ] takes a key `k` and a proof of `k \u2208 dom m\u2081 \u222a dom m\u2082` and returns\n  --    the pair `(k , v)` where `v` is the unique image of `k` under `m\u2081 \u222a\u207a m\u2082`.\n  --    i.e., `(k , v) \u2208 m\u2081 \u222a\u207a m\u2082`.\n  F[_,_] : (m\u2081 m\u2082 : A \u21c0 B) \u2192 \u03a3 A (_\u2208 dom m\u2081 \u222a dom m\u2082) \u2192 A \u00d7 B\n  F[ m\u2081 , m\u2082 ] (x , x\u2208) = x , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 x\u2208\n\n  -- 5. A simpler version of `lookup\u1d50`; it doesn't require tactics.\n  lookup\u1d50\u2208 : (m : A \u21c0 B) \u2192 k \u2208 dom m \u2192 B\n  lookup\u1d50\u2208 _ = proj\u2081 \u2218 (from dom\u2208)\n\n  -- 6. Proof that the value you get from `lookup\u1d50\u2208` is in the image of the map.\n  \u2208-lookup\u1d50\u2208 : (m : A \u21c0 B)(k\u2208 : k \u2208 dom m) \u2192 (k , lookup\u1d50\u2208 m k\u2208) \u2208 m\n  \u2208-lookup\u1d50\u2208 m k\u2208 = proj\u2082 (from dom\u2208 k\u2208)\n\n  -- 7. Irrelevance of the proof of `k \u2208 dom m` used in `lookup\u1d50\u2208`.\n  lookup\u1d50\u2208-irrelevance : (m : A \u21c0 B) {k\u2208 k\u2208\u2032 : k \u2208 dom m}\n                       \u2192 lookup\u1d50\u2208 m k\u2208 \u2261 lookup\u1d50\u2208 m k\u2208\u2032\n  lookup\u1d50\u2208-irrelevance m {k\u2208} {k\u2208\u2032} = m .proj\u2082 (\u2208-lookup\u1d50\u2208 m k\u2208) (\u2208-lookup\u1d50\u2208 m k\u2208\u2032)\n\n  -- 8. If `v` is the image of `k` under `m`, then it must be `lookup\u1d50\u2208 m k\u2208m`!\n  \u2208-lookup\u1d50\u2261 : (m : A \u21c0 B) {k\u2208m : k \u2208 dom m} \u2192 (k , v) \u2208 m \u2192 v \u2261 lookup\u1d50\u2208 m k\u2208m\n  \u2208-lookup\u1d50\u2261 m {k\u2208m} kv\u2208 = m .proj\u2082 kv\u2208 (\u2208-lookup\u1d50\u2208 m k\u2208m)\n\n  lookup\u1d50\u2208\u2261 : (m : A \u21c0 B) {k\u2208 : k \u2208 dom m} \u2192 lookup\u1d50\u2208 m k\u2208 \u2261 lookup\u1d50 m k\n  lookup\u1d50\u2208\u2261 {k = k} _ {k\u2208} = refl\n\n  opaque  -- unfolding List-Model List-Model\u1d48 to-sp\n\n    -- 0. The `\u2208-incl-set` lemma is useful for proving some properties of `_\u222a\u207a_`.\n    \u2208-incl-set : {X : \u2119 A} {a : A} (a\u2208X : a \u2208 X) \u2192 \u03a3 (a \u2208 X) \u03bb \u2022 \u2192 (a , \u2022) \u2208 incl-set X\n    \u2208-incl-set {X} {a} a\u2208X =\n      Data.Product.map\u2082 (\u03bb {a\u2208X\u2032} eq \u2192 \u2208-mapPartial {f = incl-set' X} .to (a , a\u2208X\u2032 , eq))\n                        lem\n      where\n        lem : \u03a3 (a \u2208 X) \u03bb a\u2208X\u2032 \u2192 incl-set' X a \u2261 just (a , a\u2208X\u2032)\n        lem with a \u2208? X\n        ... | yes a\u2208X\u2032 = a\u2208X\u2032 , refl\n        ... | no  a\u2209X  = \u22a5-elim (a\u2209X a\u2208X)\n\n    -- Properties of values of \u222a\u207a --------------------------------------------------\n\n    -- 1. If `k \u2208 dom m\u2081 \u222a dom m\u2082` holds, then there is a particular proof `k\u2208\u2032`\n    --    of that fact such that `(k , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2032) \u2208 m\u2081 \u222a\u207a m\u2082`.\n    -- k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a  : {m\u2081 m\u2082 : A \u21c0 B} \u2192 k \u2208 dom m\u2081 \u222a dom m\u2082\n    --             \u2192 \u03a3 (k \u2208 dom m\u2081 \u222a dom m\u2082) \u03bb k\u2208\u2032 \u2192 (k , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2032) \u2208 m\u2081 \u222a\u207a m\u2082\n    -- k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a {k = k} k\u2208 with \u2208-incl-set k\u2208\n    -- ... | k\u2208\u2032 , kk\u2208 = k\u2208\u2032 , to \u2208-map ((k , k\u2208\u2032) , refl , kk\u2208)\n\n    -- Actually, we won't use the general statement above; we only need the following\n    -- version which picks a particular proof of the fact that `k \u2208 dom m\u2081 \u222a dom m\u2082`.\n    -- In fact, for computing the value, the proof is irrelevant (see property 3 below).\n\n    -- 2. We can obtain the particular proof mentioned in 3. using `\u2208-incl-set`.\n    k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a'  : {m\u2081 m\u2082 : A \u21c0 B} (k\u2208 : k \u2208 dom m\u2081 \u222a dom m\u2082)\n                 \u2192 (k , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 (\u2208-incl-set k\u2208 .proj\u2081)) \u2208 m\u2081 \u222a\u207a m\u2082\n    k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' {k = k} {m\u2081} {m\u2082} k\u2208 = goal\n      where\n      k\u2208\u2032 : k \u2208 dom m\u2081 \u222a dom m\u2082\n      k\u2208\u2032 = \u2208-incl-set k\u2208 .proj\u2081  --  &lt;= the particular proof mentioned in 1 above.\n\n      kk\u2208 : (k , \u2208-incl-set k\u2208 .proj\u2081) \u2208 incl-set (dom m\u2081 \u222a dom m\u2082)\n      kk\u2208 = \u2208-incl-set k\u2208 .proj\u2082\n\n      goal : F[ m\u2081 , m\u2082 ] (k , \u2208-incl-set k\u2208 .proj\u2081) \u2208 map\u02e2 F[ m\u2081 , m\u2082 ] (incl-set (dom m\u2081 \u222a dom m\u2082))\n                                                -- this ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ is `(m\u2081 \u222a\u207a m\u2082)\u02e2`\n      goal = to \u2208-map ((k , k\u2208\u2032) , refl , kk\u2208)\n\n    -- 3. The value associated with a key doesn't depend on the proof of key membership.\n    fold-irrelevance : {m\u2081 m\u2082 : A \u21c0 B} {k\u2208\u2081 k\u2208\u2082 : k \u2208 (dom m\u2081 \u222a dom m\u2082)}\n                     \u2192 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2081 \u2261 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2082\n    fold-irrelevance {k = k} {m\u2081 = m\u2081} {m\u2082} {k\u2208\u2081} with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n    ... | yes k\u2208m\u2081 | yes k\u2208m\u2082 = refl\n    ... | yes k\u2208m\u2081 | no k\u2209m\u2082  = refl\n    ... | no k\u2209m\u2081  | yes k\u2208m\u2082 = refl\n    ... | no k\u2209m\u2081  | no k\u2209m\u2082 with from \u2208-\u222a k\u2208\u2081\n    ... | inj\u2081 k\u2208m\u2081 = \u22a5-elim (k\u2209m\u2081 k\u2208m\u2081)\n    ... | inj\u2082 k\u2208m\u2082 = \u22a5-elim (k\u2209m\u2082 k\u2208m\u2082)\n\n    -- 4. If `(k , v) \u2208 m\u2081 \u222a\u207a m\u2082`, then there is a particular proof `k\u2208\u2032` of\n    --    `k \u2208 dom m\u2081 \u222a dom m\u2082` such that `v \u2261 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2032`.\n    \u222a\u207a-unique-val  : {m\u2081 m\u2082 : A \u21c0 B} (k\u2208 : k \u2208 dom m\u2081 \u222a dom m\u2082) \u2192 (k , v) \u2208 m\u2081 \u222a\u207a m\u2082\n                   \u2192 v \u2261 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 (\u2208-incl-set k\u2208 .proj\u2081)\n    \u222a\u207a-unique-val {k = k} {m\u2081 = m\u2081} {m\u2082} k\u2208 kv\u2208 =\n      (m\u2081 \u222a\u207a m\u2082) .proj\u2082 kv\u2208 (to \u2208-map ((k , \u2208-incl-set k\u2208 .proj\u2081) , refl , \u2208-incl-set k\u2208 .proj\u2082))\n\n    -- 5. If `k \u2208 dom m\u2081 \u222a dom m\u2082`, and `k \u2208 dom m\u2081` and `k \u2208 dom m\u2082`, then there's a\n    --    proof `k\u2208\u2032` of `k \u2208 dom m\u2081 \u222a dom m\u2082` such that `\u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2032`.\n    \u2225\u222a\u207a\u2225\u2261lu\u25c7lu  :  {m\u2081 m\u2082 : A \u21c0 B} (k\u2208 : k \u2208 dom m\u2081 \u222a dom m\u2082)\n                    {k\u2208m\u2081 : k \u2208 dom m\u2081} {k\u2208m\u2082 : k \u2208 dom m\u2082}\n                 \u2192  \u03a3 (k \u2208 dom m\u2081 \u222a dom m\u2082) \u03bb k\u2208\u2032 \u2192 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2032 \u2261 lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\n    \u2225\u222a\u207a\u2225\u2261lu\u25c7lu {k} {m\u2081} {m\u2082} k\u2208 {k\u2208m\u2081} {k\u2208m\u2082} with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n    ... | no k\u2209m\u2081   | _       = \u22a5-elim (k\u2209m\u2081 k\u2208m\u2081)\n    ... | _         | no k\u2209m\u2082 = \u22a5-elim (k\u2209m\u2082 k\u2208m\u2082)\n    ... | yes k\u2208m\u2081\u2032 | yes k\u2208m\u2082\u2032 = k\u2208 , goal\n      where\n      open \u2261-Reasoning\n      goal : lookup\u1d50\u2208 m\u2081 k\u2208m\u2081\u2032 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\u2032 \u2261 lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\n      goal = begin\n        lookup\u1d50\u2208 m\u2081 k\u2208m\u2081\u2032 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\u2032  \u2261\u27e8 cong (_\u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\u2032) (lookup\u1d50\u2208-irrelevance m\u2081) \u27e9\n        lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\u2032   \u2261\u27e8 cong (lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7_ ) (lookup\u1d50\u2208-irrelevance m\u2082) \u27e9\n        lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082    \u220e\n\n    -- 5.' Again, we won't need the general statement (`\u2225\u222a\u207a\u2225\u2261lu\u25c7lu`), but instead the version below\n    --     which picks a particular proof of `k \u2208 dom m\u2081 \u222a dom m\u2082`.\n    \u2225\u222a\u207a\u2225\u2261lu\u25c7lu'  :  {m\u2081 m\u2082 : A \u21c0 B} (kv\u2208 : (k , v) \u2208 m\u2081 \u222a\u207a m\u2082)\n                     {k\u2208m\u2081 : k \u2208 dom m\u2081} {k\u2208m\u2082 : k \u2208 dom m\u2082}\n                  \u2192  \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 (\u2208-incl-set (\u222a\u207a-dom\u222a kv\u2208) .proj\u2081) \u2261 lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\n    \u2225\u222a\u207a\u2225\u2261lu\u25c7lu' kv\u2208 with \u2225\u222a\u207a\u2225\u2261lu\u25c7lu (\u222a\u207a-dom\u222a kv\u2208)\n    ... | k\u2208\u2032 , v\u2261 = trans fold-irrelevance v\u2261\n\n\n    ------------------------------------------------------------------------------------------------\n\n    res\u1d9c-dom\u2209\u207b : \u2200 m {ks}{a : A}{b : B} \u2192 (a , b) \u2208 (m \u2223 ks \u1d9c) \u2192 (a , b) \u2208 m \u00d7 a \u2209 ks\n    res\u1d9c-dom\u2209\u207b m x = ex-\u2286 x , (\u2208-res\u1d9c-dom\u207b $ \u2208-dom x) .proj\u2081\n\n    res\u1d9c-dom\u2209\u207a : \u2200 m {ks}{a : A}{b : B} \u2192 (a , b) \u2208 m \u00d7 a \u2209 ks \u2192 (a , b) \u2208 (m \u2223 ks \u1d9c)\n    res\u1d9c-dom\u2209\u207a m = to \u2208-filter \u2218 swap\n\n    deconstruct-\u222a\u207a  :  {m m\u2081 m\u2082 : A \u21c0 B} {a : A}\n                       {a\u2208\u2081 : a \u2208 dom m \u222a dom m\u2081}\n                       {a\u2208\u2082 : a \u2208 dom m \u222a dom m\u2082}\n                    \u2192  m\u2081 \u2261\u1d50 m\u2082 \u2192 \u2225 m \u222a\u207a m\u2081 \u2225 a\u2208\u2081 \u2261 \u2225 m \u222a\u207a m\u2082 \u2225 a\u2208\u2082\n\n    deconstruct-\u222a\u207a {m} {m\u2081} {m\u2082} {a} {a\u2208\u2081} m\u2081\u2261m\u2082\n      with a \u2208? dom m | a \u2208? dom m\u2081 | a \u2208? dom m\u2082\n    ... | yes a\u2208m | yes a\u2208m\u2081 | yes a\u2208m\u2082 =\n      cong (\u03bb (b : B) \u2192 lookup\u1d50 m a \u25c7 b)\n           (proj\u2082 m\u2082\n             (proj\u2081 m\u2081\u2261m\u2082 (proj\u2082 $ from dom\u2208 a\u2208m\u2081))  -- : (a , lookup\u1d50 m\u2081 a) \u2208 (m\u2082 \u02e2)\n             (proj\u2082 (from dom\u2208 a\u2208m\u2082))                -- : (a , lookup\u1d50 m\u2082 a) \u2208 (m\u2082 \u02e2)\n           )\n    ... | no  a\u2209m | yes a\u2208m\u2081 | yes a\u2208m\u2082 =\n      proj\u2082 m\u2082 (proj\u2081 m\u2081\u2261m\u2082 (proj\u2082 (from dom\u2208 a\u2208m\u2081))) (proj\u2082 (from dom\u2208 a\u2208m\u2082))\n    ... | yes a\u2208m | no  a\u2209m\u2081 | no a\u2209m\u2082 = refl\n    ... | _ | yes a\u2208m\u2081 | no a\u2209m\u2082 = \u22a5-elim (a\u2209m\u2082 (dom\u2286 (proj\u2081 m\u2081\u2261m\u2082) a\u2208m\u2081))\n    ... | _ | no  a\u2209m\u2081 | yes a\u2208m\u2082 = \u22a5-elim (a\u2209m\u2081 (dom\u2286 (proj\u2082 m\u2081\u2261m\u2082) a\u2208m\u2082))\n    ... | no  a\u2209m | no  a\u2209m\u2081 | no a\u2209m\u2082 with from \u2208-\u222a a\u2208\u2081\n    ... | inj\u2081 a\u2208m = \u22a5-elim (a\u2209m a\u2208m)\n    ... | inj\u2082 a\u2208m\u2081 = \u22a5-elim (a\u2209m\u2081 a\u2208m\u2081)\n\n\n    fold-\u25c7-union-comm  :  {m\u2081 m\u2082 : A \u21c0 B} {a : A}\n                          {a\u2208\u2081 : a \u2208 dom m\u2081 \u222a dom m\u2082}\n                          {a\u2208\u2082 : a \u2208 dom m\u2082 \u222a dom m\u2081}\n                       \u2192  \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 (\u2208-incl-set a\u2208\u2081 .proj\u2081)\n                       \u2261  \u2225 m\u2082 \u222a\u207a m\u2081 \u2225 (\u2208-incl-set a\u2208\u2082 .proj\u2081)\n\n    fold-\u25c7-union-comm {m\u2081} {m\u2082} {a} {a\u2208\u2081} with a \u2208? dom m\u2081 | a \u2208? dom m\u2082\n    ... | yes a\u2208m\u2081 | yes a\u2208m\u2082 = \u25c7comm (lookup\u1d50 m\u2081 a) (lookup\u1d50 m\u2082 a)\n    ... | no  a\u2209m\u2081 | yes a\u2208m\u2082 = refl\n    ... | yes a\u2208m\u2081 | no  a\u2209m\u2082 = refl\n    ... | no  a\u2209m\u2081 | no  a\u2209m\u2082 with from \u2208-\u222a a\u2208\u2081\n    ... | inj\u2081 a\u2208m\u2081 = \u22a5-elim (a\u2209m\u2081 a\u2208m\u2081)\n    ... | inj\u2082 a\u2208m\u2082 = \u22a5-elim (a\u2209m\u2082 a\u2208m\u2082)\n\n\n    \u222a\u207a-comm-\u2286 : {m\u2081 m\u2082 : A \u21c0 B} \u2192 m\u2081 \u222a\u207a m\u2082 \u2286 m\u2082 \u222a\u207a m\u2081\n    \u222a\u207a-comm-\u2286 {m\u2081} {m\u2082} {a} {b} ab\u2208 with a \u2208? dom m\u2081 | a \u2208? dom m\u2082\n    ... | yes a\u2208m\u2081 | _ = to \u2208-map $ (a , \u2208-incl-set a\u2208\u02d8 .proj\u2081)\n                                  , \u00d7-\u2261,\u2261\u2192\u2261 (refl , b\u2261) , \u2208-incl-set a\u2208\u2082 .proj\u2082\n      where\n      a\u2208\u2082 : a \u2208 unions (fromList (dom m\u2082 \u2237 dom m\u2081 \u2237 [])) .proj\u2081\n      a\u2208\u2082 = to \u2208-unions (dom m\u2081 , to \u2208-fromList (there (here refl)) , a\u2208m\u2081)\n\n      a\u2208\u02d8 : a \u2208 dom m\u2082 \u222a dom m\u2081\n      a\u2208\u02d8 = to \u2208-\u222a (inj\u2082 a\u2208m\u2081)\n\n      b\u2261 : b \u2261 fold id id _\u25c7_ (unionThese m\u2082 m\u2081 a $ \u2208-incl-set a\u2208\u02d8 .proj\u2081)\n      b\u2261 = trans (\u222a\u207a-unique-val (to \u2208-\u222a $ inj\u2081 a\u2208m\u2081) ab\u2208) fold-\u25c7-union-comm\n\n    ... | no a\u2209m\u2081 | yes a\u2208m\u2082 = to \u2208-map $ (a , \u2208-incl-set a\u2208\u02d8 .proj\u2081)\n                                        , \u00d7-\u2261,\u2261\u2192\u2261 (refl , b\u2261) , \u2208-incl-set a\u2208\u2082 .proj\u2082\n      where\n      a\u2208\u2082 : a \u2208 unions (fromList (dom m\u2082 \u2237 dom m\u2081 \u2237 [])) .proj\u2081\n      a\u2208\u2082 = to \u2208-unions (dom m\u2082 , to \u2208-fromList (here refl) , a\u2208m\u2082)\n\n      a\u2208\u02d8 : a \u2208 dom m\u2082 \u222a dom m\u2081\n      a\u2208\u02d8 = to \u2208-\u222a $ inj\u2081 a\u2208m\u2082\n\n      b\u2261 : b \u2261 fold id id _\u25c7_ (unionThese m\u2082 m\u2081 a (\u2208-incl-set a\u2208\u02d8 .proj\u2081))\n      b\u2261 = trans (\u222a\u207a-unique-val (to \u2208-\u222a (inj\u2082 a\u2208m\u2082)) ab\u2208) fold-\u25c7-union-comm\n\n    ... | no  a\u2209m\u2081 | no a\u2209m\u2082 with from \u2208-\u222a (\u222a\u207a-dom\u222a ab\u2208)\n    ... | inj\u2081 a\u2208m\u2081 = \u22a5-elim (a\u2209m\u2081 a\u2208m\u2081)\n    ... | inj\u2082 a\u2208m\u2082 = \u22a5-elim (a\u2209m\u2082 a\u2208m\u2082)\n\n\n    \u222a\u207a-comm : {m\u2081 m\u2082 : A \u21c0 B} \u2192 m\u2081 \u222a\u207a m\u2082 \u2261\u1d50 m\u2082 \u222a\u207a m\u2081\n    \u222a\u207a-comm = \u222a\u207a-comm-\u2286 , \u222a\u207a-comm-\u2286\n\n    \u222a\u207a-comm-val  :  {m\u2081 m\u2082 : A \u21c0 B}\n                    {k\u2208m\u2081\u2082 : k \u2208 dom m\u2081 \u222a dom m\u2082}\n                    {k\u2208m\u2082\u2081 : k \u2208 dom m\u2082 \u222a dom m\u2081}\n                 \u2192  \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208m\u2081\u2082 \u2261 \u2225 m\u2082 \u222a\u207a m\u2081 \u2225 k\u2208m\u2082\u2081\n    \u222a\u207a-comm-val {k = k} {m\u2081 = m\u2081}{m\u2082}{k\u2208m\u2081\u2082}{k\u2208m\u2082\u2081} = (m\u2081 \u222a\u207a m\u2082) .proj\u2082 kv\u2208\u2081\u2082 (\u222a\u207a-comm-\u2286 kv\u2208\u2082\u2081)\n      where\n      kv\u2208\u2081\u2082 : (k , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208m\u2081\u2082) \u2208 m\u2081 \u222a\u207a m\u2082\n      kv\u2208\u2081\u2082 = subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081 \u222a\u207a m\u2082) fold-irrelevance (k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208m\u2081\u2082)\n\n      kv\u2208\u2082\u2081 : (k , \u2225 m\u2082 \u222a\u207a m\u2081 \u2225 k\u2208m\u2082\u2081) \u2208 m\u2082 \u222a\u207a m\u2081\n      kv\u2208\u2082\u2081 = subst (\u03bb x \u2192 (k , x) \u2208 m\u2082 \u222a\u207a m\u2081) fold-irrelevance (k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208m\u2082\u2081)\n\n\n    \u222a\u207a-cong-\u2286\u02e1 : {m m\u2081 m\u2082 : A \u21c0 B} \u2192 m\u2081 \u2261\u1d50 m\u2082 \u2192 m \u222a\u207a m\u2081 \u2286 m \u222a\u207a m\u2082\n    \u222a\u207a-cong-\u2286\u02e1 {m}{m\u2081}{m\u2082} m\u2081\u2261m\u2082@(m\u2081\u2286m\u2082 , m\u2082\u2286m\u2081) {k} {v} kv\u2208 with from \u2208-map kv\u2208\n    ... | (.k , k\u2208) , refl , s =\n      let k\u2208'' , \u2208inclset = \u2208-incl-set k\u2208'\n          \u2261F : (k , v) \u2261 F[ m , m\u2082 ] (k , k\u2208'')\n          \u2261F = \u00d7-\u2261,\u2261\u2192\u2261 (refl , deconstruct-\u222a\u207a {a\u2208\u2081 = k\u2208} m\u2081\u2261m\u2082)\n      in  to (\u2208-map {f = F[ m , m\u2082 ]}) ((k , k\u2208'') , \u2261F , \u2208inclset)\n      where\n      a\u2208-\u222adom\u2081 : k \u2208 dom m \u222a dom m\u2081\n      a\u2208-\u222adom\u2081 = dom\u222a\u207a\u2286\u222adom (to dom\u2208 (v , kv\u2208))\n\n      dom\u2081\u2286dom\u2082 : dom m\u2081 \u2286 dom m\u2082\n      dom\u2081\u2286dom\u2082 = dom\u2286 m\u2081\u2286m\u2082\n\n      k\u2208' : k \u2208 dom m \u222a dom m\u2082\n      k\u2208' = \u222a-cong-\u2286 id dom\u2081\u2286dom\u2082 a\u2208-\u222adom\u2081\n\n    \u222a\u207a-cong-l : {m : A \u21c0 B} \u2192 (m \u222a\u207a_ ) Preserves _\u2261\u1d50_ \u27f6 _\u2261\u1d50_\n    \u222a\u207a-cong-l m\u2081\u2261m\u2082@(m\u2081\u2286m\u2082 , m\u2082\u2286m\u2081) = (\u222a\u207a-cong-\u2286\u02e1 m\u2081\u2261m\u2082) , \u222a\u207a-cong-\u2286\u02e1 (m\u2082\u2286m\u2081 , m\u2081\u2286m\u2082)\n\n    \u222a\u207a-cong-r : {m : A \u21c0 B} \u2192 ( _\u222a\u207a m) Preserves _\u2261\u1d50_ \u27f6 _\u2261\u1d50_\n    \u222a\u207a-cong-r m\u2081\u2261m\u2082 .proj\u2081 kv\u2208m\u2081m = proj\u2081 \u222a\u207a-comm (\u222a\u207a-cong-\u2286\u02e1 m\u2081\u2261m\u2082 (proj\u2081 \u222a\u207a-comm kv\u2208m\u2081m))\n    \u222a\u207a-cong-r m\u2081\u2261m\u2082@(m\u2081\u2286m\u2082 , m\u2082\u2286m\u2081) .proj\u2082 kv\u2208m\u2082m =\n      proj\u2081 \u222a\u207a-comm (\u222a\u207a-cong-\u2286\u02e1 (m\u2082\u2286m\u2081 , m\u2081\u2286m\u2082) (proj\u2081 \u222a\u207a-comm kv\u2208m\u2082m))\n\n    \u222a\u207a-dom-id : (m : A \u21c0 B) \u2192 dom m \u2261\u1d49 dom m \u222a dom (\u2205{A \u21c0 B})\n    \u222a\u207a-dom-id m = begin\n      dom m \u2248\u02d8\u27e8 \u222a-identity\u02b3 (dom m) \u27e9\n      dom m \u222a \u2205 \u2248\u02d8\u27e8 \u222a-cong \u2261\u1d49.refl dom\u2205 \u27e9\n      dom m \u222a dom (\u2205{A \u21c0 B})\n      \u220e\n      where\n      open SetoidReasoning (\u2261\u1d49-Setoid{A})\n      module \u2261\u1d49 = IsEquivalence (\u2261\u1d49-isEquivalence {A})\n\n    \u222a\u207a-id-dom\u2208 :  (m : A \u21c0 B) \u2192 k \u2208 dom m  \u21d4  k \u2208 dom m \u222a dom (\u2205{A \u21c0 B})\n    \u222a\u207a-id-dom\u2208 m = mk\u21d4 (\u222a\u207a-dom-id m .proj\u2081) (\u222a\u207a-dom-id m .proj\u2082)\n\n    \u222a\u207a-id-lemma  :  (m : A \u21c0 B)\n                    (k\u2208m : k \u2208 dom m)\n                    (k\u2208 : k \u2208 dom m \u222a dom (\u2205{A \u21c0 B}))\n                 \u2192  lookup\u1d50\u2208 m k\u2208m \u2261 \u2225 m \u222a\u207a \u2205{A \u21c0 B} \u2225 k\u2208\n\n    \u222a\u207a-id-lemma {k} m k\u2208domm k\u2208domm\u222a with k \u2208? dom m | k \u2208? dom (\u2205{A \u21c0 B})\n    ... | _ | yes  k\u2208\u2205 = \u22a5-elim (\u22a5-elim (\u2209-dom\u2205 k\u2208\u2205))\n    ... | no  k\u2209m | no  k\u2209\u2205 = case from \u2208-\u222a k\u2208domm\u222a of \u03bb where\n      (inj\u2081 k\u2208m) \u2192 \u22a5-elim (k\u2209m k\u2208m)\n      (inj\u2082 k\u2208\u2205) \u2192 \u22a5-elim (k\u2209\u2205 k\u2208\u2205)\n    ... | yes k\u2208m | no  k\u2209\u2205 with from \u2208-map k\u2208domm\n    ... | (.k , v) , refl , kv\u2208m = m .proj\u2082 kv\u2208m (\u2208-lookup\u1d50\u2208 m k\u2208m)\n                                  -- goal : v \u2261 lookup\u1d50\u2208 m k\u2208m --\n\n    \u222a\u207a-id-r : (m : A \u21c0 B) \u2192 m \u222a\u207a \u2205{A \u21c0 B} \u2261\u1d50 m\n    \u222a\u207a-id-r m .proj\u2081 {(k , v)} kv\u2208m\u2205 with from \u2208-map kv\u2208m\u2205\n    ... | (.k , k\u2208) , refl , snd = subst  (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m)\n                                          (\u222a\u207a-id-lemma m (from (\u222a\u207a-id-dom\u2208 m) k\u2208) k\u2208)\n                                          (\u2208-lookup\u1d50\u2208 m $ from (\u222a\u207a-id-dom\u2208 m) k\u2208)\n\n    \u222a\u207a-id-r m .proj\u2082 {(k , v)} kv\u2208m with to dom\u2208 (v , kv\u2208m)\n    ... | k\u2208m =\n      subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m \u222a\u207a \u2205{A \u21c0 B}) (trans lu\u2261 v\u2261) (k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208)\n      where\n      k\u2208 : k \u2208 dom m \u222a dom (\u2205{A \u21c0 B})\n      k\u2208 = to (\u222a\u207a-id-dom\u2208 m) k\u2208m\n\n      lu\u2261 : \u2225 m \u222a\u207a (\u2205{A \u21c0 B}) \u2225 (\u2208-incl-set k\u2208 .proj\u2081) \u2261 lookup\u1d50\u2208 m (\u2208-incl-set k\u2208m .proj\u2081)\n      lu\u2261 = sym $ \u222a\u207a-id-lemma m (\u2208-incl-set k\u2208m .proj\u2081) (\u2208-incl-set k\u2208 .proj\u2081)\n\n      v\u2261 : lookup\u1d50\u2208 m (\u2208-incl-set k\u2208m .proj\u2081) \u2261 v\n      v\u2261 = sym $ m .proj\u2082 kv\u2208m (\u2208-lookup\u1d50\u2208 m (\u2208-incl-set k\u2208m .proj\u2081))\n\n    restrict-cong : (m\u2081 m\u2082 : A \u21c0 B) {ks : \u2119 A} \u2192 m\u2081 \u2261\u1d50 m\u2082 \u2192 (m\u2081 \u2223 ks \u1d9c) \u2261\u1d50 (m\u2082 \u2223 ks \u1d9c)\n    restrict-cong m\u2081 m\u2082 (m\u2081\u2286m\u2082 , _) .proj\u2081 ab\u2208 with res\u1d9c-dom\u2209\u207b m\u2081 ab\u2208\n    ... | ab\u2208 , a\u2209 = res\u1d9c-dom\u2209\u207a m\u2082 (m\u2081\u2286m\u2082 ab\u2208 , a\u2209)\n    restrict-cong m\u2081 m\u2082 (_ , m\u2082\u2286m\u2081) .proj\u2082 ab\u2208 with res\u1d9c-dom\u2209\u207b m\u2082 ab\u2208\n    ... | ab\u2208 , a\u2209 = res\u1d9c-dom\u2209\u207a m\u2081 (m\u2082\u2286m\u2081 ab\u2208 , a\u2209)\n\n\n  module _ {P : A \u2192 Type} \u2983 _ : P \u2047\u00b9 \u2984 where\n\n    P\u2032 : A \u00d7 B \u2192 Type\n    P\u2032 (k , _) = P k\n\n    P\u2192P\u2032 : P k \u2192 \u2200 b \u2192 P\u2032 (k , b)\n    P\u2192P\u2032 = \u03bb z _ \u2192 z\n\n    \u2208-dom-filter-P : (m : A \u21c0 B) \u2192 k \u2208 dom (filter\u1d50 P\u2032 m) \u2192 P k\n    \u2208-dom-filter-P _ k\u2208Pm = \u2208-filter .from (dom\u2208 .from k\u2208Pm .proj\u2082) .proj\u2081\n\n    \u2208-dom-filter-dom : (m : A \u21c0 B) \u2192 k \u2208 dom (filter\u1d50 P\u2032 m) \u2192 k \u2208 dom m\n    \u2208-dom-filter-dom m k\u2208domf with from dom\u2208 k\u2208domf\n    ... | b , kb\u2208filter = to dom\u2208 (b , proj\u2082 ((from \u2208-filter) kb\u2208filter))\n\n    dom-filter-\u2286 : (m : A \u21c0 B) \u2192 dom (filter\u1d50 P\u2032 m) \u2286 dom m\n    dom-filter-\u2286 m k\u2208Pm = dom\u2208 .to (_ , filter-\u2286 (dom\u2208 .from k\u2208Pm .proj\u2082))\n\n    \u2208-dom-filter\u02e1 : (m : A \u21c0 B) \u2192 k \u2208 dom (filter\u1d50 P\u2032 m) \u2192 P k \u00d7 k \u2208 dom m\n    \u2208-dom-filter\u02e1 m h = \u2208-dom-filter-P m h , \u2208-dom-filter-dom m h\n\n    \u2208-dom-filter\u02b3 : (m : A \u21c0 B) \u2192 P k \u00d7 k \u2208 dom m \u2192 k \u2208 dom (filter\u1d50 P\u2032 m)\n    \u2208-dom-filter\u02b3 m (pk , k\u2208) = dom\u2208 .to ( (from dom\u2208 k\u2208) .proj\u2081\n                                         , to \u2208-filter (pk , (from dom\u2208 k\u2208) .proj\u2082 ) )\n\n    filter\u1d50-\u2208 : (m : A \u21c0 B) {k : A} {v : B} \u2192 P k \u2192 (k , v) \u2208 m \u2192 (k , v) \u2208 filter\u1d50 P\u2032 m\n    filter\u1d50-\u2208 m = curry $ to \u2208-filter\n\n    cong-filter\u1d50 : (m\u2081 m\u2082 : A \u21c0 B) \u2192 m\u2081 \u2261\u1d50 m\u2082 \u2192 filter\u1d50 P\u2032 m\u2081 \u2261\u1d50 filter\u1d50 P\u2032 m\u2082\n    cong-filter\u1d50 m\u2081 m\u2082 eq .proj\u2081 \u2208Pm\u2081 = filter\u1d50-\u2208 m\u2082 (\u2208-dom-filter\u02e1 m\u2081 (\u2208-dom \u2208Pm\u2081) .proj\u2081) (eq .proj\u2081 (\u2208-filter .from \u2208Pm\u2081 .proj\u2082))\n    cong-filter\u1d50 m\u2081 m\u2082 eq .proj\u2082 \u2208Pm\u2082 = filter\u1d50-\u2208 m\u2081 (\u2208-dom-filter\u02e1 m\u2082 (\u2208-dom \u2208Pm\u2082) .proj\u2081) (eq .proj\u2082 (\u2208-filter .from \u2208Pm\u2082 .proj\u2082))\n\n    \u222a\u207a-filter-P\u2032 : (m\u2081 m\u2082 : A \u21c0 B) \u2192 (k , v) \u2208 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082 \u2192 P\u2032 (k , v)\n    \u222a\u207a-filter-P\u2032 {k = k}{v} m\u2081 m\u2082 kv\u2208 with (from \u2208-\u222a (\u222a\u207a-dom\u222a kv\u2208))\n    ... | inj\u2081 k\u2208\u2081 = \u2208-dom-filter\u02e1 m\u2081 k\u2208\u2081 .proj\u2081\n    ... | inj\u2082 k\u2208\u2082 = \u2208-dom-filter\u02e1 m\u2082 k\u2208\u2082 .proj\u2081\n\n    lookup\u2261lookup-filter  : (m : A \u21c0 B) (k\u2208 : k \u2208 dom m) (k\u2208\u2032 : k \u2208 dom (filter\u1d50 P\u2032 m))\n                          \u2192 lookup\u1d50\u2208 m k\u2208 \u2261 lookup\u1d50\u2208 (filter\u1d50 P\u2032 m) k\u2208\u2032\n    lookup\u2261lookup-filter m k\u2208 k\u2208\u2032 =\n      (m .proj\u2082) (\u2208-lookup\u1d50\u2208 m k\u2208) (proj\u2082 (from \u2208-filter (\u2208-lookup\u1d50\u2208 (filter\u1d50 P\u2032 m) k\u2208\u2032)))\n\n    \u2208-\u222a\u207a-l'  : {m\u2081 m\u2082 : A \u21c0 B} {k\u2208m\u2081 : k \u2208 dom m\u2081} {k\u2208m\u2081m\u2082 : k \u2208 dom m\u2081 \u222a dom m\u2082}\n             \u2192 (k , v) \u2208 m\u2081 \u222a\u207a m\u2082 \u2192 k \u2209 dom m\u2082\n             \u2192 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 (\u2208-incl-set k\u2208m\u2081m\u2082 .proj\u2081) \u2261 lookup\u1d50\u2208 m\u2081 k\u2208m\u2081\n    \u2208-\u222a\u207a-l' {k = k} {m\u2081 = m\u2081} {m\u2082} {k\u2208m\u2081} {k\u2208m\u2081m\u2082} kv\u2208m\u2081m\u2082 k\u2209m\u2082 with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n    ... | _ | yes k\u2208\u2082 = \u22a5-elim (k\u2209m\u2082 k\u2208\u2082)\n    ... | no k\u2209\u2081 | _ = \u22a5-elim (k\u2209\u2081 k\u2208m\u2081)\n    ... | yes k\u2208\u2081 | no k\u2209\u2082 with from \u2208-map k\u2208m\u2081\n    ... | (.k , v) , refl , kv\u2208m\u2081 = m\u2081 .proj\u2082 (\u2208-lookup\u1d50\u2208 m\u2081 k\u2208\u2081) kv\u2208m\u2081\n\n    \u2208-\u222a\u207a-l  : {m\u2081 m\u2082 : A \u21c0 B} (k\u2208m\u2081 : k \u2208 dom m\u2081)\n            \u2192 (k , v) \u2208 m\u2081 \u222a\u207a m\u2082 \u2192 k \u2209 dom m\u2082\n            \u2192 v \u2261 lookup\u1d50\u2208 m\u2081 k\u2208m\u2081\n    \u2208-\u222a\u207a-l k\u2208m\u2081 kv\u2208\u2081\u2082 k\u2209m\u2082 = trans (\u222a\u207a-unique-val (\u222a\u207a-dom\u222a kv\u2208\u2081\u2082) kv\u2208\u2081\u2082) (\u2208-\u222a\u207a-l' kv\u2208\u2081\u2082 k\u2209m\u2082)\n\n\n    \u222a\u207a-filter  : (m\u2081 m\u2082 : A \u21c0 B) {a : A} {b : B}\n               \u2192 (a , b) \u2208 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082\n               \u2192 a \u2208 dom m\u2081 \u2192 a \u2209 dom m\u2082 \u2192 (a , b) \u2208 filter\u1d50 P\u2032 m\u2081\n    \u222a\u207a-filter m\u2081 m\u2082 {a} {b} ab\u2208' a\u2208 a\u2209 =\n      subst (\u03bb \u2022 \u2192 (a , \u2022) \u2208 filter\u1d50 P\u2032 m\u2081) (sym $ \u2208-\u222a\u207a-l a\u2208f\u2081 ab\u2208' a\u2209f\u2082)\n                                            (from dom\u2208 a\u2208f\u2081 .proj\u2082)\n      where\n      a\u2208f\u2081 : a \u2208 dom (filter\u1d50 P\u2032 m\u2081)\n      a\u2208f\u2081 = \u2208-dom-filter\u02b3 m\u2081 (\u222a\u207a-filter-P\u2032 m\u2081 m\u2082 ab\u2208' , a\u2208)\n\n      a\u2209f\u2082 : a \u2209 dom (filter\u1d50 P\u2032 m\u2082)\n      a\u2209f\u2082 = a\u2209 \u2218 (\u2208-dom-filter-dom m\u2082)\n\n    \u222a\u207a-filter-lookup\u2261  : \u2200 (m\u2081 m\u2082 : A \u21c0 B) {a : A} {b : B}\n                       \u2192 (a , b) \u2208 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082\n                       \u2192 (a\u2208 : a \u2208 dom m\u2081) \u2192 a \u2209 dom m\u2082\n                       \u2192 b \u2261 lookup\u1d50\u2208 m\u2081 a\u2208\n    \u222a\u207a-filter-lookup\u2261 m\u2081 m\u2082 {a} {b} ab\u2208' a\u2208 a\u2209 =\n      proj\u2082 m\u2081 (from \u2208-filter (\u222a\u207a-filter m\u2081 m\u2082 ab\u2208' a\u2208 a\u2209) .proj\u2082) (from dom\u2208 a\u2208 .proj\u2082)\n\n    \u2208-\u222a\u207a-filter\u02e1  : {m\u2081 m\u2082 : A \u21c0 B} \u2192 (k , v) \u2208 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082\n                  \u2192 (k\u2208\u222adom : k \u2208 dom m\u2081 \u222a dom m\u2082) \u2192 k \u2208 dom (m\u2081 \u222a\u207a m\u2082)\n                  \u2192 These (k \u2208 dom(filter\u1d50 P\u2032 m\u2081)) (k \u2208 dom(filter\u1d50 P\u2032 m\u2082))\n                  \u2192 v \u2261 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u222adom\n\n    \u2208-\u222a\u207a-filter\u02e1 {k = k} {v} {m\u2081}{m\u2082} kv\u2208\u2032 k\u2208\u222adom k\u2208dom\u222a\u207a (this k\u2208m\u2081\u2032) with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n    ... | no \u2209\u2081 | _ = \u22a5-elim $ \u2209\u2081 $ to dom\u2208 ( from dom\u2208 k\u2208m\u2081\u2032 .proj\u2081\n                                            , from \u2208-filter (proj\u2082 $ from dom\u2208 k\u2208m\u2081\u2032) .proj\u2082 )\n    ... | yes \u2208\u2081 | no  \u2209\u2082 = trans (\u222a\u207a-filter-lookup\u2261 m\u2081 m\u2082 kv\u2208\u2032 \u2208\u2081 \u2209\u2082) (lookup\u1d50\u2208\u2261 m\u2081)\n    ... | yes \u2208\u2081 | yes \u2208\u2082 = begin\n      v                                         \u2261\u27e8 \u222a\u207a-unique-val (\u222a\u207a-dom\u222a kv\u2208\u2032) kv\u2208\u2032 \u27e9\n      \u2225 m\u2081\u2032 \u222a\u207a m\u2082\u2032 \u2225 _                          \u2261\u27e8 \u2225\u222a\u207a\u2225\u2261lu\u25c7lu' kv\u2208\u2032 \u27e9\n      lookup\u1d50\u2208 m\u2081\u2032 k\u2208m\u2081\u2032 \u25c7 lookup\u1d50\u2208 m\u2082\u2032 k\u2208m\u2082\u2032   \u2261\u02d8\u27e8 cong (lookup\u1d50\u2208 m\u2081\u2032 k\u2208m\u2081\u2032 \u25c7_)\n                                                         (lookup\u2261lookup-filter m\u2082 \u2208\u2082 k\u2208m\u2082\u2032) \u27e9\n      lookup\u1d50\u2208 m\u2081\u2032 k\u2208m\u2081\u2032 \u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082       \u2261\u02d8\u27e8 cong (_\u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082)\n                                                         (lookup\u2261lookup-filter m\u2081 \u2208\u2081 k\u2208m\u2081\u2032) \u27e9\n      lookup\u1d50\u2208 m\u2081 \u2208\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082           \u220e\n        where\n        open \u2261-Reasoning\n        m\u2081\u2032 m\u2082\u2032 : A \u21c0 B\n        m\u2081\u2032 = filter\u1d50 P\u2032 m\u2081\n        m\u2082\u2032 = filter\u1d50 P\u2032 m\u2082\n\n        k\u2208m\u2082\u2032 : k \u2208 dom (filter\u1d50 P\u2032 m\u2082)\n        k\u2208m\u2082\u2032 = \u2208-dom-filter\u02b3 m\u2082 (proj\u2081 (\u2208-dom-filter\u02e1 m\u2081 k\u2208m\u2081\u2032) , \u2208\u2082)\n\n    \u2208-\u222a\u207a-filter\u02e1 {k = k} {v = v} {m\u2081 = m\u2081} {m\u2082} kv\u2208\u2032 k\u2208\u222adom\u2081\u2082 k\u2208dom\u222a\u2081\u2082 (that k\u2208m\u2082\u2032)\n      = trans v\u2261m\u2082m\u2081 \u222a\u207a-comm-val\n        where\n        v\u2261m\u2082m\u2081 : v \u2261 \u2225 m\u2082 \u222a\u207a m\u2081 \u2225 _\n        v\u2261m\u2082m\u2081 = \u2208-\u222a\u207a-filter\u02e1 (\u222a\u207a-comm-\u2286 kv\u2208\u2032)\n                              (proj\u2081 (\u222a-comm (dom m\u2081) (dom m\u2082)) k\u2208\u222adom\u2081\u2082)\n                              (dom\u2286 \u222a\u207a-comm-\u2286 k\u2208dom\u222a\u2081\u2082) (this k\u2208m\u2082\u2032)\n\n    \u2208-\u222a\u207a-filter\u02e1 {k = k} {v = v} {m\u2081 = m\u2081} {m\u2082} kv\u2208\u2032 k\u2208\u222adom k\u2208dom\u222a\u207a (these k\u2208m\u2081\u2032 k\u2208m\u2082\u2032)\n      with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n    ... | no \u2209\u2081 | _ = \u22a5-elim $ \u2209\u2081 $ to dom\u2208 ( from dom\u2208 k\u2208m\u2081\u2032 .proj\u2081\n                                            , from \u2208-filter (proj\u2082 $ from dom\u2208 k\u2208m\u2081\u2032) .proj\u2082 )\n    ... | yes \u2208\u2081 | no  \u2209\u2082 = trans (\u222a\u207a-filter-lookup\u2261 m\u2081 m\u2082 kv\u2208\u2032 \u2208\u2081 \u2209\u2082) (lookup\u1d50\u2208\u2261 m\u2081)\n    ... | yes \u2208\u2081 | yes \u2208\u2082 = let open \u2261-Reasoning; m\u2081\u2032 = filter\u1d50 P\u2032 m\u2081; m\u2082\u2032 = filter\u1d50 P\u2032 m\u2082 in\n      begin\n      v                                    \u2261\u27e8 \u222a\u207a-unique-val (\u222a\u207a-dom\u222a kv\u2208\u2032) kv\u2208\u2032 \u27e9\n      \u2225 m\u2081\u2032 \u222a\u207a m\u2082\u2032 \u2225 _                     \u2261\u27e8 \u2225\u222a\u207a\u2225\u2261lu\u25c7lu' kv\u2208\u2032 \u27e9\n      lookup\u1d50\u2208 m\u2081\u2032 _ \u25c7 lookup\u1d50\u2208 m\u2082\u2032 k\u2208m\u2082\u2032  \u2261\u02d8\u27e8 cong (lookup\u1d50\u2208 m\u2081\u2032 _ \u25c7_) (lookup\u2261lookup-filter m\u2082 \u2208\u2082 _) \u27e9\n      lookup\u1d50\u2208 m\u2081\u2032 k\u2208m\u2081\u2032 \u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082  \u2261\u02d8\u27e8 cong (_\u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082) (lookup\u2261lookup-filter m\u2081 \u2208\u2081 _) \u27e9\n      lookup\u1d50\u2208 m\u2081 \u2208\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082      \u220e\n\n\n    opaque\n      open Equivalence\n\n      --------------------------------------------------------------------------------------------------\n      -- filter\u1d50-\u222a\u207a-distr  -----------------------------------------------------------------------------\n      -- Note: this property only holds because P\u2032 is not looking at the value.\n      -- Counter-example if it does look at the value:\n      -- Suppose `m\u2081\u02e2 = m\u2082\u02e2 = {(0, 1)}`, `P\u2032 (0, 1)`, and `\u00ac P\u2032 (0, 2)`.\n      -- Then `m\u2081 \u222a\u207a m\u2082 \u2261 {(0, 2)}` so (lhs) `filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)` is empty,\n      -- but `(filter\u1d50 P\u2032 m\u2081)\u02e2 \u2261 (filter\u1d50 P\u2032 m\u2082)\u02e2 = {(0, 1)}` so (rhs) `filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082` contains {(0, 2)}.\n\n      filter\u1d50-\u222a\u207a-distr-\u2287 : (m\u2081 m\u2082 : A \u21c0 B) \u2192 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082 \u2286 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)\n      filter\u1d50-\u222a\u207a-distr-\u2287 m\u2081 m\u2082 {k} {v} kv\u2208Pm\u2081Pm\u2082 =\n        case \u00bf P k \u00bf of \u03bb where\n          (yes pk) \u2192 yes-case pk\n          (no \u00acpk) \u2192 \u22a5-elim (\u00acpk ([ \u2208-dom-filter-P m\u2081 , \u2208-dom-filter-P m\u2082 ]\u2032 k\u2208Pm\u2081\u2228k\u2208Pm\u2082))\n        where\n          open \u2261-Reasoning\n          k\u2208Pm\u2081\u2228k\u2208Pm\u2082 : k \u2208 dom (filter\u1d50 P\u2032 m\u2081) \u228e k \u2208 dom (filter\u1d50 P\u2032 m\u2082)\n          k\u2208Pm\u2081\u2228k\u2208Pm\u2082 = \u2208-\u222a .from (dom\u222a\u207a\u2286\u222adom (\u2208-map\u2032 kv\u2208Pm\u2081Pm\u2082))\n\n          k\u2208Pm\u2081\u2295k\u2208Pm\u2082 : These (k \u2208 dom (filter\u1d50 P\u2032 m\u2081)) (k \u2208 dom (filter\u1d50 P\u2032 m\u2082))\n          k\u2208Pm\u2081\u2295k\u2208Pm\u2082 with k \u2208? dom (filter\u1d50 P\u2032 m\u2081) | k \u2208? dom (filter\u1d50 P\u2032 m\u2082) | k\u2208Pm\u2081\u2228k\u2208Pm\u2082\n          ... | yes \u2208\u2081 | yes \u2208\u2082 | _       = these \u2208\u2081 \u2208\u2082\n          ... | yes \u2208\u2081 | no  _  | _       = this \u2208\u2081\n          ... | no  _  | yes \u2208\u2082 | _       = that \u2208\u2082\n          ... | no  \u2209\u2081 | no  _  | inj\u2081 \u2208\u2081 = \u22a5-elim (\u2209\u2081 \u2208\u2081)\n          ... | no  _  | no  \u2209\u2082 | inj\u2082 \u2208\u2082 = \u22a5-elim (\u2209\u2082 \u2208\u2082)\n\n          yes-case : P k \u2192 (k , v) \u2208 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)\n          yes-case pk = \u2208-filter .to (pk , kv\u2208m\u2081m\u2082)\n            where\n              k\u2208m\u2081\u2228k\u2208m\u2082 : k \u2208 dom m\u2081 \u228e k \u2208 dom m\u2082\n              k\u2208m\u2081\u2228k\u2208m\u2082 = map-\u228e (dom-filter-\u2286 m\u2081) (dom-filter-\u2286 m\u2082) k\u2208Pm\u2081\u2228k\u2208Pm\u2082\n\n              k\u2208m\u2081m\u2082 : k \u2208 dom m\u2081 \u222a dom m\u2082\n              k\u2208m\u2081m\u2082 = \u2208-\u222a .to k\u2208m\u2081\u2228k\u2208m\u2082\n\n              k\u2208m\u2081m\u2082\u207a : k \u2208 dom (m\u2081 \u222a\u207a m\u2082)\n              k\u2208m\u2081m\u2082\u207a = \u222adom\u2286dom\u222a\u207a k\u2208m\u2081m\u2082\n\n              [kv\u2032\u2208m\u2081m\u2082] : \u03a3 (k \u2208 dom m\u2081 \u222a dom m\u2082) (\u03bb k\u2208m\u2081m\u2082\u2032 \u2192 (k , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208m\u2081m\u2082\u2032) \u2208 m\u2081 \u222a\u207a m\u2082)\n              [kv\u2032\u2208m\u2081m\u2082] = _ , \u2208-map\u2032 (\u2208-incl-set k\u2208m\u2081m\u2082 .proj\u2082)\n\n              k\u2208m\u2081m\u2082\u2032 : k \u2208 dom m\u2081 \u222a dom m\u2082\n              k\u2208m\u2081m\u2082\u2032  = [kv\u2032\u2208m\u2081m\u2082] .proj\u2081\n\n              k\u2208m\u2081\u222a\u207am\u2082 : k \u2208 dom (m\u2081 \u222a\u207a m\u2082)\n              k\u2208m\u2081\u222a\u207am\u2082  = \u222adom\u2286dom\u222a\u207a k\u2208m\u2081m\u2082\u2032\n\n              v\u2032 : B\n              v\u2032 = \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208m\u2081m\u2082\u2032\n\n              kv\u2032\u2208m\u2081m\u2082 : (k , v\u2032) \u2208 m\u2081 \u222a\u207a m\u2082\n              kv\u2032\u2208m\u2081m\u2082 = [kv\u2032\u2208m\u2081m\u2082] .proj\u2082\n\n              v=v\u2032 : v \u2261 v\u2032\n              v=v\u2032 = \u2208-\u222a\u207a-filter\u02e1 kv\u2208Pm\u2081Pm\u2082 k\u2208m\u2081m\u2082\u2032 k\u2208m\u2081\u222a\u207am\u2082 k\u2208Pm\u2081\u2295k\u2208Pm\u2082\n\n              kv\u2208m\u2081m\u2082 : (k , v) \u2208 m\u2081 \u222a\u207a m\u2082\n              kv\u2208m\u2081m\u2082 = subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081 \u222a\u207a m\u2082) (sym v=v\u2032) kv\u2032\u2208m\u2081m\u2082\n\n      filter\u1d50-\u222a\u207a-distr-\u2286 : (m\u2081 m\u2082 : A \u21c0 B) \u2192 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082) \u2286 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082\n      filter\u1d50-\u222a\u207a-distr-\u2286 m\u2081 m\u2082 {k} {v} kv\u2208Pm\u2081m\u2082 with from \u2208-filter kv\u2208Pm\u2081m\u2082\n      ... | Pkv , kv\u2208 with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n      ... | yes k\u2208\u2081 | yes k\u2208\u2082 =\n        subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032) ((m\u2081 \u222a\u207a m\u2082) .proj\u2082 kb\u2208 kv\u2208) (\u2203b .proj\u2082)\n          where\n          open \u2261-Reasoning\n          m\u2081\u2032 m\u2082\u2032 : A \u21c0 B; m\u2081\u2032 = filter\u1d50 P\u2032 m\u2081; m\u2082\u2032 = filter\u1d50 P\u2032 m\u2082\n\n          k\u2208\u222adom\u2032 : k \u2208 dom m\u2081\u2032 \u222a dom m\u2082\u2032\n          k\u2208\u222adom\u2032 = to \u2208-\u222a $ inj\u2081 (\u2208-dom-filter\u02b3 m\u2081 (Pkv , k\u2208\u2081))\n\n          \u2203b : \u03a3 B \u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032\n          \u2203b = \u2225 m\u2081\u2032 \u222a\u207a m\u2082\u2032 \u2225 (\u2208-incl-set k\u2208\u222adom\u2032 .proj\u2081) , k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208\u222adom\u2032\n\n          b : B\n          b = \u2203b .proj\u2081\n\n          kb\u2208\u2032 : (k , b) \u2208 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)\n          kb\u2208\u2032 = filter\u1d50-\u222a\u207a-distr-\u2287 m\u2081 m\u2082 (\u2203b .proj\u2082)\n\n          kb\u2208 : (k , b) \u2208 m\u2081 \u222a\u207a m\u2082\n          kb\u2208 = (from \u2208-filter kb\u2208\u2032) .proj\u2082\n\n      ... | no k\u2209\u2081 | yes k\u2208\u2082 =\n        subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032) ((m\u2081 \u222a\u207a m\u2082) .proj\u2082 kb\u2208 kv\u2208) (\u2203b .proj\u2082)\n          where\n          open \u2261-Reasoning\n          m\u2081\u2032 m\u2082\u2032 : A \u21c0 B; m\u2081\u2032 = filter\u1d50 P\u2032 m\u2081; m\u2082\u2032 = filter\u1d50 P\u2032 m\u2082\n\n          k\u2208\u222adom\u2032 : k \u2208 dom m\u2081\u2032 \u222a dom m\u2082\u2032\n          k\u2208\u222adom\u2032 = to \u2208-\u222a $ inj\u2082 (\u2208-dom-filter\u02b3 m\u2082 (Pkv , k\u2208\u2082))\n\n          \u2203b : \u03a3 B \u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032\n          \u2203b = \u2225 m\u2081\u2032 \u222a\u207a m\u2082\u2032 \u2225 (\u2208-incl-set k\u2208\u222adom\u2032 .proj\u2081) , k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208\u222adom\u2032\n\n          b : B\n          b = \u2203b .proj\u2081\n\n          kb\u2208\u2032 : (k , b) \u2208 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)\n          kb\u2208\u2032 = filter\u1d50-\u222a\u207a-distr-\u2287 m\u2081 m\u2082 (\u2203b .proj\u2082)\n\n          kb\u2208 : (k , b) \u2208 m\u2081 \u222a\u207a m\u2082\n          kb\u2208 = (from \u2208-filter kb\u2208\u2032) .proj\u2082\n\n\n      ... | yes k\u2208\u2081 | no k\u2209\u2082 =\n        subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032) ((m\u2081 \u222a\u207a m\u2082) .proj\u2082 kb\u2208 kv\u2208) (\u2203b .proj\u2082)\n          where\n          open \u2261-Reasoning\n          m\u2081\u2032 m\u2082\u2032 : A \u21c0 B; m\u2081\u2032 = filter\u1d50 P\u2032 m\u2081; m\u2082\u2032 = filter\u1d50 P\u2032 m\u2082\n\n          k\u2208\u222adom\u2032 : k \u2208 dom m\u2081\u2032 \u222a dom m\u2082\u2032\n          k\u2208\u222adom\u2032 = to \u2208-\u222a $ inj\u2081 (\u2208-dom-filter\u02b3 m\u2081 (Pkv , k\u2208\u2081))\n\n          \u2203b : \u03a3 B \u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032\n          \u2203b = \u2225 m\u2081\u2032 \u222a\u207a m\u2082\u2032 \u2225 (\u2208-incl-set k\u2208\u222adom\u2032 .proj\u2081) , k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208\u222adom\u2032\n\n          b : B\n          b = \u2203b .proj\u2081\n\n          kb\u2208\u2032 : (k , b) \u2208 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)\n          kb\u2208\u2032 = filter\u1d50-\u222a\u207a-distr-\u2287 m\u2081 m\u2082 (\u2203b .proj\u2082)\n\n          kb\u2208 : (k , b) \u2208 m\u2081 \u222a\u207a m\u2082\n          kb\u2208 = (from \u2208-filter kb\u2208\u2032) .proj\u2082\n\n      ... | no k\u2209\u2081 | no k\u2209\u2082 with from \u2208-\u222a (\u222a\u207a-dom\u222a kv\u2208)\n      ... | inj\u2081 k\u2208\u2081 = \u22a5-elim (k\u2209\u2081 k\u2208\u2081)\n      ... | inj\u2082 k\u2208\u2082 = \u22a5-elim (k\u2209\u2082 k\u2208\u2082)\n\n\n      -- MAIN LEMMA --\n      filter\u1d50-\u222a\u207a-distr : (m\u2081 m\u2082 : A \u21c0 B) \u2192 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082) \u2261\u1d50 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082\n      filter\u1d50-\u222a\u207a-distr m\u2081 m\u2082 = filter\u1d50-\u222a\u207a-distr-\u2286 m\u2081 m\u2082 , filter\u1d50-\u222a\u207a-distr-\u2287 m\u2081 m\u2082\n\n\n      filter\u1d50-singleton-true : P k \u2192 filter\u1d50 P\u2032 \u2774 k , v \u2775 \u2261\u1d50 \u2774 k , v \u2775\n      filter\u1d50-singleton-true p .proj\u2081 = proj\u2082 \u2218 (from \u2208-filter)\n      filter\u1d50-singleton-true {k}{v} p .proj\u2082 {a} x = to \u2208-filter (subst P\u2032 (sym (from \u2208-singleton x)) p , x)\n\n      filter\u1d50-singleton-false : \u00ac P k \u2192 filter\u1d50 P\u2032 \u2774 k , v \u2775 \u2261\u1d50 \u2205\n      filter\u1d50-singleton-false \u00acp .proj\u2081 x =\n        \u22a5-elim $ \u00acp $ subst P\u2032 (from \u2208-singleton $ proj\u2082 (from \u2208-filter x)) (proj\u2081 $ from \u2208-filter x)\n      filter\u1d50-singleton-false _ .proj\u2082 = \u22a5-elim \u2218 \u2209-\u2205\n\n      filter\u1d50-restrict : \u2200 m {ks} \u2192 filter\u1d50 P\u2032 (m \u2223 ks \u1d9c) \u2261\u1d50 filter\u1d50 P\u2032 m \u2223 ks \u1d9c\n      filter\u1d50-restrict m {ks} .proj\u2081 {a , b} h with from \u2208-filter h\n      ... | Pa , ab\u2208m\u2216ks with res\u1d9c-dom\u2209\u207b m ab\u2208m\u2216ks\n      ... | ab\u2208m , a\u2209ks = res\u1d9c-dom\u2209\u207a (filter\u1d50 P\u2032 m) (to \u2208-filter (Pa , ab\u2208m) , a\u2209ks)\n      filter\u1d50-restrict m {ks} .proj\u2082 {a , b} h with res\u1d9c-dom\u2209\u207b (filter\u1d50 P\u2032 m) h\n      ... | ab\u2208m\u2032 , a\u2209ks = to \u2208-filter (from \u2208-filter ab\u2208m\u2032 .proj\u2081\n                                       , res\u1d9c-dom\u2209\u207a m (from \u2208-filter ab\u2208m\u2032 .proj\u2082 , a\u2209ks))\n\n      \u2208-filter-res- : {x : A \u00d7 B} (m : A \u21c0 B) \u2192 x \u2208 filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775 \u2192 P\u2032 x \u00d7 \u2203[ b ] x \u2261 (k , b)\n      \u2208-filter-res- m x\u2208 = proj\u2081 (from \u2208-filter $ res-\u2286 x\u2208) , res-singleton''{m = filter\u1d50 P\u2032 m} x\u2208\n\n      module \u2261\u1d49 = IsEquivalence (\u2261\u1d49-isEquivalence {\u03a3 A (\u03bb x \u2192 B)})\n      open SetoidReasoning (\u2261\u1d49-Setoid{\u03a3 A (\u03bb x \u2192 B)})\n\n      restrict-singleton-filter\u1d50-false : \u2200 m \u2192 \u00ac P k \u2192 filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775 \u1d9c \u2261\u1d50 filter\u1d50 P\u2032 m\n      restrict-singleton-filter\u1d50-false {k} m \u00acp = \u2261\u1d49.sym $\n        begin\n        filter\u1d50 P\u2032 m \u02e2                                        \u2248\u27e8 \u2261\u1d49.sym (res-ex-\u222a Dec-\u2208-singleton) \u27e9\n        (filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775) \u02e2 \u222a (filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775 \u1d9c)\u02e2  \u2248\u27e8 \u222a-cong \u00acP\u2192res-\u2205 \u2261\u1d49.refl \u27e9\n        \u2205 \u222a (filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775 \u1d9c) \u02e2                        \u2248\u27e8 \u222a-identity\u02e1 _ \u27e9\n        (filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775 \u1d9c) \u02e2                            \u220e\n          where\n          \u00acP\u2192res-\u2205 :  (filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775)\u02e2 \u2261\u1d49 \u2205\n          \u00acP\u2192res-\u2205 .proj\u2081 {a} x with \u2208-filter-res- m x\n          ... | px , b , refl = \u22a5-elim (\u00acp px)\n          \u00acP\u2192res-\u2205 .proj\u2082 = \u22a5-elim \u2218 \u2209-\u2205\n\n\n    opaque\n      lem-add-included : P k \u2192 filter\u1d50 P\u2032 (m \u222a\u207a \u2774 k , v \u2775) \u2261\u1d50 filter\u1d50 P\u2032 m \u222a\u207a \u2774 k , v \u2775\n      lem-add-included p =\n        filter\u1d50-\u222a\u207a-distr _ _ \u27e8\u2248\u27e9 \u222a\u207a-cong-l (filter\u1d50-singleton-true p)\n\n      lem-add-excluded : \u00ac P k \u2192 filter\u1d50 P\u2032 (m \u222a\u207a \u2774 k , v \u2775) \u2261\u1d50 filter\u1d50 P\u2032 m\n      lem-add-excluded p =\n        filter\u1d50-\u222a\u207a-distr _ _ \u27e8\u2248\u27e9 \u222a\u207a-cong-l (filter\u1d50-singleton-false p) \u27e8\u2248\u27e9 \u222a\u207a-id-r _\n\n      lem-del-excluded : \u2200 m \u2192 \u00ac P k \u2192 filter\u1d50 P\u2032 (m \u2223 \u2774 k \u2775 \u1d9c) \u2261\u1d50 filter\u1d50 P\u2032 m\n      lem-del-excluded m \u00acp = filter\u1d50-restrict m \u27e8\u2248\u27e9 restrict-singleton-filter\u1d50-false m \u00acp\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Utxo.html","title":"Utxo","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Data.Unit using (\u22a4)\nopen import Data.Product using (_\u00d7_; _,_)\nopen import Function.Bundles using (_\u21d4_; mk\u21d4; Equivalence)\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\nopen import Ledger.Conway.Conformance.Equivalence.Convert\n\nmodule Ledger.Conway.Conformance.Equivalence.Utxo\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Utxo txs abs public\n    open import Ledger.Conway.Specification.Utxow txs abs public\n    open import Ledger.Conway.Specification.Certs govStructure public\n\n  module C where\n    open import Ledger.Conway.Conformance.Utxo txs abs public\n    open import Ledger.Conway.Conformance.Utxow txs abs public\n    open import Ledger.Conway.Conformance.Certs govStructure public\n\nopen Tx\n\nsetDeposits : L.Deposits \u2192 L.UTxOState \u2192 L.UTxOState\nsetDeposits deposits utxoSt = record utxoSt { deposits = deposits }\n\nwithDepositsFrom : L.UTxOState \u2192 L.UTxOState \u2192 L.UTxOState\nwithDepositsFrom utxoSt = setDeposits (L.UTxOState.deposits utxoSt)\n\ninstance\n\n  UTXOSToConf : \u2200 {\u0393 s tx s'} \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s' \u2b46 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 (withDepositsFrom s s')\n  UTXOSToConf .conv\u2071 _ (L.Scripts-Yes (certsValid , eval , txValid)) = C.Scripts-Yes (eval , txValid)\n  UTXOSToConf .conv\u2071 _ (L.Scripts-No h)                              = C.Scripts-No h\n\nmodule _ {\u0393 s tx s'} where\n  open L.UTxOEnv \u0393 renaming (pparams to pp)\n  open L.UTxOState s using (deposits)\n  open Tx tx renaming (body to txb)\n\n  utxoSDeposits : \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s' \u2192 L.Deposits\n  utxoSDeposits (C.Scripts-Yes _) = L.updateDeposits pp txb deposits\n  utxoSDeposits (C.Scripts-No  _) = deposits\n\n  utxoDeposits : \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s' \u2192 L.Deposits\n  utxoDeposits (C.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ h) = utxoSDeposits h\n\n  utxowDeposits : \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s' \u2192 L.Deposits\n  utxowDeposits (C.UTXOW-inductive\u22ef _ _ _ _ _ _ _ _ h) = utxoDeposits h\n\ninstance\n  -- Here we pass in the ValidCertDeposits proof explicitly and\n  -- override the deposits in s' with updateDeposits (in case of\n  -- Scripts-Yes).\n  UTXOSFromConf : \u2200 {\u0393 s tx s'}\n                    (let open L.UTxOEnv \u0393 using () renaming (pparams to pp)\n                         open L.UTxOState s using (deposits)\n                         open Tx tx renaming (body to txb)\n                         open TxBody txb using (txCerts))\n                \u2192 (isValid tx \u2261 false \u228e L.ValidCertDeposits pp deposits txCerts)\n                  \u22a2 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s' \u2b46\u2071 \u03bb _ h \u2192\n                    \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 (setDeposits (utxoSDeposits h) s')\n  UTXOSFromConf .conv\u2071 (inj\u2081 refl)       (C.Scripts-Yes (eval , ()))\n  UTXOSFromConf .conv\u2071 (inj\u2082 validCerts) (C.Scripts-Yes (eval , txValid)) = L.Scripts-Yes (validCerts , eval , txValid)\n  UTXOSFromConf .conv\u2071 _ (C.Scripts-No h) = L.Scripts-No h\n\ninstance\n  -- It's a little weird that UTXO still has a bunch of preconditions\n  -- for consumed and produced (using updateDeposits) when the\n  -- deposits don't change! Why are they even part of the UTxOState?\n  -- In conformance the update happens in GOVCERT (under CERT).\n  UTXOToConf : \u2200 {\u0393 s tx s'} \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s' \u2b46 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXO\u2988 (withDepositsFrom s s')\n  UTXOToConf {s = s} {tx = tx} .conv\u2071 _ (L.UTXO-inductive (a , b , c , d , e , f , g , r , h , i , j , k , l , m , n , o , p , utxo)) =\n    C.UTXO-inductive (a , b , c , d , e , f , g , r , h , i , j , k , l , m , n , o , p , conv utxo)\n\n  UTXOFromConf : \u2200 {\u0393 s tx s'}\n                   (let open L.UTxOEnv \u0393 using () renaming (pparams to pp)\n                        open L.UTxOState s using (deposits)\n                        open Tx tx renaming (body to txb)\n                        open TxBody txb using (txCerts))\n               \u2192 (isValid tx \u2261 false \u228e L.ValidCertDeposits pp deposits txCerts)\n                 \u22a2 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s' \u2b46\u2071 \u03bb _ h \u2192\n                   \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXO\u2988 (setDeposits (utxoDeposits h) s')\n  UTXOFromConf {s = s} {tx = tx} .conv\u2071 validCerts (C.UTXO-inductive (a , b , c , d , e , f , g , r , h , i , j , k , l , m , n , o , p , utxo)) =\n    L.UTXO-inductive (a , b , c , d , e , f , g , r , h , i , j , k , l , m , n , o , p , (validCerts \u22a2conv utxo))\n\n  UTXOWToConf : \u2200 {\u0393 s tx s'} \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s' \u2b46 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 (withDepositsFrom s s')\n  UTXOWToConf .conv\u2071 _ (L.UTXOW-inductive\u22ef a b c d e f g h utxo) =\n    C.UTXOW-inductive\u22ef a b c d e f g h (conv utxo)\n\n  UTXOWFromConf : \u2200 {\u0393 s tx s'}\n                    (let open L.UTxOEnv \u0393 using () renaming (pparams to pp)\n                         open L.UTxOState s using (deposits)\n                         open Tx tx renaming (body to txb)\n                         open TxBody txb using (txCerts))\n                \u2192 (isValid tx \u2261 false \u228e L.ValidCertDeposits pp deposits txCerts)\n                  \u22a2 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s' \u2b46\u2071 \u03bb _ h \u2192\n                    \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 (setDeposits (utxowDeposits h) s')  -- Conformance doesn't update deposits in UTXOW\n  UTXOWFromConf .conv\u2071 validCerts (C.UTXOW-inductive\u22ef a b c d e f g h utxo) =\n    L.UTXOW-inductive\u22ef a b c d e f g h (validCerts \u22a2conv utxo)\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.html","title":"Equivalence","text":"<pre><code>{-# OPTIONS --safe #-}\n-- Proof that the rules under Ledger.Conway.Conformance are equivalent\n-- to the rules under Ledger.\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Data.Unit using (\u22a4)\nopen import Data.Product using (_\u00d7_; _,_) renaming (map to \u27e8_,_\u27e9)\nopen import Function.Bundles using (_\u21d4_; mk\u21d4; Equivalence)\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Binary using (IsEquivalence)\n\nopen import Ledger.Conway.Conformance.Equivalence.Convert\n\nmodule Ledger.Conway.Conformance.Equivalence\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nmodule L where\n  open import Ledger.Conway.Specification.Ledger txs abs public\n  open import Ledger.Conway.Specification.Utxo txs abs public\n  open import Ledger.Conway.Specification.Utxow txs abs public\n  open import Ledger.Conway.Specification.Gov txs public\n  open import Ledger.Conway.Specification.Certs govStructure public\n\nmodule C where\n  open import Ledger.Conway.Conformance.Ledger txs abs public\n  open import Ledger.Conway.Conformance.Utxo txs abs public\n  open import Ledger.Conway.Conformance.Utxow txs abs public\n  open import Ledger.Conway.Conformance.Certs govStructure public\n\nopen import Ledger.Conway.Conformance.Equivalence.Certs txs abs\nopen import Ledger.Conway.Conformance.Equivalence.Utxo txs abs\nopen import Ledger.Conway.Conformance.Equivalence.Deposits txs abs\n\nopen Tx\nopen import Axiom.Set.Properties th using (\u2261\u1d49-Setoid)\n\n-- Invalid transactions don't change the deposits\nlemInvalidDepositsL : \u2200 {\u0393 utxoSt utxoSt' tx}\n                    \u2192 isValid tx \u2261 false\n                    \u2192 \u0393 L.\u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt'\n                    \u2192 L.UTxOState.deposits utxoSt \u2261 L.UTxOState.deposits utxoSt'\nlemInvalidDepositsL refl (L.UTXOW\u21d2UTXO\n                          (L.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n                            (L.Scripts-No _))) = refl\n\nlemInvalidDepositsC : \u2200 {\u0393 utxoSt utxoSt' tx}\n                    \u2192 isValid tx \u2261 false\n                    \u2192 (h : \u0393 C.\u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt')\n                    \u2192 utxowDeposits h \u2261 L.UTxOState.deposits utxoSt'\nlemInvalidDepositsC refl (C.UTXOW\u21d2UTXO\n                          (C.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n                            (C.Scripts-No _))) = refl\n\n-- The UTXOW rule doesn't change the deposits in Conformance\nlemDepositsC : \u2200 {\u0393 utxoSt utxoSt' tx}\n             \u2192 (h : \u0393 C.\u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt')\n             \u2192 L.UTxOState.deposits utxoSt \u2261 L.UTxOState.deposits utxoSt'\nlemDepositsC (C.UTXOW\u21d2UTXO\n               (C.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n                 (C.Scripts-Yes _))) = refl\nlemDepositsC (C.UTXOW\u21d2UTXO\n               (C.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n                 (C.Scripts-No _))) = refl\n\nlemUpdateDeposits : \u2200 {\u0393 s tx s'} (open L.UTxOEnv \u0393)\n                  \u2192 isValid tx \u2261 true\n                  \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n                  \u2192 L.updateDeposits pparams (body tx) (L.UTxOState.deposits s) \u2261 L.UTxOState.deposits s'\nlemUpdateDeposits refl\n  (L.UTXOW\u21d2UTXO\n    (L.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ _ _\n      (L.Scripts-Yes _))) = refl\n\ngetValidCertDeposits : \u2200 {\u0393 s tx s'}\n                     \u2192 (let open L.UTxOEnv \u0393 using (pparams)\n                            open L.UTxOState s using (deposits)\n                            open TxBody (tx .Tx.body) using (txCerts))\n                     \u2192 isValid tx \u2261 true\n                     \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n                     \u2192 L.ValidCertDeposits pparams deposits txCerts\ngetValidCertDeposits refl\n  (L.UTXOW\u21d2UTXO\n    (L.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n      (L.Scripts-Yes (v , _)))) = v\n\nmakeCertDeps* : \u2200 {\u0393 s tx s'}\n              \u2192 (let open L.UTxOEnv \u0393 using (pparams)\n                     open L.UTxOState s using (deposits)\n                     open TxBody (tx .Tx.body) using (txCerts))\n              \u2192 isValid tx \u2261 true\n              \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n              \u2192 CertDeps* pparams txCerts\nmakeCertDeps* {s = s} valid r = \u27e6 certDDeps deposits , certGDeps deposits , validDDeps validDeps , validGDeps validDeps \u27e7*\n  where\n    open L.UTxOState s using (deposits)\n    validDeps = getValidCertDeposits valid r\n\nlem-cert-deposits-valid : \u2200 {\u0393 s tx s'} (open L.LEnv \u0393 using (pparams))\n                        \u2192 isValid tx \u2261 true\n                        \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s'\n                        \u2192 updateLedgerDeps pparams tx (certDeposits s) \u2261\u1d48 certDeposits s'\nlem-cert-deposits-valid {\u0393} {s} {tx} {s'} refl (L.LEDGER-V\u22ef refl utxow certs gov) rewrite sym (lemUpdateDeposits refl utxow) =\n  lem-upd-ddeps pparams deps tx ,\n  lem-upd-gdeps pparams deps tx\n  where\n    open L.LEnv \u0393 using (pparams)\n    deps = s .L.LState.utxoSt . L.UTxOState.deposits\n\nlem-cert-deposits-invalid : \u2200 {\u0393 s tx s'} (open L.LEnv \u0393 using (pparams))\n                        \u2192 isValid tx \u2261 false\n                        \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s'\n                        \u2192 certDeposits s \u2261\u1d48 certDeposits s'\nlem-cert-deposits-invalid refl (L.LEDGER-I\u22ef _ utxow) rewrite lemInvalidDepositsL refl utxow =\n  (id , id) , (id , id)\n\ninstance\n  LStateToConf : L.Deposits \u00d7 L.Deposits \u22a2 L.LState \u2b46 C.LState\n  LStateToConf .conv\u2071 deposits ledgerSt =\n    let open L.LState ledgerSt in\n    \u27e6 utxoSt , govSt , deposits \u22a2conv certState \u27e7\n\ninstance\n  LEDGERToConf : \u2200 {\u0393 s tx s'}\n               \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s' \u2b46\n                 \u2203[ certDeposits-s' ]\n                    certDeposits-s' \u2261\u1d48 certDeposits s'\n                  \u00d7 \u0393 C.\u22a2 (certDeposits s \u22a2conv s) \u21c0\u2987 tx ,LEDGER\u2988 (certDeposits-s' \u22a2conv s')\n  LEDGERToConf {\u0393} {s} {tx} {s'} .conv\u2071 _ r@(L.LEDGER-V\u22ef refl utxow certs gov) =\n    updateLedgerDeps pparams tx (certDeposits s)\n    , lem-cert-deposits-valid refl r\n    , subst\u2082 (\u03bb \u2022 \u25c6 \u2192 \u0393 C.\u22a2 getCertDeps* cdeposits \u22a2conv s \u21c0\u2987 tx ,LEDGER\u2988 \u27e6 \u2022 , _ , \u25c6 \u27e7)\n             utxoEq certsEq ledger'\n    where\n      open L.LEnv \u0393\n      open L.LState s\n      open L.LState s' renaming (utxoSt to utxoSt'; certState to certState'; govSt to govSt')\n      open TxBody (body tx) using (txCerts)\n      deposits = L.UTxOState.deposits utxoSt\n      utxow' : _ C.\u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 setDeposits deposits utxoSt'\n      utxow' = conv utxow\n      utxoStC'    = setDeposits (L.updateDeposits pparams (body tx) deposits) utxoSt'\n      cdeposits  = makeCertDeps* refl utxow\n      cdeposits' = updateCertDeps* txCerts cdeposits\n      certStateC' = getCertDeps* cdeposits' \u22a2conv certState'\n      certs' : _ C.\u22a2 (getCertDeps* cdeposits \u22a2conv certState) \u21c0\u2987 txCerts ,CERTS\u2988 certStateC'\n      certs' = cdeposits \u22a2conv certs\n      ledger' : \u0393 C.\u22a2 (getCertDeps* cdeposits \u22a2conv s) \u21c0\u2987 tx ,LEDGER\u2988 C.\u27e6 utxoStC' , govSt' , certStateC' \u27e7\u02e1\n      ledger' = C.LEDGER-V\u22ef refl utxow' certs' gov\n      utxoEq  : utxoStC' \u2261 utxoSt'\n      utxoEq  = cong (\u03bb \u2022 \u2192 \u27e6 _ , _ , \u2022 , _ \u27e7)\n                     (lemUpdateDeposits refl utxow)\n      ddeps = getCertDeps* cdeposits .proj\u2081\n      gdeps = getCertDeps* cdeposits .proj\u2082\n      certsEq : certStateC' \u2261 (updateDDeps pparams txCerts ddeps , updateGDeps pparams txCerts gdeps) \u22a2conv certState'\n      certsEq = cong\u2082 (\u03bb \u2022 \u25c6 \u2192 \u27e6 \u27e6 _ , _ , _ , \u2022 \u27e7 , _ , \u27e6 _ , _ , \u25c6 \u27e7 \u27e7)\n                     (lem-ddeps cdeposits)\n                     (lem-gdeps cdeposits)\n\n  -- LEDGERToConf {\u0393} {s} {tx} {s'} .conv\u2071 (cdeps , cdeps-eq) r@(L.LEDGER-I\u22ef refl utxow) =\n  LEDGERToConf {\u0393} {s} {tx} {s'} .conv\u2071 _ r@(L.LEDGER-I\u22ef refl utxow) =\n    certDeposits s , lem-cert-deposits-invalid refl r ,\n    subst (\u03bb \u2022 \u2192 \u0393 C.\u22a2 _ \u22a2conv s \u21c0\u2987 tx ,LEDGER\u2988 \u27e6 \u27e6 _ , _ , \u2022 , _ \u27e7 , _ , _ \u27e7)\n          (lemInvalidDepositsL refl utxow)\n          (C.LEDGER-I\u22ef refl (conv utxow))\n\ninstance\n\n  LStateFromConf : C.LState \u2b46 L.LState\n  LStateFromConf .conv\u2071 _ ls =\n    let open C.LState ls in\n    \u27e6 utxoSt , govSt , conv certState \u27e7\n\ncertDepositsC : C.CertState \u2192 L.Deposits \u00d7 L.Deposits\ncertDepositsC cs = let open C.CertState cs in C.DState.deposits dState , C.GState.deposits gState\n\nWellformedLState : C.LState \u2192 Type\nWellformedLState s = certDepositsC (C.LState.certState s) \u2261\u1d48 certDeposits (conv s)\n\ngetValidCertDepositsCERTS : \u2200 {\u0393 s certs s'} deposits (open L.CertEnv \u0393 using (pp))\n                          \u2192 certDepositsC s \u2261\u1d48 (certDDeps deposits , certGDeps deposits)\n                          \u2192 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s certs s'\n                          \u2192 L.ValidCertDeposits pp deposits certs\ngetValidCertDepositsCERTS deposits wf (run-[] x) = L.[]\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-deleg (C.DELEG-delegate x)) rs)\n  = L.delegate (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-deleg (C.DELEG-dereg (_ , h , h'))) rs)\n  = L.dereg (\u2208-filter .Equivalence.from (wf .proj\u2081 .proj\u2081 h) .proj\u2082) h'\n            (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-deleg (C.DELEG-reg x)) rs)\n  = L.reg (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-pool (C.POOL-regpool _)) rs)\n  = L.regpool (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-pool C.POOL-retirepool) rs)\n  = L.retirepool (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-vdel (C.GOVCERT-regdrep x)) rs)\n  = L.regdrep (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-vdel (C.GOVCERT-deregdrep (_ , h))) rs)\n  = L.deregdrep (\u2208-filter .Equivalence.from (wf .proj\u2082 .proj\u2081 h) .proj\u2082)\n                (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-vdel (C.GOVCERT-ccreghot x)) rs)\n  = L.ccreghot(getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\n\n\ngetValidCertDepositsC : \u2200 \u0393 s {s'} tx\n                     \u2192 (let open C.LEnv \u0393 using (pparams; slot; enactState)\n                            open TxBody (tx .Tx.body) using (txCerts; txGovVotes; txWithdrawals)\n                            open C.LState s\n                            open C.UTxOState utxoSt using (deposits)\n                            cc = C.allColdCreds govSt enactState\n                       )\n                     \u2192 WellformedLState s\n                     \u2192 isValid tx \u2261 true\n                     \u2192 \u27e6 epoch slot , pparams , txGovVotes , txWithdrawals , cc \u27e7 C.\u22a2 certState \u21c0\u2987 txCerts ,CERTS\u2988 s'\n                     \u2192 L.ValidCertDeposits pparams deposits txCerts\ngetValidCertDepositsC \u0393 s tx wf refl (run {s' = s'} (C.CERT-pre _ , cert-post)) =\n  getValidCertDepositsCERTS (C.UTxOState.deposits ((C.LState.utxoSt s))) wf cert-post\n\nlemUtxowDeposits : \u2200 {\u0393 s s' tx}\n                      (let open C.UTxOEnv \u0393 using (pparams))\n                  \u2192 isValid tx \u2261 true\n                  \u2192 (r : \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s')\n                  \u2192 utxowDeposits r \u2261 L.updateDeposits pparams (body tx) (C.UTxOState.deposits s')\nlemUtxowDeposits refl (C.UTXOW\u21d2UTXO\n                        (C.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n                          (C.Scripts-Yes _))) = refl\n\ninstance\n\n  LEDGERFromConf : \u2200 {\u0393 s tx s'} \u2192 WellformedLState s\n                                    \u22a2 \u0393 C.\u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s'\n                                    \u2b46 \u0393 L.\u22a2 conv s \u21c0\u2987 tx ,LEDGER\u2988 conv s'\n  LEDGERFromConf .conv\u2071 _ (C.LEDGER-I\u22ef invalid utxow) with inj\u2081 invalid \u22a2conv utxow\n  ... | utxow' rewrite lemInvalidDepositsC invalid utxow = L.LEDGER-I\u22ef invalid utxow'\n  LEDGERFromConf {\u0393} {s} {tx} {s'} .conv\u2071 wf (C.LEDGER-V\u22ef refl utxow certs gov) =\n    subst (\u03bb \u2022 \u2192 \u0393 L.\u22a2 conv s \u21c0\u2987 tx ,LEDGER\u2988 \u27e6 \u2022 , govSt' , conv certSt' \u27e7) eqUtxo ledger'\n    where\n      open C.LEnv \u0393\n\n      open C.LState s renaming (certState to certSt)\n      open C.LState s' using () renaming (utxoSt to utxoSt'; govSt to govSt'; certState to certSt')\n\n      open TxBody (body tx)\n      open C.UTxOState utxoSt using (deposits)\n\n      valid-deps : L.ValidCertDeposits pparams deposits txCerts\n      valid-deps = getValidCertDepositsC \u0393 s tx wf refl certs\n\n      utxow' : _ L.\u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 (setDeposits (utxowDeposits utxow) utxoSt')\n      utxow' = inj\u2082 valid-deps \u22a2conv utxow\n\n      eqUtxo : setDeposits (utxowDeposits utxow) utxoSt' \u2261 utxoSt'\n      eqUtxo = cong (\u03bb \u2022 \u2192 \u27e6 _ , _ , \u2022 , _ \u27e7) (lemUtxowDeposits refl utxow)\n\n      ledger' : \u0393 L.\u22a2 conv s \u21c0\u2987 tx ,LEDGER\u2988 L.\u27e6 setDeposits (utxowDeposits utxow) utxoSt'\n                                              , govSt'\n                                              , conv certSt' \u27e7\u02e1\n      ledger' = L.LEDGER-V\u22ef refl utxow' (conv certs) gov\n\nopen IsEquivalence \u2261\u1d48-isEquivalence renaming (refl to \u2261\u1d48-refl; sym to \u2261\u1d48-sym; trans to \u2261\u1d48-trans)\n\nlemCERTS'DepositsC : \u2200 {\u0393 s dcerts s'} (open C.CertEnv \u0393 using (pp))\n                   \u2192 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s dcerts s'\n                   \u2192 certDepositsC s' \u2261 \u27e8 updateDDeps pp dcerts , updateGDeps pp dcerts \u27e9 (certDepositsC s)\nlemCERTS'DepositsC (run-[] C.CERT-post) = refl\nlemCERTS'DepositsC (run-\u2237 (C.CERT-deleg  (C.DELEG-delegate     _)) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-deleg  (C.DELEG-dereg        _)) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-deleg  (C.DELEG-reg          _)) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-pool   (C.POOL-regpool       _)) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-pool    C.POOL-retirepool     )  rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-vdel   (C.GOVCERT-regdrep    _)) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-vdel   (C.GOVCERT-deregdrep  _)) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-vdel   (C.GOVCERT-ccreghot   _)) rs) = lemCERTS'DepositsC rs\n\nlemCERTSDepositsC : \u2200 {\u0393 s txCerts s'} (open C.CertEnv \u0393 using (pp))\n                  \u2192 \u0393 C.\u22a2 s \u21c0\u2987 txCerts ,CERTS\u2988 s'\n                  \u2192 certDepositsC s' \u2261 \u27e8 updateDDeps pp txCerts , updateGDeps pp txCerts \u27e9 (certDepositsC s)\nlemCERTSDepositsC (run (C.CERT-pre _ , step)) = lemCERTS'DepositsC step\n\nlemWellformed : \u2200 {\u0393 s tx s'} \u2192 WellformedLState s \u2192 \u0393 C.\u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s' \u2192 WellformedLState s'\nlemWellformed {\u0393} {s = ls} {tx} {s' = ls'} wf (C.LEDGER-V\u22ef refl utxo certs gov) = goal\n  where\n    open C.LState ls  renaming (certState to certSt)\n    open C.LState ls' renaming (utxoSt to utxoSt'; certState to certSt')\n    open L.LEnv \u0393 using (pparams)\n    open TxBody (body tx)\n\n    deposits  = L.UTxOState.deposits utxoSt\n    deposits' = L.UTxOState.deposits utxoSt'\n\n    depositsL' = L.updateDeposits pparams (body tx) deposits\n\n    ddeps = certDepositsC certSt .proj\u2081\n    gdeps = certDepositsC certSt .proj\u2082\n\n    ddeps' = certDepositsC certSt' .proj\u2081\n    gdeps' = certDepositsC certSt' .proj\u2082\n\n    lem : deposits' \u2261 depositsL'\n    lem rewrite lemDepositsC utxo = refl\n\n    lem\u2081 : (ddeps' , gdeps') \u2261 (updateDDeps pparams txCerts ddeps , updateGDeps pparams txCerts gdeps)\n    lem\u2081 = lemCERTSDepositsC certs\n\n    lem\u2082 :  (updateDDeps pparams txCerts (certDDeps deposits) , updateGDeps pparams txCerts (certGDeps deposits))\n         \u2261\u1d48 (certDDeps deposits' , certGDeps deposits')\n    lem\u2082 rewrite lem = lem-upd-ddeps pparams deposits tx , lem-upd-gdeps pparams deposits tx\n\n    lem\u2083 :  (updateDDeps pparams txCerts ddeps , updateGDeps pparams txCerts gdeps)\n         \u2261\u1d48 (updateDDeps pparams txCerts (certDDeps deposits) , updateGDeps pparams txCerts (certGDeps deposits))\n    lem\u2083 = \u27e8 cong-updateDDeps txCerts , cong-updateGDeps txCerts \u27e9 wf\n\n    goal : (ddeps' , gdeps') \u2261\u1d48 (certDDeps deposits' , certGDeps deposits')\n    goal with refl \u2190 lem\u2081 = \u2261\u1d48-trans {ddeps' , gdeps'}\n                                     {updateDDeps pparams txCerts (certDDeps deposits) , updateGDeps pparams txCerts (certGDeps deposits)}\n                                     {certDDeps deposits' , certGDeps deposits'}\n                              lem\u2083\n                              lem\u2082\nlemWellformed wf (C.LEDGER-I\u22ef refl utxo) rewrite lemDepositsC utxo = wf\n\nsetCertDeposits : L.Deposits \u00d7 L.Deposits \u2192 C.CertState \u2192 C.CertState\nsetCertDeposits (ddeps , gdeps) cs =\n  let open C.CertState cs in\n  \u27e6 record dState {deposits = ddeps} , pState , record gState {deposits = gdeps} \u27e7\n\nupdateCDep : PParams \u2192 L.DCert \u2192 L.Deposits \u00d7 L.Deposits \u2192 L.Deposits \u00d7 L.Deposits\nupdateCDep pp cert (ddep , gdep) = updateDDep pp cert ddep , updateGDep pp cert gdep\n\nopaque\n  castCERTS' : \u2200 {\u0393 certs} {s s' : L.CertState} deps\u2081 deps\u2082 deps\u2081'\n             \u2192 deps\u2081 \u2261\u1d48 deps\u2082\n             \u2192 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 (deps\u2081 \u22a2conv s) certs (deps\u2081' \u22a2conv s')\n             \u2192 \u2203[ deps\u2082' ] deps\u2081' \u2261\u1d48 deps\u2082'\n                           \u00d7 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 (deps\u2082 \u22a2conv s) certs (deps\u2082' \u22a2conv s')\n  castCERTS' deps\u2081 deps\u2082 deps\u2081' eqd (run-[] C.CERT-post) = deps\u2082 , eqd , run-[] C.CERT-post\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-deleg {dCert = cert} (C.DELEG-delegate h))    rs)\n    = let\n        open C.CertEnv \u0393 using (pp)\n        deps\u2082' , eqd' , rs' = castCERTS' (updateCDep pp cert deps\u2081) (updateCDep pp cert deps\u2082) deps\u2081'\n                                         (\u27e8 cong-updateDDep {pp} cert {deps\u2081 .proj\u2081} {deps\u2082 .proj\u2081}\n                                          , cong-updateGDep {pp} cert {deps\u2081 .proj\u2082} {deps\u2082 .proj\u2082} \u27e9 eqd) rs\n        in  deps\u2082' , eqd' , run-\u2237 (C.CERT-deleg (C.DELEG-delegate h)) rs'\n\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-deleg {dCert = cert} (C.DELEG-dereg (a , b , c))) rs) =\n    let open C.CertEnv \u0393 using (pp)\n        deps\u2082' , eqd' , rs' = castCERTS' (updateCDep pp cert deps\u2081) (updateCDep pp cert deps\u2082) deps\u2081'\n                                         (\u27e8 cong-updateDDep {pp} cert {deps\u2081 .proj\u2081} {deps\u2082 .proj\u2081}\n                                          , cong-updateGDep {pp} cert {deps\u2081 .proj\u2082} {deps\u2082 .proj\u2082} \u27e9 eqd) rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-deleg (C.DELEG-dereg (a , eqd .proj\u2081 .proj\u2081 b , c))) rs'\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-deleg {dCert = cert} (C.DELEG-reg h))         rs) =\n    let open C.CertEnv \u0393 using (pp)\n        deps\u2082' , eqd' , rs' = castCERTS' (updateCDep pp cert deps\u2081) (updateCDep pp cert deps\u2082) deps\u2081'\n                                         (\u27e8 cong-updateDDep {pp} cert {deps\u2081 .proj\u2081} {deps\u2082 .proj\u2081}\n                                          , cong-updateGDep {pp} cert {deps\u2081 .proj\u2082} {deps\u2082 .proj\u2082} \u27e9 eqd) rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-deleg (C.DELEG-reg h)) rs'\n\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-pool  {dCert = cert} (C.POOL-regpool h))      rs) =\n    let deps\u2082' , eqd' , rs' = castCERTS' deps\u2081 deps\u2082 deps\u2081' eqd rs\n    in  deps\u2082' , eqd' , run-\u2237  (C.CERT-pool (C.POOL-regpool h)) rs'\n\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-pool  {dCert = cert} C.POOL-retirepool)       rs) =\n    let deps\u2082' , eqd' , rs' = castCERTS' deps\u2081 deps\u2082 deps\u2081' eqd rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-pool C.POOL-retirepool) rs'\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-vdel  {dCert = cert} (C.GOVCERT-regdrep h))   rs) =\n    let open C.CertEnv \u0393 using (pp)\n        deps\u2082' , eqd' , rs' = castCERTS' (updateCDep pp cert deps\u2081) (updateCDep pp cert deps\u2082) deps\u2081'\n                                         (\u27e8 cong-updateDDep {pp} cert {deps\u2081 .proj\u2081} {deps\u2082 .proj\u2081}\n                                          , cong-updateGDep {pp} cert {deps\u2081 .proj\u2082} {deps\u2082 .proj\u2082} \u27e9 eqd) rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-vdel (C.GOVCERT-regdrep h)) rs'\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-vdel  {dCert = cert} (C.GOVCERT-deregdrep (a , b))) rs) =\n    let open C.CertEnv \u0393 using (pp)\n        deps\u2082' , eqd' , rs' = castCERTS' (updateCDep pp cert deps\u2081) (updateCDep pp cert deps\u2082) deps\u2081'\n                                         (\u27e8 cong-updateDDep {pp} cert {deps\u2081 .proj\u2081} {deps\u2082 .proj\u2081}\n                                          , cong-updateGDep {pp} cert {deps\u2081 .proj\u2082} {deps\u2082 .proj\u2082} \u27e9 eqd) rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-vdel (C.GOVCERT-deregdrep (a , eqd .proj\u2082 .proj\u2081 b))) rs'\n                                                                   -- ^^^^^^^^^^^^^^^^^^^ Actual work\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-vdel  {dCert = cert} (C.GOVCERT-ccreghot h))  rs) =\n    let deps\u2082' , eqd' , rs' = castCERTS' deps\u2081 deps\u2082 deps\u2081' eqd rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-vdel (C.GOVCERT-ccreghot h)) rs'\n\n  castCERTS : \u2200 {\u0393 certs} {s s' : L.CertState} deps\u2081 deps\u2082 deps\u2081'\n            \u2192 deps\u2081 \u2261\u1d48 deps\u2082\n            \u2192 \u0393 C.\u22a2 deps\u2081 \u22a2conv s \u21c0\u2987 certs ,CERTS\u2988 (deps\u2081' \u22a2conv s')\n            \u2192 \u2203[ deps\u2082' ] deps\u2081' \u2261\u1d48 deps\u2082' \u00d7 \u0393 C.\u22a2 deps\u2082 \u22a2conv s \u21c0\u2987 certs ,CERTS\u2988 (deps\u2082' \u22a2conv s')\n  castCERTS deps\u2081 deps\u2082 deps\u2081' eqd (run (C.CERT-pre h , step)) =\n    let deps\u2082' , eqd' , step' = castCERTS' deps\u2081 deps\u2082 deps\u2081' eqd step\n    in  deps\u2082' , eqd' , run (C.CERT-pre h , step')\n\n_\u22a2_\u21c0\u2987_,GOVn\u2988_ : L.GovEnv \u00d7 \u2115 \u2192 L.GovState \u2192 List (GovVote \u228e GovProposal) \u2192 L.GovState \u2192 Type\n_\u22a2_\u21c0\u2987_,GOVn\u2988_ = _\u22a2_\u21c0\u27e6_\u27e7\u1d62*'_ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = IdSTS} {_\u22a2_\u21c0\u27e6_\u27e7_ = L._\u22a2_\u21c0\u2987_,GOV\u2988_}\n\nopaque\n  castLEDGER : \u2200 {\u0393 tx} {s s' : L.LState} deps\u2081 deps\u2082 deps\u2081'\n            \u2192 deps\u2081 \u2261\u1d48 deps\u2082\n            \u2192 \u0393 C.\u22a2 deps\u2081 \u22a2conv s \u21c0\u2987 tx ,LEDGER\u2988 (deps\u2081' \u22a2conv s')\n            \u2192 \u2203[ deps\u2082' ] deps\u2081' \u2261\u1d48 deps\u2082' \u00d7 \u0393 C.\u22a2 deps\u2082 \u22a2conv s \u21c0\u2987 tx ,LEDGER\u2988 (deps\u2082' \u22a2conv s')\n  castLEDGER {\u0393} {tx} {s} {s'} deps\u2081 deps\u2082 deps\u2081' eqd (C.LEDGER-V\u22ef refl utxo certs gov) =\n    let deps\u2082' , eqd' , certs' = castCERTS deps\u2081 deps\u2082 deps\u2081' eqd certs\n    in  deps\u2082' , eqd' , C.LEDGER-V\u22ef refl utxo certs' gov\n  castLEDGER deps\u2081 deps\u2082 deps\u2081' eqd (C.LEDGER-I\u22ef refl utxo) = _ , eqd , C.LEDGER-I\u22ef refl utxo\n\n---------------------------------------------------------------------------\n-- The main result\n---------------------------------------------------------------------------\n\nopen import Ledger.Conway.Conformance.Equivalence.Bisimilarity\n\n-- An LState s\u02e1 from the Spec and an LState s\u1d9c from Conformance are\n-- bisimular iff\n--  \u2219 the deposits in the CertState of s\u1d9c are equal (as maps) to the\n--    appropriate restrictions of the deposits in the UTxOState of s\u02e1\n--  \u2219 the only difference between s\u02e1 and s\u1d9c are the extra deposits in\n--    the CertState of s\u1d9c.\n_\u223c_ : L.LState \u2192 C.LState \u2192 Type\ns\u02e1 \u223c s\u1d9c = certDeposits s\u02e1 \u2261\u1d48 certDepositsC (C.LState.certState s\u1d9c) \u00d7 s\u02e1 \u2261 conv s\u1d9c\n\n-- This gives us the main result: a bisimulation between the LEDGER\n-- rules in Ledger and in Conformance.\nbisimilarityProof : Bisimilar L._\u22a2_\u21c0\u2987_,LEDGER\u2988_ C._\u22a2_\u21c0\u2987_,LEDGER\u2988_\nbisimilarityProof .Bisimilar._\u2248_ = _\u223c_\nbisimilarityProof .Bisimilar.to {\u0393} {tx} {s\u02e1} {s\u02e1'} {s\u1d9c} (eq , refl) r =\n  let deps  , eqd  , r'  = conv r\n      deps' , eqd' , r'' = castLEDGER (certDeposits (conv s\u1d9c))\n                                      (certDepositsC (C.LState.certState s\u1d9c))\n                                      deps\n                                      eq\n                                      r'\n      eqd'' : certDeposits s\u02e1' \u2261\u1d48 deps'\n      eqd'' = \u2261\u1d48-trans {certDeposits s\u02e1'} {deps} {deps'} (\u2261\u1d48-sym {deps} {certDeposits s\u02e1'} eqd) eqd'\n  in\n  (deps' \u22a2conv s\u02e1') , (eqd'' , refl) , r''\nbisimilarityProof .Bisimilar.from {\u0393} {tx} {s\u02e1} {s\u1d9c} {s\u1d9c'} (eqd , refl) r =\n  conv s\u1d9c' , (wf' , refl) , wf \u22a2conv r\n  where\n    wf  = \u2261\u1d48-sym {certDeposits (conv s\u1d9c)} {certDepositsC (C.LState.certState s\u1d9c)} eqd\n    wf' = \u2261\u1d48-sym {certDepositsC (C.LState.certState s\u1d9c')} {certDeposits (conv s\u1d9c')} (lemWellformed wf r)\n    r' = wf \u22a2conv r\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Gov.html","title":"Gov","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nmodule Ledger.Conway.Conformance.Gov\n  (txs : _) (open TransactionStructure txs hiding (epoch))\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Axiom.Set.Properties th using (\u2203-sublist-\u21d4)\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Ledger txs abs\n\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Ledger.Conway.Conformance.Equivalence.Certs txs abs\nopen import Ledger.Conway.Conformance.Equivalence.Convert\n\nopen import Ledger.Conway.Specification.Gov txs using (GovState) public\nimport Ledger.Conway.Specification.Gov txs as L\n\nrecord GovEnv : Type where\n  field\n    txid        : TxId\n    epoch       : Epoch\n    pparams     : PParams\n    ppolicy     : Maybe ScriptHash\n    enactState  : EnactState\n    certState   : CertState\n    rewardCreds : \u2119 Credential\n\ninstance\n  unquoteDecl HasCast-GovEnv = derive-HasCast\n    [ (quote GovEnv , HasCast-GovEnv) ]\n\n_\u22a2_\u21c0\u2987_,GOVS\u2988_ : GovEnv \u2192 GovState \u2192 List (GovVote \u228e GovProposal) \u2192 GovState \u2192 Type\n\u0393 \u22a2 govSt \u21c0\u2987 gvps ,GOVS\u2988 govSt'\n  = \u27e6 txid , epoch , pparams , ppolicy , enactState , conv certState ,\n  rewardCreds \u27e7 L.\u22a2 rmOrphanDRepVotes (conv certState) govSt  \u21c0\u2987 gvps ,GOVS\u2988 govSt'\n  where open GovEnv \u0393\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Ledger.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\nimport Ledger.Conway.Conformance.Certs\n\nmodule Ledger.Conway.Conformance.Ledger.Properties\n  (txs : _) (open TransactionStructure txs) (open Ledger.Conway.Conformance.Certs govStructure)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Axiom.Set.Properties th\nopen import Ledger.Conway.Conformance.Chain txs abs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Conformance.Epoch txs abs\nopen import Ledger.Conway.Conformance.Certs.Properties govStructure\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Gov.Properties.Computational txs\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Specification.Ratify txs hiding (vote)\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Utxo.Properties txs abs\nopen import Ledger.Conway.Conformance.Utxow txs abs\nopen import Ledger.Conway.Conformance.Utxow.Properties txs abs\n\nopen import Data.Bool.Properties using (\u00ac-not)\nopen import Data.List.Base using (filter)\nopen import stdlib.Data.List.Subpermutations using (\u2208\u02e1-map-filter)\nopen import Data.List.Properties using (++-identity\u02b3; map-++; ++-assoc; length-++)\nopen import Data.List.Membership.Propositional.Properties using (\u2208-filter\u207a; map-\u2208\u2194)\nopen import Data.Product.Properties using (\u00d7-\u2261,\u2261\u2190\u2261)\nopen import Data.Nat.Properties using (+-0-monoid; +-identity\u02b3; +-suc; +-comm)\nopen import Relation.Binary using (IsEquivalence)\nopen import Relation.Unary using (Decidable)\n\nopen import Ledger.Conway.Conformance.Equivalence.Certs txs abs\nopen import Ledger.Conway.Conformance.Equivalence.Convert\n\nimport Function.Related.Propositional as R\n\nimport Relation.Binary.Reasoning.Setoid as SetoidReasoning\n\ninstance _ = +-0-monoid\n\nopen import Interface.ComputationalRelation\n\n-- ** Proof that LEDGER is computational.\n\ninstance\n  _ = Monad-ComputationResult\n\n  Computational-LEDGER : Computational _\u22a2_\u21c0\u2987_,LEDGER\u2988_ String\n  Computational-LEDGER = record {go}\n    where\n    open Computational \u2983...\u2984 renaming (computeProof to comp; completeness to complete)\n    computeUtxow = comp {STS = _\u22a2_\u21c0\u2987_,UTXOW\u2988_}\n    computeCerts = comp {STS = _\u22a2_\u21c0\u2987_,CERTS\u2988_}\n    computeGov   = comp {STS = _\u22a2_\u21c0\u2987_,GOVS\u2988_}\n\n    module go\n      (\u0393 : LEnv)   (let open LEnv \u0393)\n      (s : LState) (let open LState s)\n      (tx : Tx)    (let open Tx tx renaming (body to txb); open TxBody txb)\n      where\n      utxo\u0393 = UTxOEnv \u220b record { LEnv \u0393 }\n      cert\u0393 = CertEnv \u220b \u27e6 epoch slot , pparams , txGovVotes , txWithdrawals , _ \u27e7\n      gov\u0393 : CertState \u2192 GovEnv\n      gov\u0393 certState = \u27e6 txId , epoch slot , pparams , ppolicy , enactState , conv certState , _ \u27e7\n\n      computeProof : ComputationResult String (\u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s')\n      computeProof = case isValid \u225f true of \u03bb where\n        (yes p) \u2192 do\n          (utxoSt' , utxoStep) \u2190 computeUtxow utxo\u0393 utxoSt tx\n          (certSt' , certStep) \u2190 computeCerts cert\u0393 certState txCerts\n          (govSt'  , govStep)  \u2190 computeGov (gov\u0393 certSt') (rmOrphanDRepVotes (conv certSt') govSt) (txgov txb)\n          success (_ , LEDGER-V\u22ef p utxoStep certStep govStep)\n        (no \u00acp) \u2192 do\n          (utxoSt' , utxoStep) \u2190 computeUtxow utxo\u0393 utxoSt tx\n          success (_ , LEDGER-I\u22ef (\u00ac-not \u00acp) utxoStep)\n\n      completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s' \u2192 (proj\u2081 &lt;$&gt; computeProof) \u2261 success s'\n      completeness  ls' (LEDGER-V\u22ef v utxoStep certStep govStep)\n        with isValid \u225f true\n      ... | no \u00acv = contradiction v \u00acv\n      ... | yes refl\n        with computeUtxow utxo\u0393 utxoSt tx | complete _ _ _ _ utxoStep\n      ... | success (utxoSt' , _) | refl\n        with computeCerts cert\u0393 certState txCerts | complete _ _ _ _ certStep\n      ... | success (certSt' , _) | refl\n        with computeGov (gov\u0393 certSt') (rmOrphanDRepVotes (conv certSt') govSt) (txgov txb) | complete {STS = _\u22a2_\u21c0\u2987_,GOVS\u2988_} (gov\u0393 certSt') _ _ _ govStep\n      ... | success (govSt' , _) | refl = refl\n      completeness ls' (LEDGER-I\u22ef i utxoStep)\n        with isValid \u225f true\n      ... | yes refl = case i of \u03bb ()\n      ... | no \u00acv\n        with computeUtxow utxo\u0393 utxoSt tx | complete _ _ _ _ utxoStep\n      ... | success (utxoSt' , _) | refl = refl\n\nComputational-LEDGERS : Computational _\u22a2_\u21c0\u2987_,LEDGERS\u2988_ String\nComputational-LEDGERS = it\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Ledger.html","title":"Ledger","text":"<pre><code>{-# OPTIONS --safe #-}\n\nimport Data.List as L\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nmodule Ledger.Conway.Conformance.Ledger\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Conformance.Gov txs abs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Utxow txs abs\nopen import Ledger.Conway.Conformance.Certs govStructure\n\nopen import Ledger.Conway.Specification.Ledger txs abs public\n  using (LEnv; HasCast-LEnv; allColdCreds; rmOrphanDRepVotes; txgov)\n\nopen Tx\n\nrecord LState : Type where\n  constructor \u27e6_,_,_\u27e7\u02e1\n  field\n    utxoSt     : UTxOState\n    govSt      : GovState\n    certState  : CertState\n\ninstance\n  unquoteDecl HasCast-LState = derive-HasCast\n    [ (quote LState , HasCast-LState) ]\n\nprivate variable\n  \u0393 : LEnv\n  s s' s'' : LState\n  utxoSt' : UTxOState\n  govSt' : GovState\n  certState' : CertState\n  tx : Tx\n\nopen UTxOState\n\ndata\n\n  _\u22a2_\u21c0\u2987_,LEDGER\u2988_ : LEnv \u2192 LState \u2192 Tx \u2192 LState \u2192 Type\n\n  where\n\n  LEDGER-V :\n    let open LState s; txb = tx .body; open TxBody txb; open LEnv \u0393\n        open CertState certState; open DState dState\n        utxoSt'' = record utxoSt' { deposits = updateDeposits pparams txb (deposits utxoSt') }\n     in\n    \u2219  isValid tx \u2261 true\n    \u2219  record { LEnv \u0393 } \u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt'\n    \u2219  \u27e6 epoch slot , pparams , txGovVotes , txWithdrawals , allColdCreds govSt enactState \u27e7 \u22a2 certState \u21c0\u2987 txCerts ,CERTS\u2988 certState'\n    \u2219  \u27e6 txId , epoch slot , pparams , ppolicy , enactState ,  certState' , dom\n    rewards \u27e7 \u22a2 govSt \u21c0\u2987 txgov txb ,GOVS\u2988 govSt'\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 \u27e6 utxoSt'' , govSt' , certState' \u27e7\n\n\n  LEDGER-I : let open LState s; txb = tx .body; open TxBody txb; open LEnv \u0393 in\n    \u2219  isValid tx \u2261 false\n    \u2219  record { LEnv \u0393 } \u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt'\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 \u27e6 utxoSt' , govSt , certState \u27e7\n\npattern LEDGER-V\u22ef w x y z = LEDGER-V (w , x , y , z)\npattern LEDGER-I\u22ef y z     = LEDGER-I (y , z)\n\n_\u22a2_\u21c0\u2987_,LEDGERS\u2988_ : LEnv \u2192 LState \u2192 List Tx \u2192 LState \u2192 Type\n_\u22a2_\u21c0\u2987_,LEDGERS\u2988_ = ReflexiveTransitiveClosure {sts = _\u22a2_\u21c0\u2987_,LEDGER\u2988_}\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Properties\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Conformance.Chain txs abs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Epoch txs abs\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Conformance.Certs govStructure\n\nisCredDeposit : DepositPurpose \u2192 Type\nisCredDeposit (CredentialDeposit x) = \u22a4\nisCredDeposit _ = \u22a5\n\ninstance\n  isCredDeposit? : isCredDeposit \u2047\u00b9\n  isCredDeposit? {CredentialDeposit x} = \u2047 (yes tt)\n  isCredDeposit? {PoolDeposit x} = \u2047 (no \u03bb ())\n  isCredDeposit? {DRepDeposit x} = \u2047 (no \u03bb ())\n  isCredDeposit? {GovActionDeposit x} = \u2047 (no \u03bb ())\n\nisGADeposit : DepositPurpose \u2192 Type\nisGADeposit (GovActionDeposit x) = \u22a4\nisGADeposit _ = \u22a5\n\ninstance\n  isGADeposit? : isGADeposit \u2047\u00b9\n  isGADeposit? {CredentialDeposit x} = \u2047 (no \u03bb ())\n  isGADeposit? {PoolDeposit x} = \u2047 (no \u03bb ())\n  isGADeposit? {DRepDeposit x} = \u2047 (no \u03bb ())\n  isGADeposit? {GovActionDeposit x} = \u2047 (yes tt)\n\ngetLState : NewEpochState \u2192 LState\ngetLState = EpochState.ls \u2218 NewEpochState.epochState\n\ngetRewards : NewEpochState \u2192 Credential \u21c0 Coin\ngetRewards = DState.rewards \u2218 CertState.dState \u2218 LState.certState \u2218 getLState\n\nallDReps : NewEpochState \u2192 DReps\nallDReps = GState.dreps \u2218 CertState.gState \u2218 LState.certState \u2218 getLState\n\nactiveDReps : Epoch \u2192 NewEpochState \u2192 \u2119 Credential\nactiveDReps currentEpoch s = dom (filter\u1d50 (\u03bb (_ , e) \u2192 currentEpoch \u2264 e) (allDReps s))\n\ngetGovState : NewEpochState \u2192 GovState\ngetGovState = LState.govSt \u2218 getLState\n\ninstance\n  _ : IsSet Block Tx\n  _ = record { toSet = fromList \u2218 Block.ts }\n\n  _ : IsSet TxBody GovProposal\n  _ = record { toSet = fromList \u2218 TxBody.txGovProposals }\n\nvalidBlockIn : ChainState \u2192 Block \u2192 Type\nvalidBlockIn s b = \u2203[ s' ] _ \u22a2 s \u21c0\u2987 b ,CHAIN\u2988 s'\n\nvalidBlock : Block \u2192 Type\nvalidBlock b = \u2203[ s ] validBlockIn s b\n\n-- Transaction validity is complicated. In the truest sense, a\n-- transaction is valid if it is part of a valid block,\n-- i.e. `validTxIn\u2081`. However, a transaction can also be seen as valid\n-- if it could be applied at a certain slot (with no knowledge of an\n-- actual block). This is closer to how the mempool sees transaction\n-- validity and is expressed by `validTxIn\u2082`.\n\n-- Note that these two are not equivalent and in fact there is no\n-- implication between the two in either direction. `2 =&gt; 1` would\n-- require one to come up with a block, which we can't, but `1 =&gt; 2`\n-- is also not true, since the transaction might depend on a previous\n-- transaction in the same block. Maybe this means that `validTxIn\u2082`\n-- should be changed so that it allows for applying a list of\n-- transactions before the final transaction? However, the downside\n-- then becomes that the transaction isn't applied to the given state\n-- but to some intermediate one. Maybe we'll gain some insight on this\n-- matter once we have proven more theorems.\n\nvalidTxIn\u2081 : ChainState \u2192 Tx \u2192 Type\nvalidTxIn\u2081 s tx = \u2203[ b ] tx \u2208 b \u00d7 validBlockIn s b\n\nmodule _ (s : ChainState) (slot : Slot) where\n\n  open ChainState s; open NewEpochState newEpochState\n  open EpochState epochState; open EnactState es\n\n  private\n    ledgerEnv = \u27e6 slot , constitution .proj\u2081 .proj\u2082 , pparams .proj\u2081 , es , Acnt.treasury acnt \u27e7\n\n  validTxIn\u2082 : Tx \u2192 Type\n  validTxIn\u2082 tx = \u2203[ ls' ] ledgerEnv \u22a2 ls \u21c0\u2987 tx ,LEDGER\u2988 ls'\n\nvalidTx\u2081 : Tx \u2192 Type\nvalidTx\u2081 tx = \u2203[ s ] validTxIn\u2081 s tx\n\nChainInvariant : \u2200 {a} \u2192 (ChainState \u2192 Type a) \u2192 Type a\nChainInvariant P = \u2200 b s s' \u2192 _ \u22a2 s \u21c0\u2987 b ,CHAIN\u2988 s' \u2192 P s \u2192 P s'\n\nmodule _ (s : ChainState) where\n  open ChainState s; open NewEpochState newEpochState; open EpochState epochState\n  open LState ls\n  open EnactState es renaming (pparams to pparams')\n  open CertState certState; open DState dState\n  pparams = \u2223 pparams' \u2223\n  open PParams pparams\n  open Tx; open TxBody\n\n  -- Transaction properties\n\n  module _ {slot} {tx} (let txb = body tx) (valid : validTxIn\u2082 s slot tx)\n    (indexedSum-\u222a\u207a-hom : \u2200 {A V : Type} \u2983 _ : DecEq A \u2984 \u2983 _ : DecEq V \u2984 \u2983 mon : CommutativeMonoid 0\u2113 0\u2113 V \u2984\n      \u2192 (d\u2081 d\u2082 : A \u21c0 V) \u2192 indexedSum\u1d5b' id (d\u2081 \u222a\u207a d\u2082) \u2261 indexedSum\u1d5b' id d\u2081 \u25c7 indexedSum\u1d5b' id d\u2082)\n    (indexedSum-\u2286 : \u2200 {A : Type} \u2983 _ : DecEq A \u2984 (d d' : A \u21c0 \u2115) \u2192 d \u02e2 \u2286 d' \u02e2\n      \u2192 indexedSum\u1d5b' id d \u2264 indexedSum\u1d5b' id d') -- technically we could use an ordered monoid instead of \u2115\n    where\n    open import Ledger.Conway.Conformance.Utxow txs abs\n    open import Ledger.Conway.Conformance.Utxo.Properties txs abs\n\n  --   propose-ChangePP-hasGroup : \u2200 {up prop}\n  --     \u2192 prop \u2208 txb \u2192 prop .GovProposal.action \u2261 ChangePParams up \u2192 updateGroups up \u2262 \u2205\n  --   propose-ChangePP-hasGroup = {!!}\n\n  -- Block properties\n\n  module _ {b} (valid : validBlockIn s b) (let open Block b) where\n    isNewEpochBlock : Type\n    isNewEpochBlock = epoch slot \u2261 suc\u1d49 lastEpoch\n\n    newChainState : ChainState\n    newChainState = proj\u2081 valid\n\n    -- enact-change\u21d2newEpoch : es \u2262 getEnactState newChainState \u2192 isNewEpochBlock\n    -- enact-change\u21d2newEpoch = {!!}\n\n  -- Invariant properties\n\n  action-deposits\u2261actions-prop : Type\n  action-deposits\u2261actions-prop = filter\u02e2 isGADeposit (dom (UTxOState.deposits utxoSt))\n    \u2261 fromList (map (\u03bb where (id , _) \u2192 GovActionDeposit id) govSt)\n\n  dom-rwds\u2261credDeposits : Type\n  dom-rwds\u2261credDeposits = filter\u02e2 isCredDeposit (dom (UTxOState.deposits utxoSt))\n    \u2261 map\u02e2 CredentialDeposit (dom rewards)\n\n  pp-wellFormed : Type\n  pp-wellFormed = paramsWellFormed pparams\n\n-- action-deposits\u2261actions-inv : ChainInvariant action-deposits\u2261actions-prop\n-- action-deposits\u2261actions-inv = {!!}\n\n-- dom-rwds\u2261credDeposits-inv : ChainInvariant dom-rwds\u2261credDeposits\n-- dom-rwds\u2261credDeposits-inv = {!!}\n\n-- pp-wellFormed-inv : ChainInvariant pp-wellFormed\n-- pp-wellFormed-inv = {!!}\n\n-- Epoch boundary properties\n\n-- module _ {\u0393 es e es'} (step : \u0393 \u22a2 es \u21c0\u2987 e ,NEWEPOCH\u2988 es') where\n--   dom-rwds-const : dom (getRewards es) \u2261 dom (getRewards es')\n--   dom-rwds-const = {!!}\n\n--   prop\u2261\u2205\u21d2activeDReps-const : getGovState es \u2261 [] \u2192 activeDReps e es \u2261\u1d49 activeDReps (suc\u1d49 e) es'\n--   prop\u2261\u2205\u21d2activeDReps-const = {!!}\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Rewards.html","title":"Rewards","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Rewards\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs)\n  where\n\nopen import Ledger.Prelude\n\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Conformance.Utxo txs abs\n\nopen import Ledger.Conway.Specification.Rewards txs abs\n  hiding (_\u22a2_\u21c0\u2987_,SNAP\u2988_) public\n\nprivate variable\n  lstate : LState\n  mark set go : Snapshot\n  feeSS : Coin\n\ndata _\u22a2_\u21c0\u2987_,SNAP\u2988_ : LState \u2192 Snapshots \u2192 \u22a4 \u2192 Snapshots \u2192 Type where\n  SNAP : let open LState lstate\n             open UTxOState utxoSt\n             open CertState certState\n             stake = stakeDistr utxo (record { DState dState }) pState\n    in\n    lstate \u22a2 \u27e6 mark , set , go , feeSS \u27e7 \u21c0\u2987 tt ,SNAP\u2988 \u27e6 stake , mark , set , fees \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Script.html","title":"Script","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Algebra.Morphism\nopen import Data.List.Relation.Unary.All using (All; []; _\u2237_; all?; uncons)\nopen import Data.List.Relation.Unary.Any\nopen import Data.Nat.Properties using (+-0-commutativeMonoid; suc-injective)\n\nopen import stdlib.Data.List.Relation.Unary.MOf\n\n\nopen import Ledger.Prelude hiding (All; Any; all?; any?; _\u2237\u02b3_; uncons; _\u2286_)\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\n\nimport Ledger.Conway.Specification.Script\n\nmodule Ledger.Conway.Conformance.Script\n  (cs : _) (open CryptoStructure cs)\n  (es : _) (open EpochStructure es)\n  where\n\nopen Ledger.Conway.Specification.Script cs es\n\nrecord HSTimelock : Type where\n  field\n    timelock     : Timelock\n    tlScriptHash : ScriptHash\n    tlScriptSize : \u2115\n\ninstance\n  Hashable-HSTimelock : Hashable HSTimelock ScriptHash\n  Hashable-HSTimelock .hash = HSTimelock.tlScriptHash\n\nunquoteDecl DecEq-HSTimelock = derive-DecEq ((quote HSTimelock , DecEq-HSTimelock) \u2237 [])\n\nrecord HSPlutusScript : Type where\n  constructor MkHSPlutusScript\n  field psScriptHash : ScriptHash\n        psScriptSize : \u2115\n\ninstance\n  Hashable-HSPlutusScript : Hashable HSPlutusScript ScriptHash\n  Hashable-HSPlutusScript .hash = HSPlutusScript.psScriptHash\n\nP1ScriptStructure-HTL : P1ScriptStructure\nP1ScriptStructure-HTL = record\n  { P1Script = HSTimelock\n  ; validP1Script = \u03bb x y \u2192 evalTimelock x y \u2218 HSTimelock.timelock }\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Utxo.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract using (AbstractFunctions)\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nmodule Ledger.Conway.Conformance.Utxo.Properties\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Data.Nat.Properties hiding (_\u225f_)\nopen import Data.String.Base renaming (_++_ to _+\u02e2_) using ()\nopen import Interface.ComputationalRelation\nopen import Ledger.Prelude hiding (\u2264-trans; \u2264-antisym; All); open Properties\nopen import Ledger.Conway.Specification.Script.Validation txs abs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Prelude\nopen import stdlib-meta.Tactic.GenError\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Utxo txs abs public\n\nopen Equivalence\n\ninstance\n  _ = TokenAlgebra.Value-CommutativeMonoid tokenAlgebra\n  _ = +-0-monoid\n  _ = Functor-ComputationResult\n\ninstance\n  Computational-UTXOS : Computational _\u22a2_\u21c0\u2987_,UTXOS\u2988_ String\n  Computational-UTXOS = record {go} where\n    module go \u0393 s tx\n      (let H-Yes , \u2047 H-Yes? = Scripts-Yes-premises {\u0393} {s} {tx})\n      (let H-No  , \u2047 H-No?  = Scripts-No-premises {\u0393} {s} {tx}) where\n      open Tx tx renaming (body to txb); open TxBody txb\n      open UTxOEnv \u0393 renaming (pparams to pp)\n      open UTxOState s\n      sLst = collectP2ScriptsWithContext pp tx utxo\n\n      computeProof =\n        case H-Yes? ,\u2032 H-No? of \u03bb where\n          (yes p , no _ ) \u2192 success (_ , (Scripts-Yes p))\n          (no _  , yes p) \u2192 success (_ , (Scripts-No p))\n          (_     , _    ) \u2192 failure \"isValid check failed\"\n\n      completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n      completeness _ (Scripts-Yes p) with H-No? | H-Yes?\n      ... | yes (_ , refl) | _     = case proj\u2082 p of \u03bb ()\n      ... | no _           | yes _ = refl\n      ... | no _           | no \u00acp = case \u00acp p of \u03bb ()\n      completeness _ (Scripts-No p) with H-Yes? | H-No?\n      ... | yes (_ , refl) | _     = case proj\u2082 p of \u03bb ()\n      ... | no _           | yes _ = refl\n      ... | no _           | no \u00acp = case \u00acp p of \u03bb ()\n\ninstance\n  Computational-UTXO : Computational _\u22a2_\u21c0\u2987_,UTXO\u2988_ String\n  Computational-UTXO = record {Go}\n    where\n      module Go \u0393 s tx (let H , \u2047 H? = UTXO-premises {tx}{\u0393}{s}) where\n\n        open Computational Computational-UTXOS\n          renaming (computeProof to computeProof'; completeness to completeness')\n\n        computeProofH : Dec H \u2192 ComputationResult String (\u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s')\n        computeProofH (yes (x , y , z , e , k , l , m , c , v , j , n , o , p , q , r , t , u)) =\n            map\u2082\u2032 (UTXO-inductive\u22ef _ _ _ x y z e k l m c v j n o p q r t u) &lt;$&gt; computeProof' \u0393 s tx\n        computeProofH (no \u00acp) = failure $ genErrors \u00acp\n\n        computeProof : ComputationResult String (\u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s')\n        computeProof = computeProofH H?\n\n        completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n        completeness s' (UTXO-inductive\u22ef _ _ _ x y z e k l m c v j n o p q r t u h) with H?\n        ... | no \u00acp = \u22a5-elim $ \u00acp (x , y , z , e , k , l , m , c , v , j , n , o , p , q , r , t , u )\n        ... | yes _ with computeProof' \u0393 s tx | completeness' _ _ _ _ h\n        ... | success _ | refl = refl\n\nopen Computational \u2983...\u2984\n\nprivate variable\n  tx                         : Tx\n  utxo utxo'                 : UTxO\n  \u0393                          : UTxOEnv\n  utxoState utxoState'       : UTxOState\n  fees fees'                 : Fees\n  donations donations'       : Donations\n  deposits deposits'         : Deposits\n\nUTXO-step : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 ComputationResult String UTxOState\nUTXO-step = compute \u2983 Computational-UTXO \u2984\n\nUTXO-step-computes-UTXO  :  UTXO-step \u0393 utxoState tx \u2261 success utxoState'\n                         \u21d4  \u0393 \u22a2 utxoState \u21c0\u2987 tx ,UTXO\u2988 utxoState'\nUTXO-step-computes-UTXO = \u2261-success\u21d4STS \u2983 Computational-UTXO \u2984\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Utxo.html","title":"Utxo","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Algebra              using (CommutativeMonoid)\nopen import Data.Nat.Properties  using (+-0-monoid)\nimport Data.Maybe as M\nimport Data.Sum.Relation.Unary.All as Sum\n\nimport Data.Integer as \u2124\nimport Data.Rational as \u211a\n\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Utxo\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Script.Validation txs abs\nopen import Ledger.Conway.Specification.Fees txs using (scriptsCost)\nopen import Ledger.Conway.Conformance.Certs govStructure\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Utxo txs abs public\n\nopen PParams\n\ninstance\n  _ = +-0-monoid\n\nopen L public using (UTxOEnv; UTxOState; \u27e6_,_,_,_\u27e7\u1d58; HasCast-UTxOState; updateDeposits\n                    ; cbalance; balance; depositRefunds; consumed\n                    ; produced; outs; newDeposits; refScriptsSize )\n\nprivate variable\n  \u0393 : UTxOEnv\n  s s' : UTxOState\n  tx : Tx\n\nopen PParams\n\ndata _\u22a2_\u21c0\u2987_,UTXOS\u2988_ : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 UTxOState \u2192 Type where\n  Scripts-Yes :\n    \u2200 {\u0393} {s} {tx}\n    \u2192 let open Tx tx renaming (body to txb); open TxBody txb\n          open UTxOEnv \u0393 renaming (pparams to pp)\n          open UTxOState s\n          p2Scripts = collectP2ScriptsWithContext pp tx utxo\n      in\n        \u2219 evalP2Scripts p2Scripts \u2261 isValid\n        \u2219 isValid \u2261 true\n          \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n          \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988  \u27e6 (utxo \u2223 txIns \u1d9c) \u222a\u02e1 (L.outs txb)\n                              , fees + txFee\n                              , deposits\n                              , donations + txDonation\n                              \u27e7\n\n  Scripts-No :\n    \u2200 {\u0393} {s} {tx}\n    \u2192 let open Tx tx renaming (body to txb); open TxBody txb\n          open UTxOEnv \u0393 renaming (pparams to pp)\n          open UTxOState s\n          p2Scripts = collectP2ScriptsWithContext pp tx utxo\n      in\n        \u2219 evalP2Scripts p2Scripts \u2261 isValid\n        \u2219 isValid \u2261 false\n          \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n          \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988  \u27e6 utxo \u2223 collateralInputs \u1d9c\n                              , fees + L.cbalance (utxo \u2223 collateralInputs)\n                              , deposits\n                              , donations\n                              \u27e7\n\nunquoteDecl Scripts-Yes-premises = genPremises Scripts-Yes-premises (quote Scripts-Yes)\nunquoteDecl Scripts-No-premises  = genPremises Scripts-No-premises  (quote Scripts-No)\n\ndata _\u22a2_\u21c0\u2987_,UTXO\u2988_ : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 UTxOState \u2192 Type where\n\n  UTXO-inductive :\n    let open Tx tx renaming (body to txb); open TxBody txb; open TxWitnesses wits\n        open UTxOEnv \u0393 renaming (pparams to pp)\n        open UTxOState s\n        txOuts\u02b0 = (mapValues txOutHash txOuts)\n        overhead = 160\n    in\n    \u2219 txIns \u2262 \u2205                              \u2219 txIns \u222a refInputs \u2286 dom utxo\n    \u2219 txIns \u2229 refInputs \u2261 \u2205                  \u2219 L.inInterval slot txVldt\n    \u2219 L.minfee pp utxo tx \u2264 txFee            \u2219 (txrdmrs \u02e2 \u2262 \u2205 \u2192 L.collateralCheck pp tx utxo)\n    \u2219 consumed pp s txb \u2261 produced pp s txb  \u2219 coin mint \u2261 0\n    \u2219 txsize \u2264 maxTxSize pp\n    \u2219 L.refScriptsSize utxo tx \u2264 pp .maxRefScriptSizePerTx\n\n    \u2219 \u2200[ (_ , txout) \u2208 \u2223 txOuts\u02b0 \u2223 ]\n        inject ((overhead + L.utxoEntrySize txout) * coinsPerUTxOByte pp) \u2264\u1d57 getValue\u02b0 txout\n    \u2219 \u2200[ (_ , txout) \u2208 \u2223 txOuts\u02b0 \u2223 ]\n        serSize (getValue\u02b0 txout) \u2264 maxValSize pp\n    \u2219 \u2200[ (a , _) \u2208 range txOuts\u02b0 ]\n        Sum.All (const \u22a4) (\u03bb a \u2192 a .BootstrapAddr.attrsSize \u2264 64) a\n    \u2219 \u2200[ (a , _) \u2208 range txOuts\u02b0 ]  netId a         \u2261 NetworkId\n    \u2219 \u2200[ a \u2208 dom txWithdrawals ]    NetworkIdOf a   \u2261 NetworkId\n    \u2219 txNetworkId ~ just NetworkId\n    \u2219 currentTreasury ~ just treasury\n    \u2219 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s'\n\npattern UTXO-inductive\u22ef tx \u0393 s x y z w k l m c v j n o p q r t u h\n      = UTXO-inductive {tx}{\u0393}{s} (x , y , z , w , k , l , m , c , v , j , n , o , p , q , r , t , u , h)\nunquoteDecl UTXO-premises = genPremises UTXO-premises (quote UTXO-inductive)\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Utxow.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nimport Data.Maybe as M\n\nopen import Ledger.Prelude\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Utxow.Properties\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Conformance.Utxow txs abs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Utxo.Properties txs abs\n\nopen import stdlib-meta.Tactic.GenError using (genErrors)\n\ninstance\n  Computational-UTXOW : Computational _\u22a2_\u21c0\u2987_,UTXOW\u2988_ String\n  Computational-UTXOW = record {Go}\n    where module Go \u0393 s tx (let H , \u2047 H? = UTXOW-inductive-premises {tx}{s}) where\n\n    open Computational Computational-UTXO\n      renaming (computeProof to computeProof'; completeness to completeness')\n\n    computeProof : ComputationResult String (\u2203 (\u0393 \u22a2 s \u21c0\u2987 tx ,UTXOW\u2988_))\n    computeProof =\n      case H? of \u03bb where\n        (yes (p\u2081 , p\u2082 , p\u2083 , p\u2084 , p\u2085 , p\u2086 , p\u2087 , p\u2088)) \u2192\n          map (map\u2082\u2032 (UTXOW-inductive\u22ef p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 p\u2087 p\u2088)) (computeProof' \u0393 s tx)\n        (no \u00acp) \u2192 failure $ genErrors \u00acp\n\n    completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n                        \u2192 map proj\u2081 computeProof \u2261 success s'\n    completeness s' (UTXOW-inductive\u22ef p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 p\u2087 p\u2088 h) with H?\n    ... | no \u00acp = \u22a5-elim $ \u00acp ((p\u2081 , p\u2082 , p\u2083 , p\u2084 , p\u2085 , p\u2086 , p\u2087 , p\u2088))\n    ... | yes _ with computeProof' \u0393 s tx | completeness' _ _ _ _ h\n    ... | success _ | refl = refl\n</code></pre>"},{"location":"Ledger.Conway.Conformance.Utxow.html","title":"Utxow","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Utxow\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Specification.Script.Validation txs abs\nopen import Ledger.Conway.Specification.Certs govStructure\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Utxow txs abs public\n    open import Ledger.Conway.Specification.Utxo txs abs public\n\ndata\n\n  _\u22a2_\u21c0\u2987_,UTXOW\u2988_ : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 UTxOState \u2192 Type\n\nprivate variable\n  \u0393 : UTxOEnv\n  s s' : UTxOState\n  tx : Tx\n\ndata _\u22a2_\u21c0\u2987_,UTXOW\u2988_ where\n\n  UTXOW-inductive :\n    let open Tx tx renaming (body to txb); open TxBody txb; open TxWitnesses wits\n        open UTxOState s\n        witsKeyHashes       = map\u02e2 hash (dom vkSigs)\n        witsScriptHashes    = map\u02e2 hash scripts\n        refScriptHashes     = map\u02e2 hash (refScripts tx utxo)\n        neededScriptHashes  = mapPartial (isScriptObj  \u2218 proj\u2082) (credsNeeded utxo txb)\n        neededVKeyHashes    = mapPartial (isKeyHashObj \u2218 proj\u2082) (credsNeeded utxo txb)\n        txdatsHashes        = map\u02e2 hash txdats\n        inputsDataHashes    = mapPartial (\u03bb txout \u2192 if txOutToP2Script utxo tx txout\n                                                     then txOutToDataHash txout\n                                                     else nothing) (range (utxo \u2223 txIns))\n        refInputsDataHashes = mapPartial txOutToDataHash (range (utxo \u2223 refInputs))\n        outputsDataHashes   = mapPartial txOutToDataHash (range txOuts)\n        nativeScripts       = mapPartial toP1Script (txscripts tx utxo)\n    in\n    \u2219  \u2200[ (vk , \u03c3) \u2208 vkSigs ] isSigned vk (txidBytes txId) \u03c3\n    \u2219  \u2200[ s \u2208 nativeScripts ] (hash s \u2208 neededScriptHashes \u2192 validP1Script witsKeyHashes txVldt s)\n    \u2219  neededVKeyHashes \u2286 witsKeyHashes\n    \u2219  neededScriptHashes - refScriptHashes \u2261\u1d49 witsScriptHashes\n    \u2219  inputsDataHashes \u2286 txdatsHashes\n    \u2219  txdatsHashes \u2286 inputsDataHashes \u222a outputsDataHashes \u222a refInputsDataHashes\n    \u2219  L.languages tx utxo \u2286 L.allowedLanguages tx utxo\n    \u2219  txADhash \u2261 map hash txAD\n    \u2219  \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s'\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n\npattern UTXOW-inductive\u22ef p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 p\u2087 p\u2088 h\n      = UTXOW-inductive (p\u2081 , p\u2082 , p\u2083 , p\u2084 , p\u2085 , p\u2086 , p\u2087 , p\u2088 , h)\npattern UTXOW\u21d2UTXO x = UTXOW-inductive\u22ef _ _ _ _ _ _ _ _ x\n\nunquoteDecl UTXOW-inductive-premises =\n  genPremises UTXOW-inductive-premises (quote UTXOW-inductive)\n</code></pre>"},{"location":"Ledger.Conway.Conformance.html","title":"Conformance","text":"<pre><code>{-# OPTIONS --safe #-}\nmodule Ledger.Conway.Conformance where\n\nimport Ledger.Conway.Conformance.Certs\nimport Ledger.Conway.Conformance.Certs.Properties\nimport Ledger.Conway.Conformance.Chain\nimport Ledger.Conway.Conformance.Chain.Properties\nimport Ledger.Conway.Conformance.Equivalence\nimport Ledger.Conway.Conformance.Epoch\nimport Ledger.Conway.Conformance.Epoch.Properties\nimport Ledger.Conway.Conformance.Gov\nimport Ledger.Conway.Conformance.Ledger\nimport Ledger.Conway.Conformance.Ledger.Properties\nimport Ledger.Conway.Conformance.Properties\nimport Ledger.Conway.Conformance.Utxo\nimport Ledger.Conway.Conformance.Utxo.Properties\nimport Ledger.Conway.Conformance.Utxow\nimport Ledger.Conway.Conformance.Utxow.Properties\nimport Ledger.Conway.Conformance.Script\n</code></pre>"},{"location":"Ledger.Conway.Foreign.ExternalFunctions.html","title":"ExternalFunctions","text":"<pre><code>module Ledger.Conway.Foreign.ExternalFunctions where\n\nopen import Ledger.Prelude\nopen import Foreign.HaskellTypes.Deriving\n\nrecord ExternalFunctions : Set where\n  field extIsSigned : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 Bool\n{-# FOREIGN GHC\n  data ExternalFunctions = MkExternalFunctions\n    { extIsSigned :: Integer -&gt; Integer -&gt; Integer -&gt; Bool\n    }\n#-}\n{-# COMPILE GHC ExternalFunctions = data ExternalFunctions (MkExternalFunctions) #-}\n\ndummyExternalFunctions : ExternalFunctions\ndummyExternalFunctions = record { extIsSigned = \u03bb x x\u2081 x\u2082 \u2192 true }\n{-# COMPILE GHC dummyExternalFunctions as dummyExternalFunctions #-}\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Address.html","title":"Address","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Address where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\n\ninstance\n  HsTy-HSVKey = autoHsType HSVKey\n  Conv-HSVKey = autoConvert HSVKey\n\n  HsTy-Credential = autoHsType Credential\n  Conv-Credential = autoConvert Credential\n\n  HsTy-BaseAddr = autoHsType BaseAddr \u22a3 fieldPrefix \"base\"\n  Conv-BaseAddr = autoConvert BaseAddr\n\n  HsTy-BootstrapAddr = autoHsType BootstrapAddr \u22a3 fieldPrefix \"boot\"\n  Conv-BootstrapAddr = autoConvert BootstrapAddr\n\n  HsTy-RwdAddr = autoHsType RwdAddr \u22a3 fieldPrefix \"rwd\"\n  Conv-RwdAddr = autoConvert RwdAddr\n\nunquoteDecl = do\n  hsTypeAlias Addr\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.BaseTypes.html","title":"BaseTypes","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.BaseTypes where\n\nopen import Data.Rational\n\nopen import Ledger.Prelude.Numeric.UnitInterval\nopen import Ledger.Prelude.Numeric.PositiveNat\nopen import Ledger.Conway.Foreign.ExternalFunctions\nopen import Ledger.Conway.Foreign.HSLedger.Core public\nimport Ledger.Prelude.Foreign.HSTypes as F\n\ninstance\n  iConvTop    = Convertible-Refl {\u22a4}\n  iConvNat    = Convertible-Refl {\u2115}\n  iConvString = Convertible-Refl {String}\n  iConvBool   = Convertible-Refl {Bool}\n\ninstance\n\n  -- * Unit and empty\n\n  HsTy-\u22a5 = MkHsType \u22a5 F.Empty\n  Conv-\u22a5 = autoConvert \u22a5\n\n  HsTy-\u22a4 = MkHsType \u22a4 \u22a4\n\n  -- * Rational numbers\n\n  HsTy-Rational = MkHsType \u211a F.Rational\n  Conv-Rational : HsConvertible \u211a\n  Conv-Rational = \u03bb where\n    .to (mk\u211a n d _)       \u2192 n F., suc d\n    .from (n F., zero)    \u2192 0\u211a -- TODO is there a safer way to do this?\n    .from (n F., (suc d)) \u2192 n Data.Rational./ suc d\n\n  -- * Maps and Sets\n\n  HsTy-HSSet : \u2200 {A} \u2192 \u2983 HasHsType A \u2984 \u2192 HasHsType (\u2119 A)\n  HsTy-HSSet {A} = MkHsType _ (F.HSSet (HsType A))\n\n  Conv-HSSet : \u2200 {A} \u2983 _ : HasHsType A \u2984\n             \u2192 \u2983 HsConvertible A \u2984\n             \u2192 HsConvertible (\u2119 A)\n  Conv-HSSet = \u03bb where\n    .to \u2192 F.MkHSSet \u2218 to \u2218 setToList\n    .from \u2192 fromList\u02e2 \u2218 from \u2218 F.HSSet.elems\n\n  HsTy-Map : \u2200 {A B} \u2192 \u2983 HasHsType A \u2984 \u2192 \u2983 HasHsType B \u2984 \u2192 HasHsType (A \u21c0 B)\n  HsTy-Map {A} {B} = MkHsType _ (F.HSMap (HsType A) (HsType B))\n\n  Conv-HSMap : \u2200 {A B} \u2983 _ : HasHsType A \u2984 \u2983 _ : HasHsType B \u2984\n    \u2192 \u2983 DecEq A \u2984\n    \u2192 \u2983 HsConvertible A \u2984\n    \u2192 \u2983 HsConvertible B \u2984\n    \u2192 HsConvertible (A \u21c0 B)\n  Conv-HSMap = \u03bb where\n    .to \u2192 F.MkHSMap \u2218 to\n    .from \u2192 from \u2218 F.HSMap.assocList\n\n  -- * ComputationResult\n\n  HsTy-ComputationResult : \u2200 {l} {Err} {A : Type l}\n                           \u2192 \u2983 HasHsType Err \u2984 \u2192 \u2983 HasHsType A \u2984\n                           \u2192 HasHsType (ComputationResult Err A)\n  HsTy-ComputationResult {Err = Err} {A} = MkHsType _ (F.ComputationResult (HsType Err) (HsType A))\n\n  Conv-ComputationResult : ConvertibleType ComputationResult F.ComputationResult\n  Conv-ComputationResult = autoConvertible\n\nopen import Ledger.Conway.Foreign.HSLedger.ExternalStructures dummyExternalFunctions\n  renaming\n    ( HSTransactionStructure to DummyTransactionStructure\n    ; HSAbstractFunctions to DummyAbstractFunctions\n    )\n  public\nopen import Ledger.Conway.Conformance.Certs.Properties govStructure\n\nunquoteDecl = do\n  hsTypeAlias Coin\n  hsTypeAlias ExUnits\n  hsTypeAlias Epoch\n  hsTypeAlias ScriptHash\n\ninstance\n  HsTy-UnitInterval : HasHsType UnitInterval\n  HsTy-UnitInterval .HasHsType.HsType = F.Rational\n    -- I would like to use \u211a here, but F.Rational converts better.\n\n  Conv-UnitInterval : Convertible UnitInterval F.Rational\n  Conv-UnitInterval .to x = to (fromUnitInterval x)\n  Conv-UnitInterval .from x =\n    case toUnitInterval (from x) of \u03bb where\n      (just x) \u2192 x\n      nothing \u2192 error \"Formal Spec: rational outside of unit interval\"\n\ninstance\n  HsTy-PosNat : HasHsType PosNat\n  HsTy-PosNat .HasHsType.HsType = \u2115\n\n  Conv-PosNat : Convertible PosNat \u2115\n  Conv-PosNat .to x = to (fromPosNat x)\n  Conv-PosNat .from x =\n    case toPosNat (from x) of \u03bb where\n      (just x) \u2192 x\n      nothing \u2192 error \"Formal Spec: natural number is zero (not nonZero)\"\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Cert.html","title":"Cert","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Cert where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes hiding (CertEnv; DCert) renaming (\u27e6_,_,_\u27e7\u1d9c\u02e2 to \u27e6_,_,_\u27e7\u1d9c\u02e2'; CertState to CertState')\nopen import Ledger.Conway.Foreign.HSLedger.Certs\n\nopen import Ledger.Conway.Conformance.Certs.Properties govStructure\n  using ( Computational-CERT\n        ; Computational-CERTS\n        )\n\nopen import Ledger.Conway.Conformance.Certs govStructure\n\ninstance\n  -- HsTy-CertState = autoHsType' CertState (\u27e6_,_,_\u27e7\u1d9c\u02e2 \u21a6 \"MkCertState\" \u2237 [])\n  -- Conv-CertState = autoConvert CertState\n\n  HsTy-CertState = autoHsType CertState \u22a3 withConstructor \"MkCertState\"\n  Conv-CertState = autoConvert CertState\n\n  Conv-CertState-CertState' : Convertible CertState CertState'\n  Conv-CertState-CertState' .to \u27e6 dState , pState , gState \u27e7\u1d9c\u02e2    = \u27e6 to dState , pState , to gState \u27e7\u1d9c\u02e2'\n  Conv-CertState-CertState' .from \u27e6 dState , pState , gState \u27e7\u1d9c\u02e2' = \u27e6 from dState , pState , from gState \u27e7\u1d9c\u02e2\n\ncerts-step : HsType (CertEnv \u2192 CertState \u2192 List DCert \u2192 ComputationResult String CertState)\ncerts-step = to (compute Computational-CERTS)\n\n{-# COMPILE GHC certs-step as certsStep #-}\n\ncert-step : HsType (CertEnv \u2192 CertState \u2192 DCert \u2192 ComputationResult String CertState)\ncert-step = to (compute Computational-CERT)\n\n{-# COMPILE GHC cert-step as certStep #-}\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Certs.html","title":"Certs","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Certs where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes renaming (\u27e6_,_,_\u27e7\u1d48 to \u27e6_,_,_\u27e7\u1d48'; DState to DState'\n                                                              ; \u27e6_,_\u27e7\u1d5b to \u27e6_,_\u27e7\u1d5b'; GState to GState') hiding (CertEnv)\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Core\nopen import Ledger.Conway.Foreign.HSLedger.PParams\n\nopen import Ledger.Conway.Conformance.Certs govStructure using (\u27e6_,_,_,_\u27e7\u1d48; \u27e6_,_,_\u27e7\u1d5b; DState; GState; CertEnv)\n\nopen import Ledger.Conway.Conformance.Certs.Properties govStructure\n  using ( Computational-DELEG\n        ; Computational-GOVCERT\n        ; Computational-POOL\n        )\n\ninstance\n  HsTy-StakePoolParams = autoHsType StakePoolParams\n  Conv-StakePoolParams = autoConvert StakePoolParams\n\n  HsTy-DepositPurpose = autoHsType DepositPurpose\n  Conv-DepositPurpose = autoConvert DepositPurpose\n\n  HsTy-DelegEnv = autoHsType DelegEnv\n    \u22a3 withConstructor \"MkDelegEnv\"\n    \u2022 fieldPrefix \"de\"\n    \u2022 withName \"DelegEnv\"\n  Conv-DelegEnv = autoConvert DelegEnv\n\n  HsTy-PState = autoHsType PState\n    \u22a3 withConstructor \"MkPState\"\n    \u2022 fieldPrefix \"ps\"\n  Conv-PState = autoConvert PState\n\nrecord CertEnv' : Type where\n  field\n    epoch     : Epoch\n    pp        : PParams\n    votes     : List GovVote'\n    wdrls     : RwdAddr \u21c0 Coin\n    coldCreds : \u2119 Credential\n\ninstance\n  HsTy-CertEnv' = autoHsType CertEnv'\n    \u22a3 withConstructor \"MkCertEnv\"\n    \u2022 withName \"CertEnv\"\n    \u2022 fieldPrefix \"ce\"\n  Conv-CertEnv' = autoConvert CertEnv'\n\n  mkCertEnv' : Convertible CertEnv CertEnv'\n  mkCertEnv' = \u03bb where\n    .to   ce \u2192 let module ce = CertEnv ce in record { epoch = ce.epoch ; pp = ce.pp ; votes = to ce.votes ; wdrls = ce.wdrls ; coldCreds = ce.coldCreds }\n    .from ce \u2192 let module ce = CertEnv' ce in record { epoch = ce.epoch ; pp = ce.pp ; votes = from ce.votes ; wdrls = ce.wdrls ; coldCreds = ce.coldCreds }\n\n  HsTy-CertEnv = MkHsType CertEnv (HsType CertEnv')\n  Conv-CertEnv = mkCertEnv' \u2a3e Conv-CertEnv'\n\ninstance\n  HsTy-DState = autoHsType DState\n    \u22a3 withConstructor \"MkDState\"\n    \u2022 withName \"DState\"\n    \u2022 fieldPrefix \"ds\"\n  Conv-DState = autoConvert DState\n\n  HsTy-DCert = autoHsType DCert\n  Conv-DCert = autoConvert DCert\n\n  HsTy-GState = autoHsType GState\n    \u22a3 withConstructor \"MkGState\"\n    \u2022 fieldPrefix \"gs\"\n  Conv-GState = autoConvert GState\n\n  Conv-DState-DState' : Convertible DState DState'\n  Conv-DState-DState' .to \u27e6 voteDelegs , stakeDelegs , rewards , deposits \u27e7\u1d48 = \u27e6 voteDelegs , stakeDelegs , stakeDelegs \u27e7\u1d48'\n  Conv-DState-DState' .from \u27e6 voteDelegs , stakeDelegs , rewards \u27e7\u1d48'         = \u27e6 voteDelegs , stakeDelegs , stakeDelegs , \u2205 \u27e7\u1d48\n\n  Conv-GState-GState' : Convertible GState GState'\n  Conv-GState-GState' .to \u27e6 dreps , ccHotKeys , deposits \u27e7\u1d5b = \u27e6 dreps , ccHotKeys \u27e7\u1d5b'\n  Conv-GState-GState' .from \u27e6 dreps , ccHotKeys \u27e7\u1d5b'         = \u27e6 dreps , ccHotKeys , \u2205 \u27e7\u1d5b\n\ndeleg-step : HsType (DelegEnv \u2192 DState \u2192 DCert \u2192 ComputationResult String DState)\ndeleg-step = to (compute Computational-DELEG)\n\n{-# COMPILE GHC deleg-step as delegStep #-}\n\npool-step : HsType (PParams \u2192 PState \u2192 DCert \u2192 ComputationResult String PState)\npool-step = to (compute Computational-POOL)\n\n{-# COMPILE GHC pool-step as poolStep #-}\n\ngovcert-step : HsType (CertEnv \u2192 GState \u2192 DCert \u2192 ComputationResult String GState)\ngovcert-step = to (compute Computational-GOVCERT)\n\n{-# COMPILE GHC govcert-step as govCertStep #-}\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Chain.html","title":"Chain","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Chain where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.NewEpoch\nopen import Ledger.Conway.Foreign.HSLedger.Transaction\n\nopen import Ledger.Conway.Conformance.Chain it it\nopen import Ledger.Conway.Conformance.Chain.Properties it it\n\ninstance\n  HsTy-ChainState = autoHsType ChainState\n  Conv-ChainState = autoConvert ChainState\n\n  HsTy-Block = autoHsType Block\n  Conv-Block = autoConvert Block\n\nchain-step : HsType (\u22a4 \u2192 ChainState \u2192 Block \u2192 ComputationResult String ChainState)\nchain-step = to (compute Computational-CHAIN)\n\n{-# COMPILE GHC chain-step as chainStep #-}\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Core.html","title":"Core","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Core where\n\nopen import Ledger.Prelude hiding (\u03b5) renaming (fromList to fromList\u02e2) public\n\nopen Computational public\n\nopen import Algebra.Construct.DirectProduct using (commutativeMonoid)\nopen import Algebra.Morphism    using (module MonoidMorphisms)\nopen import Data.Nat.Properties using (+-0-commutativeMonoid) public\nimport      Data.Integer as \u2124\nimport      Data.Rational as \u211a\n\nopen import Foreign.Convertible           public\nopen import Foreign.Convertible.Deriving  public\nopen import Foreign.HaskellTypes          public\nopen import Foreign.HaskellTypes.Deriving public\n\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\n\nopen import Ledger.Conway.Specification.Transaction renaming (Vote to VoteTag) public\n\nopen import Ledger.Prelude.Foreign.Util public\n\nopen import Tactic.Derive.Show\n\ninstance\n  Hashable-\u22a4 : Hashable \u22a4 \u2115\n  Hashable-\u22a4 = \u03bb where .hash tt \u2192 0\n\nrecord HSVKey : Type where\n  constructor MkHSVKey\n  field hvkVKey       : \u2115\n        hvkStoredHash : \u2115\n\n{-# FOREIGN GHC\n  data HSVKey = MkHSVKey\n    { hvkVKey :: Integer\n    , hvkStoredHash :: Integer\n    }\n#-}\n{-# COMPILE GHC HSVKey = data HSVKey (MkHSVKey) #-}\n\nunquoteDecl DecEq-HSVKey = derive-DecEq ((quote HSVKey , DecEq-HSVKey) \u2237 [])\n\ninstance\n  Hashable-HSVKey : Hashable HSVKey \u2115\n  Hashable-HSVKey = \u03bb where .hash \u2192 HSVKey.hvkStoredHash\n\n  isHashableSet-HSVKey : isHashableSet HSVKey\n  isHashableSet-HSVKey = mkIsHashableSet \u2115\n\n  Hashable-\u2115 : Hashable \u2115 \u2115\n  Hashable-\u2115 = \u03bb where .hash \u2192 id\n\n  isHashableSet-\u2115 : isHashableSet \u2115\n  isHashableSet-\u2115 = mkIsHashableSet \u2115\n\nunquoteDecl Show-HSVKey = derive-Show\n  ((quote HSVKey , Show-HSVKey) \u2237 [])\n\nmodule Implementation where\n  Network          = \u2115\n  SlotsPerEpoch\u1d9c   = 4320 -- TODO pass this externally instead of hardcoding\n  ActiveSlotCoeff  = \u2124.1\u2124 \u211a./ 20  \n  StabilityWindow\u1d9c = 10\n  RandomnessStabilisationWindow\u1d9c = 10\n  MaxLovelaceSupply\u1d9c = 1\n  Quorum           = 1\n  NetworkId        = 0 -- Testnet\n\n  SKey = \u2115\n  VKey = HSVKey\n  Sig  = \u2115\n  Ser  = \u2115\n\n  isKeyPair  = \u03bb sk vk \u2192 sk \u2261 HSVKey.hvkVKey vk\n  sign       = _+_\n  ScriptHash = \u2115\n\n  Data         = \u2115\n  Data\u02b0        = mkHashableSet \u2115\n  toData : \u2200 {A : Type} \u2192 A \u2192 Data\n  toData _ = 0\n\n  ExUnits      = \u2115 \u00d7 \u2115\n  ExUnit-CommutativeMonoid =\n    Conversion.fromBundle (commutativeMonoid +-0-commutativeMonoid +-0-commutativeMonoid)\n  _\u2265\u1d49_ : ExUnits \u2192 ExUnits \u2192 Type\n  _\u2265\u1d49_ = _\u2261_\n\n  instance\n    Show-ExUnits : Show ExUnits\n    Show-ExUnits = Show-\u00d7\n\n  CostModel    = \u22a4\n  Language     = \u22a4\n  LangDepView  = \u22a4\n  Prices       = \u22a4\n\n  TxId            = \u2115\n  Ix              = \u2115\n  AuxiliaryData   = \u2115\n  DocHash         = \u2115\n  tokenAlgebra    = Coin-TokenAlgebra\n    where open import Ledger.Conway.Specification.TokenAlgebra.Coin ScriptHash\n            using (Coin-TokenAlgebra)\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Enact.html","title":"Enact","text":"<pre><code>open import Data.Rational using (\u211a)\nmodule Ledger.Conway.Foreign.HSLedger.Enact where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.PParams\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Actions\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Enact.Properties.Computational govStructure\n\ninstance\n  HsTy-EnactState = autoHsType EnactState \u22a3 withConstructor \"MkEnactState\"\n                                          \u2022 fieldPrefix \"es\"\n  Conv-EnactState = autoConvert EnactState\n\n  HsTy-EnactEnv = autoHsType EnactEnv \u22a3 withConstructor \"MkEnactEnv\"\n                                      \u2022 fieldPrefix \"ee\"\n  Conv-EnactEnv = autoConvert EnactEnv\n\nenact-step : HsType (EnactEnv \u2192 EnactState \u2192 GovAction \u2192 ComputationResult String EnactState)\nenact-step = to (compute Computational-ENACT)\n\n{-# COMPILE GHC enact-step as enactStep #-}\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Epoch.html","title":"Epoch","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Epoch where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Enact\nopen import Ledger.Conway.Foreign.HSLedger.Ledger\nopen import Ledger.Conway.Foreign.HSLedger.PParams\nopen import Ledger.Conway.Foreign.HSLedger.Ratify\nopen import Ledger.Conway.Foreign.HSLedger.Rewards\n\nopen import Ledger.Conway.Conformance.Epoch it it\nopen import Ledger.Conway.Conformance.Epoch.Properties it it\n\nimport Data.String as S\n\ninstance\n  Show-EPOCH : \u2200 {eps e eps'} \u2192 Show (_ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps')\n  Show-EPOCH .show (EPOCH e s) = \"EPOCH\\n\" S.++ show s S.++ \" \" S.++ show e \n\n    -- record { currentEpoch = e\n    --        ; stakeDistrs = mkStakeDistrs  (Snapshots.mark ss') govSt'\n    --                                       (utxoSt' .deposits) (voteDelegs dState)\ninstance\n  HsTy-EpochState = autoHsType EpochState \u22a3 withConstructor \"MkEpochState\"\n                                          \u2022 fieldPrefix \"es\"\n  Conv-EpochState = autoConvert EpochState\n\nepoch-step : HsType (\u22a4 \u2192 EpochState \u2192 Epoch \u2192 ComputationResult \u22a5 (EpochState \u00d7 String))\nepoch-step _ epochSt e =\n  let r = Computational-EPOCH .computeProof _ (from epochSt) e\n  in case r of \u03bb where\n    (success (s , p)) \u2192 to (success (s , show p))\n\n{-# COMPILE GHC epoch-step as epochStep #-}\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.ExternalStructures.html","title":"ExternalStructures","text":"<pre><code>open import Ledger.Conway.Foreign.ExternalFunctions\n\nmodule Ledger.Conway.Foreign.HSLedger.ExternalStructures (externalFunctions : ExternalFunctions) where\n\nimport      Data.Rational as \u211a using (pos) -- import an instance\n\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\nopen import Ledger.Conway.Foreign.HSLedger.Core\n\nHSGlobalConstants = GlobalConstants \u220b record {Implementation}\ninstance\n  HSEpochStructure = EpochStructure  \u220b \u2115EpochStructure HSGlobalConstants\n\n  HSCryptoStructure : CryptoStructure\n  HSCryptoStructure = record\n    { Implementation\n    ; pkk = HSPKKScheme\n    }\n    where\n    open ExternalFunctions externalFunctions\n    HSPKKScheme : PKKScheme\n    HSPKKScheme = record\n      { Implementation\n      ; isSigned         = \u03bb a b m \u2192 extIsSigned (HSVKey.hvkVKey a) b m \u2261 true\n      ; sign             = \u03bb _ _ \u2192 zero\n        -- we can't prove correctness since the function is provided by the Haskell implementation\n      ; isSigned-correct = error \"isSigned-correct evaluated\"\n      ; Dec-isSigned     = \u2047 (_ \u225f _)\n      }\n\n-- No P2 scripts for now\n\nopen import Ledger.Conway.Specification.Script it it\nopen import Ledger.Conway.Specification.Script.Timelock it it public\nopen import Ledger.Conway.Conformance.Script it it public\n\ninstance\n  HSScriptStructure : ScriptStructure\n  HSScriptStructure = record\n    { p1s = P1ScriptStructure-HTL\n    ; hashRespectsUnion = hashRespectsUnion\n    ; ps = HSP2ScriptStructure\n    }\n    where\n      hashRespectsUnion : \u2200 {A B \u210d}\n        \u2192 Hashable A \u210d \u2192 Hashable B \u210d\n        \u2192 Hashable (A \u228e B) \u210d\n      hashRespectsUnion a _ .hash (inj\u2081 x) = hash \u2983 a \u2984 x\n      hashRespectsUnion _ b .hash (inj\u2082 y) = hash \u2983 b \u2984 y\n\n      HSP2ScriptStructure : PlutusStructure\n      HSP2ScriptStructure = record\n        { Implementation\n        ; validPlutusScript = \u03bb _ _ _ _ \u2192 \u22a4\n        ; PlutusScript = HSPlutusScript\n        }\n\nopen import Ledger.Conway.Specification.PParams it it it hiding (Acnt; DrepThresholds; PoolThresholds)\n\nHsGovParams : GovParams\nHsGovParams = record\n  { Implementation\n  ; ppUpd = let open PParamsDiff in \u03bb where\n      .UpdateT      \u2192 PParamsUpdate\n      .updateGroups \u2192 modifiedUpdateGroups\n      .applyUpdate  \u2192 applyPParamsUpdate\n      .ppWF? {u}    \u2192 ppWF u\n  }\n  where\n    open PParamsUpdate\n    -- FIXME Replace `trustMe` with an actual proof\n    ppWF : (u : PParamsUpdate) \u2192\n      ((pp : PParams) \u2192\n      paramsWellFormed pp \u2192\n      paramsWellFormed (applyPParamsUpdate pp u))\n      \u2047\n    ppWF u with paramsUpdateWellFormed? u\n    ... | yes _ = \u2047 (yes trustMe)\n      where\n        postulate\n          trustMe :\n            ((pp : PParams) \u2192\n            paramsWellFormed pp \u2192\n            paramsWellFormed (applyPParamsUpdate pp u))\n    ... | no _  = \u2047 (no trustMe)\n      where\n        postulate\n          trustMe :\n            \u00ac((pp : PParams) \u2192\n            paramsWellFormed pp \u2192\n            paramsWellFormed (applyPParamsUpdate pp u))\n\ninstance\n  HSTransactionStructure : TransactionStructure\n  HSTransactionStructure = record\n    { Implementation\n    ; epochStructure  = HSEpochStructure\n    ; globalConstants = HSGlobalConstants\n    ; cryptoStructure = HSCryptoStructure\n    ; govParams       = HsGovParams\n    ; txidBytes       = id\n    ; scriptStructure = HSScriptStructure\n    ; adHashingScheme = isHashableSet-\u2115\n    }\n\nopen TransactionStructure HSTransactionStructure public\nopen import Ledger.Conway.Specification.Certs govStructure public\n\nopen import Ledger.Conway.Specification.Abstract it\n\ninstance\n  HSAbstractFunctions : AbstractFunctions\n  HSAbstractFunctions = record\n    { Implementation\n    ; txscriptfee = \u03bb tt y \u2192 0\n    ; serSize     = \u03bb v \u2192 0\n    ; indexOfImp  = record\n      { indexOfDCert    = \u03bb _ _ \u2192 nothing\n      ; indexOfRwdAddr  = \u03bb _ _ \u2192 nothing\n      ; indexOfTxIn     = \u03bb _ _ \u2192 nothing\n      ; indexOfPolicyId = \u03bb _ _ \u2192 nothing\n      ; indexOfVote     = \u03bb _ _ \u2192 nothing\n      ; indexOfProposal = \u03bb _ _ \u2192 nothing\n      }\n    ; runPLCScript = \u03bb _ _ _ _ \u2192 false\n    ; scriptSize = \u03bb where \n        (inj\u2081 x) \u2192 HSTimelock.tlScriptSize x\n        (inj\u2082 x) \u2192 HSPlutusScript.psScriptSize x\n    }\n\nopen import Ledger.Core.Specification.Address Network KeyHash ScriptHash using () public\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Gov.Actions.html","title":"Actions","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Gov.Actions where\n\nopen import Data.Rational using (\u211a)\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.PParams\n\nopen import Ledger.Conway.Specification.Gov.Base\nopen import Ledger.Conway.Specification.Gov.Actions govStructure using (Vote) public\n\nDocHash = GovStructure.DocHash govStructure\n\n-- nondependent version of GovAction\ndata GovAction' : Type where\n  NoConfidence        :                                             GovAction'\n  UpdateCommittee     : (Credential \u21c0 Epoch) \u2192 \u2119 Credential \u2192 \u211a  \u2192  GovAction'\n  NewConstitution     : DocHash \u2192 Maybe ScriptHash               \u2192  GovAction'\n  TriggerHardFork     : ProtVer                                  \u2192  GovAction'\n  ChangePParams       : PParamsUpdate                            \u2192  GovAction'\n  TreasuryWithdrawal  : (RwdAddr \u21c0 Treasury)                     \u2192  GovAction'\n  Info                :                                             GovAction'\n\ninstance\n  mkGovAction' : Convertible GovAction GovAction'\n  mkGovAction' = \u03bb where\n    .to \u27e6 NoConfidence        , _           \u27e7\u1d4d\u1d43 \u2192 NoConfidence\n    .to \u27e6 UpdateCommittee     , (m , p , q) \u27e7\u1d4d\u1d43 \u2192 (UpdateCommittee m p q)\n    .to \u27e6 NewConstitution     , (dh , s )   \u27e7\u1d4d\u1d43 \u2192 (NewConstitution dh s)\n    .to \u27e6 TriggerHardFork     , p           \u27e7\u1d4d\u1d43 \u2192 (TriggerHardFork p)\n    .to \u27e6 ChangePParams       , pu          \u27e7\u1d4d\u1d43 \u2192 (ChangePParams pu)\n    .to \u27e6 TreasuryWithdrawal  , m           \u27e7\u1d4d\u1d43 \u2192 ((TreasuryWithdrawal m))\n    .to \u27e6 Info                , _           \u27e7\u1d4d\u1d43 \u2192 Info\n    .from NoConfidence              \u2192 \u27e6 NoConfidence        , tt          \u27e7\u1d4d\u1d43\n    .from (UpdateCommittee m p q)   \u2192 \u27e6 UpdateCommittee     , (m , p , q) \u27e7\u1d4d\u1d43\n    .from (NewConstitution dh s)    \u2192 \u27e6 NewConstitution     , (dh , s)    \u27e7\u1d4d\u1d43\n    .from (TriggerHardFork p)       \u2192 \u27e6 TriggerHardFork     , p           \u27e7\u1d4d\u1d43\n    .from (ChangePParams pu)        \u2192 \u27e6 ChangePParams       , pu          \u27e7\u1d4d\u1d43\n    .from (TreasuryWithdrawal m)    \u2192 \u27e6 TreasuryWithdrawal  , m           \u27e7\u1d4d\u1d43\n    .from Info                      \u2192 \u27e6 Info                , tt          \u27e7\u1d4d\u1d43\n\n  HsTy-GovAction' = autoHsType GovAction' \u22a3 withName \"GovAction\"\n  Conv-GovAction' = autoConvert GovAction'\n\n  HsTy-GovAction = MkHsType GovAction (HsType GovAction')\n  Conv-GovAction = mkGovAction' \u2a3e Conv-GovAction'\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Gov.Core.html","title":"Core","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Gov.Core where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Specification.Gov.Actions govStructure using (Vote)\n\ninstance\n  HsTy-GovRole = autoHsType GovRole\n  Conv-GovRole = autoConvert GovRole\n\n  HsTy-Anchor = autoHsType Anchor\n  Conv-Anchor = autoConvert Anchor\n\n  HsTy-VDeleg = autoHsType VDeleg\n  Conv-VDeleg = autoConvert VDeleg\n\n  HsTy-Vote = autoHsType Vote\n  Conv-Vote = autoConvert Vote\n\n  HsTy-GovVotes = autoHsType GovVotes\n  Conv-GovVotes = autoConvert GovVotes\n\nGovVoter' : Type\nGovVoter' = GovRole \u00d7 Credential\n\ninstance\n  mkGovVoter' : Convertible GovVoter GovVoter'\n  mkGovVoter' .to \u27e6 CC   , c \u27e7\u1d4d\u1d5b = CC   , c\n  mkGovVoter' .to \u27e6 DRep , c \u27e7\u1d4d\u1d5b = DRep , c\n  mkGovVoter' .to \u27e6 SPO  , c \u27e7\u1d4d\u1d5b = SPO  , KeyHashObj c\n  mkGovVoter' .from (CC   , c)   = \u27e6 CC   , c \u27e7\u1d4d\u1d5b\n  mkGovVoter' .from (DRep , c)   = \u27e6 DRep , c \u27e7\u1d4d\u1d5b\n  mkGovVoter' .from (SPO  , c)   =\n    case c of \u03bb where\n      (KeyHashObj kh) \u2192 \u27e6 SPO , kh \u27e7\u1d4d\u1d5b\n      (ScriptObj _)   \u2192 error \"mkGovVoter: Converting from SPO with ScriptObj credential\"\n\n  HsTy-GovVoter = MkHsType GovVoter (HsType GovVoter')\n  Conv-GovVoter : Convertible GovVoter (HsType GovVoter')\n  Conv-GovVoter = mkGovVoter' \u2a3e Convertible-Pair\n\nunquoteDecl = do\n  hsTypeAlias GovVoter\n\nrecord GovVote' : Type where\n  field\n    gid         : GovActionID\n    voter       : GovVoter'\n    vote        : Vote\n    anchor      : Maybe Anchor\n\ninstance\n  mkGovVote' : Convertible GovVote GovVote'\n  mkGovVote' = \u03bb where\n    .to v   \u2192 let module v = GovVote v in record { gid = v.gid ; voter = to v.voter  ; vote = v.vote ; anchor = v.anchor }\n    .from v \u2192 let module v = GovVote' v in record { gid = v.gid ; voter = from v.voter ; vote = v.vote ; anchor = v.anchor }\n\n  HsTy-GovVote' = autoHsType GovVote' \u22a3 withConstructor \"MkGovVote\"\n                                      \u2022 withName \"GovVote\"\n  Conv-GovVote' = autoConvert GovVote'\n\n  HsTy-GovVote = MkHsType GovVote (HsType GovVote')\n  Conv-GovVote = mkGovVote' \u2a3e Conv-GovVote'\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Gov.html","title":"Gov","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Gov where\n\nopen import Ledger.Prelude using (Type)\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Enact\nopen import Ledger.Conway.Foreign.HSLedger.PParams\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Core\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Actions\nopen import Ledger.Conway.Foreign.HSLedger.Cert\n\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Conformance.Gov it it\nimport Ledger.Conway.Specification.Gov it as L\nopen import Ledger.Conway.Specification.Gov.Properties.Computational it\n\ninstance\n\n  HsTy-GovEnv = autoHsType GovEnv \u22a3 withConstructor \"MkGovEnv\"\n                                  \u2022 fieldPrefix \"ge\"\n  Conv-GovEnv = autoConvert GovEnv\n\n-- NeedsHash depends on a GovAction, so a little bit of manual work is\n-- required to get the types using it into Haskell.\n\n-- First we define to/fromNeedsHash that replaces the \u22a4 cases by a\n-- dummy GovActionID.\n\ntoNeedsHash : \u2200 {action} \u2192 GovActionID \u2192 NeedsHash action\ntoNeedsHash {NoConfidence}        x = x\ntoNeedsHash {UpdateCommittee}     x = x\ntoNeedsHash {NewConstitution}     x = x\ntoNeedsHash {TriggerHardFork}     x = x\ntoNeedsHash {ChangePParams}       x = x\ntoNeedsHash {TreasuryWithdrawal}  x = tt\ntoNeedsHash {Info}                x = tt\n\nfromNeedsHash : \u2200 {action} \u2192 NeedsHash action \u2192 GovActionID\nfromNeedsHash {NoConfidence}        x = x\nfromNeedsHash {UpdateCommittee}     x = x\nfromNeedsHash {NewConstitution}     x = x\nfromNeedsHash {TriggerHardFork}     x = x\nfromNeedsHash {ChangePParams}       x = x\nfromNeedsHash {TreasuryWithdrawal}  x = 0 , 0\nfromNeedsHash {Info}                x = 0 , 0\n\n-- Then we define non-dependent versions of the types that use\n-- NeedsHash.\n\nrecord GovProposal' : Type where\n  field\n    action      : GovAction'\n    prevAction  : GovActionID       -- NeedsHash action\n    policy      : Maybe ScriptHash\n    deposit     : Coin\n    returnAddr  : RwdAddr\n    anchor      : Anchor\n\nrecord GovActionState' : Type where\n  field\n    votes       : GovVotes\n    returnAddr  : RwdAddr\n    expiresIn   : Epoch\n    action      : GovAction'\n    prevAction  : GovActionID       -- NeedsHash action\n\n-- We can convert between the dependent and non-dependent versions\n-- using to/fromNeedsHash.\n\nprivate\n  mkGovProposal' : Convertible GovProposal GovProposal'\n  mkGovProposal' = \u03bb where\n    .to   p \u2192 let module p = GovProposal  p in record { p; action = to p.action  ; prevAction = fromNeedsHash p.prevAction }\n    .from p \u2192 let module p = GovProposal' p in record { p; action = from p.action; prevAction = toNeedsHash   p.prevAction }\n\n  mkGovActionState' : Convertible GovActionState GovActionState'\n  mkGovActionState' = \u03bb where\n    .to   s \u2192 let module s = GovActionState  s in record{ s; action = to s.action  ; prevAction = fromNeedsHash s.prevAction }\n    .from s \u2192 let module s = GovActionState' s in record{ s; action = from s.action; prevAction = toNeedsHash   s.prevAction }\n\n-- Auto-generated conversions for the non-dependent types\n\ninstance\n  HsTy-GovProposal' = autoHsType GovProposal' \u22a3 withName \"GovProposal\"\n                                              \u2022 withConstructor \"MkGovProposal\"\n                                              \u2022 fieldPrefix \"gp\"\n  Conv-GovProposal' = autoConvert GovProposal'\n\n  HsTy-GovActionState' = autoHsType GovActionState' \u22a3 withName \"GovActionState\"\n                                                    \u2022 withConstructor \"MkGovActionState\"\n                                                    \u2022 fieldPrefix \"gas\"\n  Conv-GovActionState' = autoConvert GovActionState'\n\n-- And finally we compose everything into conversions for the dependent types\n\ninstance\n  HsTy-GovProposal = MkHsType GovProposal (HsType GovProposal')\n  Conv-GovProposal = mkGovProposal' \u2a3e Conv-GovProposal'\n\n  HsTy-GovActionState = MkHsType GovActionState (HsType GovActionState')\n  Conv-GovActionState = mkGovActionState' \u2a3e Conv-GovActionState'\n\nunquoteDecl = do\n  hsTypeAlias GovActionID\n  hsTypeAlias GovState\n  hsTypeAlias GovVoter'\n\n-- Computational function\n\ngov-step : HsType (GovEnv \u2192 GovState \u2192 List (GovVote \u228e GovProposal) \u2192 ComputationResult String GovState)\ngov-step \u0393 govSt gvps = to (compute Computational-GOVS \u27e6 txid , e' , pparams , ppolicy , enactState , to certState , rewardCreds \u27e7 (from govSt) (from gvps))\n  where open GovEnv (from \u0393) renaming (epoch to e')\n\n{-# COMPILE GHC gov-step as govStep #-}\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Ledger.html","title":"Ledger","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Ledger where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Certs\nopen import Ledger.Conway.Foreign.HSLedger.Enact\nopen import Ledger.Conway.Foreign.HSLedger.Gov\nopen import Ledger.Conway.Foreign.HSLedger.PParams\nopen import Ledger.Conway.Foreign.HSLedger.Transaction\nopen import Ledger.Conway.Foreign.HSLedger.Utxo\nopen import Ledger.Conway.Foreign.HSLedger.Cert\n\nopen import Ledger.Conway.Conformance.Ledger it it\nopen import Ledger.Conway.Conformance.Ledger.Properties it it\n\ninstance\n  HsTy-LEnv = autoHsType LEnv \u22a3 withConstructor \"MkLEnv\"\n                              \u2022 fieldPrefix \"le\"\n  Conv-LEnv = autoConvert LEnv\n\n  HsTy-LState = autoHsType LState \u22a3 withConstructor \"MkLState\"\n  Conv-LState = autoConvert LState\n\nledger-step : HsType (LEnv \u2192 LState \u2192 Tx \u2192 ComputationResult String LState)\nledger-step = to (compute Computational-LEDGER)\n\n{-# COMPILE GHC ledger-step as ledgerStep #-}\n\nledgers-step : HsType (LEnv \u2192 LState \u2192 List Tx \u2192 ComputationResult String LState)\nledgers-step = to (compute Computational-LEDGERS)\n\n{-# COMPILE GHC ledgers-step as ledgersStep #-}\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.NewEpoch.html","title":"NewEpoch","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.NewEpoch where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Epoch\nopen import Ledger.Conway.Foreign.HSLedger.Rewards\n\nopen import Ledger.Conway.Conformance.Epoch it it\nopen import Ledger.Conway.Conformance.Epoch.Properties it it\n\nimport Data.String as S\n\ninstance\n  Show-NEWEPOCH : \u2200 {eps e eps'} \u2192 Show (_ \u22a2 eps \u21c0\u2987 e ,NEWEPOCH\u2988 eps')\n  Show-NEWEPOCH .show (NEWEPOCH-New (_ , e))        = \"NEWEPOCH-New \" S.++ show e\n  Show-NEWEPOCH .show (NEWEPOCH-Not-New x)          = \"NEWEPOCH-Not-New\"\n  Show-NEWEPOCH .show (NEWEPOCH-No-Reward-Update x) = \"NEWEPOCH-No-Reward-Update\"\n\ninstance\n  HsTy-NewEpochState = autoHsType NewEpochState \u22a3 withConstructor \"MkNewEpochState\"\n  Conv-NewEpochState = autoConvert NewEpochState\n\nnewepoch-step : HsType (\u22a4 \u2192 NewEpochState \u2192 Epoch \u2192 ComputationResult \u22a5 (NewEpochState \u00d7 String))\nnewepoch-step _ newEpochSt e =\n  let r = Computational-NEWEPOCH .computeProof _ (from newEpochSt) e\n  in case r of \u03bb where\n    (success (s , p)) \u2192 to (success (s , show p))\n\n{-# COMPILE GHC newepoch-step as newEpochStep #-}\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.PParams.html","title":"PParams","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.PParams where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\n\ninstance\n  HsTy-DrepThresholds = autoHsType DrepThresholds\n    \u22a3 withConstructor \"MkDrepThresholds\"\n  Conv-DrepThresholds = autoConvert DrepThresholds\n\n  HsTy-PoolThresholds = autoHsType PoolThresholds\n    \u22a3 withConstructor \"MkPoolThresholds\"\n  Conv-PoolThresholds = autoConvert PoolThresholds\n\n  HsTy-Acnt = autoHsType Acnt \u22a3 withConstructor \"MkAcnt\"\n  Conv-Acnt = autoConvert Acnt\n\n  HsTy-PParams = autoHsType PParams \u22a3 withConstructor \"MkPParams\"\n                                    \u2022 fieldPrefix \"pp\"\n  Conv-PParams = autoConvert PParams\n\n  HsTy-PParamsUpdate = autoHsType PParamsUpdate.PParamsUpdate \u22a3 withConstructor \"MkPParamsUpdate\"\n                                                              \u2022 fieldPrefix \"ppu\"\n  Conv-PParamsUpdate = autoConvert PParamsUpdate.PParamsUpdate\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Ratify.html","title":"Ratify","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Ratify where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Certs\nopen import Ledger.Conway.Foreign.HSLedger.Enact\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Core\nopen import Ledger.Conway.Foreign.HSLedger.Gov\n\nopen import Ledger.Conway.Specification.Enact govStructure\n\nopen import Data.String.Base renaming (_++_ to _+\u02e2_) hiding (show; length)\nimport Data.Rational.Show as Rational\n\nimport Foreign.Haskell.Pair as F\nopen import Ledger.Conway.Specification.Ratify it\nopen import Ledger.Conway.Specification.Ratify.Properties.Computational it\n\ninstance\n  HsTy-StakeDistrs = autoHsType StakeDistrs\n  Conv-StakeDistrs = autoConvert StakeDistrs\n\n  HsTy-RatifyEnv = autoHsType RatifyEnv \u22a3 withConstructor \"MkRatifyEnv\"\n                                        \u2022 fieldPrefix \"re\"\n  Conv-RatifyEnv = autoConvert RatifyEnv\n\n  HsTy-RatifyState = autoHsType RatifyState \u22a3 withConstructor \"MkRatifyState\"\n                                            \u2022 fieldPrefix \"rs\"\n                                            \u2022 RatifyState.es \u21a6 \"rsEnactState\"\n  Conv-RatifyState = autoConvert RatifyState\n\n-- ratify-debug : HsType (RatifyEnv \u2192 RatifyState \u2192 List (GovActionID \u00d7 GovActionState) \u2192 String)\n-- ratify-debug env st sig =\n--   \"Number of govactions: \" +\u02e2 show (length sig) +\u02e2 \"\\n\" +\u02e2\n--   foldr (\u03bb x s \u2192 s +\u02e2 govActionInfo x) \"\" sig\n--   where\n--     open RatifyEnv (from env)\n--     govActionInfo : HsType (GovActionID \u00d7 GovActionState) \u2192 String\n--     govActionInfo (gaId F., gas) =\n--       let\n--         open GovActionState (from gas)\n--         open RatifyState (from st)\n--         open EnactState es\n--         votes'  = actualVotes (from env) (proj\u2081 pparams) (proj\u2081 cc) (action .gaType) votes\n--         showAcceptedStakeRatio role = Rational.show (acceptedStakeRatio role (dom votes') stakeDistrs votes')\n--         showIsAccepted role = case acceptedBy? (from env) es (from gas) role of \u03bb where\n--           (yes _) \u2192 \"\u2713\"\n--           (no  _) \u2192 \"\u00d7\"\n--       in\n--         \"SPO: \\t\"  +\u02e2 showAcceptedStakeRatio SPO  +\u02e2 \"\\t\" +\u02e2 showIsAccepted SPO  +\u02e2 \"\\n\" +\u02e2\n--         \"DRep: \\t\" +\u02e2 showAcceptedStakeRatio DRep +\u02e2 \"\\t\" +\u02e2 showIsAccepted DRep +\u02e2 \"\\n\" +\u02e2\n--         \"CC: \\t\"   +\u02e2 showAcceptedStakeRatio CC   +\u02e2 \"\\t\" +\u02e2 showIsAccepted CC   +\u02e2 \"\\n\"\n\n-- {-# COMPILE GHC ratify-debug as ratifyDebug #-}\n\nratify-step : HsType (RatifyEnv \u2192 RatifyState \u2192 List (GovActionID \u00d7 GovActionState) \u2192 ComputationResult \u22a5 RatifyState)\nratify-step = to (compute Computational-RATIFIES)\n\n{-# COMPILE GHC ratify-step as ratifyStep #-}\n\ninstance\n  Show-RATIFIES : \u2200 {\u0393 s sig s'}\n    \u2192 Show (\u0393 \u22a2 s \u21c0\u2987 sig  ,RATIFIES\u2988 s')\n  Show-RATIFIES {\u0393} {s} {sig} .show r = \"\" -- ratify-debug (to \u0393) (to s) (to sig)\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Rewards.html","title":"Rewards","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Rewards where\n\nimport Data.Integer as \u2124\nimport Data.String as S\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Certs\n\nopen import Ledger.Conway.Conformance.Rewards it it\n\ninstance\n  Show-SNAP : \u2200 {ls ss ss'} \u2192 Show (ls \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss')\n  Show-SNAP {ls} {ss} {ss'} .show SNAP =\n    \"SNAP:\"\n    -- S.++\n    -- \"\\t\" S.++ show-Snapshot (Snapshots.mark ss') S.++ \"\\n\"\n    --   where show-Snapshot : Snapshot \u2192 String\n    --         show-Snapshot ss =\n    --           let open Snapshot ss\n    --           in show (proj\u2081 stake)\n\ninstance\n  HsTy-Snapshot = autoHsType Snapshot \u22a3 withConstructor \"MkSnapshot\"\n  Conv-Snapshot = autoConvert Snapshot\n\n  HsTy-Snapshots = autoHsType Snapshots \u22a3 withConstructor \"MkSnapshots\"\n  Conv-Snapshots = autoConvert Snapshots\n\nrecord HsRewardUpdate : Type where\n  field \u0394t \u0394r \u0394f : \u2124\n        rs : HsType (Credential \u21c0 Coin)\n{-# FOREIGN GHC\n  data HsRewardUpdate = MkRewardUpdate\n    { deltaT  :: Integer\n    , deltaR  :: Integer\n    , deltaF  :: Integer\n    , rs      ::\n        MAlonzo.Code.Ledger.Prelude.Foreign.HSTypes.HSMap\n          MAlonzo.Code.Ledger.Conway.Foreign.HSLedger.Address.Credential\n          Integer\n    }\n    deriving (Eq, Show)\n#-}\n\n{-# COMPILE GHC HsRewardUpdate = data HsRewardUpdate (MkRewardUpdate) #-}\n\ninstance\n  HsTy-RewardUpdate : HasHsType RewardUpdate\n  HsTy-RewardUpdate .HasHsType.HsType = HsRewardUpdate\n\n  -- manual, since we want to throw an error on non-zero update\n  Conv-RewardUpdate : Convertible RewardUpdate HsRewardUpdate\n  Conv-RewardUpdate .to   ru = record { RewardUpdate ru; rs = to (ru .RewardUpdate.rs) }\n  Conv-RewardUpdate .from ru = HsRewardUpdate\u2192RewardUpdate\n    where \n      module _ where\n        module ru = HsRewardUpdate ru\n        open ru\n\n        flowConservation? = \u00bf \u0394t + \u0394r + \u0394f + \u2124.+ (indexedSum\u1d5b' {A = Credential} (\u03bb x \u2192 x) (from rs)) \u2261 \u2124.0\u2124 \u00bf\n        \u0394t-nonnegative?   = \u00bf \u2124.0\u2124 \u2124.\u2264 \u0394t \u00bf\n        \u0394f-nonpositive?   = \u00bf \u0394f \u2124.\u2264 \u2124.0\u2124 \u00bf\n\n        HsRewardUpdate\u2192RewardUpdate : RewardUpdate\n        HsRewardUpdate\u2192RewardUpdate\n          with flowConservation? | \u0394t-nonnegative? | \u0394f-nonpositive?\n        ... | yes p | yes q | yes r = record { ru\n                                             ; rs = from ru.rs\n                                             ; flowConservation = p\n                                             ; \u0394t-nonnegative   = q\n                                             ; \u0394f-nonpositive   = r\n                                             }\n        ... | _ | _ | _ = error \"Formal Spec: cannot make a non-zero reward update\"\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Transaction.html","title":"Transaction","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger.Transaction where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Certs\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Core\nopen import Ledger.Conway.Foreign.HSLedger.Gov\nopen import Ledger.Conway.Foreign.HSLedger.PParams\n\ninstance\n  HsTy-Tag = autoHsType Tag\n  Conv-Tag = autoConvert Tag\n\n  HsTy-Timelock = autoHsType Timelock\n  -- The termination checker doesn't like recursion through lists of recursive structures, or that\n  -- we do all the matching in a rhs pattern lambda. Telling the termination checker to go away does\n  -- work though.\n  {-# TERMINATING #-}\n  Conv-Timelock = autoConvert Timelock\n\n  HsTy-HSTimelock = autoHsType HSTimelock\n  Conv-HSTimelock = autoConvert HSTimelock\n\n  HsTy-HSPlutusScript = autoHsType HSPlutusScript\n  Conv-HSPlutusScript = autoConvert HSPlutusScript\n\n  HsTy-TxWitnessess = autoHsType TxWitnesses \u22a3 withConstructor \"MkTxWitnesses\"\n  Conv-TxWitnessess = autoConvert TxWitnesses\n\n  HsTy-TxBody = autoHsType TxBody \u22a3 withConstructor \"MkTxBody\"\n  Conv-TxBody = autoConvert TxBody\n\n  HsTy-Tx = autoHsType Tx \u22a3 withConstructor \"MkTx\"\n  Conv-Tx = autoConvert Tx\n\nunquoteDecl = do\n  hsTypeAlias TxId\n  hsTypeAlias Ix\n  hsTypeAlias TxIn\n  hsTypeAlias P1Script\n  hsTypeAlias P2Script \u22a3 withName \"P2Script\"\n  hsTypeAlias Script\n  hsTypeAlias Datum\n  hsTypeAlias DataHash \u22a3 withName \"DataHash\"\n  hsTypeAlias Value\n  hsTypeAlias TxOut\n  hsTypeAlias RdmrPtr\n  hsTypeAlias ScriptHash\n  hsTypeAlias AuxiliaryData\n  hsTypeAlias Withdrawals\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Utxo.html","title":"Utxo","text":"<pre><code>{-# OPTIONS --no-qualified-instances #-}\n\nmodule Ledger.Conway.Foreign.HSLedger.Utxo where\n\nopen import Ledger.Prelude\n\nopen import Ledger.Conway.Foreign.ExternalFunctions\n\nopen import Data.String.Base renaming (_++_ to _+\u02e2_) hiding (show; length; map; fromList)\n\nopen import Ledger.Conway.Foreign.HSLedger.Core\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.Certs\nopen import Ledger.Conway.Foreign.HSLedger.PParams\nopen import Ledger.Conway.Foreign.HSLedger.Transaction\n\nopen import Foreign.Haskell.Coerce\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes hiding (TxWitnesses; refScripts; isScriptObj; isKeyHashObj)\nopen import Ledger.Conway.Specification.Script.Validation DummyTransactionStructure DummyAbstractFunctions\nopen import Ledger.Conway.Conformance.Utxo DummyTransactionStructure DummyAbstractFunctions\nopen import Ledger.Conway.Conformance.Utxow DummyTransactionStructure DummyAbstractFunctions\n\ninstance\n  HsTy-UTxOEnv = autoHsType UTxOEnv \u22a3 withConstructor \"MkUTxOEnv\"\n                                    \u2022 fieldPrefix \"ue\"\n  Conv-UTxOEnv = autoConvert UTxOEnv\n\n  HsTy-UTxOState = autoHsType UTxOState \u22a3 withConstructor \"MkUTxOState\"\n  Conv-UTxOState = autoConvert UTxOState\n\nunquoteDecl = do\n  hsTypeAlias UTxO\n  hsTypeAlias Redeemer\n\nmodule _ (ext : ExternalFunctions) where\n  open import Ledger.Conway.Foreign.HSLedger.ExternalStructures ext hiding (Tx; TxBody; inject)\n  open import Ledger.Conway.Conformance.Utxow.Properties HSTransactionStructure HSAbstractFunctions\n  open import Ledger.Conway.Conformance.Utxo.Properties HSTransactionStructure HSAbstractFunctions\n\n  utxo-step : HsType (UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 ComputationResult String UTxOState)\n  utxo-step = to (coerce \u2983 TrustMe \u2984 $ compute Computational-UTXO)\n\n  {-# COMPILE GHC utxo-step as utxoStep #-}\n\n  utxow-step : HsType (UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 ComputationResult String UTxOState)\n  utxow-step = to (coerce \u2983 TrustMe \u2984 $ compute Computational-UTXOW)\n\n  {-# COMPILE GHC utxow-step as utxowStep #-}\n\n  utxo-debug : HsType (UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 String)\n  utxo-debug env st tx =\n    let open Tx (from tx)\n        open TxBody body\n        open UTxOState (from st)\n        open UTxOEnv (from env)\n     in unlines $\n          \"Consumed:\" \u2237\n          (\"\\tInputs:      \\t\" +\u02e2 show (balance (utxo \u2223 txIns))) \u2237\n          (\"\\tMint:        \\t\" +\u02e2 show mint) \u2237\n          (\"\\tRefunds:     \\t\" +\u02e2 show (inject (depositRefunds pparams (from st) body))) \u2237\n          (\"\\tWithdrawals: \\t\" +\u02e2 show (inject (getCoin txWithdrawals))) \u2237\n          (\"\\tTotal:       \\t\" +\u02e2 show (consumed pparams (from st) body)) \u2237\n          \"Produced:\" \u2237\n          (\"\\tOutputs:     \\t\" +\u02e2 show (balance (outs body))) \u2237\n          (\"\\tDonations:   \\t\" +\u02e2 show (inject txDonation)) \u2237\n          (\"\\tDeposits:    \\t\" +\u02e2 show (inject (newDeposits pparams (from st) body))) \u2237\n          (\"\\tFees:        \\t\" +\u02e2 show (inject txFee)) \u2237\n          (\"\\tTotal:       \\t\" +\u02e2 show (produced pparams (from st) body)) \u2237\n          \"\" \u2237\n          \"Reference Scripts Info:\" \u2237\n          (\"\\tTotal size: \\t\" +\u02e2 show (refScriptsSize utxo (from tx))) \u2237\n          []\n\n  {-# COMPILE GHC utxo-debug as utxoDebug #-}\n\n  utxow-debug : HsType (UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 String)\n  utxow-debug env st tx =\n    let open Tx (from tx)\n        open TxBody body\n        open UTxOState (from st)\n        open UTxOEnv (from env)\n        open TxWitnesses (coerce \u2983 TrustMe \u2984 wits)\n        neededScriptHashes = mapPartial (isScriptObj  \u2218 proj\u2082) (credsNeeded utxo body)\n        neededVKeyHashes   = mapPartial (isKeyHashObj \u2218 proj\u2082) (credsNeeded utxo body)\n        refScriptHashes = map\u02e2\n          hash \n          (refScripts (coerce \u2983 TrustMe \u2984 (from tx)) (coerce \u2983 TrustMe \u2984 utxo))\n        witsScriptHashes  = map\u02e2 hash scripts\n     in unlines\n       $ \"neededVKeyHashes utxo txb = \"\n       \u2237 show neededVKeyHashes\n       \u2237 \"\\nwitsKeyHashes = \"\n       \u2237 show (map\u02e2 hash (dom vkSigs))\n       \u2237 \"\\nneededScriptHashes = \"\n       \u2237 show neededScriptHashes\n       \u2237 \"\\nrefScriptHashes = \"\n       \u2237 show refScriptHashes\n       \u2237 \"\\nwitsScriptHashes = \"\n       \u2237 show witsScriptHashes\n       \u2237 []\n\n  {-# COMPILE GHC utxow-debug as utxowDebug #-}\n</code></pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.html","title":"HSLedger","text":"<pre><code>module Ledger.Conway.Foreign.HSLedger where\n\nopen import Ledger.Conway.Foreign.HSLedger.Cert public\nopen import Ledger.Conway.Foreign.HSLedger.Chain public\nopen import Ledger.Conway.Foreign.HSLedger.Certs public\nopen import Ledger.Conway.Foreign.HSLedger.Enact public\nopen import Ledger.Conway.Foreign.HSLedger.Epoch public\nopen import Ledger.Conway.Foreign.HSLedger.Gov public\nopen import Ledger.Conway.Foreign.HSLedger.Ledger public\nopen import Ledger.Conway.Foreign.HSLedger.NewEpoch public\nopen import Ledger.Conway.Foreign.HSLedger.Ratify public\nopen import Ledger.Conway.Foreign.HSLedger.Utxo public\n</code></pre>"},{"location":"Ledger.Conway.Specification.Abstract.html","title":"Abstract","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Abstract (txs : TransactionStructure) where\n\nopen TransactionStructure txs\nopen import Ledger.Conway.Specification.Certs govStructure\n\nrecord indexOf : Type where\n  field\n    indexOfDCert    : DCert \u2192 List DCert \u2192 Maybe Ix\n    indexOfRwdAddr  : RwdAddr \u2192 Withdrawals \u2192 Maybe Ix\n    indexOfTxIn     : TxIn \u2192 \u2119 TxIn \u2192 Maybe Ix\n    indexOfPolicyId : ScriptHash \u2192 \u2119 ScriptHash \u2192 Maybe Ix\n    indexOfVote     : GovVoter \u2192 List GovVoter \u2192 Maybe Ix\n    indexOfProposal : GovProposal \u2192 List GovProposal \u2192 Maybe Ix\n\nrecord AbstractFunctions : Type where\n  field txscriptfee  : Prices \u2192 ExUnits \u2192 Coin\n        serSize      : Value \u2192 MemoryEstimate\n        indexOfImp   : indexOf\n        runPLCScript : CostModel \u2192 P2Script \u2192 ExUnits \u2192 List Data \u2192 Bool\n        scriptSize   : Script \u2192 \u2115\n</code></pre>"},{"location":"Ledger.Conway.Specification.BlockBody.Properties.Computational.html","title":"Computational","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\nopen import Ledger.Conway.Specification.Abstract using (AbstractFunctions)\n\nmodule Ledger.Conway.Specification.BlockBody.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\nopen import Ledger.Conway.Specification.BlockBody txs abs\nopen import Ledger.Conway.Specification.Ledger.Properties.Computational txs abs\nopen import Ledger.Prelude\n\nopen Computational \u2983...\u2984\n\ninstance\n  Computational-BBODY : Computational _\u22a2_\u21c0\u2987_,BBODY\u2988_ String\n  Computational-BBODY .computeProof \u0393 (ls , _) block = do\n    _ , lsStep \u2190 computeProof _ ls (block .ts)\n    success\n      (_ , BBODY-Block-Body (block .\u2261-bBodySize , block .\u2261-bBodyHash , lsStep))\n    where open Block\n\n  Computational-BBODY .completeness _ s b _\n    (BBODY-Block-Body (_ , _ , lsStep))\n    with recomputeProof lsStep | completeness _ _ _ _ lsStep\n  ... | success _ | refl = refl\n</code></pre>"},{"location":"Ledger.Conway.Specification.BlockBody.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.BlockBody.Properties where\n\nopen import Ledger.Conway.Specification.BlockBody.Properties.Computational\n</code></pre>"},{"location":"Ledger.Conway.Specification.BlockBody.html","title":"BlockBody","text":""},{"location":"Ledger.Conway.Specification.BlockBody.html#blocks","title":"Blocks","text":"<p>The block follows mostly the definition of the Shelley specification. One notable difference is that the size and the hash of the block body are fields of the block, instead of functions.</p> <pre><code>record BHBody : Type where\n  field\n    bvkcold : VKey\n    bsize   : \u2115\n    slot    : Slot\n    bhash   : KeyHash\n    hBbsize : \u2115\n\nrecord BHeader : Type where\n  field\n    bhbody : BHBody\n    bhsig  : Sig\n\nrecord Block : Type where\n  field\n    bheader     : BHeader\n    ts          : List Tx\n    bBodySize   : \u2115\n    bBodyHash   : KeyHash\n    \u2261-bBodySize : bBodySize \u2261 BHBody.hBbsize (BHeader.bhbody bheader)\n    \u2261-bBodyHash : bBodyHash \u2261 BHBody.bhash (BHeader.bhbody bheader)\n</code></pre>"},{"location":"Ledger.Conway.Specification.BlockBody.html#block-body-transition","title":"Block Body Transition","text":"<p>The Block Body Transition updates the block body state which comprises the ledger state and the map describing the produced blocks. The environment of the <code>BBODY</code> transition includes the protocol parameters and the accounting state.</p> <p>The helper function <code>incrBlocks</code> counts the number of non-overlay blocks produced by each stake pool.</p> <p>The signal of the <code>BBODY</code> rule is a block from which we extract:</p> <ul> <li>the sequence of transactions, <code>txs</code> = <code>block</code> .<code>ts</code>, of the block;</li> <li>the block header body <code>bhb</code> = <code>block</code> .<code>bheader</code> .<code>bhbody</code>;</li> <li>the hash of the verification key of the issuer of the block, <code>hk</code> = <code>hash</code> (<code>bhb</code> .<code>bvkcold</code>).</li> </ul> <p>The transition is executed if the following preconditions are met:</p> <ul> <li>The size of the block body matches the value given in the block header body.</li> <li>The hash of the block body matches the value given in the block header body.</li> <li>The <code>LEDGERS</code> transition succeeds.</li> </ul> <p>After this, the transition system updates the mapping of the hashed stake pool keys to the incremented value of produced blocks <code>n + 1</code>, provided the current slot is not an overlay slot.</p> <p>The <code>BBODY</code> rule has two predicate failures:</p> <ul> <li>if the size of the block body in the header is not equal to the real size of   the block body, there is a WrongBlockBodySize failure.</li> <li>if the hash of the block body is not also the hash of transactions, there is   an InvalidBodyHash failure.</li> </ul> <pre><code>BBodyEnv : Type\nBBodyEnv = EnactState \u00d7 Acnt\n\nBBodyState : Type\nBBodyState = LState \u00d7 BlocksMade\n\nincrBlocks : KeyHash \u2192 BlocksMade \u2192 BlocksMade\nincrBlocks hk b = b \u222a\u207a singleton\u1d50 hk 1\n\ndata _\u22a2_\u21c0\u2987_,BBODY\u2988_\n  : BBodyEnv \u2192 BBodyState \u2192 Block \u2192 BBodyState \u2192 Type where\n\n  BBODY-Block-Body : \u2200 {acnt ls ls' b block es} \u2192\n    let\n      open BHeader\n      open BHBody\n      open Block\n      open EnactState\n      txs = block .ts\n      bhb = block .bheader .bhbody\n      hk = hash (bhb .bvkcold)\n      pp = PParamsOf es\n      \u0393  = \u27e6 bhb .slot , \u2223 es .constitution \u2223 , pp , es , TreasuryOf acnt \u27e7\n\n     in\n    \u2219 block .bBodySize \u2261 bhb .hBbsize\n    \u2219 block .bBodyHash \u2261 bhb .bhash\n    \u2219 \u0393 \u22a2 ls \u21c0\u2987 txs ,LEDGERS\u2988 ls'\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    (es , acnt) \u22a2 ls , b \u21c0\u2987 block ,BBODY\u2988 (ls' , incrBlocks hk b)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.Properties.Computational.html","title":"Computational","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Gov.Base\n\nmodule Ledger.Conway.Specification.Certs.Properties.Computational (gs : _) (open GovStructure gs) where\n\nopen import Data.Maybe.Properties\nopen import Relation.Nullary.Decidable\n\nopen import Tactic.ReduceDec\n\nopen import Algebra using (CommutativeMonoid)\nopen import Ledger.Conway.Specification.Gov.Actions gs hiding (yes; no)\nopen import Ledger.Conway.Specification.Certs gs\n\nopen import Data.Nat.Properties using (+-0-monoid; +-0-commutativeMonoid; +-identity\u02b3; +-identity\u02e1)\nopen import Axiom.Set.Properties th\nopen import Relation.Binary using (IsEquivalence)\nopen Computational \u2983...\u2984\n\nopen import stdlib-meta.Tactic.GenError using (genErrors)\n\nopen CertState\nopen GovVote using (voter)\n\ninstance\n  Computational-DELEG : Computational _\u22a2_\u21c0\u2987_,DELEG\u2988_ String\n  Computational-DELEG .computeProof de st\u1d48 =\n    let open DelegEnv de; open DState st\u1d48 in\n    \u03bb where\n    (delegate c mv mc d) \u2192 case \u00bf (c \u2209 dom rewards \u2192 d \u2261 pparams .PParams.keyDeposit)\n                                \u00d7 (c \u2208 dom rewards \u2192 d \u2261 0)\n                                \u00d7 mv \u2208 map\u02e2 (just \u2218 vDelegCredential) delegatees \u222a\n                                    fromList ( nothing \u2237 just vDelegAbstain \u2237 just vDelegNoConfidence \u2237 [] )\n                                \u00d7 mc \u2208 map\u02e2 just (dom pools) \u222a \u2774 nothing \u2775\n                                \u00bf of \u03bb where\n      (yes p) \u2192 success (-, DELEG-delegate p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    (dereg c d) \u2192 case \u00bf (c , 0) \u2208 rewards \u00bf of \u03bb where\n      (yes p) \u2192 success (-, DELEG-dereg p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    (reg c d) \u2192 case \u00bf c \u2209 dom rewards\n                     \u00d7 (d \u2261 pparams .PParams.keyDeposit \u228e d \u2261 0)\n                     \u00bf of \u03bb where\n      (yes p) \u2192 success (-, DELEG-reg p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    _ \u2192 failure \"Unexpected certificate in DELEG\"\n  Computational-DELEG .completeness de st\u1d48 (delegate c mv mc d)\n    s' (DELEG-delegate p) rewrite dec-yes (\u00bf (c \u2209 dom (DState.rewards st\u1d48) \u2192 d \u2261 DelegEnv.pparams de .PParams.keyDeposit)\n                                \u00d7 (c \u2208 dom (DState.rewards st\u1d48) \u2192 d \u2261 0)\n                                \u00d7 mv \u2208 map\u02e2 (just \u2218 vDelegCredential) (DelegEnv.delegatees de) \u222a fromList ( nothing \u2237 just vDelegAbstain \u2237 just vDelegNoConfidence \u2237 [] )\n                                \u00d7 mc \u2208 map\u02e2 just (dom (DelegEnv.pools de)) \u222a \u2774 nothing \u2775\n                                           \u00bf) p .proj\u2082 = refl\n  Computational-DELEG .completeness de st\u1d48 (dereg c d) _ (DELEG-dereg p)\n    rewrite dec-yes (\u00bf (c , 0) \u2208 (DState.rewards st\u1d48) \u00bf) p .proj\u2082 = refl\n  Computational-DELEG .completeness de st\u1d48 (reg c d) _ (DELEG-reg p)\n    rewrite dec-yes (\u00bf c \u2209 dom (DState.rewards st\u1d48) \u00d7 (d \u2261 DelegEnv.pparams de .PParams.keyDeposit \u228e d \u2261 0) \u00bf) p .proj\u2082 = refl\n\n  Computational-POOL : Computational _\u22a2_\u21c0\u2987_,POOL\u2988_ String\n  Computational-POOL .computeProof _ st\u1d56 (regpool c _) =\n    let open PState st\u1d56 in\n    case \u00ac? (c \u2208? dom pools) of \u03bb where\n      (yes p) \u2192 success (-, POOL-regpool p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-POOL .computeProof _ _ (retirepool c e) = success (-, POOL-retirepool)\n  Computational-POOL .computeProof _ _ _ = failure \"Unexpected certificate in POOL\"\n  Computational-POOL .completeness _ st\u1d56 (regpool c _) _ (POOL-regpool \u00acp)\n    rewrite dec-no (c \u2208? dom (PState.pools st\u1d56)) \u00acp = refl\n  Computational-POOL .completeness _ _ (retirepool _ _) _ POOL-retirepool = refl\n\n  Computational-GOVCERT : Computational _\u22a2_\u21c0\u2987_,GOVCERT\u2988_ String\n  Computational-GOVCERT .computeProof ce st\u1d4d (regdrep c d _) =\n    let open CertEnv ce; open PParams pp in\n    case \u00bf (d \u2261 drepDeposit \u00d7 c \u2209 dom (GState.dreps st\u1d4d))\n         \u228e (d \u2261 0 \u00d7 c \u2208 dom (GState.dreps st\u1d4d)) \u00bf of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-regdrep p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof _ st\u1d4d (deregdrep c _) =\n    let open GState st\u1d4d in\n    case c \u2208? dom dreps of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-deregdrep p)\n      (no \u00acp)  \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof ce st\u1d4d (ccreghot c _) =\n    let open CertEnv ce; open GState st\u1d4d in\n    case \u00bf ((c , nothing) \u2209 ccHotKeys \u02e2) \u00d7 c \u2208 coldCreds \u00bf of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-ccreghot p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof _ _ _ = failure \"Unexpected certificate in GOVCERT\"\n  Computational-GOVCERT .completeness ce st\u1d4d\n    (regdrep c d _) _ (GOVCERT-regdrep p)\n    rewrite dec-yes\n      \u00bf (let open CertEnv ce; open PParams pp; open GState st\u1d4d in\n        (d \u2261 drepDeposit \u00d7 c \u2209 dom dreps) \u228e (d \u2261 0 \u00d7 c \u2208 dom dreps))\n      \u00bf p .proj\u2082 = refl\n  Computational-GOVCERT .completeness _ st\u1d4d\n    (deregdrep c _) _ (GOVCERT-deregdrep p)\n    rewrite dec-yes (c \u2208? dom (GState.dreps st\u1d4d)) p .proj\u2082 = refl\n  Computational-GOVCERT .completeness ce st\u1d4d\n    (ccreghot c _) _ (GOVCERT-ccreghot p)\n    rewrite dec-yes (\u00bf (((c , nothing) \u2209 (GState.ccHotKeys st\u1d4d) \u02e2) \u00d7 c \u2208 CertEnv.coldCreds ce) \u00bf) p .proj\u2082 = refl\n\n  Computational-CERT : Computational _\u22a2_\u21c0\u2987_,CERT\u2988_ String\n  Computational-CERT .computeProof ce cs dCert\n    with computeProof \u27e6 CertEnv.pp ce , PState.pools (pState cs) , dom (GState.dreps (gState cs)) \u27e7 (dState cs) dCert\n       | computeProof (CertEnv.pp ce) (pState cs) dCert | computeProof ce (gState cs) dCert\n  ... | success (_ , h) | _               | _               = success (-, CERT-deleg h)\n  ... | failure _       | success (_ , h) | _               = success (-, CERT-pool h)\n  ... | failure _       | failure _       | success (_ , h) = success (-, CERT-vdel h)\n  ... | failure e\u2081      | failure e\u2082      | failure e\u2083      = failure $\n    \"DELEG: \" &lt;&gt; e\u2081 &lt;&gt; \"\\nPOOL: \" &lt;&gt; e\u2082 &lt;&gt; \"\\nVDEL: \" &lt;&gt; e\u2083\n  Computational-CERT .completeness ce cs\n    dCert@(delegate c mv mc d) cs' (CERT-deleg h)\n    with computeProof \u27e6 CertEnv.pp ce , PState.pools (pState cs) , dom (GState.dreps (gState cs)) \u27e7 (dState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(reg c d) cs' (CERT-deleg h)\n    with computeProof \u27e6 CertEnv.pp ce , PState.pools (pState cs) , dom (GState.dreps (gState cs)) \u27e7 (dState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(dereg c _) cs' (CERT-deleg h)\n    with computeProof \u27e6 CertEnv.pp ce , PState.pools (pState cs) , dom (GState.dreps (gState cs)) \u27e7 (dState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(regpool c poolParams) cs' (CERT-pool h)\n    with computeProof (CertEnv.pp ce) (pState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(retirepool c e) cs' (CERT-pool h)\n    with completeness _ _ _ _ h\n  ... | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(regdrep c d an)\n    cs' (CERT-vdel h)\n    with computeProof ce (gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(deregdrep c _) cs' (CERT-vdel h)\n    with computeProof ce (gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(ccreghot c mkh) cs' (CERT-vdel h)\n    with computeProof ce (gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n\n  Computational-PRE-CERT : Computational _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ String\n  Computational-PRE-CERT .computeProof ce cs _ =\n    let open CertEnv ce; open PParams pp\n        open GState (gState cs); open DState (dState cs)\n        refresh = mapPartial (isGovVoterDRep \u2218 voter) (fromList votes)\n        refreshedDReps  = mapValueRestricted (const (CertEnv.epoch ce + drepActivity)) dreps refresh\n    in case \u00bf filter\u02e2 isKeyHash (map\u02e2 RwdAddr.stake (dom wdrls)) \u2286 dom voteDelegs\n              \u00d7 map\u02e2 (map\u2081 RwdAddr.stake) (wdrls \u02e2) \u2286 rewards \u02e2 \u00bf of \u03bb where\n      (yes p) \u2192 success (-, CERT-pre p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-PRE-CERT .completeness ce st _ st' (CERT-pre p)\n    rewrite let dState = CertState.dState st; open DState dState in\n      dec-yes \u00bf filter\u02e2 isKeyHash (map\u02e2 RwdAddr.stake (dom (CertEnv.wdrls ce))) \u2286 dom voteDelegs\n                \u00d7 map\u02e2 (map\u2081 RwdAddr.stake) (CertEnv.wdrls ce \u02e2) \u2286 rewards \u02e2 \u00bf\n        p .proj\u2082 = refl\n\n  -- POST-CERT has no premises, so computing always succeeds\n  -- with the unique post-state and proof CERT-post.\n  Computational-POST-CERT : Computational _\u22a2_\u21c0\u2987_,POST-CERT\u2988_ String\n  Computational-POST-CERT .computeProof ce cs tt = success ( cs' , CERT-post)\n    where\n      dreps : DReps\n      dreps = GState.dreps (gState cs)\n      validVoteDelegs : VoteDelegs\n      validVoteDelegs = (VoteDelegsOf cs) \u2223^ ( map\u02e2 vDelegCredential (dom dreps) \u222a fromList (vDelegNoConfidence \u2237 vDelegAbstain \u2237 []) )\n      cs' : CertState\n      cs' = \u27e6 \u27e6 validVoteDelegs , StakeDelegsOf cs , RewardsOf cs \u27e7 , PStateOf cs , GStateOf cs \u27e7\n\n  -- Completeness: the relational proof pins s' to exactly `post`,\n  -- and computeProof returns success at that same state; so refl.\n  Computational-POST-CERT .completeness ce cs _ cs' CERT-post = refl\n\nComputational-CERTS : Computational _\u22a2_\u21c0\u2987_,CERTS\u2988_ String\nComputational-CERTS = it\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.Properties.PoV.html","title":"PoV","text":"<p> Theorem (The <code>CERTS</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>l</code> be a list of <code>DCert</code>s, and let <code>s\u2081</code>, <code>s\u2099</code> be <code>CertState</code>s such that <code>s\u2081</code> <code>\u21c0\u2987</code> <code>l</code> <code>,CERTS\u2988</code> <code>s\u2099</code>. Then, the value of <code>s\u2081</code> is equal to the value of <code>s\u2099</code> plus the value of the withdrawals in <code>\u0393</code>.</p> <p>Formally.</p> <pre><code>    CERTS-pov : {\u0393 : CertEnv} {s\u2081 s\u2099  : CertState}\n      \u2192 \u2200[ a \u2208 dom (WithdrawalsOf \u0393) ] NetworkIdOf a \u2261 NetworkId\n      \u2192 \u0393 \u22a2 s\u2081 \u21c0\u2987 l ,CERTS\u2988 s\u2099\n      \u2192 getCoin s\u2081 \u2261 getCoin s\u2099 + getCoin (WithdrawalsOf \u0393)\n</code></pre> <p>Proof.</p> <pre><code>    CERTS-pov {\u0393 = \u0393} validNetId (run (pre-cert , certs)) =\n      trans  (PRE-CERT-pov validNetId pre-cert)\n             (cong (_+ getCoin (WithdrawalsOf \u0393)) (sts-pov certs))\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html","title":"PoVLemmas","text":"<p>Lemma (The <code>CERT</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>s</code>, <code>s'</code> be <code>CertState</code>s such that <code>s</code> <code>\u21c0\u2987</code> <code>dcert</code> <code>,CERT\u2988</code> <code>s'</code> for some <code>dcert</code> : <code>DCert</code>. Then, <code>getCoin</code> <code>s</code> \\(\u2261\\) <code>getCoin</code> <code>s'</code>.</p> <p>Formally.</p> <pre><code>  CERT-pov : {\u0393 : CertEnv} {s s'  : CertState}\n    \u2192 \u0393 \u22a2 s \u21c0\u2987 dCert ,CERT\u2988 s'\n    \u2192 getCoin s \u2261 getCoin s'\n</code></pre> <p>Proof.</p> <pre><code>  CERT-pov (CERT-deleg (DELEG-delegate {rwds = rwds} _)) = sym (\u222a\u02e1singleton0\u2261 rwds)\n  CERT-pov (CERT-deleg (DELEG-reg {rwds = rwds} _)) = sym (\u222a\u02e1singleton0\u2261 rwds)\n  CERT-pov {s = \u27e6 _ , st\u1d56 , st\u1d4d \u27e7\u1d9c\u02e2}{\u27e6 _ , st\u1d56' , st\u1d4d' \u27e7\u1d9c\u02e2}\n    (CERT-deleg (DELEG-dereg {c = c} {rwds} {vDelegs = vDelegs}{sDelegs} x)) = begin\n    getCoin \u27e6 \u27e6 vDelegs , sDelegs , rwds \u27e7 , st\u1d56 , st\u1d4d \u27e7\n      \u2261\u02d8\u27e8 \u2261\u1d49-getCoin rwds-\u222a\u02e1-decomp rwds\n          ( \u2261\u1d49.trans rwds-\u222a\u02e1-\u222a (\u2261\u1d49.trans \u222a-sym (res-ex-\u222a Dec-\u2208-singleton)) ) \u27e9\n    getCoin rwds-\u222a\u02e1-decomp\n      \u2261\u27e8 \u2261\u1d49-getCoin rwds-\u222a\u02e1-decomp ((rwds \u2223 \u2774 c \u2775 \u1d9c) \u222a\u02e1 \u2774 (c , 0) \u2775\u1d50) rwds-\u222a\u02e1\u2261sing-\u222a\u02e1  \u27e9\n    getCoin ((rwds \u2223 \u2774 c \u2775 \u1d9c) \u222a\u02e1 \u2774 (c , 0) \u2775\u1d50 )\n      \u2261\u27e8 \u222a\u02e1singleton0\u2261 (rwds \u2223 \u2774 c \u2775 \u1d9c) \u27e9\n    getCoin \u27e6 \u27e6 vDelegs \u2223 \u2774 c \u2775 \u1d9c , sDelegs \u2223 \u2774 c \u2775 \u1d9c , rwds \u2223 \u2774 c \u2775 \u1d9c \u27e7 , st\u1d56' , st\u1d4d' \u27e7\n      \u220e\n    where\n    module \u2261\u1d49 = IsEquivalence (\u2261\u1d49-isEquivalence {Credential \u00d7 Coin})\n    rwds-\u222a\u02e1-decomp = (rwds \u2223 \u2774 c \u2775 \u1d9c) \u222a\u02e1 (rwds \u2223 \u2774 c \u2775 )\n\n    rwds-\u222a\u02e1-\u222a : rwds-\u222a\u02e1-decomp \u02e2 \u2261\u1d49 (rwds \u2223 \u2774 c \u2775 \u1d9c)\u02e2 \u222a (rwds \u2223 \u2774 c \u2775)\u02e2\n    rwds-\u222a\u02e1-\u222a = disjoint-\u222a\u02e1-\u222a (disjoint-sym res-ex-disjoint)\n\n    disj : disjoint (dom ((rwds \u2223 \u2774 c \u2775\u02e2 \u1d9c) \u02e2)) (dom (\u2774 c , 0 \u2775\u1d50 \u02e2))\n    disj {a} a\u2208res a\u2208dom  = res-comp-dom a\u2208res (dom-single\u2192single a\u2208dom)\n\n    rwds-\u222a\u02e1\u2261sing-\u222a\u02e1 : rwds-\u222a\u02e1-decomp \u02e2 \u2261\u1d49 ((rwds \u2223 \u2774 c \u2775 \u1d9c) \u222a\u02e1 \u2774 (c , 0) \u2775\u1d50 )\u02e2\n    rwds-\u222a\u02e1\u2261sing-\u222a\u02e1 = \u2261\u1d49.trans rwds-\u222a\u02e1-\u222a\n                              ( \u2261\u1d49.trans (\u222a-cong \u2261\u1d49.refl (res-singleton'{m = rwds} x))\n                                         (\u2261\u1d49.sym $ disjoint-\u222a\u02e1-\u222a disj) )\n  CERT-pov (CERT-pool x) = refl\n  CERT-pov (CERT-vdel x) = refl\n\n  injOn : (wdls : Withdrawals)\n          \u2192 \u2200[ a \u2208 dom (wdls \u02e2) ] NetworkIdOf a \u2261 NetworkId\n          \u2192 InjectiveOn (dom (wdls \u02e2)) RwdAddr.stake\n  injOn _ h {record { stake = stakex }} {record { stake = stakey }} x\u2208 y\u2208 refl =\n    cong (\u03bb u \u2192 record { net = u ; stake = stakex }) (trans (h x\u2208) (sym (h y\u2208)))\n\n  module Certs-Pov-lemmas\n    -- TODO: prove some or all of the following assumptions, used in roof of `CERTBASE-pov`.\n    ( sumConstZero    :  {A : Type} \u2983 _ : DecEq A \u2984 {X : \u2119 A} \u2192 getCoin (constMap X 0) \u2261 0 )\n    ( res-decomp      :  {A : Type} \u2983 _ : DecEq A \u2984 (m m' : A \u21c0 Coin)\n                         \u2192 (m \u222a\u02e1 m')\u02e2 \u2261\u1d49 (m \u222a\u02e1 (m' \u2223 dom (m \u02e2) \u1d9c))\u02e2 )\n    ( getCoin-cong    :  {A : Type} \u2983 _ : DecEq A \u2984 (s : A \u21c0 Coin) (s' : \u2119 (A \u00d7 Coin)) \u2192 s \u02e2 \u2261\u1d49 s'\n                         \u2192 indexedSum' proj\u2082 (s \u02e2) \u2261 indexedSum' proj\u2082 s' )\n    ( \u2261\u1d49-getCoin\u02e2     :  {A A' : Type} \u2983 _ : DecEq A \u2984 \u2983 _ : DecEq A' \u2984 (s : \u2119 (A \u00d7 Coin)) {f : A \u2192 A'}\n                         \u2192 InjectiveOn (dom s) f \u2192 getCoin (map\u02e2 (map\u2081 f) s) \u2261 getCoin s )\n    where\n</code></pre> <p>Lemma (<code>PRE-CERT</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>\u0393</code> : <code>CertEnv</code> be a certificate environment, and let <code>s</code>, <code>s'</code> : <code>CertState</code> be certificate states such that <code>s</code> <code>\u21c0\u2987</code> _ <code>,PRE-CERT\u2988</code> <code>s'</code>. Then, the value of <code>s</code> is equal to the value of <code>s'</code> plus the value of the withdrawals in <code>\u0393</code>.  In other terms,</p> <p><code>getCoin</code> <code>s</code> \\(\u2261\\) <code>getCoin</code> <code>s'</code> + <code>getCoin</code> (<code>\u0393</code> .<code>wdrls</code> ).</p> <p>Formally.</p> <pre><code>    PRE-CERT-pov : {\u0393 : CertEnv} {s s' : CertState}\n      \u2192 \u2200[ a \u2208 dom (CertEnv.wdrls \u0393) ] NetworkIdOf a \u2261 NetworkId\n      \u2192 \u0393 \u22a2 s \u21c0\u2987 _ ,PRE-CERT\u2988 s'\n      \u2192 getCoin s \u2261 getCoin s' + getCoin (CertEnv.wdrls \u0393)\n</code></pre> <p>Proof.</p> <pre><code>    PRE-CERT-pov  {\u0393   = \u0393}\n                  {s   = cs}\n                  {s'  = cs'}\n                  validNetId\n                  (CERT-pre {pp}{vs}{e}{dreps}{wdrls} (_ , wdrlsCC\u2286rwds)) =\n      let\n        open DState (dState cs )\n        open DState (dState cs') renaming (rewards to rewards')\n        module \u2261\u1d49       = IsEquivalence (\u2261\u1d49-isEquivalence {Credential \u00d7 Coin})\n        wdrlsCC         = map\u02e2 (map\u2081 RwdAddr.stake) (wdrls \u02e2)\n        zeroMap         = constMap (map\u02e2 RwdAddr.stake (dom wdrls)) 0\n        rwds-\u222a\u02e1-decomp  = (rewards \u2223 dom wdrlsCC \u1d9c) \u222a\u02e1 (rewards \u2223 dom wdrlsCC)\n      in\n        begin\n          getCoin rewards\n            \u2261\u02d8\u27e8 \u2261\u1d49-getCoin rwds-\u222a\u02e1-decomp rewards\n                ( \u2261\u1d49.trans (disjoint-\u222a\u02e1-\u222a (disjoint-sym res-ex-disjoint))\n                           (\u2261\u1d49.trans \u222a-sym (res-ex-\u222a (_\u2208? dom wdrlsCC))) ) \u27e9\n          getCoin rwds-\u222a\u02e1-decomp\n            \u2261\u27e8 indexedSum\u1d5b'-\u222a (rewards \u2223 dom wdrlsCC \u1d9c) (rewards \u2223 dom wdrlsCC)\n                              (disjoint-sym res-ex-disjoint) \u27e9\n          getCoin (rewards \u2223 dom wdrlsCC \u1d9c) + getCoin (rewards \u2223 dom wdrlsCC )\n            \u2261\u27e8 cong (getCoin (rewards \u2223 dom wdrlsCC \u1d9c) +_)\n               ( getCoin-cong (rewards \u2223 dom wdrlsCC) wdrlsCC (res-subset{m = rewards} wdrlsCC\u2286rwds) ) \u27e9\n          getCoin (rewards \u2223 dom wdrlsCC \u1d9c) + getCoin wdrlsCC\n            \u2261\u27e8 cong (getCoin (rewards \u2223 dom wdrlsCC \u1d9c) +_) (\u2261\u1d49-getCoin\u02e2 (wdrls \u02e2) (injOn wdrls validNetId)) \u27e9\n          getCoin (rewards \u2223 dom wdrlsCC \u1d9c) + getCoin wdrls\n            \u2261\u02d8\u27e8 cong (_+ getCoin wdrls)\n                ( begin\n                  getCoin (zeroMap \u222a\u02e1 rewards)\n                    \u2261\u27e8 \u2261\u1d49-getCoin (zeroMap \u222a\u02e1 rewards) (zeroMap \u222a\u02e1 (rewards \u2223 dom zeroMap \u1d9c))\n                                  (res-decomp zeroMap rewards) \u27e9\n                  getCoin (zeroMap \u222a\u02e1 (rewards \u2223 dom zeroMap \u1d9c))\n                    \u2261\u27e8 indexedSum\u1d5b'-\u222a zeroMap (rewards \u2223 dom zeroMap \u1d9c)\n                                      (disjoint-sym res-comp-dom) \u27e9\n                  getCoin zeroMap + getCoin (rewards \u2223 dom zeroMap \u1d9c)\n                    \u2261\u27e8 cong (\u03bb u \u2192 u + getCoin (rewards \u2223 dom zeroMap \u1d9c)) sumConstZero \u27e9\n                  0 + getCoin (rewards \u2223 (dom zeroMap) \u1d9c)\n                    \u2261\u27e8 +-identity\u02e1 (getCoin (rewards \u2223 dom zeroMap \u1d9c)) \u27e9\n                  getCoin (rewards \u2223 dom zeroMap \u1d9c)\n                    \u2261\u27e8 \u2261\u1d49-getCoin (rewards \u2223 dom zeroMap \u1d9c) (rewards \u2223 dom wdrlsCC \u1d9c)\n                       ( res-comp-cong\n                         ( \u2286-Transitive (proj\u2081 constMap-dom) (proj\u2082 dom-map\u02e1\u2261map-dom)\n                         , \u2286-Transitive (proj\u2081 dom-map\u02e1\u2261map-dom) (proj\u2082 constMap-dom) ) ) \u27e9\n                  getCoin (rewards \u2223 dom wdrlsCC \u1d9c)\n                    \u220e ) \u27e9\n          getCoin (zeroMap \u222a\u02e1 rewards) + getCoin wdrls\n            \u220e\n</code></pre> <p>Lemma (<code>POST-CERT</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>\u0393</code> : <code>CertEnv</code> be a certificate environment, and let <code>s</code>, <code>s'</code> : <code>CertState</code> be certificate states such that <code>s</code> <code>\u21c0\u2987</code> _ <code>,POST-CERT\u2988</code> <code>s'</code>. Then, the value of <code>s</code> is equal to the value of <code>s'</code>. In other terms,</p> <p><code>getCoin</code> <code>s</code> \\(\u2261\\) <code>getCoin</code> <code>s'</code>.</p> <p>Formally.</p> <pre><code>    POST-CERT-pov : {\u0393 : CertEnv} {s s' : CertState}\n      \u2192 \u0393 \u22a2 s \u21c0\u2987 _ ,POST-CERT\u2988 s'\n      \u2192 getCoin s \u2261 getCoin s'\n</code></pre> <p>Proof.</p> <pre><code>    POST-CERT-pov CERT-post = refl\n</code></pre> <p>Lemma (iteration of <code>CERT</code> rule preserves value).</p> <p>Informally. Let <code>l</code> be a list of <code>DCert</code>s, and let <code>s\u2081</code>, <code>s\u2099</code> be <code>CertState</code>s such that, starting with <code>s\u2081</code> and successively applying the <code>CERT</code> rule to with <code>DCert</code>s from the list <code>l</code>, we obtain <code>s\u2099</code>. Then, the value of <code>s\u2081</code> is equal to the value of <code>s\u2099</code>.</p> <p>Formally.</p> <pre><code>    sts-pov : {\u0393 : CertEnv} {s\u2081 s\u2099 : CertState} {sigs : List DCert}\n      \u2192 RunTraceAndThen _\u22a2_\u21c0\u2987_,CERT\u2988_ _\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s\u2081 sigs s\u2099\n      \u2192 getCoin s\u2081 \u2261 getCoin s\u2099\n</code></pre> <p>Proof.</p> <pre><code>    sts-pov (run-[] x) = POST-CERT-pov x\n    sts-pov (run-\u2237 x xs) = trans (CERT-pov x) (sts-pov xs)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.Properties.VoteDelegsVDeleg.html","title":"VoteDelegsVDeleg","text":"<p> Claim (<code>voteDelegs</code> by <code>credVoter</code> constructor).</p> <p>Informally.</p> <p>A <code>CertState</code> has a <code>DState</code>, a <code>PState</code>, and a <code>GState</code>.  The <code>DState</code> contains a field <code>voteDelegs</code> which is a mapping from <code>Credential</code> to <code>VDeleg</code>.</p> <p><code>VDeleg</code> is a datatype with three constructors; the one of interest to us here is <code>vDelegCredential{.AgdaInductiveConstructor}, which takes a</code>Credential`{.AgdaDatatype}.</p> <p>Now suppose we have a collection <code>C</code> of credentials---for instance, given <code>d</code> : <code>DState</code>, take <code>C</code> to be the domain of the <code>voteDelegs</code> field of <code>d</code>. We could then obtain a set of <code>VDeleg</code>s by applying <code>vDelegCredential{.AgdaInductiveConstructor} to each element of</code>C`{.AgdaBound}.</p> <p>The present property asserts that the set of <code>VDeleg</code>s that results from the application of <code>vDelegCredential</code> to the domain of the <code>voteDelegs</code> of <code>d</code> contains the range of the <code>voteDelegs</code> of <code>d</code>.</p> <p>Formally.</p> <pre><code>voteDelegsVDeleg :  DState \u2192 Type\nvoteDelegsVDeleg d = range (VoteDelegsOf d) \u2286 map\u02e2 vDelegCredential (dom (VoteDelegsOf d))\n</code></pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Certs.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Certs.Properties where\n\nopen import Ledger.Conway.Specification.Certs.Properties.Computational\nopen import Ledger.Conway.Specification.Certs.Properties.PoV\nopen import Ledger.Conway.Specification.Certs.Properties.PoVLemmas\nopen import Ledger.Conway.Specification.Certs.Properties.VoteDelegsVDeleg\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html","title":"Certificates","text":""},{"location":"Ledger.Conway.Specification.Certs.html#stake-pool-parameter-definitions","title":"Stake Pool Parameter Definitions","text":"<pre><code>record StakePoolParams : Type where\n  field\n    owners          : \u2119 KeyHash\n    cost            : Coin\n    margin          : UnitInterval\n    pledge          : Coin\n    rewardAccount   : Credential\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html#deposit-types","title":"Deposit Types","text":"<pre><code>data DepositPurpose : Type where\n  CredentialDeposit  : Credential   \u2192 DepositPurpose\n  PoolDeposit        : KeyHash      \u2192 DepositPurpose\n  DRepDeposit        : Credential   \u2192 DepositPurpose\n  GovActionDeposit   : GovActionID  \u2192 DepositPurpose\n\nDeposits : Type\nDeposits = DepositPurpose \u21c0 Coin\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html#miscellaneous-type-aliases","title":"Miscellaneous Type Aliases","text":"<pre><code>CCHotKeys : Type\nCCHotKeys = Credential \u21c0 Maybe Credential\n\nDReps : Type\nDReps = Credential \u21c0 Epoch\n\nPoolEnv : Type\nPoolEnv = PParams\n\nPools : Type\nPools = KeyHash \u21c0 StakePoolParams\n\nRetiring : Type\nRetiring = KeyHash \u21c0 Epoch\n\nRewards : Type\nRewards = Credential \u21c0 Coin\n\nStake : Type\nStake = Credential \u21c0 Coin\n\nStakeDelegs : Type\nStakeDelegs = Credential \u21c0 KeyHash\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html#delegation-definitions","title":"Delegation Definitions","text":"<pre><code>data DCert : Type where\n  delegate    : Credential \u2192 Maybe VDeleg \u2192 Maybe KeyHash \u2192 Coin \u2192 DCert\n  dereg       : Credential \u2192 Maybe Coin \u2192 DCert\n  regpool     : KeyHash \u2192 StakePoolParams \u2192 DCert\n  retirepool  : KeyHash \u2192 Epoch \u2192 DCert\n  regdrep     : Credential \u2192 Coin \u2192 Anchor \u2192 DCert\n  deregdrep   : Credential \u2192 Coin \u2192 DCert\n  ccreghot    : Credential \u2192 Maybe Credential \u2192 DCert\n</code></pre> <pre><code>cwitness : DCert \u2192 Maybe Credential\ncwitness (delegate c _ _ _)  = just c\ncwitness (dereg c _)         = just c\ncwitness (regpool kh _)      = just $ KeyHashObj kh\ncwitness (retirepool kh _)   = just $ KeyHashObj kh\ncwitness (regdrep c _ _)     = just c\ncwitness (deregdrep c _)     = just c\ncwitness (ccreghot c _)      = just c\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html#certification-types","title":"Certification Types","text":"<pre><code>record CertEnv : Type where\n  field\n    epoch     : Epoch\n    pp        : PParams\n    votes     : List GovVote\n    wdrls     : Withdrawals\n    coldCreds : \u2119 Credential\n\nrecord DState : Type where\n</code></pre> <pre><code>  field\n    voteDelegs   : VoteDelegs\n    stakeDelegs  : StakeDelegs\n    rewards      : Rewards\n\nrecord PState : Type where\n  field\n    pools     : Pools\n    retiring  : KeyHash \u21c0 Epoch\n\nrecord GState : Type where\n</code></pre> <pre><code>  field\n    dreps      : DReps\n    ccHotKeys  : Credential \u21c0 Maybe Credential\n\nrecord CertState : Type where\n</code></pre> <pre><code>  field\n    dState : DState\n    pState : PState\n    gState : GState\n\nrecord DelegEnv : Type where\n  field\n    pparams       : PParams\n    pools         : Pools\n    delegatees    : \u2119 Credential\n</code></pre> <pre><code>rewardsBalance : DState \u2192 Coin\nrewardsBalance ds = \u2211[ x \u2190 RewardsOf ds ] x\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html#changes-introduced-in-the-conway-era","title":"Changes Introduced in the Conway Era","text":""},{"location":"Ledger.Conway.Specification.Certs.html#delegation","title":"Delegation","text":"<p>Registered credentials can now delegate to a <code>DRep</code> as well as to a stake pool.  This is achieved by giving the <code>delegate</code> certificate two optional fields, corresponding to a <code>DRep</code> and stake pool.</p> <p>Stake can be delegated for voting and block production simultaneously, since these are two separate features. In fact, preventing this could weaken the security of the chain, since security relies on high participation of honest stake holders.</p>"},{"location":"Ledger.Conway.Specification.Certs.html#removal-of-pointer-addresses-genesis-delegations-and-mir-certificates","title":"Removal of Pointer Addresses, Genesis Delegations and MIR Certificates","text":"<p>Support for pointer addresses, genesis delegations and MIR certificates is removed (see CIP-1694 and CKB+23). In <code>DState</code>, this means that the four fields relating to those features are no longer present, and <code>DelegEnv</code> contains none of the fields it used to in the Shelley era (see CVG19, ).</p> <p>Note that pointer addresses are still usable, only their staking functionality has been retired. So all funds locked behind pointer addresses are still accessible, they just don\u2019t count towards the stake distribution anymore. Genesis delegations and MIR certificates have been superceded by the new governance mechanisms, in particular the <code>TreasuryWithdrawal</code> governance action in case of the MIR certificates.</p>"},{"location":"Ledger.Conway.Specification.Certs.html#explicit-deposits","title":"Explicit Deposits","text":"<p>Registration and deregistration of staking credentials are now required to explicitly state the deposit that is being paid or refunded. This deposit is used for checking correctness of transactions with certificates. Including the deposit aligns better with other design decisions such as having explicit transaction fees and helps make this information visible to light clients and hardware wallets.</p> <p>While not shown in the figures, the old certificates without explicit deposits will still be supported for some time for backwards compatibility.</p>"},{"location":"Ledger.Conway.Specification.Certs.html#governance-certificate-rules","title":"Governance Certificate Rules","text":"<p>The rules for transition systems dealing with individual certificates are defined in Sections Auxiliary <code>DELEG</code> Transition System, Auxiliary <code>POOL</code> transition system, and Auxiliary <code>GOVCERT</code> transition system.</p> <p><code>GOVCERT</code> deals with the new certificates relating to <code>DRep</code>s and the constitutional committee.</p> <ul> <li> <p><code>GOVCERT-regdrep</code> registers (or    re-registers) a <code>DRep</code>.  In case of registration,    a deposit needs to be paid.  Either way, the activity period of the    <code>DRep</code> is reset.</p> </li> <li> <p><code>GOVCERT-deregdrep</code> deregisters a    <code>DRep</code>.</p> </li> <li> <p><code>GOVCERT-ccreghot</code> registers a \"hot\"    credential for constitutional committee members.<sup>1</sup> We check that the    cold key did not previously resign from the committee. We allow this    delegation for any cold credential that is either part of    <code>EnactState</code> or a proposal. This allows a newly    elected member of the constitutional committee to immediately delegate    their vote to a hot key and use it to vote. Since votes are counted    after previous actions have been enacted, this allows constitutional    committee members to act without a delay of one epoch.</p> </li> </ul>"},{"location":"Ledger.Conway.Specification.Certs.html#auxiliary-deleg-transition-system","title":"Auxiliary DELEG transition system","text":"<pre><code>data _\u22a2_\u21c0\u2987_,DELEG\u2988_ : DelegEnv \u2192 DState \u2192 DCert \u2192 DState \u2192 Type where\n\n  DELEG-delegate :\n    \u2219 (c \u2209 dom rwds \u2192 d \u2261 pp .keyDeposit)\n    \u2219 (c \u2208 dom rwds \u2192 d \u2261 0)\n    \u2219 mvd \u2208 map\u02e2 (just \u2218 vDelegCredential) delegatees \u222a\n            fromList ( nothing \u2237 just vDelegAbstain \u2237 just vDelegNoConfidence \u2237 [] )\n    \u2219 mkh \u2208 map\u02e2 just (dom pools) \u222a \u2774 nothing \u2775\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 pp , pools , delegatees \u27e7 \u22a2 \u27e6 vDelegs , sDelegs , rwds \u27e7 \u21c0\u2987 delegate c mvd mkh d ,DELEG\u2988 \u27e6 insertIfJust c mvd vDelegs , insertIfJust c mkh sDelegs , rwds \u222a\u02e1 \u2774 c , 0 \u2775 \u27e7\n\n  DELEG-dereg :\n    \u2219 (c , 0) \u2208 rwds\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 pp , pools , delegatees \u27e7 \u22a2 \u27e6 vDelegs , sDelegs , rwds \u27e7 \u21c0\u2987 dereg c md ,DELEG\u2988 \u27e6 vDelegs \u2223 \u2774 c \u2775 \u1d9c , sDelegs \u2223 \u2774 c \u2775 \u1d9c , rwds \u2223 \u2774 c \u2775 \u1d9c \u27e7\n\n  DELEG-reg :\n    \u2219 c \u2209 dom rwds\n    \u2219 d \u2261 pp .keyDeposit \u228e d \u2261 0\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 pp , pools , delegatees \u27e7 \u22a2 \u27e6 vDelegs , sDelegs , rwds \u27e7 \u21c0\u2987 reg c d ,DELEG\u2988 \u27e6 vDelegs , sDelegs , rwds \u222a\u02e1 \u2774 c , 0 \u2775 \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html#auxiliary-pool-transition-system","title":"Auxiliary POOL transition system","text":"<pre><code>data _\u22a2_\u21c0\u2987_,POOL\u2988_ : PoolEnv \u2192 PState \u2192 DCert \u2192 PState \u2192 Type where\n\n  POOL-regpool :\n    \u2219 kh \u2209 dom pools\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      pp \u22a2 \u27e6 pools , retiring \u27e7 \u21c0\u2987 regpool kh poolParams ,POOL\u2988 \u27e6 \u2774 kh , poolParams \u2775 \u222a\u02e1 pools , retiring \u27e7\n\n  POOL-retirepool :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    pp \u22a2 \u27e6 pools , retiring \u27e7 \u21c0\u2987 retirepool kh e ,POOL\u2988 \u27e6 pools , \u2774 kh , e \u2775 \u222a\u02e1 retiring \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html#auxiliary-govcert-transition-system","title":"Auxiliary GOVCERT transition system","text":"<pre><code>data _\u22a2_\u21c0\u2987_,GOVCERT\u2988_ : CertEnv \u2192 GState \u2192 DCert \u2192 GState \u2192 Type where\n\n  GOVCERT-regdrep :\n    \u2219 (d \u2261 pp .drepDeposit \u00d7 c \u2209 dom dReps) \u228e (d \u2261 0 \u00d7 c \u2208 dom dReps)\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 dReps , ccKeys \u27e7 \u21c0\u2987 regdrep c d an ,GOVCERT\u2988 \u27e6 \u2774 c , e + pp .drepActivity \u2775 \u222a\u02e1 dReps , ccKeys \u27e7\n\n  GOVCERT-deregdrep :\n    \u2219 c \u2208 dom dReps\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 dReps , ccKeys \u27e7 \u21c0\u2987 deregdrep c d ,GOVCERT\u2988 \u27e6 dReps \u2223 \u2774 c \u2775 \u1d9c , ccKeys \u27e7\n\n  GOVCERT-ccreghot :\n    \u2219 (c , nothing) \u2209 ccKeys\n    \u2219 c \u2208 cc\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 dReps , ccKeys \u27e7 \u21c0\u2987 ccreghot c mc ,GOVCERT\u2988 \u27e6 dReps , \u2774 c , mc \u2775 \u222a\u02e1 ccKeys \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html#sec:the-certs-transition-system","title":"The CERTS Transition System","text":"<p>This section culminates in the definition of the <code>CERTS</code> transition system by bundling previously defined pieces together into a <code>CERT</code> transition rule which <code>CERTS</code> runs on a sequence of signals, keeping track of the certification state as it progresses.</p>"},{"location":"Ledger.Conway.Specification.Certs.html#the-cert-transition-system","title":"The CERT Transition System","text":"<pre><code>data _\u22a2_\u21c0\u2987_,CERT\u2988_  : CertEnv \u2192 CertState \u2192 DCert \u2192 CertState \u2192 Type where\n\n  CERT-deleg :\n    \u2219 \u27e6 pp , PState.pools st\u1d56 , dom (GState.dreps st\u1d4d) \u27e7 \u22a2 st\u1d48 \u21c0\u2987 dCert ,DELEG\u2988 st\u1d48'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 st\u1d48 , st\u1d56 , st\u1d4d \u27e7 \u21c0\u2987 dCert ,CERT\u2988 \u27e6 st\u1d48' , st\u1d56 , st\u1d4d \u27e7\n\n  CERT-pool :\n    \u2219 pp \u22a2 st\u1d56 \u21c0\u2987 dCert ,POOL\u2988 st\u1d56'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 st\u1d48 , st\u1d56 , st\u1d4d \u27e7 \u21c0\u2987 dCert ,CERT\u2988 \u27e6 st\u1d48 , st\u1d56' , st\u1d4d \u27e7\n\n  CERT-vdel :\n    \u2219 \u0393 \u22a2 st\u1d4d \u21c0\u2987 dCert ,GOVCERT\u2988 st\u1d4d'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 \u27e6 st\u1d48 , st\u1d56 , st\u1d4d \u27e7 \u21c0\u2987 dCert ,CERT\u2988 \u27e6 st\u1d48 , st\u1d56 , st\u1d4d' \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html#the-pre-cert-transition-rule","title":"The PRE-CERT Transition Rule","text":"<p>Here we define the <code>PRE-CERT</code> transition rule.  This rule is applied at the start of the <code>CERTS</code> transition rule and handles the following important housekeeping tasks:</p> <ul> <li> <p>check the correctness of withdrawals and ensure that withdrawals only    happen from credentials that have delegated their voting power;</p> </li> <li> <p>set the activity timer of all <code>DRep</code>s that voted    to <code>drepActivity</code> epochs in the future;</p> </li> <li> <p>set the rewards of the credentials that withdrew funds to zero.</p> </li> </ul> <p>Regarding the second item, if there is a new governance proposal to vote on in this transaction, then expiry for all <code>DReps</code> will be increased by the number of dormant epochs.  However, the <code>PRE-CERT</code> transition occurs in <code>LEDGER</code> before the <code>GOV</code> rule, so it cannot validate any governance proposal.  This is not a problem since the entire transaction will fail if the proposal is not accepted in the <code>GOV</code> rule.</p> <pre><code>data _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ : CertEnv \u2192 CertState \u2192 \u22a4 \u2192 CertState \u2192 Type where\n\n  CERT-pre :\n    let refresh         = mapPartial (isGovVoterDRep \u2218 voter) (fromList vs)\n        refreshedDReps  = mapValueRestricted (const (e + pp .drepActivity)) dReps refresh\n        wdrlCreds       = map\u02e2 stake (dom wdrls)\n    in\n    \u2219 filter isKeyHash wdrlCreds \u2286 dom voteDelegs\n    \u2219 map\u02e2 (map\u2081 stake) (wdrls \u02e2) \u2286 rewards \u02e2\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 \u27e6 voteDelegs , stakeDelegs , rewards \u27e7 , st\u1d56 , \u27e6 dReps , ccHotKeys \u27e7 \u27e7 \u21c0\u2987 _ ,PRE-CERT\u2988 \u27e6 \u27e6 voteDelegs , stakeDelegs , constMap wdrlCreds 0 \u222a\u02e1 rewards \u27e7 , st\u1d56 , \u27e6 refreshedDReps , ccHotKeys \u27e7 \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html#the-post-cert-transition-rule","title":"The POST-CERT Transition Rule","text":"<p>The <code>POST-CERT</code> transition rule is applied at the end of the <code>CERTS</code> rule and it ensures that only valid registered <code>DReps</code> are included in the final <code>CertState</code>.</p> <pre><code>data _\u22a2_\u21c0\u2987_,POST-CERT\u2988_ : CertEnv \u2192 CertState \u2192 \u22a4 \u2192 CertState \u2192 Type where\n\n  CERT-post :\n    \u27e6 e , pp , vs , wdrls , cc \u27e7 \u22a2 \u27e6 \u27e6 voteDelegs , stakeDelegs , rewards \u27e7 , st\u1d56 , st\u1d4d \u27e7 \u21c0\u2987 _ ,POST-CERT\u2988 \u27e6 \u27e6 voteDelegs \u2223^ (map\u02e2 vDelegCredential (dom (DRepsOf st\u1d4d)) \u222a fromList (vDelegNoConfidence \u2237 vDelegAbstain \u2237 [])) , stakeDelegs , rewards \u27e7 , st\u1d56 , st\u1d4d \u27e7\n\n_\u22a2_\u21c0\u2987_,CERTS\u2988_  : CertEnv \u2192 CertState  \u2192 List DCert  \u2192 CertState  \u2192 Type\n_\u22a2_\u21c0\u2987_,CERTS\u2988_ = RunTraceAfterAndThen _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ _\u22a2_\u21c0\u2987_,CERT\u2988_ _\u22a2_\u21c0\u2987_,POST-CERT\u2988_\n</code></pre>"},{"location":"Ledger.Conway.Specification.Certs.html#references","title":"References","text":"<p>[CKB+23]  Jared Corduan and Andre Knispel and Matthias Benkort and Kevin Hammond and Charles Hoskinson and Samuel Leathers. A First Step Towards On-Chain Decentralized Governance. 2023.</p> <p>[CVG19]  Jared Corduan and Polina Vinogradova and Matthias G\u00fcdemann. A Formal Specification of the Cardano Ledger. 2019.</p> <ol> <li> <p>By \"hot\" and \"cold\" credentials we mean the following: a cold credential is used to register a hot credential, and then the hot credential is used for voting. The idea is that the access to the cold credential is kept in a secure location, while the hot credential is more conveniently accessed. If the hot credential is compromised, it can be changed using the cold credential.\u00a0\u21a9</p> </li> </ol>"},{"location":"Ledger.Conway.Specification.Chain.Properties.Computational.html","title":"Computational","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\nopen import Ledger.Conway.Specification.Abstract using (AbstractFunctions)\n\nmodule Ledger.Conway.Specification.Chain.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\nopen import Ledger.Conway.Specification.BlockBody.Properties.Computational txs abs\nopen import Ledger.Conway.Specification.Chain txs abs\nopen import Ledger.Conway.Specification.Enact govStructure using (EnactState)\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.RewardUpdate txs abs\nopen import Ledger.Conway.Specification.RewardUpdate.Properties.Computational txs abs\nopen import Ledger.Prelude\n\nopen Computational \u2983...\u2984\n\nmodule _\n  (nes : NewEpochState)\n  (open EpochState (NewEpochState.epochState nes) using (ls) renaming (es to es'))\n  (open EnactState es' using (pparams))\n  (open PParams \u2223 pparams \u2223 using (maxRefScriptSizePerBlock))\n  (ts : List Tx)\n  where\n  refScriptSize\u2264?Bound : Dec (totalRefScriptsSize ls ts \u2264 maxRefScriptSizePerBlock)\n  refScriptSize\u2264?Bound = totalRefScriptsSize ls ts \u2264? maxRefScriptSizePerBlock\n\ninstance\n  Computational-CHAIN : Computational _\u22a2_\u21c0\u2987_,CHAIN\u2988_ String\n  Computational-CHAIN .computeProof \u0393 s b = do\n    nes , tickStep \u2190 map\u2081 \u22a5-elim $ computeProof {STS = _\u22a2_\u21c0\u2987_,TICK\u2988_} _ _ _\n    (_ , _) , bbStep \u2190 computeProof _ (LStateOf nes , nes .NewEpochState.bcur) b\n    case refScriptSize\u2264?Bound nes (b .Block.ts) of \u03bb where\n      (no \u00acp) \u2192 failure \"totalRefScriptsSize &gt; maxRefScriptSizePerBlock\"\n      (yes p) \u2192 success (_ , CHAIN (p , tickStep , bbStep))\n\n  Computational-CHAIN .completeness _ s b _ (CHAIN {nes = nes} (p , tickStep , bbStep))\n    with recomputeProof tickStep | completeness _ _ _ _ tickStep\n  ... | success _ | refl\n    with recomputeProof bbStep | completeness _ _ _ _ bbStep\n  ... | success _ | refl\n    with refScriptSize\u2264?Bound nes (Block.ts b)\n  ... | yes p = refl\n  ... | no \u00acp = \u22a5-elim (\u00acp p)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Chain.Properties.CredDepsEqualDomRwds.html","title":"CredDepsEqualDomRwds","text":"<p>Claim (Equality of credential depsoits is a <code>CHAIN</code> invariant).</p> <p>Informally.</p> <p>This property concerns two quantities associated with a given <code>ChainState</code> <code>cs</code>,</p> <ul> <li> <p>the credential deposits of the <code>UTxOState</code> of <code>cs</code> and</p> </li> <li> <p>the credential deposits of the rewards in the ledger state of <code>cs</code>.</p> </li> </ul> <p>The predicate <code>credDeposits\u2261dom-rwds</code> <code>cs</code> asserts that these quantities are equal for <code>cs</code>.</p> <p>The property <code>credDeposits\u2261dom-rwds-inv</code> asserts that <code>credDeposits\u2261dom-rwds</code> is a chain invariant. That is, if <code>cs</code> and <code>cs'</code> are two <code>ChainState</code>s such that <code>cs</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,CHAIN\u2988</code> <code>cs'</code>, then <code>credDeposits\u2261dom-rwds</code> <code>cs</code> only if <code>credDeposits\u2261dom-rwds</code> <code>cs'</code>.</p> <p>Formally.</p> <pre><code>credDeposits\u2261dom-rwds : ChainState \u2192 Type\ncredDeposits\u2261dom-rwds cs =  filter isCredDeposit (dom (DepositsOf cs))\n                            \u2261 map CredentialDeposit (dom (RewardsOf cs))\n\ncredDeposits\u2261dom-rwds-inv : Type\ncredDeposits\u2261dom-rwds-inv = LedgerInvariant _\u22a2_\u21c0\u2987_,CHAIN\u2988_ credDeposits\u2261dom-rwds\n</code></pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Chain.Properties.EpochStep.html","title":"EpochStep","text":"<p>Claim (New enact state only if new epoch).</p> <p>Informally.</p> <p>Let <code>cs</code> and <code>cs'</code> be <code>ChainState</code>s and <code>b</code> a <code>Block</code>. If <code>cs</code> <code>\u21c0\u2987</code> <code>b</code> <code>,CHAIN\u2988</code> <code>cs'</code> and if the enact states of <code>cs</code> and <code>cs'</code> differ, then the epoch of the slot of <code>b</code> is the successor of the last epoch of <code>cs</code>.</p> <p>Formally.</p> <pre><code>enact-change\u21d2newEpoch : (b : Block) {cs cs'  : ChainState}\n  \u2192 _ \u22a2 cs \u21c0\u2987 b ,CHAIN\u2988 cs' \u2192 EnactStateOf cs \u2262 EnactStateOf cs'\n  \u2192 Type\n\nenact-change\u21d2newEpoch b {cs} h es\u2262es' =\n  epoch (b .bheader .bhbody .slot) \u2261 suc\u1d49 (LastEpochOf cs)\n  where\n    open Block\n    open BHeader\n    open BHBody\n</code></pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Chain.Properties.GovDepsMatch.html","title":"GovDepsMatch","text":"<p> Theorem (<code>govDepsMatch</code> is invariant of <code>CHAIN</code> rule).</p> <p>Informally.</p> <p>Fix a <code>Block</code> <code>b</code>, a <code>ChainState</code> <code>cs</code>, and a <code>NewEpochState</code> <code>nes</code>. Let <code>csLState</code> be the ledger state of <code>cs</code>. Recall, a <code>ChainState</code> has just one field, <code>newEpochState</code> : <code>NewEpochState</code>. Consider the chain state <code>cs'</code> defined as follows:</p> <pre><code>  cs' : ChainState\n  cs' .newEpochState =\n    record nes {epochState  = record (EpochStateOf cs) {ls = LStateOf nes}}\n</code></pre> <p>That is <code>cs'</code> is essentially <code>nes</code>, but the <code>EpochState</code> field is set to the <code>epochState</code> of <code>cs</code> with the exception of the <code>LState</code> field, which is set to that of <code>nes</code>. Let <code>utxoSt</code> and <code>utxoSt'</code> be the respective <code>UTxOState</code>s of the ledger states of <code>cs</code> and <code>cs'</code>, respectively, and let <code>govSt</code> and <code>govSt'</code> be their respective <code>GovState</code>s. Assume the following conditions hold:</p> <ul> <li> <p>Let <code>removed'</code> : <code>\u2119</code>(<code>GovActionID</code> \u00d7 <code>GovActionState</code>) be the union of</p> <ul> <li> <p>the governance actions in the <code>removed</code> field of the ratify state of <code>eps</code>, and</p> </li> <li> <p>the orphaned governance actions in the <code>GovState</code> of <code>eps</code>.</p> </li> </ul> <p>Let \\(\\mathcal{G}\\) be the set \\(\\{\\)<code>GovActionDeposit</code> <code>id</code> : <code>id</code> \u2208 <code>proj\u2081</code> <code>removed'</code>\\(\\}\\).</p> <p>\\(\\mathcal{G}\\) is a subset of the set of deposits of the chain state <code>cs</code>; that is,</p> <p><code>map</code> (<code>GovActionDeposit</code> \\(\u2218\\) <code>proj\u2081</code>) <code>removed'</code> \u2286 <code>dom</code> (<code>DepositsOf</code> <code>cs</code>).</p> </li> <li> <p>The total reference script size of <code>csLState</code> is not    greater than the maximum allowed size per block (as specified in <code>PParams</code>).</p> </li> <li> <p><code>cs</code> <code>\u21c0\u2987</code> <code>b</code> <code>,CHAIN\u2988</code> <code>cs'</code>.</p> </li> </ul> <p>Under these conditions, if the governance action deposits of <code>utxoSt</code> equal those of <code>govSt</code>, then the same holds for <code>utxoSt'</code> and <code>govSt'</code>. In other terms,</p> <p><code>govDepsMatch</code> <code>csLState</code> implies <code>govDepsMatch</code> <code>nesState</code>.</p> <p>Formally.</p> <pre><code>  CHAIN-govDepsMatch :\n    map (GovActionDeposit \u2218 proj\u2081) removed' \u2286 dom (DepositsOf cs)\n    \u2192  totalRefScriptsSize csLState ts \u2264 maxRefScriptSizePerBlock\n    \u2192  _ \u22a2 cs \u21c0\u2987 b ,CHAIN\u2988 cs'\n    \u2192  govDepsMatch csLState \u2192 govDepsMatch (LStateOf nes)\n</code></pre> <p>Proof.</p> <pre><code>  CHAIN-govDepsMatch rrm rss\n      ( CHAIN ( x\n              , TICK ((NEWEPOCH-New (_ , eps\u2081\u2192eps\u2082)) , _)\n              , BBODY-Block-Body (_ , _ , ledgers)\n              )\n      ) =\n    RTC-preserves-inv LEDGER-govDepsMatch ledgers\n     \u2218 EPOCH-PROPS.EPOCH-govDepsMatch rrm eps\u2081\u2192eps\u2082\n\n  CHAIN-govDepsMatch rrm rss\n      ( CHAIN ( x\n              , TICK (NEWEPOCH-Not-New _ , _)\n              , BBODY-Block-Body (_ , _ , ledgers)\n              )\n      ) =\n    RTC-preserves-inv LEDGER-govDepsMatch ledgers\n\n  CHAIN-govDepsMatch rrm rss\n      ( CHAIN ( x\n              , TICK (NEWEPOCH-No-Reward-Update (_ , eps\u2081\u2192eps\u2082) , _)\n              , BBODY-Block-Body (_ , _ , ledgers)\n              )\n      ) =\n    RTC-preserves-inv LEDGER-govDepsMatch ledgers\n     \u2218 EPOCH-PROPS.EPOCH-govDepsMatch rrm eps\u2081\u2192eps\u2082\n</code></pre>"},{"location":"Ledger.Conway.Specification.Chain.Properties.PParamsWellFormed.html","title":"PParamsWellFormed","text":"<p>Claim (Well-formedness of <code>PParams</code> is a <code>CHAIN</code> invariant).</p> <p>Informally.</p> <p>We say the <code>PParams</code> of a chain state are well-formed if each of the following parameters is non-zero: <code>maxBlockSize</code>, <code>maxTxSize</code>, <code>maxHeaderSize</code>, <code>maxValSize</code>, <code>refScriptCostStride</code>, <code>coinsPerUTxOByte</code>, <code>poolDeposit</code>, <code>collateralPercentage</code>, <code>ccMaxTermLength</code>, <code>govActionLifetime</code>, <code>govActionDeposit</code>, <code>drepDeposit</code>.</p> <p>We claim that <code>pp-wellFormed</code> is a chain invariant. That is, if <code>cs</code> and <code>cs'</code> are chain states such that <code>cs</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,CHAIN\u2988</code> <code>cs'</code>, and if the <code>PParams</code> of <code>cs</code> are well-formed, then so are the <code>PParams</code> of <code>cs'</code> .</p> <p>Formally.</p> <pre><code>pp-wellFormed : ChainState \u2192 Type\npp-wellFormed = paramsWellFormed \u2218 PParamsOf\n\npp-wellFormed-invariant : Type\npp-wellFormed-invariant = LedgerInvariant _\u22a2_\u21c0\u2987_,CHAIN\u2988_ pp-wellFormed\n</code></pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Chain.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Chain.Properties where\n\nopen import Ledger.Conway.Specification.Chain.Properties.Computational\nopen import Ledger.Conway.Specification.Chain.Properties.CredDepsEqualDomRwds\nopen import Ledger.Conway.Specification.Chain.Properties.EpochStep\nopen import Ledger.Conway.Specification.Chain.Properties.GovDepsMatch\nopen import Ledger.Conway.Specification.Chain.Properties.PParamsWellFormed\n</code></pre>"},{"location":"Ledger.Conway.Specification.Enact.Properties.Computational.html","title":"Computational","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Gov.Base\n\nmodule Ledger.Conway.Specification.Enact.Properties.Computational (gs : _) (open GovStructure gs) where\n\nopen import Ledger.Prelude\n\nopen import Ledger.Conway.Specification.Gov.Actions gs hiding (yes; no)\nopen import Ledger.Conway.Specification.Enact gs\n\nopen EnactState\n\nopen Computational \u2983...\u2984\n\ninstance\n  Computational-ENACT : Computational _\u22a2_\u21c0\u2987_,ENACT\u2988_ String\n  Computational-ENACT .computeProof \u0393\u1d49 s =\n    let open EnactEnv \u0393\u1d49 renaming (treasury to t; epoch to e) in\n    \u03bb where\n    \u27e6 NoConfidence        , _               \u27e7\u1d4d\u1d43 \u2192 success (_ , Enact-NoConf)\n    \u27e6 UpdateCommittee     , (new , rem , q) \u27e7\u1d4d\u1d43 \u2192\n      case \u00bf \u2200[ term \u2208 range new ]\n               term \u2264 CCMaxTermLengthOf s +\u1d49' e \u00bf of \u03bb where\n      (yes p) \u2192 success (-, Enact-UpdComm\n        (subst (\u03bb x \u2192 \u2200[ term \u2208 range new ] term \u2264 x) (sym +\u1d49\u2261+\u1d49') p))\n      (no \u00acp) \u2192 failure \"ENACT failed at \u2200[ term \u2208 range new ] term \u2264 (CCMaxTermLengthOf s +\u1d49 e)\"\n    \u27e6 NewConstitution     , _               \u27e7\u1d4d\u1d43 \u2192 success (-, Enact-NewConst)\n    \u27e6 TriggerHardFork     , _               \u27e7\u1d4d\u1d43 \u2192 success (-, Enact-HF)\n    \u27e6 ChangePParams       , _               \u27e7\u1d4d\u1d43 \u2192 success (-, Enact-PParams)\n    \u27e6 Info                , _               \u27e7\u1d4d\u1d43 \u2192 success (-, Enact-Info)\n    \u27e6 TreasuryWithdrawal  , wdrl            \u27e7\u1d4d\u1d43 \u2192\n      case \u00bf \u2211[ x \u2190 s .withdrawals \u222a\u207a wdrl ] x \u2264 t \u00bf of \u03bb where\n        (yes p)  \u2192 success (-, Enact-Wdrl p)\n        (no _)   \u2192 failure \"ENACT failed at \u2211[ x \u2190 (s .withdrawals \u222a\u207a wdrl) \u1da0\u1d50 ] x \u2264 t\"\n  Computational-ENACT .completeness \u0393\u1d49 s action _ p\n    with action | p\n  ... | \u27e6 .NoConfidence        , _               \u27e7\u1d4d\u1d43 | Enact-NoConf   = refl\n  ... | \u27e6 .UpdateCommittee     , (new , rem , q) \u27e7\u1d4d\u1d43 | Enact-UpdComm p\n    rewrite dec-yes\n      (\u00bf \u2200[ term \u2208 range new ] term\n           \u2264 CCMaxTermLengthOf s +\u1d49' EnactEnv.epoch \u0393\u1d49 \u00bf)\n      (subst (\u03bb x \u2192 \u2200[ term \u2208 range new ] term \u2264 x) +\u1d49\u2261+\u1d49' p) .proj\u2082\n      = refl\n  ... | \u27e6 .NewConstitution     , _               \u27e7\u1d4d\u1d43 | Enact-NewConst = refl\n  ... | \u27e6 .TriggerHardFork     , _               \u27e7\u1d4d\u1d43 | Enact-HF       = refl\n  ... | \u27e6 .ChangePParams       , _               \u27e7\u1d4d\u1d43 | Enact-PParams  = refl\n  ... | \u27e6 .Info                , _               \u27e7\u1d4d\u1d43 | Enact-Info     = refl\n  ... | \u27e6 .TreasuryWithdrawal  , wdrl            \u27e7\u1d4d\u1d43 | Enact-Wdrl p\n    rewrite dec-yes (\u00bf \u2211[ x \u2190 s .withdrawals \u222a\u207a wdrl ] x \u2264 EnactEnv.treasury \u0393\u1d49 \u00bf) p .proj\u2082\n    = refl\n</code></pre>"},{"location":"Ledger.Conway.Specification.Enact.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Enact.Properties where\n\nopen import Ledger.Conway.Specification.Enact.Properties.Computational\n</code></pre>"},{"location":"Ledger.Conway.Specification.Enact.html","title":"Enactment","text":""},{"location":"Ledger.Conway.Specification.Enact.html#auxiliary-types-and-function","title":"Auxiliary Types and Functions","text":"<p>This section contains some definitions required to define the <code>ENACT</code> transition system.  <code>EnactEnv</code> is the environment and <code>EnactState</code> the state of <code>ENACT</code>, which enacts a governance action.  All governance actions except <code>TreasuryWithdrawal</code> and <code>Info</code> modify <code>EnactState</code> permanently, which of course can have further consequences. <code>TreasuryWithdrawal</code> accumulates withdrawal temporarily in the <code>withdrawals</code> field of <code>EnactState</code>, but this information is applied and reset in <code>EPOCH</code> (see EPOCH Transition System). Also, enacting these governance actions is the only way of modifying <code>EnactState</code>.</p> <p>Note that all other fields of <code>EnactState</code> also contain a <code>GovActionID</code> since they are <code>HashProtected</code>.</p> <pre><code>record EnactEnv : Type where\n  field\n    gid       : GovActionID\n    treasury  : Treasury\n    epoch     : Epoch\n\nrecord EnactState : Type where\n  field\n    cc            : HashProtected (Maybe ((Credential \u21c0 Epoch) \u00d7 \u211a))\n    constitution  : HashProtected (DocHash \u00d7 Maybe ScriptHash)\n    pv            : HashProtected ProtVer\n    pparams       : HashProtected PParams\n    withdrawals   : Withdrawals\n</code></pre> <pre><code>ccCreds : HashProtected (Maybe ((Credential \u21c0 Epoch) \u00d7 \u211a)) \u2192 \u2119 Credential\nccCreds (just x   , _)  = dom (x .proj\u2081)\nccCreds (nothing  , _)  = \u2205\n\ngetHash : \u2200 {a} \u2192 NeedsHash a \u2192 Maybe GovActionID\ngetHash {NoConfidence}        h = just h\ngetHash {UpdateCommittee}     h = just h\ngetHash {NewConstitution}     h = just h\ngetHash {TriggerHardFork}     h = just h\ngetHash {ChangePParams}       h = just h\ngetHash {TreasuryWithdrawal}  _ = nothing\ngetHash {Info}                _ = nothing\n\ngetHashES : EnactState \u2192 GovActionType \u2192 Maybe GovActionID\ngetHashES es NoConfidence          = just (es .cc .proj\u2082)\ngetHashES es (UpdateCommittee)     = just (es .cc .proj\u2082)\ngetHashES es (NewConstitution)     = just (es .constitution .proj\u2082)\ngetHashES es (TriggerHardFork)     = just (es .pv .proj\u2082)\ngetHashES es (ChangePParams)       = just (es .pparams .proj\u2082)\ngetHashES es (TreasuryWithdrawal)  = nothing\ngetHashES es Info                  = nothing\n</code></pre> <p>Type of the ENACT transition system</p> <pre><code>data _\u22a2_\u21c0\u2987_,ENACT\u2988_ : EnactEnv \u2192 EnactState \u2192 GovAction \u2192 EnactState \u2192 Type\n</code></pre>"},{"location":"Ledger.Conway.Specification.Enact.html#enact-transition-system","title":"ENACT Transition System","text":"<p>This section defines the rules of the <code>ENACT</code> transition system. Usually no preconditions are checked and the state is simply updated (including the <code>GovActionID</code> for the hash protection scheme, if required).  The exceptions are <code>UpdateCommittee</code> and <code>TreasuryWithdrawal</code>:</p> <ul> <li> <p><code>UpdateCommittee</code> requires that maximum   terms are respected, and</p> </li> <li> <p><code>TreasuryWithdrawal</code> requires that the   treasury is able to cover the sum of all withdrawals (old and new).</p> </li> </ul> <pre><code>  Enact-NoConf :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u27e6 gid , t , e \u27e7 \u22a2 s \u21c0\u2987 \u27e6 NoConfidence , _ \u27e7\u1d4d\u1d43 ,ENACT\u2988 record s { cc = nothing , gid }\n\n  Enact-UpdComm : let old      = maybe proj\u2081 \u2205 (s .cc .proj\u2081)\n                      maxTerm  = CCMaxTermLengthOf s +\u1d49 e\n                  in\n    \u2200[ term \u2208 range new ] term \u2264 maxTerm\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u27e6 gid , t , e \u27e7 \u22a2 s \u21c0\u2987 \u27e6 UpdateCommittee , (new , rem , q) \u27e7\u1d4d\u1d43 ,ENACT\u2988\n      record s { cc = just ((new \u222a\u02e1 old) \u2223 rem \u1d9c , q) , gid }\n\n  Enact-NewConst :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u27e6 gid , t , e \u27e7 \u22a2 s \u21c0\u2987 \u27e6 NewConstitution , (dh , sh) \u27e7\u1d4d\u1d43 ,ENACT\u2988 record s { constitution = (dh , sh) , gid }\n\n  Enact-HF :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u27e6 gid , t , e \u27e7 \u22a2 s \u21c0\u2987 \u27e6 TriggerHardFork , v \u27e7\u1d4d\u1d43 ,ENACT\u2988 record s { pv = v , gid }\n\n  Enact-PParams :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u27e6 gid , t , e \u27e7 \u22a2 s \u21c0\u2987 \u27e6 ChangePParams , up \u27e7\u1d4d\u1d43 ,ENACT\u2988\n      record s { pparams = applyUpdate (PParamsOf s) up , gid }\n\n  Enact-Wdrl : let newWdrls = s .withdrawals \u222a\u207a wdrl in\n    \u2211[ x \u2190 newWdrls ] x \u2264 t\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u27e6 gid , t , e \u27e7 \u22a2 s \u21c0\u2987 \u27e6 TreasuryWithdrawal , wdrl \u27e7\u1d4d\u1d43 ,ENACT\u2988 record s { withdrawals = newWdrls }\n\n  Enact-Info :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u27e6 gid , t , e \u27e7 \u22a2 s \u21c0\u2987 \u27e6 Info , _ \u27e7\u1d4d\u1d43 ,ENACT\u2988 s\n</code></pre>"},{"location":"Ledger.Conway.Specification.Epoch.Properties.Computational.html","title":"Computational","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nopen import Agda.Builtin.FromNat\n\nmodule Ledger.Conway.Specification.Epoch.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.PoolReap txs abs\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Specification.Ratify.Properties.Computational txs\nopen import Ledger.Conway.Specification.Rewards txs abs\n\nopen import Data.List using (filter)\nimport Relation.Binary.PropositionalEquality as PE\n\nopen Computational \u2983...\u2984\n\nmodule _ {lstate : LState} {ss : Snapshots} where\n  SNAP-total : \u2203[ ss' ] lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n  SNAP-total = -, SNAP\n\n  SNAP-complete : \u2200 ss' \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss' \u2192 proj\u2081 SNAP-total \u2261 ss'\n  SNAP-complete ss' SNAP = refl\n\n  SNAP-deterministic : \u2200 {ss' ss''}\n                     \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n                     \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'' \u2192 ss' \u2261 ss''\n  SNAP-deterministic SNAP SNAP = refl\n\nmodule _ {e : Epoch} (prs : PoolReapState) where\n  POOLREAP-total : \u2203[ prs' ] _ \u22a2 prs \u21c0\u2987 e ,POOLREAP\u2988 prs'\n  POOLREAP-total = -, POOLREAP\n\n  POOLREAP-complete\n    : \u2200 prs' \u2192 _ \u22a2 prs \u21c0\u2987 e ,POOLREAP\u2988 prs' \u2192 proj\u2081 POOLREAP-total \u2261 prs'\n  POOLREAP-complete prs' POOLREAP = refl\n\n  POOLREAP-deterministic\n    : \u2200 {prs' prs''}\n    \u2192 _ \u22a2 prs \u21c0\u2987 e ,POOLREAP\u2988 prs'\n    \u2192 _ \u22a2 prs \u21c0\u2987 e ,POOLREAP\u2988 prs''\n    \u2192 prs' \u2261 prs''\n  POOLREAP-deterministic POOLREAP POOLREAP = refl\n\nmodule _ {eps : EpochState} {e : Epoch} where\n\n  open EpochState eps hiding (es)\n\n  prs = \u27e6 u0 .utxoSt' , acnt , cs .dState , cs .pState \u27e7\n    where\n      open LState\n      open CertState\n      open EPOCH-Updates0\n      cs = ls .certState\n      u0 = EPOCH-updates0 fut ls\n\n  EPOCH-total : \u2203[ eps' ] _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n  EPOCH-total =\n    -, EPOCH\n         ( SNAP-total .proj\u2082\n         , RATIFIES-total' .proj\u2082\n         , POOLREAP-total prs .proj\u2082)\n\n  private\n    EPOCH-state : Snapshots \u2192 RatifyState \u2192 PoolReapState \u2192 EpochState\n    EPOCH-state ss fut' (\u27e6 utxoSt'' , acnt' , dState' , pState' \u27e7\u1d56) =\n      let\n        EPOCHUpdates es govSt' dState'' gState' _ acnt'' =\n          EPOCH-updates fut ls dState' acnt'\n        certState' = \u27e6 dState'' , pState' , gState' \u27e7\u1d9c\u02e2\n       in\n          record\n            { acnt = acnt''\n            ; ss = ss\n            ; ls = \u27e6 utxoSt'' , govSt' , certState' \u27e7\u02e1\n            ; es = es\n            ; fut = fut'\n            }\n\n  EPOCH-deterministic : \u2200 eps' eps''\n                      \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n                      \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps''\n                      \u2192 eps' \u2261 eps''\n  EPOCH-deterministic\n      eps'\n      eps''\n      (EPOCH\n        {utxoSt'' = utxoSt''\u2081}\n        {acnt' = acnt'\u2081}\n        {dState' = dState'\u2081}\n        {pState' = pState'\u2081}\n        (p\u2081 , p\u2082 , p\u2083)\n      )\n      (EPOCH\n        {utxoSt'' = utxoSt''\u2082}\n        {acnt' = acnt'\u2082}\n        {dState' = dState'\u2082}\n        {pState' = pState'\u2082}\n        (p\u2081' , p\u2082' , p\u2083')\n      ) =\n    cong\u2082 _$_ (cong\u2082 EPOCH-state ss'\u2261ss'' fut'\u2261fut'') prs'\u2261prs''\n    where\n      ss'\u2261ss'' : EpochState.ss eps' \u2261 EpochState.ss eps''\n      ss'\u2261ss'' = SNAP-deterministic p\u2081 p\u2081'\n\n      fut'\u2261fut'' : EpochState.fut eps' \u2261 EpochState.fut eps''\n      fut'\u2261fut'' = RATIFIES-deterministic-\u2261\n                    (cong (\u03bb x \u2192 record\n                                   { stakeDistrs = mkStakeDistrs (Snapshots.mark x) _ _ _ _ _\n                                   ; currentEpoch = _\n                                   ; dreps = _\n                                   ; ccHotKeys = _\n                                   ; treasury = _\n                                   }) ss'\u2261ss'')\n                                   refl refl p\u2082 p\u2082'\n\n      prs'\u2261prs'' : \u27e6 utxoSt''\u2081 , acnt'\u2081 , dState'\u2081 , pState'\u2081 \u27e7\u1d56 \u2261\n                   \u27e6 utxoSt''\u2082 , acnt'\u2082 , dState'\u2082 , pState'\u2082 \u27e7\n      prs'\u2261prs'' = POOLREAP-deterministic prs p\u2083 p\u2083'\n\n  EPOCH-complete : \u2200 eps' \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps' \u2192 proj\u2081 EPOCH-total \u2261 eps'\n  EPOCH-complete eps' p = EPOCH-deterministic (proj\u2081 EPOCH-total) eps' (proj\u2082 EPOCH-total) p\n\n  abstract\n    EPOCH-total' : \u2203[ eps' ] _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n    EPOCH-total' = EPOCH-total\n\n    EPOCH-complete' : \u2200 eps' \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps' \u2192 proj\u2081 EPOCH-total' \u2261 eps'\n    EPOCH-complete' = EPOCH-complete\n\ninstance\n  Computational-EPOCH : Computational _\u22a2_\u21c0\u2987_,EPOCH\u2988_ \u22a5\n  Computational-EPOCH .computeProof \u0393 s sig = success EPOCH-total'\n  Computational-EPOCH .completeness \u0393 s sig s' h = cong success (EPOCH-complete' s' h)\n\nmodule _ {e : Epoch} where\n\n  NEWEPOCH-total : \u2200 nes'' \u2192 \u2203[ nes' ] _ \u22a2 nes'' \u21c0\u2987 e ,NEWEPOCH\u2988 nes'\n  NEWEPOCH-total nes with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | inspect NewEpochState.ru nes\n  ... | yes p | just ru | PE.[ refl ] =  \u27e6 e , _ , _ , EPOCH-total' .proj\u2081 , nothing , _ \u27e7\n                                      , NEWEPOCH-New (p , EPOCH-total' .proj\u2082)\n  ... | yes p | nothing | PE.[ refl ] = \u27e6 e , _ , _ , proj\u2081 EPOCH-total' , nothing , _ \u27e7\n                                      , NEWEPOCH-No-Reward-Update (p , EPOCH-total' .proj\u2082)\n  ... | no \u00acp | _ | _ = -, NEWEPOCH-Not-New \u00acp\n\n  NEWEPOCH-complete : \u2200 nes nes' \u2192 _ \u22a2 nes \u21c0\u2987 e ,NEWEPOCH\u2988 nes' \u2192 proj\u2081 (NEWEPOCH-total nes) \u2261 nes'\n  -- NEWEPOCH-complete nes nes' h with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | h\n  NEWEPOCH-complete nes nes' h with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | inspect NewEpochState.ru nes | h\n  ... | yes p | just ru | PE.[ refl ] | NEWEPOCH-New (x , x\u2081) rewrite EPOCH-complete' _ x\u2081 = refl\n  ... | yes p | ru | PE.[ refl ] | NEWEPOCH-Not-New x = \u22a5-elim $ x p\n  ... | yes p | nothing | PE.[ refl ] | NEWEPOCH-No-Reward-Update (x , x\u2081) rewrite EPOCH-complete' _ x\u2081 = refl\n  ... | no \u00acp | ru | PE.[ refl ] | NEWEPOCH-New (x , x\u2081)  = \u22a5-elim $ \u00acp x\n  ... | no \u00acp | ru | PE.[ refl ] | NEWEPOCH-Not-New x = refl\n  ... | no \u00acp | nothing | PE.[ refl ] | NEWEPOCH-No-Reward-Update (x , x\u2081) = \u22a5-elim $ \u00acp x\n\ninstance\n  Computational-NEWEPOCH : Computational _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_ \u22a5\n  Computational-NEWEPOCH .computeProof \u0393 s sig = success (NEWEPOCH-total _)\n  Computational-NEWEPOCH .completeness \u0393 s sig s' h = cong success (NEWEPOCH-complete _ s' h)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Epoch.Properties.ConstRwds.html","title":"ConstRwds","text":"<p>Claim (The <code>NEWEPOCH</code> rule leaves rewards unchanged).</p> <p>Informally.</p> <p>Rewards are left unchanged by the <code>NEWEPOCH</code> rule. That is, if <code>es</code> and <code>es'</code> are two <code>NewEpochState</code>s such that <code>es</code> <code>\u21c0\u2987</code> <code>e</code> <code>,NEWEPOCH\u2988</code> <code>es'</code>, then the rewards of <code>es</code> and <code>es'</code> are equal.</p> <p>Formally.</p> <pre><code>dom-rwds-const : {e : Epoch} (es es' : NewEpochState)\n  \u2192 _ \u22a2 es \u21c0\u2987 e ,NEWEPOCH\u2988 es' \u2192 Type\n\ndom-rwds-const es es' step = dom (RewardsOf es) \u2261 dom (RewardsOf es')\n</code></pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Epoch.Properties.GovDepsMatch.html","title":"GovDepsMatch","text":"<p> Lemma (<code>govDepsMatch</code> is invariant of <code>EPOCH</code> rule).</p> <p>Informally.</p> <p>Let <code>eps</code>, <code>eps'</code> : <code>EpochState</code> be two epoch states and let <code>e</code> : <code>Epoch</code> be an epoch. Recall, <code>LStateOf</code> <code>eps</code> gives the ledger state of <code>eps</code>. If <code>eps</code> <code>\u21c0\u2987</code> <code>e</code> <code>,EPOCH\u2988</code> <code>eps'</code>, then (under a certain special condition) <code>govDepsMatch</code> (<code>LStateOf</code> <code>eps</code>) implies <code>govDepsMatch</code> (<code>LStateOf</code> <code>eps'</code>).</p> <p>The special condition under which the property holds is the same as the one in Chain.Properties.GovDepsMatch: let <code>removed'</code> be the union of the governance actions in the <code>removed</code> field of the ratify state of <code>eps</code> and the orphaned governance actions in the <code>GovState</code> of <code>eps</code>.</p> <p>For the formal statement of the lemma,</p> <ul> <li> <p>let \\(\ud835\udca2\\) be the set \\(\\{\\)<code>GovActionDeposit</code> <code>id</code> : <code>id</code> \\(\u2208\\) <code>proj\u2081</code> <code>removed'</code>\\(\\}\\), and</p> </li> <li> <p>assume \\(\ud835\udca2\\) is a subset of the set of deposits of (the governance state of) <code>eps</code>.</p> </li> </ul> <p>Formally.</p> <pre><code>  EPOCH-govDepsMatch :  {eps' : EpochState} {e : Epoch}\n    \u2192 map (GovActionDeposit \u2218 proj\u2081) removed' \u2286 dom (DepositsOf eps)\n    \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n    \u2192 govDepsMatch (LStateOf eps) \u2192 govDepsMatch (LStateOf eps')\n</code></pre> <p>Proof.</p> <pre><code>  EPOCH-govDepsMatch {eps'} {e} ratify-removed (EPOCH (x , _ , POOLREAP)) =\n      poolReapMatch \u2218 ratifiesSnapMatch\n    where\n\n    -- the combinator used in the EPOCH rule\n    \u0394\u03a0 : \u2119 DepositPurpose\n    \u0394\u03a0 = map (proj\u2081 \u2218 proj\u2082) removedGovActions\n\n    -- a simpler combinator that suffices here;\n    \u0394\u03a0' : \u2119 DepositPurpose\n    \u0394\u03a0' = map (GovActionDeposit \u2218 proj\u2081) removed'\n    -- Below we prove \u0394\u03a0 and \u0394\u03a0' are essentially equivalent.\n\n    P : GovActionID \u00d7 GovActionState \u2192 Type\n    P = \u03bb u \u2192 proj\u2081 u \u2209 map proj\u2081 removed'\n\n    P? : Decidable P\n    P? = \u03bb u \u2192 \u00bf P u \u00bf\n\n    utxoDeps : Deposits\n    utxoDeps = UTxOState.deposits (LState.utxoSt epsLState)\n\n    -- utxo deposits restricted to new form of set used in EPOCH rule\n    utxoDeps' : Deposits\n    utxoDeps' = utxoDeps \u2223 \u0394\u03a0' \u1d9c\n\n    \u0394\u03a0'\u2261\u0394\u03a0 : \u0394\u03a0' \u2261\u1d49 \u0394\u03a0\n    \u0394\u03a0'\u2261\u0394\u03a0 = \u0394\u03a0'\u2286\u0394\u03a0 , \u0394\u03a0\u2286\u0394\u03a0'\n      where\n      \u0394\u03a0'\u2286\u0394\u03a0 : \u0394\u03a0' \u2286 \u0394\u03a0\n      \u0394\u03a0'\u2286\u0394\u03a0 {a} x with from \u2208-map x\n      ... | (gaid , gast) , refl , gaidgast\u2208rem with from \u2208-map (ratify-removed x)\n      ... | (dp , c) , refl , dpc\u2208utxoDeps = let gadc = (GovActionDeposit gaid , c) in\n        to \u2208-map ((returnAddr {txs} gast , gadc)\n                 , refl\n                 , to \u2208-concatMap\u02e2 ((gaid , gast)\n                                   , gaidgast\u2208rem\n                                   , to \u2208-map (gadc , refl , res-singleton\u207a {m = utxoDeps} dpc\u2208utxoDeps)))\n      \u0394\u03a0\u2286\u0394\u03a0' : \u0394\u03a0 \u2286 \u0394\u03a0'\n      \u0394\u03a0\u2286\u0394\u03a0' {a} x with from \u2208-map x\n      ... | (rwa , dp , c) , refl , rwa-dp-c\u2208 with (from \u2208-concatMap\u02e2 rwa-dp-c\u2208)\n      ... | (gaid , gast) , gaid-gast-\u2208-removed , rwa-dp-c-\u2208-map with (from \u2208-map rwa-dp-c-\u2208-map)\n      ... | (_ , _) , refl , q\u2208 =\n        to \u2208-map ((gaid , gast)\n                 , proj\u2081 (\u00d7-\u2261,\u2261\u2190\u2261 (proj\u2082 (res-singleton'' {m = utxoDeps} q\u2208)))\n                 , gaid-gast-\u2208-removed)\n\n    map-filter-decomp : \u2200 a \u2192 (a \u2209 \u0394\u03a0' \u00d7 a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) govSt)\n                               \u21d4 (a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081)(filter P? govSt))\n    map-filter-decomp a = mk\u21d4 i (\u03bb h \u2192 ii h , iii h)\n      where\n      i : ((a \u2209 \u0394\u03a0') \u00d7 (a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) govSt))\n          \u2192 a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt)\n      i (a\u2209\u0394\u03a0' , a\u2208) with Inverse.from (map-\u2208\u2194 (GovActionDeposit \u2218 proj\u2081)) a\u2208\n      ... | b , b\u2208 , refl = Inverse.to (map-\u2208\u2194 (GovActionDeposit \u2218 proj\u2081))\n                                       (b , \u2208-filter\u207a P? b\u2208 (a\u2209\u0394\u03a0' \u2218 \u2208-map\u207a-\u2218) , refl)\n\n      ii : a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt) \u2192 a \u2209 \u0394\u03a0'\n      ii a\u2208 a\u2208\u0394\u03a0' with from (\u2208\u02e1-map-filter {l = govSt} {P? = P?}) a\u2208\n      ... | _ , _ , refl , Pb with \u2208-map\u207b' a\u2208\u0394\u03a0'\n      ... | q , refl , q\u2208rem = Pb (to \u2208-map (q , refl , q\u2208rem))\n\n      iii : a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt)\n            \u2192 a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) govSt\n      iii a\u2208 with from (\u2208\u02e1-map-filter {l = govSt} {P? = P?}) a\u2208\n      ... | b , b\u2208 , refl , Pb = Inverse.to (map-\u2208\u2194 (GovActionDeposit \u2218 proj\u2081)) (b , (b\u2208 , refl))\n\n\n    main-invariance-lemma :\n        filter\u02e2 isGADeposit (dom utxoDeps) \u2261\u1d49' fromList (map' (GovActionDeposit \u2218 proj\u2081) govSt)\n        ---------------------------------------------------------------------------------------------------\n      \u2192 filter\u02e2 isGADeposit (dom utxoDeps') \u2261\u1d49' fromList (map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt))\n\n    main-invariance-lemma HYP a = let open R.EquationalReasoning in\n      a \u2208 filter\u02e2 isGADeposit (dom utxoDeps')                          \u223c\u27e8 R.SK-sym \u2208-filter \u27e9\n      (isGADeposit a \u00d7 a \u2208 dom utxoDeps')                              \u223c\u27e8 R.K-refl \u00d7-cong \u2208-res\u1d9c-dom \u27e9\n      (isGADeposit a \u00d7 a \u2209 \u0394\u03a0' \u00d7 \u2203[ q ] (a , q) \u2208 utxoDeps)             \u223c\u27e8 \u00d7-\u21d4-swap \u27e9\n      (a \u2209 \u0394\u03a0' \u00d7 isGADeposit a \u00d7 \u2203[ q ] (a , q) \u2208 utxoDeps)             \u223c\u27e8 R.K-refl \u00d7-cong (R.K-refl \u00d7-cong dom\u2208)\u27e9\n      (a \u2209 \u0394\u03a0' \u00d7 isGADeposit a \u00d7 a \u2208 dom utxoDeps)                      \u223c\u27e8 R.K-refl \u00d7-cong \u2208-filter \u27e9\n      (a \u2209 \u0394\u03a0' \u00d7 a \u2208 filter\u02e2 isGADeposit (dom utxoDeps))                \u223c\u27e8 R.K-refl \u00d7-cong (HYP a) \u27e9\n      (a \u2209 \u0394\u03a0' \u00d7 a \u2208 fromList (map' (GovActionDeposit \u2218 proj\u2081) govSt))  \u223c\u27e8 R.K-refl \u00d7-cong (R.SK-sym \u2208-fromList)\u27e9\n      (a \u2209 \u0394\u03a0' \u00d7 a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) govSt)            \u223c\u27e8 map-filter-decomp a \u27e9\n      a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt)           \u223c\u27e8 \u2208-fromList \u27e9\n      a \u2208 fromList (map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt)) \u220e\n\n    u0 = EPOCH-updates0 (RatifyStateOf eps) (LStateOf eps)\n\n    ls\u2081 = record (LStateOf eps') { utxoSt = EPOCH-Updates0.utxoSt' u0 }\n\n    open LState\n    open CertState\n\n    retiredDeposits : \u2119 DepositPurpose\n    retiredDeposits = map\u02e2 PoolDeposit ((PStateOf eps) .retiring \u207b\u00b9 e)\n\n    d\u2261PoolDepositA\n      : (d : DepositPurpose)\n      \u2192 d \u2208 dom (DepositsOf ls\u2081 \u2223 retiredDeposits)\n      \u2192 \u2203[ kh ] d \u2261 PoolDeposit kh\n    d\u2261PoolDepositA d d\u2208res =\n      Product.map\u2082 proj\u2081 $\n        \u2208-map\u207b' $       -- (\u2203[ a ] d \u2261 PoolDeposit a \u00d7 a \u2208 _)\n         res-dom d\u2208res  -- d \u2208 retiredDeposits\n      where import Data.Product.Base as Product using (map\u2082)\n\n    ratifiesSnapMatch : govDepsMatch (LStateOf eps) \u2192 govDepsMatch ls\u2081\n    ratifiesSnapMatch =\n       \u2261\u1d49.trans (filter-cong $ dom-cong (res-comp-cong $ \u2261\u1d49.sym \u0394\u03a0'\u2261\u0394\u03a0))\n       \u2218 from \u2261\u1d49\u21d4\u2261\u1d49' \u2218 main-invariance-lemma \u2218 to \u2261\u1d49\u21d4\u2261\u1d49'\n\n    noGADepositIsRetired\n      : (d : DepositPurpose)\n      \u2192 d \u2208 dom (DepositsOf ls\u2081 \u2223 retiredDeposits)\n      \u2192 \u00ac isGADeposit d\n    noGADepositIsRetired d d\u2208res dIsGA\n     rewrite (proj\u2082 $ d\u2261PoolDepositA d d\u2208res)\n     with dIsGA\n    ... | ()\n\n    dropRetiredDeposits :\n      filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c)) \u2261\u1d49\n        filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081))\n    dropRetiredDeposits = begin\n      filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c))\n\n        \u2248\u27e8 \u222a-identity\u02e1 _ \u27e8\n\n      \u2205\u02e2 \u222a filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c))\n\n        \u2248\u27e8 \u222a-cong\n             (filter-\u2205 noGADepositIsRetired)\n             (IsEquivalence.refl \u2261\u1d49-isEquivalence)\n         \u27e8\n\n      filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081 \u2223 retiredDeposits))\n      \u222a\n      filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c))\n\n        \u2248\u27e8 filter-hom-\u222a \u27e8\n\n      filter\u02e2 isGADeposit\n        (dom (DepositsOf ls\u2081 \u2223 retiredDeposits)\n         \u222a\n         dom (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c)\n        )\n\n        \u2248\u27e8 filter-cong dom\u222a \u27e8\n\n      filter\u02e2 isGADeposit\n        (dom\n          ((DepositsOf ls\u2081 \u2223 retiredDeposits) \u02e2\n            \u222a\n           (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c) \u02e2\n          )\n        )\n\n        \u2248\u27e8 IsEquivalence.refl \u2261\u1d49-isEquivalence \u27e9\n\n      filter\u02e2 isGADeposit\n        (Rel.dom\n          (((DepositsOf ls\u2081 \u02e2) \u2223\u02b3 retiredDeposits)\n            \u222a\n           ((DepositsOf ls\u2081 \u02e2) \u2223\u02b3 retiredDeposits \u1d9c)\n          )\n        )\n\n        \u2248\u27e8 filter-cong $ dom-cong (res-ex-\u222a dec\u00b9) \u27e9\n\n      filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081))\n      \u220e\n\n      where\n        open SetoidReasoning (\u2261\u1d49-Setoid {A = DepositPurpose})\n        open import Relation.Binary using (IsEquivalence)\n        import Axiom.Set.Rel th as Rel\n\n    poolReapMatch : govDepsMatch ls\u2081 \u2192 govDepsMatch (LStateOf eps')\n    poolReapMatch = \u2261\u1d49.trans dropRetiredDeposits\n</code></pre>"},{"location":"Ledger.Conway.Specification.Epoch.Properties.NoPropSameDReps.html","title":"NoPropSameDReps","text":"<p>Claim (DReps unchanged if no gov proposals).</p> <p>Informally.</p> <p>If <code>es</code> is a <code>NewEpochState</code>, and if the <code>GovState</code> of <code>es</code> contains no governance proposals, then the set of <code>activeDReps</code> of <code>es</code> in <code>Epoch</code> <code>e</code> is equal to the set of <code>activeDReps</code> of <code>es</code> in the next epoch.</p> <p>Formally.</p> <pre><code>prop\u2261\u2205\u21d2activeDReps-const : Epoch \u2192 NewEpochState \u2192 Type\nprop\u2261\u2205\u21d2activeDReps-const e es =\n  GovStateOf es \u2261 [] \u2192 activeDReps e es \u2261\u1d49 activeDReps (suc\u1d49 e) es\n</code></pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Epoch.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Epoch.Properties where\n\nopen import Ledger.Conway.Specification.Epoch.Properties.Computational\nopen import Ledger.Conway.Specification.Epoch.Properties.ConstRwds\nopen import Ledger.Conway.Specification.Epoch.Properties.GovDepsMatch\nopen import Ledger.Conway.Specification.Epoch.Properties.NoPropSameDReps\n</code></pre>"},{"location":"Ledger.Conway.Specification.Epoch.html","title":"Epoch Boundary","text":"<p>This module introduces the epoch boundary transition system and the related reward calculation.</p>"},{"location":"Ledger.Conway.Specification.Epoch.html#epoch-and-newepoch-transition-system-types","title":"EPOCH and NEWEPOCH Transition System Types","text":"<pre><code>record EpochState : Type where\n</code></pre> <pre><code>  field\n    acnt       : Acnt\n    ss         : Snapshots\n    ls         : LState\n    es         : EnactState\n    fut        : RatifyState\n</code></pre> <pre><code>PoolDelegatedStake : Type\nPoolDelegatedStake = KeyHash \u21c0 Coin\n\nrecord NewEpochState : Type where\n  field\n    lastEpoch   : Epoch\n    bprev       : BlocksMade\n    bcur        : BlocksMade\n    epochState  : EpochState\n    ru          : Maybe RewardUpdate\n    pd          : PoolDelegatedStake\n</code></pre> Differences with the Shelley Specification <p>The formal specification utilizes the type <code>PoolDelegatedStake</code> in lieu of the derived type <code>PoolDistr</code> (Figure 5, Shelley specification CVG19). The latter can be computed from the former by divinding the associated <code>Coin</code> to each <code>KeyHash</code> by the total stake in the map.</p> <p>In addition, the formal specification omits the VRF key hashes in the codomain of <code>PoolDelegatedStake</code> as they are not implemented at the moment.</p>"},{"location":"Ledger.Conway.Specification.Epoch.html#rewardupdate","title":"RewardUpdate","text":""},{"location":"Ledger.Conway.Specification.Epoch.html#computing-rewardupdate","title":"Computing RewardUpdate","text":"<p>This section defines the function <code>createRUpd</code> which creates a <code>RewardUpdate</code>, i.e. the net flow of Ada due to paying out rewards after an epoch:</p> <pre><code>  createRUpd : \u2115 \u2192 BlocksMade \u2192 EpochState \u2192 Coin \u2192 RewardUpdate\n  createRUpd slotsPerEpoch b es total =\n    record  { \u0394t = \u0394t\u2081\n            ; \u0394r = 0 - \u0394r\u2081 + \u0394r\u2082\n            ; \u0394f = 0 - pos feeSS\n            ; rs = rs\n</code></pre> <pre><code>            }\n    where\n      prevPp : PParams\n      prevPp = PParamsOf es\n\n      reserves : Reserves\n      reserves = ReservesOf es\n\n      pstakego : Snapshot\n      pstakego = (SnapshotsOf es) .Snapshots.go\n\n      feeSS : Fees\n      feeSS = FeesOf (SnapshotsOf es)\n\n      stake : Stake\n      stake = StakeOf pstakego\n\n      delegs : StakeDelegs\n      delegs = StakeDelegsOf pstakego\n\n      poolParams : Pools\n      poolParams = PoolsOf pstakego\n\n      blocksMade : \u2115\n      blocksMade = \u2211[ m \u2190 b ] m\n\n      \u03c1 \u03b7 \u03c4 : \u211a\n      \u03c1 = fromUnitInterval (prevPp .PParams.monetaryExpansion)\n      \u03b7 = from\u2115 blocksMade \u00f7\u2080 (from\u2115 slotsPerEpoch * ActiveSlotCoeff)\n      \u03c4 = fromUnitInterval (prevPp .PParams.treasuryCut)\n\n      \u0394r\u2081 rewardPot \u0394t\u2081 R : \u2124\n      \u0394r\u2081 = floor (1 \u2293 \u03b7 * \u03c1 * from\u2115 reserves)\n      rewardPot = pos feeSS + \u0394r\u2081\n      \u0394t\u2081 = floor (from\u2124 rewardPot * \u03c4)\n      R = rewardPot - \u0394t\u2081\n\n      circulation : Coin\n      circulation = total - reserves\n\n      rs : Rewards\n      rs = reward prevPp b (posPart R) poolParams stake delegs circulation\n\n      \u0394r\u2082 : \u2124\n      \u0394r\u2082 = R - pos (\u2211[ c \u2190 rs ] c)\n</code></pre> <p>Relevant quantities are:</p> <ul> <li> <p><code>prevPp</code>: Previous protocol parameters, which   correspond to the parameters during the epoch for which we are   creating rewards.</p> </li> <li> <p><code>ActiveSlotCoeff</code>: Global constant, equal to the   probability that a party holding all the stake will be selected to be   a leader for given slot. Equals \\(1/20\\) during the Shelley era on the   Cardano Mainnet.</p> </li> <li> <p><code>\u0394r\u2081</code>: Ada taken out of the reserves for paying   rewards, as determined by the <code>monetaryExpansion</code> protocol   parameter.</p> </li> <li> <p><code>rewardPot</code>: Total amount of coin available for rewards   this epoch, as described in Team18.</p> </li> <li> <p><code>feeSS</code>: The fee pot which, together with the reserves,   funds the <code>rewardPot</code>. We use the fee pot that   accumulated during the epoch for which we now compute block production   rewards. Note that fees are not explicitly removed from any account:   the fees come from transactions paying them and are accounted for   whenever transactions are processed.</p> </li> <li> <p><code>\u0394t\u2081</code>: The proportion of the reward pot that will move   to the treasury, as determined by the <code>treasuryCut</code>   protocol parameter. The remaining pot is called the   <code>R</code>, just as in Team18.</p> </li> <li> <p><code>pstakego</code>: Stake distribution used for calculating the   rewards. This is the oldest stake distribution snapshot, labeled   <code>go</code>.</p> </li> <li> <p><code>rs</code>: The rewards, as calculated by the function   <code>reward</code>.</p> </li> <li> <p><code>\u0394r\u2082</code>: The difference between the maximal amount of   rewards that could have been paid out if pools had been optimal, and   the actual rewards paid out. This difference is returned to the   reserves.</p> </li> <li> <p><code>\u00f7\u2080</code>: Division operator that returns zero when the   denominator is zero.</p> </li> </ul>"},{"location":"Ledger.Conway.Specification.Epoch.html#applying-rewardupdate","title":"Applying RewardUpdate","text":"<p>This section defines the function <code>applyRUpd</code>, which applies a <code>RewardUpdate</code> to the <code>EpochState</code>.</p> <pre><code>applyRUpd : RewardUpdate \u2192 EpochState \u2192 EpochState\napplyRUpd rewardUpdate \u27e6 \u27e6 treasury , reserves \u27e7\u1d43\n                       , ss\n                       , \u27e6 \u27e6 utxo , fees , deposits , donations \u27e7\u1d58\n                         , govSt\n                         , \u27e6 \u27e6 voteDelegs , stakeDelegs , rewards \u27e7\u1d48 , pState , gState \u27e7\u1d9c\u02e2 \u27e7\u02e1\n                       , es\n                       , fut\n                       \u27e7\u1d49' = \u27e6 \u27e6 posPart (pos treasury + \u0394t + pos unregRU')\n                               , posPart (pos reserves + \u0394r) \u27e7\n                             , ss\n                             , \u27e6 \u27e6 utxo , posPart (pos fees + \u0394f) , deposits , donations \u27e7\n                               , govSt\n                               , \u27e6 \u27e6 voteDelegs , stakeDelegs , rewards \u222a\u207a regRU \u27e7 , pState , gState \u27e7 \u27e7\n                             , es\n                             , fut \u27e7\n  where\n    open RewardUpdate rewardUpdate using (\u0394t; \u0394r; \u0394f; rs)\n    regRU     = rs \u2223 dom rewards\n    unregRU   = rs \u2223 dom rewards \u1d9c\n    unregRU'  = \u2211[ x \u2190 unregRU ] x\n</code></pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#stake-distributions","title":"Stake Distributions","text":"<p>This section defines the functions <code>calculatePoolDelegatedState</code>, <code>calculateVDelegDelegatedStake</code>, and <code>mkStakeDistrs</code>, which calculates stake distributions for voting purposes.</p> <pre><code>  calculatePoolDelegatedStake\n    : Snapshot\n    \u2192 PoolDelegatedStake\n  calculatePoolDelegatedStake ss =\n      -- Shelley spec: the output map must contain keys appearing in both\n      -- sd and the pool parameters.\n      sd \u2223 dom (PoolsOf ss)\n    where\n      -- stake credentials delegating to each pool\n      stakeCredentialsPerPool : Rel KeyHash Credential\n      stakeCredentialsPerPool = (StakeDelegsOf ss \u02e2) \u207b\u00b9\u02b3\n\n      -- delegated stake per pool\n      sd : KeyHash \u21c0 Coin\n      sd = aggregate\u208a ((stakeCredentialsPerPool \u2218\u02b3 (StakeOf ss \u02e2)) \u1da0\u02e2)\n</code></pre> <p>The function <code>calculatePoolDelegatedState</code> calculates the delegated stake to SPO{.AgdaFunction}s. This function is used both in the <code>EPOCH</code> rule (via <code>calculatePoolDelegatedStateForVoting</code>, see below) and in the <code>NEWEPOCH</code> rule.</p> <pre><code>  stakeFromGADeposits\n    : GovState\n    \u2192 UTxOState\n    \u2192 Stake\n  stakeFromGADeposits govSt utxoSt = aggregateBy\n     (map\u02e2 (\u03bb (gaid , addr) \u2192 (gaid , addr) , stake addr) govSt')\n     (mapFromPartialFun (\u03bb (gaid , _) \u2192 lookup\u1d50? deposits (GovActionDeposit gaid)) govSt')\n     where\n       open UTxOState utxoSt\n\n       govSt' : \u2119 (GovActionID \u00d7 RwdAddr)\n       govSt' = map\u02e2 (map\u2082 returnAddr) (fromList govSt)\n</code></pre> <p>The function <code>stakeFromGADeposits</code> computes the stake pertaining to governance action deposits. It returns a map which, for each governance action, maps its <code>returnAddr</code> (as a staking credential) to the deposit.</p> <pre><code>  calculateVDelegDelegatedStake\n    : Epoch\n    \u2192 UTxOState\n    \u2192 GovState\n    \u2192 GState\n    \u2192 DState\n    \u2192 VDeleg \u21c0 Coin\n  calculateVDelegDelegatedStake currentEpoch utxoSt govSt gState dState\n    = aggregate\u208a (((activeVoteDelegs \u02e2) \u207b\u00b9\u02b3\n                  \u2218\u02b3 (stakePerCredential \u222a\u207a stakeFromGADeposits govSt utxoSt) \u02e2) \u1da0\u02e2)\n    where\n      open UTxOState utxoSt\n      open DState dState\n      open GState gState\n\n      -- active DReps\n      activeDReps : \u2119 Credential\n      activeDReps = dom (filter\u1d50 (\u03bb (_ , e) \u2192 currentEpoch \u2264 e) dreps)\n\n      -- active vote delegations\n      activeVoteDelegs : VoteDelegs\n      activeVoteDelegs = voteDelegs \u2223^ ((map\u02e2 vDelegCredential activeDReps)\n                                        \u222a \u2774 vDelegNoConfidence \u2775 \u222a \u2774 vDelegAbstain \u2775)\n\n      -- stake per delegated credential\n      stakePerCredential : Stake\n      stakePerCredential = mapFromFun (\u03bb c \u2192 cbalance (utxo \u2223^' \u03bb txout \u2192 getStakeCred txout \u2261 just c))\n                                      (dom activeVoteDelegs)\n</code></pre> <pre><code>  calculatePoolDelegatedStakeForVoting\n    : Snapshot\n    \u2192 UTxOState\n    \u2192 GovState\n    \u2192 GState\n    \u2192 DState\n    \u2192 KeyHash \u21c0 Coin\n  calculatePoolDelegatedStakeForVoting ss utxoSt govSt gState dState\n    = calculatePoolDelegatedStake ss \u222a\u207a (stakeFromDeposits \u2223 dom (PoolsOf ss))\n    where\n      stakeFromDeposits : KeyHash \u21c0 Coin\n      stakeFromDeposits = aggregate\u208a (((StakeDelegsOf ss \u02e2) \u207b\u00b9\u02b3\n                                      \u2218\u02b3 (stakeFromGADeposits govSt utxoSt \u02e2)) \u1da0\u02e2)\n</code></pre> <p>The function <code>calculatePoolDelegatedStakeForVoting</code> computes the delegated stake to <code>SPO</code>s that will be used for counting votes. It complements the result of <code>calculatePoolDelegatedStake</code> with the deposits made to governance actions.</p> Erratum <p>CIP-1694 specifies that deposits of governance actions should count towards the stake for voting purposes:</p> <p>The deposit amount will be added to the deposit pot, similar to stake key deposits. It will also be counted towards the stake of the reward address it will be paid back to, to not reduce the submitter's voting power to vote on their own (and competing) actions.</p> <p>While originally intended for <code>DRep</code>s only, the Haskell implementation and the formal specification count deposits on governance actions towards the stake of <code>SPO</code>s as well.</p> <pre><code>  mkStakeDistrs\n    : Snapshot\n    \u2192 Epoch\n    \u2192 UTxOState\n    \u2192 GovState\n    \u2192 GState\n    \u2192 DState\n    \u2192 StakeDistrs\n  mkStakeDistrs ss currentEpoch utxoSt govSt gState dState =\n    \u27e6 calculateVDelegDelegatedStake currentEpoch utxoSt govSt gState dState\n    , calculatePoolDelegatedStakeForVoting ss utxoSt govSt gState dState \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#epoch-transition-system","title":"EPOCH Transition System","text":"<p>The <code>EPOCH</code> transition has a few updates that are encapsulated in the following functions. We need these functions to bring them in scope for some proofs about <code>EPOCH</code>.</p>"},{"location":"Ledger.Conway.Specification.Epoch.html#helper-functions","title":"Helper Functions","text":"<pre><code>getOrphans : EnactState \u2192 GovState \u2192 GovState\ngetOrphans es govSt = proj\u2081 $ iterate step ([] , govSt) (length govSt)\n  where\n    step : GovState \u00d7 GovState \u2192 GovState \u00d7 GovState\n    step (orps , govSt) =\n      let\n        isOrphan? a prev = \u00ac? (hasParent? es govSt a prev)\n        (orps' , govSt') = partition\n          (\u03bb (_ , record {action = a ; prevAction = prev}) \u2192 isOrphan? (a .gaType) prev)\n          govSt\n      in\n        (orps ++ orps' , govSt')\n</code></pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#update-functions","title":"Update Functions","text":"<pre><code>record EPOCH-Updates0 : Type where\n  constructor EPOCHUpdates0\n  field\n    es             : EnactState\n    govSt'         : GovState\n    payout         : Withdrawals\n    gState'        : GState\n    utxoSt'        : UTxOState\n    totWithdrawals : Coin\n\nEPOCH-updates0 : RatifyState \u2192 LState \u2192 EPOCH-Updates0\nEPOCH-updates0 fut ls =\n    EPOCHUpdates0 es govSt' payout gState' utxoSt' totWithdrawals\n  where\n    open LState ls public\n    open CertState certState using (gState) public\n    open RatifyState fut renaming (es to esW)\n\n    es : EnactState\n    es = record esW { withdrawals = \u2205 }\n\n    tmpGovSt : GovState\n    tmpGovSt = filter (\u03bb x \u2192 proj\u2081 x \u2209 map\u02e2 proj\u2081 removed) govSt\n\n    orphans : \u2119 (GovActionID \u00d7 GovActionState)\n    orphans  = fromList (getOrphans es tmpGovSt)\n\n    removed' : \u2119 (GovActionID \u00d7 GovActionState)\n    removed' = removed \u222a orphans\n\n    govSt' : GovState\n    govSt' = filter (\u03bb x \u2192 proj\u2081 x \u2209 map\u02e2 proj\u2081 removed') govSt\n\n    removedGovActions : \u2119 (RwdAddr \u00d7 DepositPurpose \u00d7 Coin)\n    removedGovActions =\n      flip concatMap\u02e2 removed' \u03bb (gaid , gaSt) \u2192\n        map\u02e2\n          (returnAddr gaSt ,_)\n          ((DepositsOf utxoSt \u2223 \u2774 GovActionDeposit gaid \u2775) \u02e2)\n\n    govActionReturns : RwdAddr \u21c0 Coin\n    govActionReturns =\n      aggregate\u208a (map\u02e2 (\u03bb (a , _ , d) \u2192 a , d) removedGovActions \u1da0\u02e2)\n\n    payout : RwdAddr \u21c0 Coin\n    payout = govActionReturns \u222a\u207a WithdrawalsOf esW\n\n    gState' : GState\n    gState' =\n      \u27e6 (if null govSt' then mapValues (1 +_) (DRepsOf gState) else DRepsOf gState)\n      , CCHotKeysOf gState \u2223 ccCreds (EnactState.cc es)\n      \u27e7\n\n    utxoSt' : UTxOState\n    utxoSt' = record utxoSt\n      { deposits = DepositsOf utxoSt \u2223 map\u02e2 (proj\u2081 \u2218 proj\u2082) removedGovActions \u1d9c\n      ; donations = 0\n      }\n\n    totWithdrawals : Coin\n    totWithdrawals = \u2211[ x \u2190 WithdrawalsOf esW ] x\n\nrecord EPOCH-Updates : Type where\n  constructor EPOCHUpdates\n  field\n    es             : EnactState\n    govSt'         : GovState\n    dState''       : DState\n    gState'        : GState\n    utxoSt'        : UTxOState\n    acnt''         : Acnt\n\nEPOCH-updates\n  : RatifyState \u2192 LState \u2192 DState \u2192 Acnt \u2192 EPOCH-Updates\nEPOCH-updates fut ls dState' acnt' =\n    EPOCHUpdates (u0 .es) (u0 .govSt') dState'' (u0 .gState') (u0 .utxoSt') acnt''\n  where\n    open LState\n    open EPOCH-Updates0\n\n    u0 = EPOCH-updates0 fut ls\n\n    refunds : Credential \u21c0 Coin\n    refunds = pullbackMap (u0 .payout) toRwdAddr (dom (RewardsOf dState'))\n\n    dState'' : DState\n    dState'' = record dState' { rewards = RewardsOf dState' \u222a\u207a refunds }\n\n    unclaimed : Coin\n    unclaimed = getCoin (u0 .payout) - getCoin refunds\n\n    acnt'' : Acnt\n    acnt'' = record acnt'\n      { treasury =\n          TreasuryOf acnt' \u2238 u0 .totWithdrawals + DonationsOf ls + unclaimed\n      }\n</code></pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#transition-rule","title":"Transition Rule","text":"<p>This section defines the <code>EPOCH</code> transition rule. </p> <p>In Conway, the <code>EPOCH</code> rule invokes <code>RATIFIES</code>, and carries out the following tasks:</p> <ul> <li> <p>Payout all the enacted treasury withdrawals.</p> </li> <li> <p>Remove expired and enacted governance actions, and refund deposits.</p> </li> <li> <p>If <code>govSt\u2019</code> is empty, increment the activity counter for   <code>DRep</code>s.</p> </li> <li> <p>Remove all hot keys from the constitutional committee delegation map   that do not belong to currently elected members.</p> </li> <li> <p>Apply the resulting enact state from the previous epoch boundary   <code>fut</code> and store the resulting enact state   <code>fut\u2019</code>.</p> </li> </ul> <p><pre><code>data _\u22a2_\u21c0\u2987_,EPOCH\u2988_ : \u22a4 \u2192 EpochState \u2192 Epoch \u2192 EpochState \u2192 Type where\n</code></pre> <pre><code>  EPOCH :\n</code></pre></p> <pre><code>    let\n      EPOCHUpdates es govSt' dState'' gState' utxoSt' acnt'' =\n        EPOCH-updates fut ls dState' acnt'\n\n      stakeDistrs : StakeDistrs\n      stakeDistrs = mkStakeDistrs (Snapshots.mark ss') e utxoSt'\n                                  govSt' (GStateOf ls) (DStateOf ls)\n\n      \u0393 : RatifyEnv\n      \u0393 = \u27e6 stakeDistrs , e , DRepsOf ls , CCHotKeysOf ls , TreasuryOf acnt , PoolsOf ls , VoteDelegsOf ls \u27e7\n\n    in\n        ls \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n      \u2219 \u0393  \u22a2 \u27e6 es , \u2205 , false \u27e7 \u21c0\u2987 govSt' ,RATIFIES\u2988 fut'\n      \u2219 _  \u22a2 \u27e6 utxoSt' , acnt , DStateOf ls , PStateOf ls \u27e7 \u21c0\u2987 e ,POOLREAP\u2988 \u27e6 utxoSt'' , acnt' , dState' , pState' \u27e7\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 \u27e6 acnt , ss , ls , es\u2080 , fut \u27e7 \u21c0\u2987 e ,EPOCH\u2988 \u27e6 acnt'' , ss' , \u27e6 utxoSt'' , govSt' , \u27e6 dState'' , pState' , gState' \u27e7\u1d9c\u02e2 \u27e7 , es , fut' \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#newepoch-transition-system","title":"NEWEPOCH Transition System","text":"<p>This section defines the <code>NEWEPOCH</code> transition system.</p> <pre><code>data _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_ : \u22a4 \u2192 NewEpochState \u2192 Epoch \u2192 NewEpochState \u2192 Type where\n\n  NEWEPOCH-New : \u2200 {bprev bcur : BlocksMade} \u2192\n    let\n      eps' = applyRUpd ru eps\n      ss   = EpochState.ss eps''\n      pd'  = calculatePoolDelegatedStake (Snapshots.set ss)\n    in\n      \u2219 e \u2261 lastEpoch + 1\n      \u2219 _ \u22a2 eps' \u21c0\u2987 e ,EPOCH\u2988 eps''\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 \u27e6 lastEpoch , bprev , bcur , eps , just ru , pd \u27e7 \u21c0\u2987 e ,NEWEPOCH\u2988 \u27e6 e , bcur , \u2205\u1d50  , eps'' , nothing , pd' \u27e7\n\n  NEWEPOCH-Not-New : \u2200 {bprev bcur : BlocksMade} \u2192\n    \u2219 e \u2262 lastEpoch + 1\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 \u27e6 lastEpoch , bprev , bcur , eps , mru , pd \u27e7 \u21c0\u2987 e ,NEWEPOCH\u2988 \u27e6 lastEpoch , bprev , bcur , eps , mru , pd \u27e7\n\n  NEWEPOCH-No-Reward-Update : \u2200 {bprev bcur : BlocksMade} \u2192\n    let\n      ss  = EpochState.ss eps'\n      pd' = calculatePoolDelegatedStake (Snapshots.set ss)\n    in\n      \u2219 e \u2261 lastEpoch + 1\n      \u2219 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 \u27e6 lastEpoch , bprev , bcur , eps , nothing , pd \u27e7 \u21c0\u2987 e ,NEWEPOCH\u2988 \u27e6 e , bcur , \u2205\u1d50 , eps' , nothing , pd' \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#references","title":"References","text":"<p>[CVG19]  Jared Corduan and Polina Vinogradova and Matthias G\u00fcdemann. A Formal Specification of the Cardano Ledger. 2019.</p> <p>[Team18]  IOHK Formal Methods Team. Design Specification for Delegation and Incentives in Cardano, IOHK Deliverable SL-D1. 2018.</p>"},{"location":"Ledger.Conway.Specification.Fees.html","title":"Fee Calculation","text":"<p>This section is part of the Ledger.Conway.Specification.Fees module of the formal ledger specification where we define the functions used to compute the fees associated with reference scripts.</p> <p>The function <code>scriptsCost</code>, defined in the Calculation of Fees for Reference Scripts section, calculates the fee for reference scripts in a transaction. It takes as input the total size of the reference scripts in bytes---calculated by <code>refScriptsSize</code> (see Functions used in UTxO rules)---and uses a function (<code>scriptsCostAux</code>) that is piece-wise linear in the size, where the linear constant multiple grows with each <code>refScriptCostStride</code> bytes. In addition, <code>scriptsCost</code> depends on the following constants (which are bundled with the protocol parameters; see the Protocol Parameter Declarations section):</p> <ul> <li> <p><code>refScriptCostMultiplier</code>, a rational number, the   growth factor or step multiplier that determines how much the price   per byte increases after each increment;</p> </li> <li> <p><code>refScriptCostStride</code>, an integer, the size in bytes at   which the price per byte grows linearly;</p> </li> <li> <p><code>minFeeRefScriptCoinsPerByte</code>, a rational number, the   base fee or initial price per byte.</p> </li> </ul> <p>For background on this particular choice of fee calculation, see Kuleshevich24.</p>"},{"location":"Ledger.Conway.Specification.Fees.html#sec:calculation-of-fees","title":"Calculation of Fees for Reference Scripts","text":"<pre><code>scriptsCost : (pp : PParams) \u2192 \u2115 \u2192 Coin\nscriptsCost pp scriptSize\n  = scriptsCostAux 0\u211a minFeeRefScriptCoinsPerByte scriptSize\n</code></pre> <pre><code>  where\n    minFeeRefScriptCoinsPerByte = PParams.minFeeRefScriptCoinsPerByte pp\n    refScriptCostMultiplier = PParams.refScriptCostMultiplier pp\n    refScriptCostStride = PParams.refScriptCostStride pp\n    scriptsCostAux : \u211a        -- accumulator\n                   \u2192 \u211a        -- current tier price\n                   \u2192 (n : \u2115)  -- remaining script size\n</code></pre> <pre><code>                   \u2192 Coin\n    scriptsCostAux acl curTierPrice n\n</code></pre> <pre><code>       = case  n \u2264? from\u2115\u207a refScriptCostStride of\n</code></pre> <pre><code>                (yes _)  \u2192 \u2223 floor (acl + (from\u2115 n * curTierPrice)) \u2223\n                (no  p)  \u2192 scriptsCostAux\n                             (acl + (from\u2115 (from\u2115\u207a refScriptCostStride) * curTierPrice))\n                             (refScriptCostMultiplier * curTierPrice)\n                             (n - from\u2115\u207a refScriptCostStride)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Fees.html#references","title":"References","text":"<p>[Kuleshevich24]  Alexey Kuleshevich. Changes to the fee calculation due to Reference Scripts. 2024.</p>"},{"location":"Ledger.Conway.Specification.Gov.Base.html","title":"Base","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Gov.Base where\n\nopen import Prelude using (Type)\nopen import Class.DecEq\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\nopen import Ledger.Conway.Specification.Script.Base\nimport Ledger.Conway.Specification.PParams\n\nrecord GovStructure : Type\u2081 where\n  field TxId DocHash : Type\n        \u2983 DecEq-TxId \u2984 : DecEq TxId\n\n  field cryptoStructure : _\n  open CryptoStructure cryptoStructure public\n\n  field epochStructure : _\n  open EpochStructure epochStructure public\n\n  field scriptStructure : ScriptStructure cryptoStructure epochStructure\n  open ScriptStructure scriptStructure public\n\n  open Ledger.Conway.Specification.PParams cryptoStructure epochStructure scriptStructure public\n\n  field govParams : GovParams\n  open GovParams govParams public\n\n  field globalConstants : _\n  open GlobalConstants globalConstants public\n\n  open import Ledger.Core.Specification.Address Network KeyHash ScriptHash public\n</code></pre>"},{"location":"Ledger.Conway.Specification.Gov.Properties.ChangePPGroup.html","title":"ChangePPGroup","text":"<p>Claim (PParam updates have non-empty groups).</p> <p>Informally.</p> <p>Let <code>p</code> : <code>GovProposal</code> be a governance proposal and suppose the <code>GovActionType</code> of <code>p</code> <code>.action</code> is <code>ChangePParams</code>. If the data field of <code>p</code>\u2014that is <code>pu</code> = <code>p</code> <code>.action</code> <code>.gaData</code>\u2014is denoted by <code>pu</code> (for \"parameter update\"), then the set <code>updateGroups</code> <code>pu</code> is nonempty.</p> <p>Formally.</p> <pre><code>ChangePPHasGroup : {tx : Tx} {p : GovProposal} (pu : PParamsUpdate)\n  \u2192 p \u2208 Tx.body tx \u2192 p .GovProposal.action \u2261 \u27e6 ChangePParams , pu \u27e7\u1d4d\u1d43\n  \u2192 Type\nChangePPHasGroup pu _ _ = updateGroups pu \u2262 \u2205\n</code></pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Gov.Properties.Computational.html","title":"Computational","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Gov.Base\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nmodule Ledger.Conway.Specification.Gov.Properties.Computational\n  (txs : _) (open TransactionStructure txs using (govStructure))\n  (open GovStructure govStructure hiding (epoch)) where\n\nopen import Ledger.Prelude hiding (Any; any?)\n\nopen import Axiom.Set.Properties\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Gov.Actions govStructure hiding (yes; no)\nopen import Ledger.Conway.Specification.Ratify txs\n\nimport Data.List.Membership.Propositional as P\nopen import Data.List.Membership.Propositional.Properties\nopen import Data.List.Relation.Unary.All using (all?; All)\nopen import Data.List.Relation.Unary.Any hiding (map)\nopen import Data.List.Relation.Unary.Unique.Propositional\nopen import Data.Maybe.Properties\nopen import Relation.Binary using (IsEquivalence)\n\nopen import Tactic.Defaults\nopen import stdlib-meta.Tactic.GenError\n\nopen Equivalence\nopen GovActionState\nopen Inverse\n\nlookupActionId : (pparams : PParams) (role : GovRole) (aid : GovActionID) (epoch : Epoch) (s : GovState) \u2192\n                 Dec (Any (\u03bb (aid' , ast) \u2192 aid \u2261 aid' \u00d7 canVote pparams (action ast) role \u00d7 \u00ac (expired epoch ast)) s)\nlookupActionId pparams role aid epoch =\n  let instance _ = \u03bb {e ga} \u2192 \u2047 (expired? e ga)\n   in any? \u03bb _ \u2192 \u00bf _ \u00bf\n\nprivate\n  isUpdateCommittee : (a : GovAction) \u2192 Dec (\u2203[ new ] \u2203[ rem ] \u2203[ q ] a \u2261 \u27e6 UpdateCommittee , (new , rem , q) \u27e7\u1d4d\u1d43)\n  isUpdateCommittee \u27e6 NoConfidence       , _                \u27e7\u1d4d\u1d43 = no \u03bb()\n  isUpdateCommittee \u27e6 UpdateCommittee    , (new , rem , q)  \u27e7\u1d4d\u1d43 = yes (new , rem , q , refl)\n  isUpdateCommittee \u27e6 NewConstitution    , _                \u27e7\u1d4d\u1d43 = no \u03bb()\n  isUpdateCommittee \u27e6 TriggerHardFork    , _                \u27e7\u1d4d\u1d43 = no \u03bb()\n  isUpdateCommittee \u27e6 ChangePParams      , _                \u27e7\u1d4d\u1d43 = no \u03bb()\n  isUpdateCommittee \u27e6 TreasuryWithdrawal , _                \u27e7\u1d4d\u1d43 = no \u03bb()\n  isUpdateCommittee \u27e6 Info               , _                \u27e7\u1d4d\u1d43 = no \u03bb()\n\n  hasPrev : \u2200 x v \u2192 Dec (\u2203[ v' ] x .action \u2261 \u27e6 TriggerHardFork , v' \u27e7\u1d4d\u1d43 \u00d7 pvCanFollow v' v)\n  hasPrev record { action = \u27e6 NoConfidence        , _   \u27e7\u1d4d\u1d43} v = no \u03bb ()\n  hasPrev record { action = \u27e6 UpdateCommittee     , _   \u27e7\u1d4d\u1d43} v = no \u03bb ()\n  hasPrev record { action = \u27e6 NewConstitution     , _   \u27e7\u1d4d\u1d43} v = no \u03bb ()\n  hasPrev record { action = \u27e6 TriggerHardFork     , v'  \u27e7\u1d4d\u1d43} v = case pvCanFollow? {v'} {v} of \u03bb where\n    (yes p) \u2192 yes (-, refl , p)\n    (no \u00acp) \u2192 no  (\u03bb where (_ , refl , h) \u2192 \u00acp h)\n  hasPrev record { action = \u27e6 ChangePParams       , _   \u27e7\u1d4d\u1d43} v = no \u03bb ()\n  hasPrev record { action = \u27e6 TreasuryWithdrawal  , _   \u27e7\u1d4d\u1d43} v = no \u03bb ()\n  hasPrev record { action = \u27e6 Info                , _   \u27e7\u1d4d\u1d43} v = no \u03bb ()\n\nopaque\n  unfolding validHFAction isRegistered\n\n  instance\n    validHFAction? : \u2200 {p s e} \u2192 validHFAction p s e \u2047\n    validHFAction? {record { action = \u27e6 NoConfidence        , _ \u27e7\u1d4d\u1d43}} = Dec-\u22a4\n    validHFAction? {record { action = \u27e6 UpdateCommittee     , _ \u27e7\u1d4d\u1d43}} = Dec-\u22a4\n    validHFAction? {record { action = \u27e6 NewConstitution     , _ \u27e7\u1d4d\u1d43}} = Dec-\u22a4\n    validHFAction? {record { action = \u27e6 TriggerHardFork     , v \u27e7\u1d4d\u1d43 ; prevAction = prev }} {s} {record { pv = (v' , aid') }}\n      with aid' \u225f prev \u00d7-dec pvCanFollow? {v'} {v} | any? (\u03bb (aid , x) \u2192 aid \u225f prev \u00d7-dec hasPrev x v) s\n    ... | yes p | _ = \u2047 yes (inj\u2081 p)\n    ... | no _ | yes p with ((aid , x) , x\u2208xs , (refl , v , h)) \u2190 P.find p = \u2047 yes (inj\u2082\n      (x , v , to \u2208-fromList x\u2208xs , h))\n    ... | no \u00acp\u2081 | no \u00acp\u2082 = \u2047 no \u03bb\n      { (inj\u2081 x) \u2192 \u00acp\u2081 x\n      ; (inj\u2082 (s , v , (h\u2081 , h\u2082 , h\u2083))) \u2192 \u00acp\u2082 $\n        \u2203\u2208-Any ((prev , s) , (from \u2208-fromList h\u2081 , refl , (v , h\u2082 , h\u2083))) }\n    validHFAction? {record { action = \u27e6 ChangePParams       , _ \u27e7\u1d4d\u1d43}} = Dec-\u22a4\n    validHFAction? {record { action = \u27e6 TreasuryWithdrawal  , _ \u27e7\u1d4d\u1d43}} = Dec-\u22a4\n    validHFAction? {record { action = \u27e6 Info                , _ \u27e7\u1d4d\u1d43}} = Dec-\u22a4\n\n  isRegistered? : \u2200 \u0393 v \u2192 Dec (isRegistered \u0393 v)\n  isRegistered? _ \u27e6 CC   , _ \u27e7\u1d4d\u1d5b = \u00bf _ \u2208 _ \u00bf\n  isRegistered? _ \u27e6 DRep , _ \u27e7\u1d4d\u1d5b = \u00bf _ \u2208 _ \u00bf\n  isRegistered? _ \u27e6 SPO  , _ \u27e7\u1d4d\u1d5b = \u00bf _ \u2208 _ \u00bf\n\nopen GovVoter\n\ninstance\n  Computational-GOV : Computational _\u22a2_\u21c0\u2987_,GOV\u2988_ String\n  Computational-GOV = record {Go} where\n    module Go \u0393 s where\n      open GovEnv (proj\u2081 \u0393)\n      k = proj\u2082 \u0393\n\n      module GoVote sig where\n        open GovVote sig\n\n        computeProof = case lookupActionId pparams (gvRole voter) gid epoch s ,\u2032 isRegistered? (proj\u2081 \u0393) voter of \u03bb where\n            (yes p , yes p') \u2192 case Any\u2194 .from p of \u03bb where\n              (_ , mem , refl , cV , \u00acexp) \u2192 success (_ , GOV-Vote (\u2208-fromList .to mem , cV , p' , \u00acexp))\n            (yes _ , no \u00acp) \u2192 failure (genErrors \u00acp)\n            (no \u00acp , _    ) \u2192 failure (genErrors \u00acp)\n\n        completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 inj\u2081 sig ,GOV\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n        completeness s' (GOV-Vote {ast = ast} (mem , cV , reg , \u00acexpired))\n          with lookupActionId pparams (gvRole voter) gid epoch s | isRegistered? (proj\u2081 \u0393) voter\n        ... | no \u00acp | _ = \u22a5-elim (\u00acp (Any\u2194 .to (_ , \u2208-fromList .from mem , refl , cV , \u00acexpired)))\n        ... | yes _ | no \u00acp = \u22a5-elim $ \u00acp reg\n        ... | yes p | yes q with Any\u2194 .from p \n        ... | ((_ , ast') , mem , refl , cV) = refl\n\n      module GoProp prop where\n        open GovProposal prop\n          renaming (action to a; deposit to d; policy to p; returnAddr to addr; prevAction to prev)\n        open PParams pparams hiding (a)\n\n        instance \n          Dec-actionWellFormed = actionWellFormed?\n          Dec-actionValid = actionValid?\n        {-# INCOHERENT Dec-actionWellFormed #-}\n        {-# INCOHERENT Dec-actionValid #-}\n\n        H = \u00bf actionWellFormed a\n            \u00d7 actionValid rewardCreds p ppolicy epoch a\n            \u00d7 d \u2261 govActionDeposit\n            \u00d7 validHFAction prop s enactState\n            \u00d7 hasParent' enactState s (a .gaType) prev\n            \u00d7 NetworkIdOf addr \u2261 NetworkId\n            \u00d7 CredentialOf addr \u2208 rewardCreds \u00bf\n            ,\u2032 isUpdateCommittee a\n\n        computeProof = case H of \u03bb where\n          (yes (wf , av , dep , vHFA , HasParent' en , goodAddr , regReturn) , yes (new , rem , q , refl)) \u2192\n            case \u00bf \u2200[ e \u2208 range new ] epoch &lt; e \u00d7 dom new \u2229 rem \u2261\u1d49 \u2205 \u00bf of \u03bb where\n              (yes newOk) \u2192 success (-, GOV-Propose {_} {_} {_} {_} {_} {_} {_} {_} {_} {(new , rem , q)} (wf , av , dep , vHFA , en , goodAddr , regReturn))\n              (no \u00acp)     \u2192 failure (genErrors \u00acp)\n          (yes (wf , av , dep , vHFA , HasParent' en , goodAddr , returnReg) , no notNewComm) \u2192 success\n            (-, GOV-Propose {_} {_} {_} {_} {_} {_} {_} {_} {_} {a .gaData} (wf , av , dep , vHFA , en , goodAddr , returnReg))\n          (no \u00acp , _) \u2192 failure (genErrors \u00acp)\n\n        completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 inj\u2082 prop ,GOV\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n        completeness s' (GOV-Propose (wf , av , dep , vHFA , en , goodAddr)) with H\n        ... | (no \u00acp , _) = \u22a5-elim (\u00acp (wf , av , dep , vHFA , HasParent' en , goodAddr))\n        ... | (yes (_ , _ , _ , _ , HasParent' _ , _) , no notNewComm) = refl\n        ... | (yes (_ , (_ , (av\u2081 , av\u2082)) , _ , _ , HasParent' _ , _) , yes (new , rem , q , refl))\n          rewrite dec-yes \u00bf \u2200[ e \u2208 range new ] epoch &lt; e \u00d7 dom new \u2229 rem \u2261\u1d49 \u2205 \u00bf (\u03bb { x \u2192 av\u2081 x , av\u2082 }) .proj\u2082 = refl\n\n      computeProof : (sig : GovVote \u228e GovProposal) \u2192 _\n      computeProof (inj\u2081 s) = GoVote.computeProof s\n      computeProof (inj\u2082 s) = GoProp.computeProof s\n\n      completeness : \u2200 sig s' \u2192 \u0393 \u22a2 s \u21c0\u2987 sig ,GOV\u2988 s' \u2192 _\n      completeness (inj\u2081 s) = GoVote.completeness s\n      completeness (inj\u2082 s) = GoProp.completeness s\n\nComputational-GOVS : Computational _\u22a2_\u21c0\u2987_,GOVS\u2988_ String\nComputational-GOVS = it\n\nallEnactable-singleton : \u2200 {aid s es} \u2192 getHash (s .prevAction) \u2261 getHashES es (GovActionTypeOf s)\n  \u2192 allEnactable es [ (aid , s) ]\nallEnactable-singleton {aid} {s} {es} eq = helper All.\u2237 All.[]\n  where\n    module \u2261\u1d49 = IsEquivalence (\u2261\u1d49-isEquivalence th)\n\n    helper : enactable es (getAidPairsList [ (aid , s) ]) (aid , s)\n    helper with getHashES es (GovActionTypeOf s) | getHash (s .prevAction)\n    ... | just x | just x' with refl &lt;- just-injective eq =\n      [ (aid , x) ] , proj\u2081 \u2261\u1d49.refl , All.[] \u2237 [] , inj\u2081 (refl , refl)\n    ... | just x | nothing = case eq of \u03bb ()\n    ... | nothing | _ = _\n</code></pre>"},{"location":"Ledger.Conway.Specification.Gov.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Gov.Properties where\n\nopen import Ledger.Conway.Specification.Gov.Properties.Computational\nopen import Ledger.Conway.Specification.Gov.Properties.ChangePPGroup\n</code></pre>"},{"location":"Ledger.Conway.Specification.Gov.html","title":"Governance","text":"<p>The behavior of <code>GovState</code> is similar to that of a queue. New proposals are appended at the end, but any proposal can be removed at the epoch boundary. However, for the purposes of enactment, earlier proposals take priority. Note that <code>EnactState</code> used in <code>GovEnv</code> is defined in the Enact module.</p>"},{"location":"Ledger.Conway.Specification.Gov.html#governance-types","title":"Governance Types","text":"<p>Derived types</p> <pre><code>GovState : Type\nGovState = List (GovActionID \u00d7 GovActionState)\n</code></pre> <pre><code>record GovEnv : Type where\n  field\n    txid        : TxId\n    epoch       : Epoch\n    pparams     : PParams\n    ppolicy     : Maybe ScriptHash\n    enactState  : EnactState\n    certState   : CertState\n    rewardCreds : \u2119 Credential\n</code></pre>"},{"location":"Ledger.Conway.Specification.Gov.html#governance-functions","title":"Governance Functions","text":"<p>The function definitions worth highlighting in this section are the following:</p> <ul> <li> <p><code>addVote</code> inserts (and potentially overrides) a vote   made for a particular governance action (identified by its ID) by a   credential with a role.</p> </li> <li> <p><code>addAction</code> adds a new proposed action at the end of a   given <code>GovState</code>.</p> </li> <li> <p>The <code>validHFAction</code> property indicates whether a given   proposal, if it is a <code>TriggerHardFork</code>   action, can potentially be enacted in the future. For this to be the   case, its <code>prevAction</code> needs to exist, be another   <code>TriggerHardFork</code> action and have a   compatible version.</p> </li> </ul> <pre><code>govActionPriority : GovActionType \u2192 \u2115\ngovActionPriority NoConfidence        = 0\ngovActionPriority UpdateCommittee     = 1\ngovActionPriority NewConstitution     = 2\ngovActionPriority TriggerHardFork     = 3\ngovActionPriority ChangePParams       = 4\ngovActionPriority TreasuryWithdrawal  = 5\ngovActionPriority Info                = 6\n\nOverlap : GovActionType \u2192 GovActionType \u2192 Type\nOverlap NoConfidence     UpdateCommittee  = \u22a4\nOverlap UpdateCommittee  NoConfidence     = \u22a4\nOverlap a                a'               = a \u2261 a'\n</code></pre> <pre><code>insertGovAction : GovState \u2192 GovActionID \u00d7 GovActionState \u2192 GovState\ninsertGovAction [] gaPr = [ gaPr ]\ninsertGovAction ((gaID\u2080 , gaSt\u2080) \u2237 gaPrs) (gaID\u2081 , gaSt\u2081)\n  =  if govActionPriority (action gaSt\u2080 .gaType) \u2264 govActionPriority (action gaSt\u2081 .gaType)\n     then (gaID\u2080 , gaSt\u2080) \u2237 insertGovAction gaPrs (gaID\u2081 , gaSt\u2081)\n     else (gaID\u2081 , gaSt\u2081) \u2237 (gaID\u2080 , gaSt\u2080) \u2237 gaPrs\n\nmkGovStatePair :  Epoch \u2192 GovActionID \u2192 RwdAddr \u2192 (a : GovAction) \u2192 NeedsHash (a .gaType)\n                  \u2192 GovActionID \u00d7 GovActionState\nmkGovStatePair e aid addr a prev = (aid , gas)\n  where\n  gas : GovActionState\n  gas = record  { votes = record { gvCC = \u2205 ; gvDRep = \u2205 ; gvSPO = \u2205 }\n                ; returnAddr = addr\n                ; expiresIn = e\n                ; action = a\n                ; prevAction = prev\n                }\n\naddAction :  GovState \u2192 Epoch \u2192 GovActionID \u2192 RwdAddr\n             \u2192 (a : GovAction) \u2192 NeedsHash (a .gaType)\n             \u2192 GovState\naddAction s e aid addr a prev = insertGovAction s (mkGovStatePair e aid addr a prev)\n</code></pre> <pre><code>  addVote : GovState \u2192 GovActionID \u2192 GovVoter \u2192 Vote \u2192 GovState\n  addVote gSt aid voter v = map modifyVotes gSt\n    where\n    modifyVotes : GovActionID \u00d7 GovActionState \u2192 GovActionID \u00d7 GovActionState\n    modifyVotes (gid , gaSt) = gid , (if gid \u2261 aid then record gaSt { votes = votes' voter } else gaSt)\n      where\n      open GovVotes (votes gaSt)\n      votes' : GovVoter \u2192 GovVotes\n      votes' \u27e6 CC , c \u27e7\u1d4d\u1d5b = record { gvCC = insert gvCC c v ; gvDRep = gvDRep ; gvSPO = gvSPO }\n      votes' \u27e6 DRep , c \u27e7\u1d4d\u1d5b = record { gvCC = gvCC ; gvDRep = insert gvDRep c v ; gvSPO = gvSPO }\n      votes' \u27e6 SPO , kh \u27e7\u1d4d\u1d5b = record { gvCC = gvCC ; gvDRep = gvDRep ; gvSPO = insert gvSPO kh v }\n\n  isRegistered : GovEnv \u2192 GovVoter \u2192 Type\n  isRegistered \u0393 v = case v of\n    \u03bb where\n      \u27e6 CC   , c  \u27e7\u1d4d\u1d5b \u2192 just c \u2208 range (CCHotKeysOf (CertStateOf \u0393))\n      \u27e6 DRep , c  \u27e7\u1d4d\u1d5b \u2192 c \u2208 dom (DRepsOf (CertStateOf \u0393))\n      \u27e6 SPO  , kh \u27e7\u1d4d\u1d5b \u2192 kh \u2208 dom (PoolsOf (CertStateOf \u0393))\n\n  validHFAction : GovProposal \u2192 GovState \u2192 EnactState \u2192 Type\n  validHFAction (record { action = \u27e6 TriggerHardFork , v \u27e7\u1d4d\u1d43 ; prevAction = prev }) s e =\n    (aid' \u2261 prev \u00d7 pvCanFollow ver v) \u228e \u2203\u2082[ x , v' ]  (prev , x) \u2208 fromList s\n                                                      \u00d7 x .action \u2261 \u27e6 TriggerHardFork , v' \u27e7\u1d4d\u1d43\n                                                      \u00d7 pvCanFollow v' v\n    where\n      ver : ProtVer\n      ver = EnactState.pv e .proj\u2081\n      aid' : GovActionID\n      aid' = EnactState.pv e .proj\u2082\n\n  validHFAction _ _ _ = \u22a4\n</code></pre>"},{"location":"Ledger.Conway.Specification.Gov.html#enactability-predicate","title":"Enactability Predicate","text":"<p>This section contains some of the functions used to determine whether certain actions are enactable in a given state.  Specifically, <code>allEnactable</code> passes the <code>GovState</code> to <code>getAidPairsList</code> to obtain a list of <code>GovActionID</code>-pairs which is then passed to <code>enactable</code>. The latter uses the <code>_connects_to_</code> function to check whether the list of <code>GovActionID</code>-pairs connects the proposed action to a previously enacted one.<sup>1</sup></p> <p>The function <code>govActionPriority</code> assigns a priority to the various types of governance actions. This is useful for ordering lists of governance actions (see the definition of the <code>insertGovAction</code> function in the section on Functions of the GOV Transition System Priority is also used to check if two actions <code>Overlap</code>; that is, they would modify the same piece of <code>EnactState</code>.</p> <pre><code>enactable  : EnactState \u2192 List (GovActionID \u00d7 GovActionID)\n           \u2192 GovActionID \u00d7 GovActionState \u2192 Type\nenactable e aidPairs = \u03bb (aidNew , as) \u2192 case getHashES e (action as .gaType) of\n  \u03bb where\n   nothing        \u2192 \u22a4\n   (just aidOld)  \u2192 \u2203[ t ]  fromList t \u2286 fromList aidPairs\n                            \u00d7 Unique t \u00d7 t connects aidNew to aidOld\n\nallEnactable : EnactState \u2192 GovState \u2192 Type\nallEnactable e aid\u00d7states = All (enactable e (getAidPairsList aid\u00d7states)) aid\u00d7states\n\nhasParentE : EnactState \u2192 GovActionID \u2192 GovActionType \u2192 Type\nhasParentE e aid gaTy = case getHashES e gaTy of\n  \u03bb where\n    nothing    \u2192 \u22a4\n    (just id)  \u2192 id \u2261 aid\n\nhasParent : EnactState \u2192 GovState \u2192 (gaTy : GovActionType) \u2192 NeedsHash gaTy \u2192 Type\nhasParent e s gaTy aid = case getHash aid of\n  \u03bb where\n    nothing      \u2192 \u22a4\n    (just aid')  \u2192 hasParentE e aid' gaTy\n                   \u228e Any (\u03bb (gid , gas) \u2192 gid \u2261 aid' \u00d7 Overlap (GovActionTypeOf gas) gaTy) s\n</code></pre>"},{"location":"Ledger.Conway.Specification.Gov.html#validity-and-wellformedness-predicates","title":"Validity and Wellformedness Predicates","text":"<p>This section defines predicates used in the <code>GOVPropose</code> case of the GOV rule to ensure that a governance action is valid and well-formed.</p> <pre><code>actionValid : \u2119 Credential \u2192 Maybe ScriptHash \u2192 Maybe ScriptHash \u2192 Epoch \u2192 GovAction \u2192 Type\nactionValid rewardCreds p ppolicy epoch \u27e6 ChangePParams , _ \u27e7\u1d4d\u1d43 =\n  p \u2261 ppolicy\nactionValid rewardCreds p ppolicy epoch \u27e6 TreasuryWithdrawal  , x \u27e7\u1d4d\u1d43 =\n  p \u2261 ppolicy \u00d7 map\u02e2 RwdAddr.stake (dom x) \u2286 rewardCreds\nactionValid rewardCreds p ppolicy epoch \u27e6 UpdateCommittee , (new , rem , q) \u27e7\u1d4d\u1d43 =\n  p \u2261 nothing \u00d7 (\u2200[ e \u2208 range new ]  epoch &lt; e) \u00d7 (dom new \u2229 rem \u2261\u1d49 \u2205)\nactionValid rewardCreds p ppolicy epoch _ =\n  p \u2261 nothing\n\nactionWellFormed : GovAction \u2192 Type\nactionWellFormed \u27e6 ChangePParams , x \u27e7\u1d4d\u1d43 = ppdWellFormed x\nactionWellFormed \u27e6 TreasuryWithdrawal  , x \u27e7\u1d4d\u1d43 =\n  (\u2200[ a \u2208 dom x ] NetworkIdOf a \u2261 NetworkId) \u00d7 (\u2203[ v \u2208 range x ] \u00ac (v \u2261 0))\nactionWellFormed _                 = \u22a4\n</code></pre> <ul> <li> <p><code>actionValid</code> ensures that the proposed action is valid    given the current state of the system:</p> <ul> <li> <p>a <code>ChangePParams</code> action is valid if the    proposal policy is provided;</p> </li> <li> <p>a <code>TreasuryWithdrawal</code> action is valid if    the proposal policy is provided and the reward stake credential is    registered;</p> </li> <li> <p>an <code>UpdateCommittee</code> action is valid if    credentials of proposed candidates have not expired, and the action    does not propose to both add and remove the same candidate.</p> </li> </ul> </li> <li> <p><code>actionWellFormed</code> ensures that the proposed action is     well-formed:</p> </li> <li> <p>a <code>ChangePParams</code> action must preserves well-formedness of the protocol parameters;</p> </li> <li> <p>a <code>TreasuryWithdrawal</code> action is well-formed if the       network ID is correct and there is at least one non-zero withdrawal amount in       the given <code>RwdAddrToCoinMap</code> map.</p> </li> </ul>"},{"location":"Ledger.Conway.Specification.Gov.html#the-gov-transition-system","title":"The GOV Transition System","text":"<p>The <code>GOV</code> transition rule has the following type signature:</p> <pre><code>data _\u22a2_\u21c0\u2987_,GOV\u2988_ : GovEnv \u00d7 \u2115 \u2192 GovState \u2192 GovVote \u228e GovProposal \u2192 GovState \u2192 Type where\n\n  GOV-Vote :\n    \u2219 (aid , ast) \u2208 fromList s\n    \u2219 canVote (PParamsOf \u0393) (action ast) (gvRole voter)\n    \u2219 isRegistered \u0393 voter\n    \u2219 \u00ac expired (\u0393 .epoch) ast\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      (\u0393 , k) \u22a2 s \u21c0\u2987 inj\u2081 \u27e6 aid , voter , v , machr \u27e7 ,GOV\u2988 addVote s aid voter v\n\n  GOV-Propose :\n    let pp           = PParamsOf \u0393\n        e            = \u0393 .epoch\n        enactState   = EnactStateOf \u0393\n        rewardCreds  = \u0393 .rewardCreds\n        prop         = record { returnAddr = addr ; action = a ; anchor = achr\n                              ; policy = p ; deposit = d ; prevAction = prev }\n    in\n    \u2219 actionWellFormed a\n    \u2219 actionValid rewardCreds p (\u0393 .ppolicy) e a\n    \u2219 d \u2261 pp .govActionDeposit\n    \u2219 validHFAction prop s enactState\n    \u2219 hasParent enactState s (GovActionTypeOf a) prev\n    \u2219 NetworkIdOf addr \u2261 NetworkId\n    \u2219 CredentialOf addr \u2208 rewardCreds\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      (\u0393 , k) \u22a2 s \u21c0\u2987 inj\u2082 prop ,GOV\u2988 addAction s (pp .govActionLifetime +\u1d49 e)\n                                                 (\u0393 .txid , k) addr a prev\n</code></pre> <p>The <code>GOVS</code> transition rule is actually a function with following signature:</p> <pre><code>_\u22a2_\u21c0\u2987_,GOVS\u2988_ : GovEnv \u2192 GovState \u2192 List (GovVote \u228e GovProposal) \u2192 GovState \u2192 Type\n</code></pre> <p>Specifically, it is defined as a reduction combinator that applies the <code>GOV</code> rule at each step.<sup>2</sup></p> <pre><code>_\u22a2_\u21c0\u2987_,GOVS\u2988_ = ReflexiveTransitiveClosure\u1d62 {sts = _\u22a2_\u21c0\u2987_,GOV\u2988_}\n</code></pre> <p>For <code>GOVVote</code>, we check that the governance action being voted on exists; that the voter\u2019s role is allowed to vote (see <code>canVote</code> in Section Functions related to voting; and that the voter\u2019s credential is actually associated with their role (see <code>isRegistered</code> in the section on the Type signature of the GOV transition relation.</p> <p>For <code>GOVPropose</code>, we check the correctness of the deposit along with some and some conditions that ensure the action is well-formed and valid; naturally, these checks depend on the type of action being proposed (see the section on Validity and Wellformedness Predicates.</p> <ol> <li> <p>To see the definition of the <code>_connects_to_</code> function, click the \u201cShow more Agda\u201d button.\u00a0\u21a9</p> </li> <li> <p>The Agda code defining various versions of the <code>ReflexiveTransitiveClosure</code>    type is not yet documented as we are in the process of refactoring it.\u00a0\u21a9</p> </li> </ol>"},{"location":"Ledger.Conway.Specification.Ledger.Properties.Base.html","title":"Base","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\nimport Ledger.Conway.Specification.Certs\n\nmodule Ledger.Conway.Specification.Ledger.Properties.Base\n  (txs : _) (open TransactionStructure txs) (open Ledger.Conway.Specification.Certs govStructure)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Utxow txs abs\n\n-- open import Data.List using (map)\nopen import Data.List.Properties using (++-identity\u02b3; map-++)\n\nopen import Axiom.Set.Properties th\n\nopen import Data.Nat.Properties using (+-0-monoid; +-identity\u02b3; +-suc)\nopen import Relation.Binary using (IsEquivalence)\nimport Relation.Binary.Reasoning.Setoid as SetoidReasoning\n\n-- ** Proof that the set equality `govDepsMatch` (below) is a LEDGER invariant.\n\n-- Mapping a list of `GovActionID \u00d7 GovActionState`s to a list of\n-- `DepositPurpose`s is so common, we give it a name `dpMap`;\n-- it's equivalent to `map (\u03bb (id , _) \u2192 GovActionDeposit id)`.\ndpMap : GovState \u2192 List DepositPurpose\ndpMap = map (GovActionDeposit \u2218 proj\u2081)\n\nisGADeposit : DepositPurpose \u2192 Type\nisGADeposit dp = isGADeposit\u1d47 dp \u2261 true\n  where\n  isGADeposit\u1d47 : DepositPurpose \u2192 Bool\n  isGADeposit\u1d47 (GovActionDeposit _) = true\n  isGADeposit\u1d47 _                    = false\n\ngovDepsMatch : LState \u2192 Type\ngovDepsMatch ls =\n  filter\u02e2 isGADeposit (dom (DepositsOf ls)) \u2261\u1d49 fromList (dpMap (GovStateOf ls))\n\nmodule \u2261\u1d49 = IsEquivalence (\u2261\u1d49-isEquivalence {DepositPurpose})\npattern UTXOW-UTXOS x = UTXOW\u21d2UTXO (UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ x)\nopen Equivalence\n\nfilterGA : \u2200 txId n \u2192 filter\u02e2 isGADeposit \u2774 GovActionDeposit (txId , n) \u2775 \u2261\u1d49 \u2774 GovActionDeposit (txId , n) \u2775\nproj\u2081 (filterGA txId n) {a} x = (proj\u2082 (from \u2208-filter x)) where open Equivalence\nproj\u2082 (filterGA txId n) {a} x = to \u2208-filter (\u03be (from \u2208-singleton x) , x)\n  where\n  \u03be : a \u2261 GovActionDeposit (txId , n) \u2192 isGADeposit a\n  \u03be refl = refl\n\nmodule LEDGER-PROPS (tx : Tx) (\u0393 : LEnv) (s : LState) where\n  open Tx tx renaming (body to txb); open TxBody txb\n  open LEnv \u0393 renaming (pparams to pp)\n  open PParams pp using (govActionDeposit; govActionLifetime)\n  open LState s\n  open CertState certState\n  open DState dState\n\n  -- initial utxo deposits\n  utxoDeps : Deposits\n  utxoDeps = UTxOState.deposits (LState.utxoSt s)\n\n  -- GovState definitions and lemmas --\n  mkAction : GovProposal \u2192 \u2115 \u2192 GovActionID \u00d7 GovActionState\n  mkAction p n = let open GovProposal p in\n    mkGovStatePair\n      (govActionLifetime +\u1d49 epoch slot)\n      (txId , n) returnAddr action prevAction\n\n  -- update GovState with a proposal\n  propUpdate : GovState \u2192 GovProposal \u2192 \u2115 \u2192 GovState\n  propUpdate s p n = insertGovAction s (mkAction p n)\n\n  -- update GovState with a vote\n  voteUpdate : GovState \u2192 GovVote \u2192 GovState\n  voteUpdate s v = addVote s gid voter vote\n    where open GovVote v\n\n  -- update GovState with a list of votes and proposals\n  updateGovStates : List (GovVote \u228e GovProposal) \u2192 \u2115 \u2192 GovState \u2192 GovState\n  updateGovStates [] _ s = s\n  updateGovStates (inj\u2081 v \u2237 vps) k s = updateGovStates vps (suc k) (voteUpdate s v)\n  updateGovStates (inj\u2082 p \u2237 vps) k s = updateGovStates vps (suc k) (propUpdate s p k)\n\n  -- updateGovStates faithfully represents a step of the LEDGER sts\n  STS\u2192GovSt\u2261 : \u2200 {s' : LState} \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s'\n               \u2192 isValid \u2261 true \u2192 GovStateOf s' \u2261 updateGovStates (txgov txb) 0 (rmOrphanDRepVotes (CertStateOf s') (GovStateOf s))\n  STS\u2192GovSt\u2261 (LEDGER-V x) refl = STS\u2192updateGovSt\u2261 (txgov txb) 0 (proj\u2082 (proj\u2082 (proj\u2082 x)))\n    where\n    STS\u2192updateGovSt\u2261 : (vps : List (GovVote \u228e GovProposal)) (k : \u2115) {certSt : CertState} {govSt govSt' : GovState}\n      \u2192 (_\u22a2_\u21c0\u27e6_\u27e7\u1d62*'_ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = IdSTS}{_\u22a2_\u21c0\u2987_,GOV\u2988_} (\u27e6 txId , epoch slot , pp , ppolicy , enactState , certSt , dom rewards \u27e7 , k) govSt vps govSt')\n      \u2192 govSt' \u2261 updateGovStates vps k govSt\n    STS\u2192updateGovSt\u2261 [] _ (BS-base Id-nop) = refl\n    STS\u2192updateGovSt\u2261 (inj\u2081 v \u2237 vps) k (BS-ind (GOV-Vote x) h)\n      = STS\u2192updateGovSt\u2261 vps (suc k) h\n    STS\u2192updateGovSt\u2261 (inj\u2082 p \u2237 vps) k (BS-ind (GOV-Propose x) h) = STS\u2192updateGovSt\u2261 vps (suc k) h\n\n  opaque\n    unfolding addVote\n\n    dpMap-rmOrphanDRepVotes : \u2200 certState govSt \u2192 dpMap (rmOrphanDRepVotes certState govSt) \u2261 dpMap govSt\n    dpMap-rmOrphanDRepVotes certState govSt = sym (fmap-\u2218 govSt) -- map proj\u2081 \u2218 map (map\u2082 _) \u2261 map (proj\u2081 \u2218 map\u2082 _) \u2261 map proj\u2081\n\nmodule SetoidProperties (tx : Tx) (\u0393 : LEnv) (s : LState) where\n  open Tx tx renaming (body to txb); open TxBody txb\n  open LEnv \u0393 renaming (pparams to pp)\n  open LEDGER-PROPS tx \u0393 s using (utxoDeps; propUpdate; mkAction; updateGovStates; STS\u2192GovSt\u2261; voteUpdate; dpMap-rmOrphanDRepVotes)\n  open SetoidReasoning (\u2261\u1d49-Setoid{DepositPurpose})\n\n  CredDepIsNotGADep : \u2200 {a c} \u2192 a \u2261 CredentialDeposit c \u2192 \u00ac isGADeposit a\n  CredDepIsNotGADep refl ()\n\n  PoolDepIsNotGADep : \u2200 {a c} \u2192 a \u2261 PoolDeposit c \u2192 \u00ac isGADeposit a\n  PoolDepIsNotGADep refl ()\n\n  DRepDepIsNotGADep : \u2200 {a c} \u2192 a \u2261 DRepDeposit c \u2192 \u00ac isGADeposit a\n  DRepDepIsNotGADep refl ()\n\n  filterCR : (c : DCert) (deps : Deposits)\n             \u2192 filter\u02e2 isGADeposit (dom ( deps \u2223 certRefund c \u1d9c \u02e2 )) \u2261\u1d49 filter\u02e2 isGADeposit (dom (deps \u02e2))\n  filterCR (dereg c _) deps = \u2261\u1d49.sym $ begin\n    filter\u02e2 isGADeposit (dom (deps \u02e2)) \u2248\u02d8\u27e8 filter-cong $ dom-cong (res-ex-\u222a Dec-\u2208-singleton) \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr)\u02e2 \u222a (deps \u2223 cr \u1d9c)\u02e2)) \u2248\u27e8 filter-cong dom\u222a \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr) \u02e2) \u222a dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr) \u02e2)) \u222a filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 \u222a-cong filter0 \u2261\u1d49.refl \u27e9\n    \u2205 \u222a filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 \u222a-identity\u02e1 $ filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2)) \u220e\n    where\n    cr = \u2774 CredentialDeposit c \u2775\n    filter0 = filter-\u2205 (\u03bb _ \u2192 CredDepIsNotGADep \u2218 (from \u2208-singleton) \u2218 res-dom)\n  filterCR (deregdrep c _) deps = \u2261\u1d49.sym $ begin\n    filter\u02e2 isGADeposit (dom (deps \u02e2)) \u2248\u02d8\u27e8 filter-cong $ dom-cong (res-ex-\u222a Dec-\u2208-singleton) \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr)\u02e2 \u222a (deps \u2223 cr \u1d9c)\u02e2)) \u2248\u27e8 filter-cong dom\u222a \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr) \u02e2) \u222a dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr) \u02e2)) \u222a filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 \u222a-cong filter0 \u2261\u1d49.refl \u27e9\n    \u2205 \u222a filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 \u222a-identity\u02e1 $ filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2)) \u220e\n    where\n    cr = \u2774 DRepDeposit c \u2775\n    filter0 = filter-\u2205 (\u03bb _ \u2192 DRepDepIsNotGADep \u2218 (from \u2208-singleton) \u2218 res-dom)\n  filterCR (delegate _ _ _ _)  deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n  filterCR (regpool _ _)       deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n  filterCR (regdrep _ _ _)     deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n  filterCR (retirepool _ _)    deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n  filterCR (ccreghot _ _)      deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n  filterCR (reg _ _)           deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n\n  filterCD : (c : DCert) (deps : Deposits) \u2192 filter\u02e2 isGADeposit (dom (certDeposit c pp \u02e2)) \u2261\u1d49 \u2205\n  filterCD (delegate _ _ _ _)  deps = filter-\u2205 \u03bb _ \u2192 CredDepIsNotGADep \u2218 from \u2208-singleton \u2218 dom-single\u2192single\n  filterCD (reg _ _)           deps = filter-\u2205 \u03bb _ \u2192 CredDepIsNotGADep \u2218 from \u2208-singleton \u2218 dom-single\u2192single\n  filterCD (regpool _ _)       deps = filter-\u2205 \u03bb _ \u2192 PoolDepIsNotGADep \u2218 from \u2208-singleton \u2218 dom-single\u2192single\n  filterCD (regdrep _ _ _)     deps = filter-\u2205 \u03bb _ \u2192 DRepDepIsNotGADep \u2218 from \u2208-singleton \u2218 dom-single\u2192single\n  filterCD (dereg _ _)         deps = \u2261\u1d49.trans (filter-cong dom\u2205) $ filter-\u2205 \u03bb _ a\u2208 _ \u2192 \u2209-\u2205 a\u2208\n  filterCD (retirepool _ _)    deps = \u2261\u1d49.trans (filter-cong dom\u2205) $ filter-\u2205 \u03bb _ a\u2208 _ \u2192 \u2209-\u2205 a\u2208\n  filterCD (deregdrep _ _)     deps = \u2261\u1d49.trans (filter-cong dom\u2205) $ filter-\u2205 \u03bb _ a\u2208 _ \u2192 \u2209-\u2205 a\u2208\n  filterCD (ccreghot _ _)      deps = \u2261\u1d49.trans (filter-cong dom\u2205) $ filter-\u2205 \u03bb _ a\u2208 _ \u2192 \u2209-\u2205 a\u2208\n\n  noGACerts : (cs : List DCert) (deps : Deposits)\n    \u2192 filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs deps)) \u2261\u1d49 filter\u02e2 isGADeposit (dom deps)\n  noGACerts [] _ = filter-cong \u2261\u1d49.refl\n  noGACerts (dcert@(delegate _ _ _ _) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u222a\u207a cd))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u222a\u207a cd)) \u2248\u27e8 filter-cong dom\u222a\u207a\u2261\u222adom \u27e9\n    filter\u02e2 isGADeposit (dom deps \u222a dom (cd \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a filter\u02e2 isGADeposit (dom (cd \u02e2)) \u2248\u27e8 \u222a-cong \u2261\u1d49.refl $ filterCD dcert deps \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a \u2205 \u2248\u27e8 \u222a-identity\u02b3 $ filter\u02e2 isGADeposit (dom deps) \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n    where\n      cd = certDeposit dcert pp\n      filter0 = filterCD dcert deps\n  noGACerts (dcert@(reg _ _) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u222a\u207a cd))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u222a\u207a cd)) \u2248\u27e8 filter-cong dom\u222a\u207a\u2261\u222adom \u27e9\n    filter\u02e2 isGADeposit (dom deps \u222a dom (cd \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a filter\u02e2 isGADeposit (dom (cd \u02e2)) \u2248\u27e8 \u222a-cong \u2261\u1d49.refl $ filterCD dcert deps \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a \u2205 \u2248\u27e8 \u222a-identity\u02b3 $ filter\u02e2 isGADeposit (dom deps) \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n    where\n      cd = certDeposit dcert pp\n      filter0 = filterCD dcert deps\n  noGACerts (dcert@(regpool _ _) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u222a\u207a cd))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u222a\u207a cd)) \u2248\u27e8 filter-cong dom\u222a\u207a\u2261\u222adom \u27e9\n    filter\u02e2 isGADeposit (dom deps \u222a dom (cd \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a filter\u02e2 isGADeposit (dom (cd \u02e2)) \u2248\u27e8 \u222a-cong \u2261\u1d49.refl filter0 \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a \u2205 \u2248\u27e8 \u222a-identity\u02b3 $ filter\u02e2 isGADeposit (dom deps) \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n    where\n      cd = certDeposit dcert pp\n      filter0 = filterCD dcert deps\n  noGACerts (dcert@(regdrep _ _ _) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u222a\u207a certDeposit dcert pp))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u222a\u207a cd)) \u2248\u27e8 filter-cong dom\u222a\u207a\u2261\u222adom \u27e9\n    filter\u02e2 isGADeposit (dom deps \u222a dom (cd \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a filter\u02e2 isGADeposit (dom (cd \u02e2)) \u2248\u27e8 \u222a-cong \u2261\u1d49.refl filter0 \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a \u2205 \u2248\u27e8 \u222a-identity\u02b3 $ filter\u02e2 isGADeposit (dom deps) \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n    where\n      cd = certDeposit dcert pp\n      filter0 = filterCD dcert deps\n  noGACerts (dcert@(dereg c v) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u2223 certRefund (dereg c v)\u1d9c))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u2223 certRefund (dereg c v)\u1d9c)) \u2248\u27e8 filterCR dcert deps \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n  noGACerts (dcert@(deregdrep c v) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u2223 certRefund (deregdrep c v)\u1d9c))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u2223 certRefund (deregdrep c v)\u1d9c)) \u2248\u27e8 filterCR dcert deps \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n  noGACerts (retirepool _ _ \u2237 cs) deps = noGACerts cs deps\n  noGACerts (ccreghot _ _ \u2237 cs) deps = noGACerts cs deps\n\n  opaque\n    unfolding addVote\n\n    dpMap\u2218voteUpdate\u2261dpMap : (v : GovVote) {govSt : GovState}\n      \u2192 dpMap (voteUpdate govSt v) \u2261 dpMap govSt\n    dpMap\u2218voteUpdate\u2261dpMap v {[]} = refl\n    dpMap\u2218voteUpdate\u2261dpMap v {(aid , ast) \u2237 govSt} =\n      cong (\u03bb x \u2192 (GovActionDeposit \u2218 proj\u2081) (aid , ast) \u2237 x) (dpMap\u2218voteUpdate\u2261dpMap v)\n\n  props-dpMap-votes-invar : (vs : List GovVote) (ps : List GovProposal) {k : \u2115} {govSt : GovState}\n    \u2192 fromList (dpMap (updateGovStates (map inj\u2082 ps ++ map inj\u2081 vs) k govSt ))\n      \u2261\u1d49 fromList (dpMap (updateGovStates (map inj\u2082 ps) k govSt))\n  props-dpMap-votes-invar [] ps {k} {govSt} = \u2261\u1d49.reflexive\n    (cong (\u03bb x \u2192 fromList (dpMap (updateGovStates x k govSt))) (++-identity\u02b3 (map inj\u2082 ps)))\n  props-dpMap-votes-invar (v \u2237 vs) [] {k} {govSt} = begin\n    fromList (dpMap (updateGovStates (map inj\u2081 (v \u2237 vs)) k govSt))\n      \u2248\u27e8 props-dpMap-votes-invar vs [] \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 []) (suc k) (voteUpdate govSt v)))\n      \u2261\u27e8 cong fromList (dpMap\u2218voteUpdate\u2261dpMap v) \u27e9\n    fromList (dpMap govSt)\n      \u220e\n  props-dpMap-votes-invar (v \u2237 vs) (p \u2237 ps) {k} {govSt} = props-dpMap-votes-invar (v \u2237 vs) ps\n\n  dpMap-update-\u222a : \u2200 gSt p k\n    \u2192 fromList (dpMap gSt) \u222a \u2774 GovActionDeposit (txId , k) \u2775\n        \u2261\u1d49 fromList (dpMap (propUpdate gSt p k))\n  dpMap-update-\u222a [] p k = \u222a-identity\u02e1 (fromList (dpMap [ mkAction p k ]))\n  dpMap-update-\u222a (g@(gaID\u2080 , gaSt\u2080) \u2237 gSt) p k\n    with (govActionPriority (GovActionTypeOf gaSt\u2080))\n         \u2264? (govActionPriority (GovActionTypeOf (proj\u2082 (mkAction p k))))\n  ... | yes _  = begin\n      fromList (dpMap (g \u2237 gSt)) \u222a \u2774 GovActionDeposit (txId , k) \u2775\n        \u2248\u27e8 \u222a-cong fromList-\u222a-singleton \u2261\u1d49.refl \u27e9\n      (\u2774 GovActionDeposit gaID\u2080 \u2775 \u222a fromList (dpMap gSt)) \u222a \u2774 GovActionDeposit (txId , k) \u2775\n        \u2248\u27e8 \u222a-assoc \u2774 GovActionDeposit gaID\u2080 \u2775 (fromList (dpMap gSt)) \u2774 GovActionDeposit (txId , k) \u2775 \u27e9\n      \u2774 GovActionDeposit gaID\u2080 \u2775 \u222a (fromList (dpMap gSt) \u222a \u2774 GovActionDeposit (txId , k) \u2775)\n        \u2248\u27e8 \u222a-cong \u2261\u1d49.refl (dpMap-update-\u222a gSt p k) \u27e9\n      \u2774 GovActionDeposit gaID\u2080 \u2775 \u222a fromList (dpMap (propUpdate gSt p k))\n        \u2248\u02d8\u27e8 fromList-\u222a-singleton \u27e9\n      fromList (dpMap (g \u2237 insertGovAction gSt (mkAction p k)))\n        \u220e\n  ... | no _   = begin\n      fromList (dpMap (g \u2237 gSt)) \u222a \u2774 GovActionDeposit (txId , k) \u2775\n        \u2248\u27e8 \u222a-comm (fromList (dpMap (g \u2237 gSt))) \u2774 GovActionDeposit (txId , k) \u2775 \u27e9\n      \u2774 GovActionDeposit (txId , k) \u2775 \u222a fromList (dpMap (g \u2237 gSt))\n        \u2248\u02d8\u27e8 fromList-\u222a-singleton \u27e9\n      fromList (dpMap ((mkAction p k) \u2237 g \u2237 gSt))\n        \u220e\n\n  connex-lemma : \u2200 gSt p ps {k}\n    \u2192 fromList (dpMap (updateGovStates (map inj\u2082 ps) k gSt)) \u222a \u2774 GovActionDeposit (txId , k + length ps) \u2775\n        \u2261\u1d49 fromList (dpMap (updateGovStates (map inj\u2082 ps) (suc k) (propUpdate gSt p k)))\n  connex-lemma gSt p [] {k} = begin\n      fromList (dpMap gSt) \u222a \u2774 GovActionDeposit (txId , k + 0) \u2775\n        \u2261\u27e8 cong (\u03bb x \u2192 fromList (dpMap gSt) \u222a \u2774 GovActionDeposit (txId , x) \u2775) (+-identity\u02b3 k) \u27e9\n      fromList (dpMap gSt) \u222a \u2774 GovActionDeposit (txId , k) \u2775\n        \u2248\u27e8 dpMap-update-\u222a gSt p k \u27e9\n      fromList (dpMap (propUpdate gSt p k))\n        \u220e\n  connex-lemma gSt p (p' \u2237 ps) {k} = begin\n    fromList (dpMap (updateGovStates (map inj\u2082 (p' \u2237 ps)) k gSt))\n      \u222a \u2774 GovActionDeposit (txId , k + length (p' \u2237 ps)) \u2775\n        \u2261\u27e8 cong (\u03bb x \u2192 fromList (dpMap (updateGovStates (map inj\u2082 (p' \u2237 ps)) k gSt))\n            \u222a \u2774 GovActionDeposit (txId , x) \u2775) (+-suc k (length ps)) \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) (suc k) (propUpdate gSt p' k)))\n      \u222a \u2774 GovActionDeposit (txId , (suc k) + length ps) \u2775\n        \u2248\u02d8\u27e8 \u222a-cong (connex-lemma gSt p' ps) \u2261\u1d49.refl \u27e9\n    (fromList (dpMap (updateGovStates (map inj\u2082 ps) k gSt))\n      \u222a \u2774 GovActionDeposit (txId , k + length ps) \u2775)\n      \u222a \u2774 GovActionDeposit (txId , (suc k) + length ps) \u2775\n        \u2248\u27e8 \u222a-cong (connex-lemma gSt p ps) \u2261\u1d49.refl \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) (suc k) (propUpdate gSt p k)))\n      \u222a \u2774 GovActionDeposit (txId , (suc k) + length ps) \u2775\n        \u2248\u27e8 connex-lemma (propUpdate gSt p k) p' ps \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 (p' \u2237 ps)) (suc k) (propUpdate gSt p k)))\n        \u220e\n\n  utxo-govst-connex : \u2200 txp {utxoDs gSt gad}\n    \u2192 filter\u02e2 isGADeposit (dom (utxoDs)) \u2261\u1d49 fromList (dpMap gSt)\n    \u2192 filter\u02e2 isGADeposit (dom (updateProposalDeposits txp txId gad utxoDs))\n      \u2261\u1d49 fromList (dpMap (updateGovStates (map inj\u2082 txp) 0 gSt))\n  utxo-govst-connex [] x = x\n  utxo-govst-connex (p \u2237 ps) {utxoDs} {gSt} {gad} x = begin\n    filter\u02e2 isGADeposit (dom (updateProposalDeposits (p \u2237 ps) txId gad utxoDs))\n      \u2248\u27e8 filter-cong dom\u222a\u207a\u2261\u222adom \u27e9\n    filter\u02e2 isGADeposit ((dom (updateProposalDeposits ps txId gad utxoDs))\n      \u222a (dom{X = Deposits} \u2774 GovActionDeposit (txId , length ps) , gad \u2775))\n      \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom (updateProposalDeposits ps txId gad utxoDs)) \u222a filter\u02e2 isGADeposit\n        (dom{X = Deposits} \u2774 GovActionDeposit (txId , length ps) , gad \u2775)\n      \u2248\u27e8 \u222a-cong (utxo-govst-connex ps x) (filter-cong dom-single\u2261single) \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) 0 gSt))\n      \u222a filter\u02e2 isGADeposit \u2774 GovActionDeposit (txId , length ps) \u2775\n      \u2248\u27e8 \u222a-cong  \u2261\u1d49.refl (filterGA txId _) \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) 0 gSt)) \u222a \u2774 GovActionDeposit (txId , length ps) \u2775\n      \u2248\u27e8 connex-lemma gSt p ps \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 (p \u2237 ps)) 0 gSt)) \u220e\n\n  -- The list of natural numbers from 0 up to `n` - 1.\n  \u27e60:&lt;_\u27e7 : \u2115 \u2192 List \u2115\n  \u27e60:&lt; 0     \u27e7 = []\n  \u27e60:&lt; suc n \u27e7 = \u27e60:&lt; n \u27e7 ++ [ n ]\n\n  connex-lemma-rep : \u2200 k govSt ps \u2192\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) k govSt))\n    \u2261\u1d49\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7)\n  connex-lemma-rep k govSt [] = begin\n    fromList (dpMap govSt)\n      \u2248\u02d8\u27e8 \u222a-identity\u02b3 (fromList (dpMap govSt)) \u27e9\n    fromList (dpMap govSt) \u222a fromList []\n      \u2261\u27e8\u27e9\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; 0 \u27e7) \u220e\n  connex-lemma-rep k govSt (p \u2237 ps) = begin\n    fromList (dpMap (updateGovStates (map inj\u2082 (p \u2237 ps)) k govSt))\n      \u2261\u27e8\u27e9\n    fromList (dpMap (updateGovStates (inj\u2082 p \u2237 map inj\u2082 ps) k govSt))\n      \u2261\u27e8\u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) (suc k) (propUpdate govSt p k)))\n      \u2248\u02d8\u27e8 connex-lemma govSt p ps {k} \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) k govSt)) \u222a \u2774 GovActionDeposit (txId , k + length ps) \u2775\n      \u2248\u27e8 \u222a-cong (connex-lemma-rep k govSt ps) \u2261\u1d49.refl \u27e9\n    (fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7)) \u222a \u2774 GovActionDeposit (txId , k + length ps) \u2775\n      \u2248\u27e8 \u222a-assoc (fromList (dpMap govSt)) (fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7)) \u2774 GovActionDeposit (txId , k + length ps) \u2775 \u27e9\n    fromList (dpMap govSt) \u222a (fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7) \u222a \u2774 GovActionDeposit (txId , k + length ps) \u2775)\n      \u2261\u27e8\u27e9\n    fromList (dpMap govSt) \u222a (fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7) \u222a fromList [ GovActionDeposit (txId , k + length ps) ])\n      \u2248\u27e8 \u222a-cong \u2261\u1d49.refl (\u222a-fromList-++ (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7) [ GovActionDeposit (txId , k + length ps) ]) \u27e9\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7 ++ [ GovActionDeposit (txId , k + length ps) ])\n      \u2261\u02d8\u27e8 cong (\u03bb x \u2192 fromList (dpMap govSt) \u222a fromList x) (map-++ _ \u27e60:&lt; length ps \u27e7 [ length ps ]) \u27e9\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) (\u27e60:&lt; length ps \u27e7 ++ [ length ps ]))\n      \u2261\u27e8\u27e9\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length (p \u2237 ps) \u27e7) \u220e\n\n  -- Removing orphan DRep votes does not modify the set of GAs in GovState\n  |\u1d52-GAs-pres : \u2200 k govSt certState \u2192\n    fromList (dpMap (updateGovStates (txgov txb) k (rmOrphanDRepVotes certState govSt)))\n    \u2261\u1d49\n    fromList (dpMap (updateGovStates (txgov txb) k govSt))\n  |\u1d52-GAs-pres k govSt certState = begin\n    fromList (dpMap (updateGovStates (txgov txb) k (rmOrphanDRepVotes certState govSt)))\n      \u2248\u27e8 props-dpMap-votes-invar txGovVotes txGovProposals {k} {rmOrphanDRepVotes certState govSt} \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 txGovProposals) k (rmOrphanDRepVotes certState govSt)))\n      \u2248\u27e8 connex-lemma-rep k (rmOrphanDRepVotes certState govSt) txGovProposals \u27e9\n    fromList (dpMap (rmOrphanDRepVotes certState govSt)) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length txGovProposals \u27e7)\n      \u2261\u27e8 cong (\u03bb x \u2192 fromList x \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length txGovProposals \u27e7)) (dpMap-rmOrphanDRepVotes certState govSt) \u27e9\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length txGovProposals \u27e7)\n      \u2248\u02d8\u27e8 connex-lemma-rep k govSt txGovProposals \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 txGovProposals) k govSt))\n      \u2248\u02d8\u27e8 props-dpMap-votes-invar txGovVotes txGovProposals {k} {govSt} \u27e9\n    fromList (dpMap (updateGovStates (txgov txb) k govSt)) \u220e\n</code></pre>"},{"location":"Ledger.Conway.Specification.Ledger.Properties.GovDepsMatch.html","title":"GovDepsMatch","text":"<p> Lemma (<code>govDepsMatch</code> is invariant of <code>LEDGER</code> rule).</p> <p>Informally.</p> <p>Suppose <code>s</code> and <code>s'</code> are ledger states such that <code>s</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,LEDGER\u2988</code> <code>s'</code>. Let <code>utxoSt</code> and <code>utxoSt'</code> be their respective <code>UTxOState</code>s and let <code>govSt</code>  and <code>govSt'</code> be their respective <code>GovState</code>s. If the governance action deposits of <code>utxoSt</code> are equal to those of <code>govSt</code>, then the same holds for <code>utxoSt'</code> and <code>govSt'</code>. In other terms, if <code>govDepsMatch</code> <code>s</code>, then <code>govDepsMatch</code> <code>s'</code>.</p> <p>Formally.</p> <pre><code>LEDGER-govDepsMatch :  LedgerInvariant _\u22a2_\u21c0\u2987_,LEDGER\u2988_ govDepsMatch\n</code></pre> <p>Proof.</p> <pre><code>LEDGER-govDepsMatch (LEDGER-I\u22ef refl (UTXOW-UTXOS (Scripts-No _))) aprioriMatch = aprioriMatch\n\nLEDGER-govDepsMatch {\u0393}{s}{tx}{s'}\n    utxosts@(LEDGER-V\u22ef tx-valid (UTXOW-UTXOS (Scripts-Yes x)) _ GOV-sts) aprioriMatch =\n    let  open Tx tx; open TxBody body\n         open LEnv \u0393 renaming (pparams to pp)\n         open PParams pp using (govActionDeposit)\n         open LState s\n         open LState s' renaming (govSt to govSt'; certState to certState')\n         open LEDGER-PROPS tx \u0393 s using (utxoDeps; updateGovStates; STS\u2192GovSt\u2261)\n         open SetoidProperties tx \u0393 s using (|\u1d52-GAs-pres; props-dpMap-votes-invar; utxo-govst-connex; noGACerts)\n    in\n    begin\n      filter\u02e2 isGADeposit (dom (updateDeposits pp body utxoDeps))\n        \u2248\u27e8 noGACerts txCerts (updateProposalDeposits txGovProposals txId govActionDeposit utxoDeps) \u27e9\n      filter\u02e2 isGADeposit (dom (updateProposalDeposits txGovProposals txId govActionDeposit utxoDeps))\n        \u2248\u27e8 utxo-govst-connex txGovProposals aprioriMatch \u27e9\n      fromList (dpMap (updateGovStates (map inj\u2082 txGovProposals) 0 govSt))\n        \u2248\u02d8\u27e8 props-dpMap-votes-invar txGovVotes txGovProposals \u27e9\n      fromList (dpMap (updateGovStates (txgov body) 0 govSt ))\n        \u2248\u02d8\u27e8 |\u1d52-GAs-pres 0 govSt certState' \u27e9\n      fromList (dpMap (updateGovStates (txgov body) 0 (rmOrphanDRepVotes certState' govSt)))\n        \u2261\u02d8\u27e8 cong (fromList \u2218 dpMap ) (STS\u2192GovSt\u2261 utxosts tx-valid) \u27e9\n      fromList (dpMap govSt') \u220e\n\nLEDGER-govDepsMatch {s' = s'} utxosts@(LEDGER-V (() , UTXOW-UTXOS (Scripts-No (_ , refl)) , _ , GOV-sts)) aprioriMatch\n</code></pre>"},{"location":"Ledger.Conway.Specification.Ledger.Properties.PoV.html","title":"PoV","text":"<p> Theorem (The <code>LEDGER</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>s</code> and <code>s'</code> be ledger states and  let <code>tx</code> : <code>Tx</code> be a fresh transaction, that is, a transaction that is not already part of the <code>UTxOState</code> of <code>s</code>. If <code>s</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,LEDGER\u2988</code> <code>s'</code>, then the coin values of <code>s</code> and <code>s'</code> are equal, that is,  <code>getCoin</code> <code>s</code> \\(\u2261\\) <code>getCoin</code> <code>s'</code>.</p> <p>Formally.</p> <pre><code>  LEDGER-pov : {\u0393 : LEnv} {s s' : LState}\n    \u2192 txId \u2209 map\u02e2 proj\u2081 (dom (UTxOOf s))\n    \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s' \u2192 getCoin s \u2261 getCoin s'\n</code></pre> <p>Proof.</p> <pre><code>  LEDGER-pov\n    {s  = s}\n    {s' = s'}\n    h (LEDGER-V {utxoSt' = utxoSt''} ( valid , UTXOW\u21d2UTXO st@(UTXO-induction r) , h' , _ )) =\n    let\n      open LState s\n      open CertState certState\n      open LState s' renaming (utxoSt to utxoSt'; govSt to govSt'; certState to certState')\n      open CertState certState'\n      open \u2261-Reasoning\n      open Certs-PoV indexedSum\u1d5b'-\u222a sumConstZero res-decomp  getCoin-cong \u2261\u1d49-getCoin\u02e2\n      zeroMap    = constMap (map\u02e2 RwdAddr.stake (dom txWithdrawals)) 0\n    in\n    begin\n      getCoin utxoSt + getCoin certState\n        \u2261\u27e8 cong (getCoin utxoSt +_) (CERTS-pov r h') \u27e9\n      getCoin utxoSt + (getCoin certState' + getCoin txWithdrawals)\n        \u2261\u02d8\u27e8 cong (\u03bb x \u2192 getCoin utxoSt + (getCoin certState' + x )) (*-identity\u02b3 (getCoin txWithdrawals)) \u27e9\n      getCoin utxoSt + (getCoin certState' + getCoin txWithdrawals * 1)\n        \u2261\u02d8\u27e8 cong (\u03bb u \u2192 getCoin utxoSt + (getCoin certState' + getCoin txWithdrawals * \u03c7 u)) valid \u27e9\n      getCoin utxoSt + (getCoin certState' + getCoin txWithdrawals * \u03c7 isValid)\n        \u2261\u27e8 cong (getCoin utxoSt +_) (+-comm (getCoin certState') _) \u27e9\n      getCoin utxoSt + (getCoin txWithdrawals * \u03c7 isValid + getCoin certState')\n        \u2261\u02d8\u27e8 +-assoc (getCoin utxoSt) (getCoin txWithdrawals * \u03c7 isValid) (getCoin certState') \u27e9\n      getCoin utxoSt + getCoin txWithdrawals * \u03c7 isValid + getCoin certState'\n        \u2261\u27e8 cong (_+ getCoin certState') (UTXOpov h st) \u27e9\n      getCoin utxoSt' + getCoin certState'\n        \u220e\n\n  LEDGER-pov  {s = s}\n              {s' = s'}\n              h (LEDGER-I {utxoSt' = utxoSt''} (invalid , UTXOW\u21d2UTXO st)) =\n    let\n        open LState s\n        open CertState certState\n        open LState s' renaming (utxoSt to utxoSt'; govSt to govSt'; certState to certState')\n        open UTxOState utxoSt\n        open UTxOState utxoSt' renaming (utxo to utxo'; fees to fees'\n                                        ; deposits to deposits'; donations to donations') in\n    cong (_+ rewardsBalance dState)\n    ( begin\n      getCoin \u27e6 utxo , fees , deposits , donations \u27e7\n        \u2261\u02d8\u27e8 +-identity\u02b3 (getCoin \u27e6 utxo , fees , deposits , donations \u27e7) \u27e9\n      getCoin \u27e6 utxo , fees , deposits , donations \u27e7 + 0\n        \u2261\u02d8\u27e8 cong (getCoin \u27e6 utxo , fees , deposits , donations \u27e7 +_) (*-zero\u02b3 (getCoin txWithdrawals)) \u27e9\n      getCoin \u27e6 utxo , fees , deposits , donations \u27e7 + getCoin txWithdrawals * 0\n        \u2261\u02d8\u27e8 cong (\u03bb x \u2192 getCoin \u27e6 utxo , fees , deposits , donations \u27e7 + getCoin txWithdrawals * \u03c7 x) invalid \u27e9\n      getCoin \u27e6 utxo , fees , deposits , donations \u27e7 + getCoin txWithdrawals * \u03c7 isValid\n        \u2261\u27e8 UTXOpov h st \u27e9\n      getCoin \u27e6 utxo' , fees' , deposits' , donations' \u27e7 \u220e )\n    where open \u2261-Reasoning\n</code></pre>"},{"location":"Ledger.Conway.Specification.Ledger.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Ledger.Properties where\n\nopen import Ledger.Conway.Specification.Ledger.Properties.Base\nopen import Ledger.Conway.Specification.Ledger.Properties.Computational\nopen import Ledger.Conway.Specification.Ledger.Properties.GovDepsMatch\nopen import Ledger.Conway.Specification.Ledger.Properties.PoV\n</code></pre>"},{"location":"Ledger.Conway.Specification.Ledger.html","title":"Ledger","text":"<p>This module defines the ledger transition system where valid transactions transform the ledger state.</p>"},{"location":"Ledger.Conway.Specification.Ledger.html#ledger-transition-system-types","title":"LEDGER Transition System Types","text":"<pre><code>record LEnv : Type where\n  field\n    slot        : Slot\n    ppolicy     : Maybe ScriptHash\n    pparams     : PParams\n    enactState  : EnactState\n    treasury    : Treasury\n</code></pre> <pre><code>record LState : Type where\n</code></pre> <pre><code>  field\n    utxoSt     : UTxOState\n    govSt      : GovState\n    certState  : CertState\n</code></pre>"},{"location":"Ledger.Conway.Specification.Ledger.html#helper-functions","title":"Helper Functions","text":"<pre><code>txgov : TxBody \u2192 List (GovVote \u228e GovProposal)\ntxgov txb = map inj\u2082 txGovProposals ++ map inj\u2081 txGovVotes\n  where open TxBody txb\n\nrmOrphanDRepVotes : CertState \u2192 GovState \u2192 GovState\nrmOrphanDRepVotes cs govSt = L.map (map\u2082 go) govSt\n  where\n   ifDRepRegistered : Credential \u2192 Type\n   ifDRepRegistered c = c \u2208 dom (DRepsOf cs)\n\n   go : GovActionState \u2192 GovActionState\n   go gas = record gas { votes = record (gas .votes) { gvDRep = filterKeys ifDRepRegistered (gas .votes .gvDRep) } }\n\nallColdCreds : GovState \u2192 EnactState \u2192 \u2119 Credential\nallColdCreds govSt es =\n  ccCreds (es .cc) \u222a concatMap\u02e2 (\u03bb (_ , st) \u2192 proposedCC (GovActionOf st)) (fromList govSt)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Ledger.html#ledger-transition-system","title":"LEDGER Transition System","text":"<pre><code>data _\u22a2_\u21c0\u2987_,LEDGER\u2988_ : LEnv \u2192 LState \u2192 Tx \u2192 LState \u2192 Type where\n  LEDGER-V :\n    let  txb = tx .body\n</code></pre> <pre><code>    in\n      \u2219 isValid tx \u2261 true\n      \u2219 \u27e6 slot , pp , treasury \u27e7  \u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt'\n      \u2219 \u27e6 epoch slot , pp , txGovVotes , txWithdrawals , allColdCreds govSt enactState \u27e7 \u22a2 certState \u21c0\u2987 txCerts ,CERTS\u2988 certState'\n      \u2219 \u27e6 txId , epoch slot , pp , ppolicy , enactState , certState' , dom (RewardsOf certState) \u27e7 \u22a2 rmOrphanDRepVotes certState' govSt \u21c0\u2987 txgov txb ,GOVS\u2988 govSt'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 slot , ppolicy , pp , enactState , treasury \u27e7 \u22a2 \u27e6 utxoSt , govSt , certState \u27e7 \u21c0\u2987 tx ,LEDGER\u2988 \u27e6 utxoSt' , govSt' , certState' \u27e7\n\n  LEDGER-I :\n      \u2219 isValid tx \u2261 false\n      \u2219 \u27e6 slot , pp , treasury \u27e7 \u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u27e6 slot , ppolicy , pp , enactState , treasury \u27e7 \u22a2 \u27e6 utxoSt , govSt , certState \u27e7 \u21c0\u2987 tx ,LEDGER\u2988 \u27e6 utxoSt' , govSt , certState \u27e7\n</code></pre> <p>The rule <code>LEDGER</code> invokes the <code>GOVS</code> rule to process governance action proposals and votes.</p> Note <p>The governance state used as input to <code>GOVS</code> is filtered to remove votes from <code>DRep</code>s that are no longer registered (see function <code>rmOrphanDRepVotes</code>).</p> <p>This mechanism serves to prevent attacks where malicious adversaries could submit transactions that</p> <ol> <li>register a fraudulent <code>DRep</code>,</li> <li>cast numerous votes utilizing that <code>DRep</code>,</li> <li>deregisters the <code>DRep</code> thereby recovering the deposit.</li> </ol>"},{"location":"Ledger.Conway.Specification.Ledger.html#ledgers-transition-system","title":"LEDGERS Transition System","text":"<pre><code>_\u22a2_\u21c0\u2987_,LEDGERS\u2988_ : LEnv \u2192 LState \u2192 List Tx \u2192 LState \u2192 Type\n_\u22a2_\u21c0\u2987_,LEDGERS\u2988_ = ReflexiveTransitiveClosure {sts = _\u22a2_\u21c0\u2987_,LEDGER\u2988_}\n</code></pre>"},{"location":"Ledger.Conway.Specification.PoolReap.html","title":"Pool Reaping Transition","text":"<pre><code>record PoolReapState : Type where\n</code></pre> <pre><code>  field\n    utxoSt     : UTxOState   -- utxo state\n    acnt       : Acnt        -- accounting\n    dState     : DState      -- delegation state\n    pState     : PState      -- pool state\n</code></pre> <pre><code>  _\u22a2_\u21c0\u2987_,POOLREAP\u2988_ : \u22a4 \u2192 PoolReapState \u2192 Epoch \u2192 PoolReapState \u2192 Type where\n  POOLREAP : let\n    open PoolReapState poolReapState\n    open StakePoolParams\n    open UTxOState\n    open PState\n    open DState\n    open Acnt\n    open PParams\n\n    retired    = pState .retiring \u207b\u00b9 e\n    rewardAcnts : DepositPurpose \u21c0 Credential\n    rewardAcnts =\n      mapKeys PoolDeposit $\n      mapValues rewardAccount $\n      pState .pools \u2223 retired\n\n    rewardAcnts' : Credential \u21c0 Coin\n    rewardAcnts' = aggregateBy (rewardAcnts \u02e2) (utxoSt .deposits)\n\n    refunds : Credential \u21c0 Coin\n    refunds = rewardAcnts' \u2223 dom (dState .rewards)\n\n    mRefunds = rewardAcnts' \u2223 dom (dState .rewards) \u1d9c\n\n    unclaimed  = getCoin mRefunds\n\n    retiredDeposits : \u2119 DepositPurpose\n    retiredDeposits = map\u02e2 PoolDeposit retired\n\n    utxoSt' = record utxoSt { deposits = utxoSt .deposits \u2223 retiredDeposits \u1d9c }\n\n    acnt' = record acnt { treasury = acnt .treasury + unclaimed }\n\n    dState' =\n      \u27e6 dState .voteDelegs\n      , dState .stakeDelegs \u2223^ retired \u1d9c\n      , dState .rewards \u222a\u207a refunds\n      \u27e7\n\n    pState' = \u27e6 pState .pools \u2223 retired \u1d9c , pState .retiring \u2223 retired \u1d9c \u27e7\n\n    in\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    _ \u22a2 \u27e6 utxoSt , acnt , dState , pState \u27e7 \u21c0\u2987 e ,POOLREAP\u2988 \u27e6 utxoSt' , acnt' , dState' , pState' \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Specification.Ratify.Properties.Computational.html","title":"Computational","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Ratify.Properties.Computational\n  (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Enact.Properties.Computational govStructure\nopen import Ledger.Conway.Specification.Ratify txs\n\nopen Computational \u2983...\u2984 hiding (computeProof; completeness)\n\nprivate\n  module Implementation\n    \u0393 (s : RatifyState) (sig : GovActionID \u00d7 _)\n    (let gid , st = sig)\n    where\n    open RatifyState s\n    open RatifyEnv \u0393; open GovActionState st\n    es'  = compute \u27e6 gid , treasury , currentEpoch \u27e7 es action\n    acc? = accepted? \u0393 es st\n    exp? = expired? currentEpoch st\n    del? = delayed? (action .gaType) prevAction es delay\n\n    opaque\n      acceptConds? : \u2200 a \u2192 Dec (acceptConds \u0393 s a)\n      acceptConds? _ = Dec-\u00d7 \u2983 \u2047 accepted? _ _ _ \u2984\n        \u2983 Dec-\u00d7 \u2983 Dec-\u2192 \u2983 \u2047 delayed? _ _ _ _ \u2984 \u2984 \u2983 \u2047 Computational\u21d2Dec' \u2984 \u2984 .dec\n\n    RATIFY-total : \u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFY\u2988 s'\n    RATIFY-total\n      with acceptConds? sig | exp?\n    ... | yes p@(_ , _ , (_ , q)) | _ = -, RATIFY-Accept (p , q)\n    ... | no \u00acp | no \u00aca = -, RATIFY-Continue (\u00acp , \u00aca)\n    ... | no \u00acp | yes a = -, RATIFY-Reject (\u00acp , a)\n\n    computeProof = success {Err = \u22a5} RATIFY-total\n\n    RATIFY-completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFY\u2988 s' \u2192 RATIFY-total .proj\u2081 \u2261 s'\n    RATIFY-completeness st\u02b3 (RATIFY-Accept (p , a)) with acceptConds? sig\n    ... | no \u00ach = \u22a5-elim (\u00ach p)\n    ... | yes (_ , _ , _ , h) = cong (\u03bb st\u1d49 \u2192 \u27e6 st\u1d49 , _ , _ \u27e7) $ computational\u21d2rightUnique Computational-ENACT h a\n    RATIFY-completeness s' (RATIFY-Reject (\u00acp , a))\n      rewrite dec-no (acceptConds? _) \u00acp | dec-yes exp? a .proj\u2082 = refl\n    RATIFY-completeness s' (RATIFY-Continue (\u00acp , \u00aca))\n      rewrite dec-no (acceptConds? _) \u00acp | dec-no exp? \u00aca = refl\n\n    completeness = cong (success {Err = \u22a5}) \u2218\u2082 RATIFY-completeness\n\ninstance\n  Computational-RATIFY : Computational _\u22a2_\u21c0\u2987_,RATIFY\u2988_ \u22a5\n  Computational-RATIFY = record {Implementation}\n\nComputational-RATIFIES : Computational _\u22a2_\u21c0\u2987_,RATIFIES\u2988_ \u22a5\nComputational-RATIFIES = it\n\nRATIFIES-total : \u2200 {\u0393 s sig} \u2192 \u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s'\nRATIFIES-total = ReflexiveTransitiveClosure-total (Implementation.RATIFY-total _ _ _)\n\nRATIFIES-complete : \u2200 {\u0393 s sig s'} \u2192\n  \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s' \u2192 RATIFIES-total {\u0393} {s} {sig} .proj\u2081 \u2261 s'\nRATIFIES-complete = computational\u21d2rightUnique Computational-RATIFIES (RATIFIES-total .proj\u2082)\n\nopaque\n  RATIFIES-total' : \u2200 {\u0393 s sig} \u2192 \u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s'\n  RATIFIES-total' = RATIFIES-total\n\n  RATIFIES-complete' : \u2200 {\u0393 s sig s'} \u2192\n    \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s' \u2192 RATIFIES-total' {\u0393} {s} {sig} .proj\u2081 \u2261 s'\n  RATIFIES-complete' = RATIFIES-complete\n\n  RATIFIES-deterministic : \u2200 {\u0393 s sig s' s''}\n    \u2192 \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s'\n    \u2192 \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s''\n    \u2192 s' \u2261 s''\n  RATIFIES-deterministic p\u2081 p\u2082 = trans (sym (RATIFIES-complete' p\u2081)) (RATIFIES-complete' p\u2082)\n\n  RATIFIES-deterministic-\u2261 : \u2200 {\u0393 \u0393' s s' sig sig' s'' s'''}\n    \u2192 \u0393 \u2261 \u0393'\n    \u2192 s \u2261 s'\n    \u2192 sig \u2261 sig'\n    \u2192 \u0393  \u22a2 s  \u21c0\u2987 sig  ,RATIFIES\u2988 s''\n    \u2192 \u0393' \u22a2 s' \u21c0\u2987 sig' ,RATIFIES\u2988 s'''\n    \u2192 s'' \u2261 s'''\n  RATIFIES-deterministic-\u2261 refl refl refl = RATIFIES-deterministic\n</code></pre>"},{"location":"Ledger.Conway.Specification.Ratify.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Ratify.Properties where\n\nopen import Ledger.Conway.Specification.Ratify.Properties.Computational\n</code></pre>"},{"location":"Ledger.Conway.Specification.RewardUpdate.Properties.Computational.html","title":"Computational","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\nopen import Ledger.Conway.Specification.Abstract using (AbstractFunctions)\n\nmodule Ledger.Conway.Specification.RewardUpdate.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\nopen import Ledger.Conway.Specification.RewardUpdate txs abs\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Epoch.Properties.Computational txs abs\nopen import Ledger.Prelude\n\nopen Computational \u2983...\u2984\n\ninstance\n  Computational-RUPD : Computational _\u22a2_\u21c0\u2987_,RUPD\u2988_ \u22a5\n  Computational-RUPD .computeProof _ (just ru) _ =\n    success (just ru , RUPD-Reward-Update-Exists)\n  Computational-RUPD .computeProof _ nothing slot\n    with firstSlot (epoch slot) + RandomnessStabilisationWindow &lt;? slot\n  ... | yes p  =\n    let ru' = _\n     in success (just ru' , RUPD-Create-Reward-Update {ru' = ru'} p)\n  ... | no \u00acp = success (nothing , RUPD-Reward-Too-Early \u00acp)\n\n  Computational-RUPD .completeness _ s slot s' RUPD-Reward-Update-Exists\n    = refl\n  Computational-RUPD .completeness _ s slot (just ru') (RUPD-Create-Reward-Update slot&gt;)\n    with firstSlot (epoch slot) + RandomnessStabilisationWindow &lt;? slot\n  ... | yes _ = refl\n  ... | no slot\u226f = \u22a5-elim (slot\u226f slot&gt;)\n  Computational-RUPD .completeness _ s slot nothing (RUPD-Reward-Too-Early \u00acslot&gt;)\n    with firstSlot (epoch slot) + RandomnessStabilisationWindow &lt;? slot\n  ... | no _ = refl\n  ... | yes slot&gt; = \u22a5-elim $ \u00acslot&gt; slot&gt;\n\n  Computational-TICK : Computational _\u22a2_\u21c0\u2987_,TICK\u2988_ \u22a5\n  Computational-TICK .computeProof _ nes _ = do\n    (nes' , neStep) \u2190 computeProof {STS = _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_} _ _ _\n    (_ , ruStep) \u2190 computeProof _ (nes' .NewEpochState.ru) _\n    success (_ , TICK (neStep , ruStep))\n\n  Computational-TICK .completeness _ _ _ _ (TICK (neStep , ruStep))\n    with completeness _ _ _ _ neStep\n  ... | refl\n    with recomputeProof ruStep | completeness _ _ _ _ ruStep\n  ... | success _ | refl\n     = refl\n</code></pre>"},{"location":"Ledger.Conway.Specification.RewardUpdate.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.RewardUpdate.Properties where\n\nopen import Ledger.Conway.Specification.RewardUpdate.Properties.Computational\n</code></pre>"},{"location":"Ledger.Conway.Specification.RewardUpdate.html","title":"RewardUpdate","text":""},{"location":"Ledger.Conway.Specification.RewardUpdate.html#reward-update-transition","title":"Reward Update Transition","text":"<p>The Reward Update Transition calculates a new <code>RewardUpdate</code> to apply in an epoch transition.</p> <p>The environment consists of the produced blocks and the epoch state. The state is an optional reward update.</p> <p>There are three transition cases, one that computes a new reward update, one that leaves the rewards update unchanged as it has not yet been applied and finally one that leaves the reward update unchanged as the transition was started too early.</p> <p>The signal of the transition rule RUPD is the current slot <code>s</code>.</p> <p>The execution of the transition role is as follows:</p> <ul> <li>If the current reward update is empty and <code>s</code> is greater than the   sum of the first slot of its epoch and the duration   <code>RandomnessStabilisationWindow\u1d9c</code>, then a new rewards update is   calculated and the state is updated.</li> <li>If the current reward update is not <code>nothing</code>, i.e.   a reward update has already been calculated but not yet applied, then the   state is not updated.</li> <li>If the current reward update is empty and <code>s</code> is less than or   equal to the sum of the first slot of its epoch and the duration   <code>RandomnessStabilisationWindow\u1d9c</code>, then the state is not updated.</li> </ul> <pre><code>RUpdEnv : Type\nRUpdEnv = BlocksMade \u00d7 EpochState\n\n\ndata _\u22a2_\u21c0\u2987_,RUPD\u2988_\n  : RUpdEnv \u2192 Maybe RewardUpdate \u2192 Slot \u2192 Maybe RewardUpdate \u2192 Type where\n\n  RUPD-Create-Reward-Update : \u2200 {b es s} {ru' : RewardUpdate} \u2192\n    let\n      ru' = createRUpd SlotsPerEpoch\u1d9c b es MaxLovelaceSupply\u1d9c\n    in\n    \u2219 s &gt; firstSlot (epoch s) + RandomnessStabilisationWindow\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    (b , es) \u22a2 nothing \u21c0\u2987 s ,RUPD\u2988 just ru'\n\n  RUPD-Reward-Update-Exists : \u2200 {b es s ru} \u2192\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    (b , es) \u22a2 just ru \u21c0\u2987 s ,RUPD\u2988 just ru\n\n  RUPD-Reward-Too-Early : \u2200 {b es s} \u2192\n    \u2219 \u00ac s &gt; firstSlot (epoch s) + RandomnessStabilisationWindow\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    (b , es) \u22a2 nothing \u21c0\u2987 s ,RUPD\u2988 nothing\n</code></pre>"},{"location":"Ledger.Conway.Specification.RewardUpdate.html#chain-tick-transition","title":"Chain Tick Transition","text":"<p>The Chain Tick Transition performs some chain level upkeep. The environment consists of a set of genesis keys, and the state is the epoch specific state necessary for the <code>NEWEPOCH</code> transition.</p> <p>Two transitions are done:</p> <ul> <li>The <code>NEWEPOCH</code> transition performs any state change needed if   it is the first block of a new epoch.</li> <li>The <code>RUPD</code> creates the reward update if it is late enough in   the epoch. Note that for every block header, either <code>NEWEPOCH</code>   or <code>RUPD</code> will be the identity transition.</li> </ul> <pre><code>data _\u22a2_\u21c0\u2987_,TICK\u2988_\n  : \u22a4 \u2192 NewEpochState \u2192 Slot \u2192 NewEpochState \u2192 Type where\n\n  TICK : \u2200 {slot nes nes' ru''} \u2192\n    let open NewEpochState in\n    -- TODO: Is this really how it should be?\n    -- We are skipping adoptGenesisDelegs here.\n    \u2219 tt \u22a2 nes \u21c0\u2987 epoch slot ,NEWEPOCH\u2988 nes'\n    \u2219 (nes .bprev , nes .epochState) \u22a2 (nes' .ru) \u21c0\u2987 slot ,RUPD\u2988 ru''\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      tt \u22a2 nes \u21c0\u2987 slot ,TICK\u2988 record nes' { ru = ru'' }\n</code></pre>"},{"location":"Ledger.Conway.Specification.Rewards.html","title":"Rewards","text":"<p>In this section we define how rewards for stake pools and their delegators are calculated and paid out. This calculation has two main aspects.</p> <ol> <li> <p>The amount of rewards to be paid out. This is defined in the section     Amount of Rewards to be Paid Out.</p> </li> <li> <p>The time when rewards are paid out. This is defined in the section     Timing of Rewards Payout.</p> </li> </ol>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:rewards-motivation","title":"Rewards Motivation","text":"<p>In order to operate, any blockchain needs to attract parties that are willing to spend computational and network resources on processing transactions and producing new blocks. These parties, called block producers, are incentivized by monetary rewards.</p> <p>Cardano is a proof-of-stake (PoS) blockchain: through a random lottery, one block producer is selected to produce one particular block. The probability for being select depends on their stake of Ada, that is the amount of Ada that they (and their delegators) own relative to the total amount of Ada. (We will explain delegation below.) After successful block production, the block producer is eligible for a share of the rewards.</p> <p>The rewards for block producers come from two sources: during an initial period, rewards are paid out from the reserve, which is an initial allocation of Ada created for this very purpose. Over time, the reserve is depleted, and rewards are sourced from transaction fees.</p> <p>Rewards are paid out epoch by epoch.</p> <p>Rewards are collective, but depend on performance: after every epoch, a fraction of the available reserve and the transaction fees accumulated during that epoch are added together. This sum is paid out to the block producers proportionally to how many blocks they have created each. In order to avoid perverse incentives, block producers do not receive individual rewards that depend on the content of their blocks.</p> <p>Not all people can or want to set up and administer a dedicated computer that produces blocks. However, these people still own Ada, and their stake is relevant for block production. Specifically, these people have the option to delegate their stake to a stake pool, which belongs to a block producer. This stake counts towards the stake of the pool in the block production lottery. In turn, the protocol distributes the rewards for produced blocks to the stake pool owner and their delegators. The owner receives a fixed fee (\u201ccost\u201d) and a share of the rewards (\u201cmargin\u201d). The remainder is distributed among delegators in proportion to their stake. By design, delegation and ownership are separate---delegation counts towards the stake of the pool, but delegators remain in full control of their Ada, stake pools cannot spend delegated Ada.</p> <p>Stake pools compete for delegators based on fees and performance. In order to achieve stable blockchain operation, the rewards are chosen such that they incentivize the system to evolve into a large, but fixed number of stake pools that attract most of the stake. For more details about the design and rationale of the rewards and delegation system, see Team18.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:amount-of-rewards-to-be-paid-out","title":"Amount of Rewards to be Paid Out","text":""},{"location":"Ledger.Conway.Specification.Rewards.html#sec:precision-rewards","title":"Precision of Arithmetic Operations","text":"<p>When computing rewards, all intermediate results are computed using rational numbers, <code>\u211a</code>, and converted to <code>Coin</code> using the <code>floor</code> function at the very end of the computation.</p> <p>Note for implementors</p> <p>Values in <code>\u211a</code> can have arbitrarily large nominators and denominators. Please use an appropriate type that represents rational numbers as fractions of unbounded nominators and denominators. Types such as <code>Double</code>, <code>Float</code>, <code>BigDecimal</code> (Java Platform), or <code>Fixed</code> (fixed-precision arithmetic) do not faithfully represent the rational numbers, and are not suitable for computing rewards according to this specification!</p> <p>We use the following arithmetic operations besides basic arithmetic:</p> <ul> <li> <p><code>from\u2115</code>: Interpret a natural number as a rational   number.</p> </li> <li> <p><code>floor</code>: Round a rational number to the next smaller   integer.</p> </li> <li> <p><code>posPart</code>: Convert an integer to a natural number by   mapping all negative numbers to zero.</p> </li> <li> <p><code>\u00f7</code>: Division of rational numbers.</p> </li> <li> <p><code>\u00f7\u2080</code>: Division operator that returns zero when the   denominator is zero.</p> </li> <li> <p><code>/</code>: Division operator that maps integer arguments to a   rational number.</p> </li> <li> <p><code>/\u2080</code>: Like <code>\u00f7\u2080</code>, but with integer   arguments.</p> </li> </ul>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:rewards-distribution-calculation","title":"Rewards Distribution Calculation","text":"<p>This section defines the amount of rewards that are paid out to stake pools and their delegators.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:maxpool","title":"Function <code>maxPool</code> used for computing a Reward Update","text":"<p>This subsection defines the function <code>maxPool</code> which gives the maximum reward a stake pool can receive in an epoch. Relevant quantities are the following:</p> <ul> <li> <p><code>rewardPot</code>: Total rewards to be paid out after the   epoch.</p> </li> <li> <p><code>stake</code>: Relative stake of the pool.</p> </li> <li> <p><code>pledge</code>: Relative stake that the pool owner has   pledged themselves to the pool.</p> </li> <li> <p><code>z0</code>: Relative stake of a fully saturated pool.</p> </li> <li> <p><code>nopt</code>: Protocol parameter, planned number of block   producers.</p> </li> <li> <p><code>a0</code>: Protocol parameter that incentivizes higher   pledges.</p> </li> <li> <p><code>reward\u211a</code>: Pool rewards as a rational number.</p> </li> <li> <p><code>reward\u2115</code>: Pool rewards after rounding to a natural   number of lovelace.</p> </li> </ul> <pre><code>maxPool : PParams \u2192 Coin \u2192 UnitInterval \u2192 UnitInterval \u2192 Coin\nmaxPool pparams rewardPot stake pledge = reward\u2115\n  where\n    a0    = 0 \u2294\u211a pparams .PParams.a0\n    1+a0  = 1 + a0\n    nopt  = 1 \u2294 pparams .PParams.nopt\n</code></pre> <pre><code>    z0       = 1 / nopt\n    stake'   = fromUnitInterval stake \u2293 z0\n    pledge'  = fromUnitInterval pledge \u2293 z0\n</code></pre> <pre><code>    reward\u211a =  from\u2115 rewardPot \u00f7 1+a0\n               *  (  stake' + pledge' * a0\n                    * ( stake' - pledge' * (z0 - stake') \u00f7 z0 )\n                    \u00f7 z0\n                  )\n    reward\u2115 = posPart (floor reward\u211a)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:mkApparentPerformance","title":"Function <code>mkApparentPerformance</code>","text":"<p>This section defines the function <code>mkApparentPerformance</code> which is used for computing a Reward Update; it computes the apparent performance of a stake pool.  Relevant quantities are the following:</p> <ul> <li> <p><code>stake</code>: Relative active stake of the pool.</p> </li> <li> <p><code>poolBlocks</code>: Number of blocks that the pool added to   the chain in the last epoch.</p> </li> <li> <p><code>totalBlocks</code>: Total number of blocks added in the last   epoch.</p> </li> </ul> <pre><code>mkApparentPerformance : UnitInterval \u2192 \u2115 \u2192 \u2115 \u2192 \u211a\nmkApparentPerformance stake poolBlocks totalBlocks = ratioBlocks \u00f7\u2080 stake'\n  where\n    stake' = fromUnitInterval stake\n</code></pre> <pre><code>    ratioBlocks = (pos poolBlocks) / (1 \u2294 totalBlocks)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:rewardOwners-and-rewardMember","title":"Functions <code>rewardOwners</code> and <code>rewardMember</code>","text":"<p>This subsection defines the functions <code>rewardOwners</code> and <code>rewardMember</code>.  Their purpose is to divide the reward for one pool between pool owners and individual delegators by taking into account a fixed pool cost, a relative pool margin, and the stake of each member.  The rewards will be distributed as follows:</p> <ul> <li> <p><code>rewardOwners</code>: These funds will go to the   <code>rewardAccount</code> specified in the pool registration   certificate.</p> </li> <li> <p><code>rewardMember</code>: These funds will go to the reward   accounts of the individual delegators.</p> </li> </ul> <p>Relevant quantities for these functions are the following:</p> <ul> <li> <p><code>rewards</code>: Rewards paid out to this pool.</p> </li> <li> <p><code>poolParams</code>: Pool parameters, such as cost and margin.</p> </li> <li> <p><code>ownerStake</code>: Stake of the pool owners relative to the   total amount of Ada.</p> </li> <li> <p><code>memberStake</code>: Stake of the pool member relative to the   total amount of Ada.</p> </li> <li> <p><code>stake</code>: Stake of the whole pool relative to the total   amount of Ada.</p> </li> </ul> <pre><code>rewardOwners : Coin \u2192 StakePoolParams \u2192 UnitInterval \u2192 UnitInterval \u2192 Coin\nrewardOwners rewards poolParams ownerStake stake = if rewards \u2264 cost\n  then rewards\n  else cost + posPart (floor (\n        (from\u2115 rewards - from\u2115 cost) * (margin + (1 - margin) * ratioStake)))\n  where\n    ratioStake  = fromUnitInterval ownerStake \u00f7\u2080 fromUnitInterval stake\n    cost        = poolParams .StakePoolParams.cost\n    margin      = fromUnitInterval (poolParams .StakePoolParams.margin)\n</code></pre> <pre><code>rewardMember : Coin \u2192 StakePoolParams \u2192 UnitInterval \u2192 UnitInterval \u2192 Coin\nrewardMember rewards poolParams memberStake stake = if rewards \u2264 cost\n  then 0\n  else posPart (floor (\n         (from\u2115 rewards - from\u2115 cost) * ((1 - margin) * ratioStake)))\n  where\n    ratioStake  = fromUnitInterval memberStake \u00f7\u2080 fromUnitInterval stake\n    cost        = poolParams .StakePoolParams.cost\n    margin      = fromUnitInterval (poolParams .StakePoolParams.margin)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:rewardOnePool","title":"Function <code>rewardOnePool</code> for Computing a Reward Update","text":"<p>This subsection defines the function <code>rewardOnePool</code> which calculates the rewards given out to each member of a given pool. Relevant quantities are:</p> <ul> <li> <p><code>rewardPot</code>: Total rewards to be paid out for this   epoch.</p> </li> <li> <p><code>n</code>: Number of blocks produced by the pool in the last   epoch.</p> </li> <li> <p><code>N</code>: Expectation value of the number of blocks to be   produced by the pool.</p> </li> <li> <p><code>stakeDistr</code>: Distribution of stake, as mapping from   <code>Credential</code> to <code>Coin</code>.</p> </li> <li> <p><code>\u03c3</code>: Total relative stake controlled by the pool.</p> </li> <li> <p><code>\u03c3a</code>: Total active relative stake controlled by the   pool, used for selecting block producers.</p> </li> <li> <p><code>tot</code>: Total amount of Ada in circulation, for   computing the relative stake.</p> </li> <li> <p><code>mkRelativeStake</code>: Compute stake relative to the total   amount in circulation.</p> </li> <li> <p><code>ownerStake</code>: Total amount of stake controlled by the   stake pool operator and owners.</p> </li> <li> <p><code>maxP</code>: Maximum rewards the pool can claim if the   pledge is met, and zero otherwise.</p> </li> <li> <p><code>poolReward</code>: Actual rewards to be paid out to this   pool.</p> </li> </ul> <pre><code>rewardOnePool :  PParams \u2192 Coin \u2192 \u2115 \u2192 \u2115 \u2192 StakePoolParams\n                 \u2192 Stake \u2192 UnitInterval \u2192 UnitInterval \u2192 Coin \u2192 Stake\n\nrewardOnePool pp rewardPot n N poolParams stakeDistr \u03c3 \u03c3a tot = memberRewards \u222a\u207a ownersRewards\n  where\n  mkRelativeStake : Coin \u2192 UnitInterval\n  mkRelativeStake = \u03bb coin \u2192 clamp (coin /\u2080 tot)\n\n  owners : \u2119 Credential\n  owners = map\u02e2 KeyHashObj (poolParams .StakePoolParams.owners)\n\n  ownerStake pledge maxP poolReward : Coin\n  ownerStake  = \u2211[ c \u2190 stakeDistr \u2223 owners ] c\n  pledge      = poolParams .StakePoolParams.pledge\n  maxP        =  if pledge \u2264 ownerStake\n                 then maxPool pp rewardPot \u03c3 (mkRelativeStake pledge)\n                 else 0\n  poolReward  = posPart $ floor $ (mkApparentPerformance \u03c3a n N) * from\u2115 maxP\n\n  stakeMap[_] :  (Coin \u2192 StakePoolParams \u2192 UnitInterval \u2192 UnitInterval \u2192 Coin)\n                 \u2192 Coin \u2192 UnitInterval \u2192 Coin\n  stakeMap[ f ] = (f poolReward poolParams) \u2218 mkRelativeStake\n\n  memberRewards : Stake\n  memberRewards = mapValues (\u03bb coin \u2192 stakeMap[ rewardMember ] coin \u03c3)\n                            (stakeDistr \u2223 owners \u1d9c)\n\n  ownersRewards : Stake\n  ownersRewards =  \u2774 poolParams .StakePoolParams.rewardAccount\n                   , stakeMap[ rewardOwners ] ownerStake \u03c3 \u2775\u1d50\n</code></pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#filtering-the-stake-distribution-to-one-stake-pool","title":"Filtering the Stake Distribution to One Stake Pool","text":"<p>This section defines the <code>poolStake</code> function which filters the stake distribution to one stake pool. Relevant quantities are:</p> <ul> <li> <p><code>hk</code>: <code>KeyHash</code> of the stake pool to be   filtered by.</p> </li> <li> <p><code>delegs</code>: Mapping from <code>Credential</code>s to   stake pool that they delegate to.</p> </li> <li> <p><code>stake</code>: Distribution of stake for all   <code>Credential</code>s.</p> </li> </ul> <pre><code>poolStake  : KeyHash \u2192 StakeDelegs \u2192 Stake \u2192 Stake\npoolStake hk delegs stake = stake \u2223 dom (delegs \u2223^ \u2774 hk \u2775)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:computing-a-reward-update","title":"Computing a Reward Update","text":"<p>This section defines the <code>reward</code> function which applies <code>rewardOnePool</code> to each registered stake pool. Relevant quantities are the following:</p> <ul> <li> <p><code>uncurry\u1d50</code>: Helper function to rearrange a nested   mapping.</p> </li> <li> <p><code>blocks</code>: Number of blocks produced by pools in the   last epoch, as a mapping from pool <code>KeyHash</code> to number.</p> </li> <li> <p><code>poolParams</code>: Parameters of all known stake pools.</p> </li> <li> <p><code>stake</code>: Distribution of stake, as mapping from   <code>Credential</code> to <code>Coin</code>.</p> </li> <li> <p><code>delegs</code>: Mapping from <code>Credential</code>s to   stake pool that they delegate to.</p> </li> <li> <p><code>total</code>: Total stake \\(=\\) amount of Ada in circulation,   for computing the relative stake.</p> </li> <li> <p><code>active</code>: Active stake \\(=\\) amount of Ada that was used   for selecting block producers.</p> </li> <li> <p><code>\u03a3_/total</code>: Sum of stake divided by total stake.</p> </li> <li> <p><code>\u03a3_/active</code>: Sum of stake divided by active stake.</p> </li> <li> <p><code>N</code>: Total number of blocks produced in the last epoch.</p> </li> <li> <p><code>pdata</code>: Data needed to compute rewards for each pool.</p> </li> </ul> <pre><code>BlocksMade : Type\nBlocksMade = KeyHash \u21c0 \u2115\n\nuncurry\u1d50 :\n</code></pre> <pre><code>  A \u21c0 (B \u21c0 C) \u2192 (A \u00d7 B) \u21c0 C\n</code></pre> <pre><code>reward :  PParams \u2192 BlocksMade \u2192 Coin \u2192 Pools \u2192 Stake \u2192 StakeDelegs \u2192 Coin \u2192 Stake\nreward pp blocks rewardPot pools stake delegs total = rewards\n  where\n    active      = \u2211[ c \u2190 stake ] c\n    \u03a3_/total    = \u03bb st \u2192 clamp ((\u2211[ c \u2190 st ] c) /\u2080 total)\n    \u03a3_/active   = \u03bb st \u2192 clamp ((\u2211[ c \u2190 st ] c) /\u2080 active)\n    N           = \u2211[ m \u2190 blocks ] m\n    mkPoolData  = \u03bb hk p \u2192 map  (\u03bb n \u2192 (n , p , poolStake hk delegs stake))\n                                (lookup\u1d50? blocks hk)\n    pdata       = mapMaybeWithKey\u1d50 mkPoolData pools\n\n    f : \u2115 \u00d7 StakePoolParams \u00d7 Stake \u2192 Stake\n    f = (\u03bb (n , p , s) \u2192 rewardOnePool pp rewardPot n N p s (\u03a3 s /total) (\u03a3 s /active) total)\n\n    results : (KeyHash \u00d7 Credential) \u21c0 Coin\n    results =  uncurry\u1d50 (mapValues f pdata)\n    rewards  = aggregateBy (map\u02e2 (\u03bb (kh , cred) \u2192 (kh , cred) , cred) (dom results)) results\n</code></pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:reward-update","title":"Reward Update","text":"<p>This section defines the <code>RewardUpdate</code> type, which records the net flow of Ada due to paying out rewards after an epoch. The update consists of four net flows.</p> <ul> <li> <p><code>\u0394t</code>: The change to the treasury. This will be a positive   value.</p> </li> <li> <p><code>\u0394r</code>: The change to the reserves. We typically expect this   to be a negative value.</p> </li> <li> <p><code>\u0394f</code>: The change to the fee pot. This will be a negative   value.</p> </li> <li> <p><code>rs</code>: The map of new individual rewards, to be added to   the existing rewards.</p> </li> </ul> <p>We require these net flows to satisfy certain constraints that are also stored in the <code>RewardUpdate</code> data type.  Specifically, <code>flowConservation</code> asserts that all four net flows add up to zero.  We also state the directions of <code>\u0394t</code> and <code>\u0394f</code>.</p> <pre><code>record RewardUpdate : Set where\n  field\n    \u0394t \u0394r \u0394f          : \u2124\n    rs                : Stake\n    flowConservation  : \u0394t + \u0394r + \u0394f + pos (\u2211[ c \u2190 rs ] c) \u2261 0\n    \u0394t-nonnegative    : 0 \u2264 \u0394t\n    \u0394f-nonpositive    : \u0394f \u2264 0\n</code></pre> <p>The function <code>createRUpd</code> calculates the <code>RewardUpdate</code>, but requires the definition of the type <code>EpochState</code>, so we have to defer the definition of this function to the Epoch Boundary section.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:diagram-rewards","title":"Diagram: preservation of funds and rewards","text":"<p>The flowchart in this section illustrates the potential flows of funds through the entire system that can happen during one transition step as described in this document.</p> <p>Exception. Withdrawals from the \u201cTreasury\u201d are not shown in the diagram; they can move funds into \u201cReward accounts.\u201d</p> <p>Potential flows of funds during one transition step</p> <p> </p> <p>Value flows between accounting pots, but the total amount of value in the system remains constant.  In particular, the red subgraph represents the inputs and outputs to the <code>rewardPot</code>, a temporary variable used during the reward update calculation in the function <code>createRUpd</code>.  Each red arrow corresponds to one field of the <code>RewardUpdate</code> data type.  The blue arrows represent the flow of funds after they have passed through the <code>rewardPot</code>.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:stake-distribution-calculation","title":"Stake Distribution Calculation","text":"<p>This section defines the calculation of the stake distribution for the purpose of calculating rewards.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#definitions-of-the-snapshot-type","title":"Definitions of the Snapshot type","text":"<p>This subsection defines the <code>Snapshot</code> type which represents a stake distribution snapshot.  Such a snapshot contains the essential data needed to compute rewards.</p> <ul> <li> <p><code>stake</code> A stake distribution, that is a mapping from   stake credentials to the active stake that they own in coins.</p> </li> <li> <p><code>delegations</code>: A delegation map, that is a mapping from   stake credentials to the stake pools that they delegate to.</p> </li> <li> <p><code>pools</code>: A mapping that stores the pool   parameters of each stake pool.</p> </li> </ul> <pre><code>record Snapshot : Set where\n  field\n    stake        : Stake\n    delegations  : StakeDelegs\n    pools        : Pools\n</code></pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#functions-for-computing-stake-distributions","title":"Functions for Computing Stake Distributions","text":"<p>This section defines the calculation of the stake distribution from the data contained in a ledger state.  Here,</p> <ul> <li> <p><code>utxoBalance</code> computes the coin balance of all those   UTxO with a given stake <code>Credential</code>.</p> </li> <li> <p><code>activeDelegs</code> represents the active stake   <code>Credential</code>s, i.e.\u00a0those that delegate to an existing   pool and that have a registered reward account.</p> </li> <li> <p><code>activeRewards</code> is a mapping from active stake   <code>Credential</code>s to the balance of their reward account.</p> </li> <li> <p><code>activeStake</code> stores the stake for each active   <code>Credential</code>, i.e.\u00a0the sum of coins from the UTxO set   plus the reward account balance.</p> </li> </ul> <pre><code>  stakeDistr : UTxO \u2192 DState \u2192 PState \u2192 Snapshot\n  stakeDistr utxo dState pState =\n      \u27e6 activeStake , StakeDelegsOf dState , pools \u27e7\n    where\n</code></pre> <pre><code>      pools          = PoolsOf pState\n      utxoBalance    = \u03bb cred \u2192 cbalance (utxo \u2223^' \u03bb txout \u2192 getStakeCred txout \u2261 just cred)\n      activeDelegs   = (StakeDelegsOf dState \u2223 dom (RewardsOf dState)) \u2223^ dom pools\n      activeRewards  = RewardsOf dState \u2223 dom activeDelegs\n      activeStake    =\n        mapWithKey (\u03bb c rewardBalance \u2192 utxoBalance c + rewardBalance) activeRewards\n</code></pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:timing-of-rewards-payout","title":"Timing of Rewards Payout","text":""},{"location":"Ledger.Conway.Specification.Rewards.html#sec:rewards-calculation-timeline","title":"Rewards Calculation Timeline","text":"<p>As described in the Rewards Motivation section, the probability of producing a block depends on the stake delegated to the block producer.  However, the stake distribution changes over time, as funds are transferred between parties.  This raises the question: What is the point in time from which we take the stake distribution?  Right at the moment of producing a block?  Some time in the past?  How do we deal with the fact that the blockchain is only eventually consistent (i.e., blocks can be rolled back before a stable consensus on the chain is formed)?</p> <p>On Cardano, the answer to these questions is to group time into epochs.  An epoch is long enough such that at the beginning of a new epoch, the beginning of the previous epoch has become stable.  An epoch is also long enough for human users to react to parameter changes, such as stake pool costs or performance.  But an epoch is also short enough so that changes to the stake distribution will be reflected in block production within a reasonable time frame.</p> <p>The rewards for the blocks produced during a given epoch \\(e_i\\) involve the two epochs surrounding it.  In particular, the stake distribution will come from the previous epoch and the rewards will be calculated in the following epoch.  At each epoch boundary, one snapshot of the stake distribution is taken; changes to the stake distribution within an epoch are not considered until the next snapshot is taken. More concretely:</p> <ol> <li> <p>A stake distribution snapshot is taken at the begining of epoch \\(e_{i-1}\\).</p> </li> <li> <p>The randomness for leader election is fixed during epoch \\(e_{i-1}\\)</p> </li> <li> <p>Epoch \\(e_{i}\\) begins, blocks are produced using the snapshot taken at (A).</p> </li> <li> <p>Epoch \\(e_{i}\\) ends.  A snapshot is taken of the stake pool performance during     epoch \\(e_{i}\\). A snapshot is also taken of the fee pot.</p> </li> <li> <p>The snapshots from (D) are stable and the reward calculation can begin.</p> </li> <li> <p>The reward calculation is finished and an update to the ledger state is ready to     be applied.</p> </li> <li> <p>Rewards are given out.</p> </li> </ol> <p>Timeline of the rewards calculation</p> <p>The snapshot taken at (A) is labeled \u201cmark\u201d during epoch \\(e_{i-1}\\), \u201cset\u201d during epoch \\(e_i\\) and \u201cgo\u201d during epoch \\(e_{i+1}\\).  At (G) the snapshot taken at (A) is no longer needed and will be discarded.</p> <p> </p> <p>N.B.  Between time D and E we are concerned with chain growth and stability. Therefore this duration can be stated as 2k blocks (to state it in slots requires details about the particular version of the Ouroboros protocol). The duration between F and G is also 2k blocks.  Between E and F a single honest block is enough to ensure a random nonce.</p> <p>In order to specify this logic, we store the last three snapshots of the stake distributions.  The mnemonic \u201cmark, set, go\u201d will be used to keep track of the snapshots, where the label \u201cmark\u201d refers to the most recent snapshot, and \u201cgo\u201d refers to the snapshot that is ready to be used in the reward calculation.  Blocks will be produced using the snapshot labeled \u201cset\u201d, whereas rewards are computed from the snapshot labeled \u201cgo\u201d.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:illustration-reward-cycle","title":"Example Illustration of the Reward Cycle","text":"<p>For better understanding, here an example of the logic described in the previous section.</p> <p>1.00,0.50,0.00 0.65,0.00,0.00 0.00,0.50,0.00 0.00,0.95,0.00 0.00,0.00,0.90 0.00,0.60,0.90</p> <p>Bob registers his stake pool in epoch \\(e_1\\). Alice delegates to Bob\u2019s stake pool in epoch \\(e_1\\). Just before the end of epoch \\(e_1\\), Bob submits a stake pool re-registration, changing his pool parameters. The change in parameters is not immediate, as shown by the curved arrow around the epoch boundary.</p> <p>A snapshot is taken on the \\(e_1\\)/\\(e_2\\) boundary. It is labeled \u201cmark\u201d initially. This snapshot includes Alice\u2019s delegation to Bob\u2019s pool, and Bob\u2019s pool parameters and listed in the initial pool registration certificate.</p> <p>If Alice changes her delegation choice any time during epoch \\(e_2\\), she will never be effected by Bob\u2019s change of parameters.</p> <p>A new snapshot is taken on the \\(e_2\\)/\\(e_3\\) boundary. The previous (darker blue) snapshot is now labeled \u201cset\u201d, and the new one labeled \u201cmark\u201d. The \u201cset\u201d snapshot is used for leader election in epoch \\(e_3\\).</p> <p>On the \\(e_3\\)/\\(e_4\\) boundary, the darker blue snapshot is labeled \u201cgo\u201d and the lighter blue snapshot is labeled \u201cset\u201d. Bob\u2019s stake pool performance during epoch \\(e_3\\) (he produced 4 blocks) will be used with the darker blue snapshot for the rewards which will be handed out at the beginning of epoch \\(e_5\\).</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:stake-distribution-snapshots","title":"Stake Distribution Snapshots","text":"<p>This section defines the SNAP transition rule for stake distribution snapshots, including the type <code>Snapshots</code> that contains the data that needs to be saved at the end of an epoch.  This relevant data are:</p> <ul> <li> <p><code>mark</code>, <code>set</code>, <code>go</code>: Three stake   distribution snapshots as explained in   the [Rewards Timeline][Rewards Calculation Timeline] section.</p> </li> <li> <p><code>feeSS</code>: stores the fees which are added to the reward pot   during the next reward update calculation, which is then subtracted   from the fee pot on the epoch boundary.</p> </li> </ul> <pre><code>record Snapshots : Set where\n  field\n    mark set go  : Snapshot\n    feeSS        : Fees\n</code></pre> <p>The snapshot transition rule has no preconditions and results in the following state change:</p> <ul> <li> <p>The oldest snapshot is replaced with the penultimate one.</p> </li> <li> <p>The penultimate snapshot is replaced with the newest one.</p> </li> <li> <p>The newest snapshot is replaced with one just calculated.</p> </li> <li> <p>The current fees pot is stored in <code>feeSS</code>.  Note that this value will   not change during the epoch, unlike the <code>fees</code> value in the UTxO state.</p> </li> </ul> <p> <pre><code>data _\u22a2_\u21c0\u2987_,SNAP\u2988_ : LState \u2192 Snapshots \u2192 \u22a4 \u2192 Snapshots \u2192 Type where\n  SNAP :\n    let stake = stakeDistr (UTxOOf ls) (DStateOf ls) (PStateOf ls) in\n    ls \u22a2 \u27e6 mark , set , go , feeSS \u27e7 \u21c0\u2987 tt ,SNAP\u2988 \u27e6 stake , mark , set , FeesOf ls \u27e7\n</code></pre></p>"},{"location":"Ledger.Conway.Specification.Rewards.html#references","title":"References","text":"<p>[Team18]  IOHK Formal Methods Team. Design Specification for Delegation and Incentives in Cardano, IOHK Deliverable SL-D1. 2018.</p>"},{"location":"Ledger.Conway.Specification.Script.Base.html","title":"Base","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Algebra.Morphism\nopen import Data.List.Relation.Unary.All using (All; []; _\u2237_; all?; uncons)\nopen import Data.List.Relation.Unary.Any\nopen import Data.Nat.Properties using (+-0-commutativeMonoid; suc-injective)\n\nopen import stdlib.Data.List.Relation.Unary.MOf\n\n\nopen import Ledger.Prelude hiding (All; Any; all?; any?; _\u2237\u02b3_; uncons; _\u2286_)\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\n\nmodule Ledger.Conway.Specification.Script.Base\n  (cs : _) (open CryptoStructure cs)\n  (es : _) (open EpochStructure es)\n  where\n\nrecord P1ScriptStructure : Type\u2081 where\n  field P1Script : Type\n        validP1Script : \u2119 KeyHash \u2192 Maybe Slot \u00d7 Maybe Slot \u2192 P1Script \u2192 Type\n        \u2983 Dec-validP1Script \u2984 : validP1Script \u2047\u00b3\n        \u2983 Hashable-P1Script \u2984 : Hashable P1Script ScriptHash\n        \u2983 DecEq-P1Script    \u2984 : DecEq P1Script\n\nrecord PlutusStructure : Type\u2081 where\n  field Data\u02b0 : HashableSet\n        Language PlutusScript CostModel Prices LangDepView ExUnits : Type\n        PlutusV1 PlutusV2 PlutusV3   : Language\n        \u2983 ExUnit-CommutativeMonoid \u2984 : CommutativeMonoid 0\u2113 0\u2113 ExUnits\n        \u2983 Hashable-PlutusScript    \u2984 : Hashable PlutusScript ScriptHash\n        \u2983 DecEq-Language           \u2984 : DecEq Language\n        \u2983 DecEq-CostModel          \u2984 : DecEq CostModel\n        \u2983 DecEq-LangDepView        \u2984 : DecEq LangDepView\n        \u2983 Show-CostModel           \u2984 : Show CostModel\n\n  field  _\u2265\u1d49_              : ExUnits \u2192 ExUnits \u2192 Type\n         \u2983 DecEq-ExUnits \u2984 : DecEq ExUnits\n         \u2983 DecEQ-Prices  \u2984 : DecEq Prices\n         \u2983 Show-ExUnits  \u2984 : Show ExUnits\n         \u2983 Show-Prices   \u2984 : Show Prices\n\n  open HashableSet Data\u02b0 renaming (T to Data; THash to DataHash) public\n\n  -- Type aliases for Data\n  Datum    = Data\n  Redeemer = Data\n\n  field validPlutusScript : CostModel \u2192 List Data \u2192 ExUnits \u2192 PlutusScript \u2192 Type\n        \u2983 Dec-validPlutusScript \u2984 : \u2200 {x} \u2192 (validPlutusScript x \u2047\u00b3)\n        language : PlutusScript \u2192 Language\n        toData : \u2200 {A : Type} \u2192 A \u2192 Data\n\nrecord ScriptStructure : Type\u2081 where\n\n  field p1s : P1ScriptStructure\n\n  open P1ScriptStructure p1s public\n\n  field hashRespectsUnion :\n          {A B Hash : Type} \u2192 Hashable A Hash \u2192 Hashable B Hash \u2192 Hashable (A \u228e B) Hash\n\n  field ps : PlutusStructure\n  open PlutusStructure ps public\n    renaming ( PlutusScript       to P2Script\n             ; validPlutusScript  to validP2Script\n             )\n\n  Script = P1Script \u228e P2Script\n\n  open import Data.Empty\n  open import Agda.Builtin.Equality\n  open import Relation.Binary.PropositionalEquality\n\n  instance\n    Hashable-Script : Hashable Script ScriptHash\n    Hashable-Script = hashRespectsUnion Hashable-P1Script Hashable-PlutusScript\n\n  isP1Script : Script \u2192 Type\n  isP1Script = T \u2218 is-just \u2218 isInj\u2081\n\n  isP1Script? : \u2200 {s} \u2192 isP1Script s \u2047\n  isP1Script? {inj\u2081 x} .dec = yes tt\n  isP1Script? {inj\u2082 y} .dec = no \u03bb ()\n\n  isNativeScript : Script \u2192 Type\n  isNativeScript = isP1Script\n\n  toP1Script : Script \u2192 Maybe P1Script\n  toP1Script = isInj\u2081\n\n  isP2Script : Script \u2192 Type\n  isP2Script = T \u2218 is-just \u2218 isInj\u2082\n\n  isP2Script? : \u2200 {s} \u2192 isP2Script s \u2047\n  isP2Script? {inj\u2081 x} .dec = no \u03bb ()\n  isP2Script? {inj\u2082 y} .dec = yes tt\n\n  toP2Script : Script \u2192 Maybe P2Script\n  toP2Script = isInj\u2082\n</code></pre>"},{"location":"Ledger.Conway.Specification.Script.Timelock.html","title":"Timelock Scripts","text":"<p>This section defines <code>Timelock</code> scripts, which verify the presence of keys and whether a transaction happens in a certain slot interval.  The scripts are executed as part of the regular witnessing.</p>"},{"location":"Ledger.Conway.Specification.Script.Timelock.html#sec:the-timelock-type","title":"The Timelock Type","text":"<pre><code>data Timelock : Type where\n  RequireAllOf       : List Timelock      \u2192 Timelock\n  RequireAnyOf       : List Timelock      \u2192 Timelock\n  RequireMOf         : \u2115 \u2192 List Timelock  \u2192 Timelock\n  RequireSig         : KeyHash            \u2192 Timelock\n  RequireTimeStart   : Slot               \u2192 Timelock\n  RequireTimeExpire  : Slot               \u2192 Timelock\n</code></pre>"},{"location":"Ledger.Conway.Specification.Script.Timelock.html#sec:the-evaltimelock-type","title":"The evalTimelock Type","text":"<pre><code>data evalTimelock (khs : \u2119 KeyHash) (I : Maybe Slot \u00d7 Maybe Slot) : Timelock \u2192 Type where\n  evalAll : All (evalTimelock khs I) ss \u2192 (evalTimelock khs I) (RequireAllOf ss)\n  evalAny : Any (evalTimelock khs I) ss \u2192 (evalTimelock khs I) (RequireAnyOf ss)\n  evalMOf : MOf m (evalTimelock khs I) ss \u2192 (evalTimelock khs I) (RequireMOf m ss)\n  evalSig : x \u2208 khs \u2192 (evalTimelock khs I) (RequireSig x)\n  evalTSt : M.Any (a \u2264_) (I .proj\u2081) \u2192 (evalTimelock khs I) (RequireTimeStart a)\n  evalTEx : M.Any (_\u2264 a) (I .proj\u2082) \u2192 (evalTimelock khs I) (RequireTimeExpire a)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Script.Validation.html","title":"Validation","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Script.Validation\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs) (open indexOf indexOfImp)\n  where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Certs govStructure\n\ndata ScriptPurpose : Type where\n  Cert     : DCert        \u2192 ScriptPurpose\n  Rwrd     : RwdAddr      \u2192 ScriptPurpose\n  Mint     : ScriptHash   \u2192 ScriptPurpose\n  Spend    : TxIn         \u2192 ScriptPurpose\n  Vote     : GovVoter     \u2192 ScriptPurpose\n  Propose  : GovProposal  \u2192 ScriptPurpose\n\nrdptr : TxBody \u2192 ScriptPurpose \u2192 Maybe RdmrPtr\nrdptr txb = \u03bb where\n  (Cert h)     \u2192 map (Cert    ,_) $ indexOfDCert    h txCerts\n  (Rwrd h)     \u2192 map (Rewrd   ,_) $ indexOfRwdAddr  h txWithdrawals\n  (Mint h)     \u2192 map (Mint    ,_) $ indexOfPolicyId h (policies mint)\n  (Spend h)    \u2192 map (Spend   ,_) $ indexOfTxIn     h txIns\n  (Vote h)     \u2192 map (Vote    ,_) $ indexOfVote     h (map GovVote.voter txGovVotes)\n  (Propose h)  \u2192 map (Propose ,_) $ indexOfProposal h txGovProposals\n where open TxBody txb\n\nindexedRdmrs : Tx \u2192 ScriptPurpose \u2192 Maybe (Redeemer \u00d7 ExUnits)\nindexedRdmrs tx sp = maybe (\u03bb x \u2192 lookup\u1d50? txrdmrs x) nothing (rdptr body sp)\n  where open Tx tx; open TxWitnesses wits\n\ngetDatum : Tx \u2192 UTxO \u2192 ScriptPurpose \u2192 Maybe Datum\ngetDatum tx utxo (Spend txin) =\n  do (_ , _ , just d , _) \u2190 lookup\u1d50? utxo txin\n                          where\n                            (_ , _ , nothing , _) \u2192 nothing\n     case d of \u03bb where\n       (inj\u2081 d) \u2192 just d\n       (inj\u2082 h) \u2192 lookup\u1d50? m h\n     where\n       m = setToMap (map\u02e2 &lt; hash , id &gt; (TxWitnesses.txdats (Tx.wits tx)))\ngetDatum tx utxo _ = nothing\n\nrecord TxInfo : Type where\n  field realizedInputs : UTxO\n        txOuts         : Ix \u21c0 TxOut\n        fee            : Value\n        mint           : Value\n        txCerts        : List DCert\n        txWithdrawals  : Withdrawals\n        txVldt         : Maybe Slot \u00d7 Maybe Slot\n        vkKey          : \u2119 KeyHash\n        txdats         : \u2119 Datum\n        txId           : TxId\n\ntxInfo : Language \u2192 PParams\n                  \u2192 UTxO\n                  \u2192 Tx\n                  \u2192 TxInfo\ntxInfo l pp utxo tx = record\n  { TxBody body\n  ; TxWitnesses wits\n  ; realizedInputs = utxo \u2223 txIns\n  ; fee = inject txFee\n  ; mint = mint\n  ; vkKey = reqSignerHashes\n  } where open Tx tx; open TxBody body\n\ncredsNeeded : UTxO \u2192 TxBody \u2192 \u2119 (ScriptPurpose \u00d7 Credential)\ncredsNeeded utxo txb\n  =  map\u02e2 (\u03bb (i , o)  \u2192 (Spend  i , payCred (proj\u2081 o))) ((utxo \u2223 (txIns \u222a collateralInputs)) \u02e2)\n  \u222a  map\u02e2 (\u03bb a        \u2192 (Rwrd   a , stake a)) (dom \u2223 txWithdrawals \u2223)\n  \u222a  mapPartial (\u03bb c  \u2192 (Cert   c ,_) &lt;$&gt; cwitness c) (fromList txCerts)\n  \u222a  map\u02e2 (\u03bb x        \u2192 (Mint   x , ScriptObj x)) (policies mint)\n  \u222a  mapPartial (\u03bb v \u2192 if isGovVoterCredential v then (\u03bb {c} \u2192 just (Vote v , c)) else nothing)\n                (fromList (map voter txGovVotes))\n  \u222a  mapPartial (\u03bb p \u2192 if p .policy then (\u03bb {sh} \u2192 just (Propose  p , ScriptObj sh)) else nothing)\n                (fromList txGovProposals)\n  where\n    open TxBody txb\n    open GovVote\n    open RwdAddr\n    open GovProposal\n\nvalContext : TxInfo \u2192 ScriptPurpose \u2192 Data\nvalContext txinfo sp = toData (txinfo , sp)\n\ntxOutToDataHash : TxOut \u2192 Maybe DataHash\ntxOutToDataHash (_ , _ , d , _) = d &gt;&gt;= isInj\u2082\n\ntxOutToP2Script\n  : UTxO \u2192 Tx\n  \u2192 TxOut \u2192 Maybe P2Script\ntxOutToP2Script utxo tx (a , _) =\n  do sh \u2190 isScriptObj (payCred a)\n     s  \u2190 lookupScriptHash sh tx utxo\n     toP2Script s\n\nopaque\n  collectP2ScriptsWithContext\n    : PParams \u2192 Tx \u2192 UTxO\n    \u2192 List (P2Script \u00d7 List Data \u00d7 ExUnits \u00d7 CostModel)\n  collectP2ScriptsWithContext pp tx utxo\n    = setToList\n    $ mapPartial (\u03bb (sp , c) \u2192 if isScriptObj c\n                                then (\u03bb {sh} \u2192 toScriptInput sp sh)\n                                else nothing)\n    $ credsNeeded utxo (tx .Tx.body)\n    where\n      toScriptInput\n        : ScriptPurpose \u2192 ScriptHash\n        \u2192 Maybe (P2Script \u00d7 List Data \u00d7 ExUnits \u00d7 CostModel)\n      toScriptInput sp sh =\n        do s \u2190 lookupScriptHash sh tx utxo\n           p2s \u2190 toP2Script s\n           (rdmr , exunits) \u2190 indexedRdmrs tx sp\n           let data'     = maybe [_] [] (getDatum tx utxo sp) ++ rdmr \u2237 [ valContext (txInfo (language p2s) pp utxo tx) sp ]\n               costModel = PParams.costmdls pp\n           just (p2s , data' , exunits , costModel)\n\nevalP2Scripts : List (P2Script \u00d7 List Data \u00d7 ExUnits \u00d7 CostModel) \u2192 Bool\nevalP2Scripts = all (\u03bb (s , d , eu , cm) \u2192 runPLCScript cm s eu d)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Script.html","title":"Script","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\n\nmodule Ledger.Conway.Specification.Script\n  (cs : _) (open CryptoStructure cs)\n  (es : _) (open EpochStructure es)\n  where\n\nopen import Ledger.Conway.Specification.Script.Base cs es public\nopen import Ledger.Conway.Specification.Script.Timelock cs es public\n</code></pre>"},{"location":"Ledger.Conway.Specification.Test.Examples.HelloWorld.html","title":"HelloWorld","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\nopen import Ledger.Conway.Specification.Test.Prelude\n\nmodule Ledger.Conway.Specification.Test.Examples.HelloWorld where\n\nscriptImp : ScriptImplementation String String\nscriptImp = record { serialise = id ;\n                     deserialise = \u03bb x \u2192 just x ;\n                     toData' = \u03bb x \u2192 \"dummy\" }\n\nopen import Ledger.Conway.Specification.Test.LedgerImplementation String String scriptImp\nopen import Ledger.Conway.Specification.Test.Lib String String scriptImp\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Transaction\nopen TransactionStructure SVTransactionStructure\nopen import Ledger.Core.Specification.Epoch\nopen EpochStructure SVEpochStructure\nopen Implementation\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational SVTransactionStructure SVAbstractFunctions\n\n-- true if redeemer is \"Hello World\"\nhelloWorld' : Maybe String \u2192 Maybe String \u2192 Bool\nhelloWorld' _ (just s) = \u230a (s \u225f \"Hello World\") \u230b\nhelloWorld' _ _ = false\n\nhelloWorld : PlutusScript\nhelloWorld = 777 , applyScript helloWorld'\n\ninitEnv : UTxOEnv\ninitEnv = createEnv 0\n\ninitTxOut : TxOut\ninitTxOut = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 777 ;\n                           stake = just (ScriptObj 777) })\n                           , 10 , nothing , nothing\n\nscript : TxIn \u00d7 TxOut\nscript = (6 , 6) , initTxOut\n\ninitState : UTxO\ninitState = fromList' (script \u2237 (createInitUtxoState 5 1000000000000))\n\nsucceedTx : Tx\nsucceedTx = record { body = record\n                         { txIns = Ledger.Prelude.fromList ((6 , 6) \u2237 (5 , 5) \u2237 [])\n                         ; refInputs = \u2205\n                         ; collateralInputs = Ledger.Prelude.fromList ((5 , 5) \u2237 [])\n                         ; txOuts = fromListIx ((6 , initTxOut)\n                                               \u2237 (5\n                                                 , ((inj\u2081 (record { net = 0 ;\n                                                                    pay = KeyHashObj 5 ;\n                                                                    stake = just (KeyHashObj 5) }))\n                                                 , (1000000000000 - 10000000000) , nothing , nothing))\n                                               \u2237 [])\n                         ; txFee = 10000000000\n                         ; mint = 0\n                         ; txVldt = nothing , nothing\n                         ; txCerts = []\n                         ; txWithdrawals = \u2205\n                         ; txGovVotes = []\n                         ; txGovProposals = []\n                         ; txDonation = 0\n                         ; txADhash = nothing\n                         ; txNetworkId = just 0\n                         ; currentTreasury = nothing\n                         ; txId = 7\n                         ; reqSignerHashes = \u2205\n                         ; scriptIntegrityHash = nothing\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((5 , 12) \u2237 []) ;\n                                -- signature now is first number + txId \u2261 second number\n                                -- first number is needs to be the id for the script\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 helloWorld) \u2237 []) ;\n                                txdats = \u2205 ;\n                                txrdmrs = fromList\u1d50 (((Spend , 6) , \"Hello World\" , (5 , 5)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n\nfailTx : Tx\nfailTx = record { body = record\n                         { txIns = Ledger.Prelude.fromList ((6 , 6) \u2237 [])\n                         ; refInputs = \u2205\n                         ; collateralInputs = \u2205\n                         ; txOuts = \u2205\n                         ; txFee = 10\n                         ; mint = 0\n                         ; txVldt = nothing , nothing\n                         ; txCerts = []\n                         ; txWithdrawals = \u2205\n                         ; txGovVotes = []\n                         ; txGovProposals = []\n                         ; txDonation = 0\n                         ; txADhash = nothing\n                         ; txNetworkId = just 0\n                         ; currentTreasury = nothing\n                         ; txId = 7\n                         ; reqSignerHashes = \u2205\n                         ; scriptIntegrityHash = nothing\n                         } ;\n                wits = record { vkSigs = \u2205 ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 helloWorld) \u2237 []) ;\n                                txdats = \u2205 ;\n                                txrdmrs = fromList\u1d50 (((Spend , 6) , \"Hello World!\" , (5 , 5)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n\nsucceedState : List (P2Script \u00d7 List Implementation.Data \u00d7 Implementation.ExUnits \u00d7 Implementation.CostModel)\nsucceedState = (collectP2ScriptsWithContext (UTxOEnv.pparams initEnv) succeedTx initState)\n\nevalSucceedScript : Bool\nevalSucceedScript = evalP2Scripts succeedState\n\nfailState : List (P2Script \u00d7 List Implementation.Data \u00d7 Implementation.ExUnits \u00d7 Implementation.CostModel)\nfailState = (collectP2ScriptsWithContext (UTxOEnv.pparams initEnv) failTx initState)\n\nevalFailScript : Bool\nevalFailScript = evalP2Scripts failState\n\nopaque\n  unfolding Computational-UTXO\n  unfolding collectP2ScriptsWithContext\n  unfolding setToList\n  unfolding outs\n\n  _ : notEmpty succeedState \u2261 \u22a4\n  _ = refl\n\n  -- need to check that the state is non-empty otherwise evalP2Scripts will always return true\n  _ : notEmpty succeedState \u2261 \u22a4\n  _ = refl\n\n  _ : evalSucceedScript \u2261 true\n  _ = refl\n\n  _ : notEmpty failState \u2261 \u22a4\n  _ = refl\n\n  _ : evalFailScript \u2261 false\n  _ = refl\n\n  -- Compute the result of running the UTXO rules on the succeedTx transaction\n  succeedExample : ComputationResult String UTxOState\n  succeedExample = UTXO-step initEnv \u27e6 initState , 0 , \u2205 , 0 \u27e7  succeedTx\n\n  _ : isSuccess succeedExample \u2261 true\n  _  = refl\n\n  -- Compute the result of running the UTXO rules on the failTx transaction\n  failExample : ComputationResult String UTxOState\n  failExample = UTXO-step initEnv \u27e6 initState , 0 , \u2205 , 0 \u27e7  failTx\n\n  _ : isFailure failExample\n  _ = _ , refl\n</code></pre>"},{"location":"Ledger.Conway.Specification.Test.Examples.SucceedIfNumber.html","title":"SucceedIfNumber","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\nopen import Ledger.Conway.Specification.Test.Prelude\n\nmodule Ledger.Conway.Specification.Test.Examples.SucceedIfNumber where\n\nscriptImp : ScriptImplementation \u2115 \u2115\nscriptImp = record { serialise = id ;\n                     deserialise = \u03bb x \u2192 just x ;\n                     toData' = \u03bb x \u2192 9999999 }\n\nopen import Ledger.Conway.Specification.Test.LedgerImplementation \u2115 \u2115 scriptImp\nopen import Ledger.Conway.Specification.Test.Lib \u2115 \u2115 scriptImp\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Transaction\nopen TransactionStructure SVTransactionStructure\nopen import Ledger.Core.Specification.Epoch\nopen EpochStructure SVEpochStructure\nopen Implementation\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational SVTransactionStructure SVAbstractFunctions\n\n-- succeed if the datum is 1\nsucceedIf1Datum' : Maybe \u2115 \u2192 Maybe \u2115 \u2192 Bool\nsucceedIf1Datum' (just (suc zero)) _ = true\nsucceedIf1Datum' _ _ = false\n\nsucceedIf1Datum : PlutusScript\nsucceedIf1Datum = 777 , applyScript succeedIf1Datum'\n\n--succeed if the redeemer is 1\nsucceedIf1Redeemer' : Maybe \u2115 \u2192 Maybe \u2115 \u2192 Bool\nsucceedIf1Redeemer' _ (just (suc zero)) = true\nsucceedIf1Redeemer' _ _ = false\n\nsucceedIf1Redeemer : PlutusScript\nsucceedIf1Redeemer = 888 , applyScript succeedIf1Redeemer'\n\ninitEnv : UTxOEnv\ninitEnv = createEnv 0\n\n-- initTxOut for script with datum reference\ninitTxOut : TxOut\ninitTxOut = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 777 ;\n                           stake = just (ScriptObj 777) })\n                           , 10 , just (inj\u2082 1) , nothing\n\n-- initTxOut for script without datum reference\ninitTxOut' : TxOut\ninitTxOut' = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 888 ;\n                           stake = just (ScriptObj 888) })\n                           , 10 , nothing , nothing\n\nscriptDatum : TxIn \u00d7 TxOut\nscriptDatum = (6 , 6) , initTxOut\n\nscriptRedeemer : TxIn \u00d7 TxOut\nscriptRedeemer = (6 , 6) , initTxOut'\n\ninitStateDatum : UTxO\ninitStateDatum = fromList' (scriptDatum \u2237 (createInitUtxoState 5 1000000000000))\n\ninitStateRedeemer : UTxO\ninitStateRedeemer = fromList' (scriptRedeemer \u2237 (createInitUtxoState 5 1000000000000))\n\nsucceedTx : Tx\nsucceedTx = record { body = record\n                         { txIns = Ledger.Prelude.fromList ((6 , 6) \u2237 (5 , 5) \u2237 [])\n                         ; refInputs = \u2205\n                         ; collateralInputs = Ledger.Prelude.fromList ((5 , 5) \u2237 [])\n                         ; txOuts = fromListIx ((6 , initTxOut)\n                                                \u2237 (5\n                                                  , ((inj\u2081 (record { net = 0 ;\n                                                                     pay = KeyHashObj 5 ;\n                                                                     stake = just (KeyHashObj 5) }))\n                                                  , (1000000000000 - 10000000000) , nothing , nothing))\n                                                \u2237 [])\n                         ; txId = 7\n                         ; txCerts = []\n                         ; txFee = 10000000000\n                         ; txWithdrawals = \u2205\n                         ; txVldt = nothing , nothing\n                         ; txADhash = nothing\n                         ; txDonation = 0\n                         ; txGovVotes = []\n                         ; txGovProposals = []\n                         ; txNetworkId = just 0\n                         ; currentTreasury = nothing\n                         ; mint = 0\n                         ; reqSignerHashes = \u2205\n                         ; scriptIntegrityHash = nothing\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((5 , 12) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 succeedIf1Datum) \u2237 []) ;\n                                txdats = Ledger.Prelude.fromList (1 \u2237 []) ;\n                                txrdmrs = fromList\u1d50 (((Spend , 6) , 5 , (5 , 5)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n\nevalScriptDatum : Bool\nevalScriptDatum = evalP2Scripts (collectP2ScriptsWithContext (UTxOEnv.pparams initEnv) succeedTx initStateDatum)\n\nexampleDatum : Maybe Datum\nexampleDatum = getDatum succeedTx initStateDatum (Spend (6 , 6))\n\nfailTx : Tx\nfailTx = record { body = record\n                         { txIns = Ledger.Prelude.fromList ((6 , 6) \u2237 [])\n                         ; refInputs = \u2205\n                         ; collateralInputs = \u2205\n                         ; txOuts = \u2205\n                         ; txId = 7\n                         ; txCerts = []\n                         ; txFee = 10\n                         ; txWithdrawals = \u2205\n                         ; txVldt = nothing , nothing\n                         ; txADhash = nothing\n                         ; txDonation = 0\n                         ; txGovVotes = []\n                         ; txGovProposals = []\n                         ; txNetworkId = just 0\n                         ; currentTreasury = nothing\n                         ; mint = 0\n                         ; reqSignerHashes = \u2205\n                         ; scriptIntegrityHash = nothing\n                         } ;\n                wits = record { vkSigs = \u2205 ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 succeedIf1Redeemer) \u2237 []) ;\n                                txdats = \u2205 ;\n                                txrdmrs = fromList\u1d50 (((Spend , 6) , 1 , (5 , 5)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n\n\nevalScriptRedeemer : Bool\nevalScriptRedeemer = evalP2Scripts (collectP2ScriptsWithContext (UTxOEnv.pparams initEnv) failTx initStateRedeemer)\n\nexampleDatum' : Maybe Datum\nexampleDatum' = getDatum failTx initStateRedeemer (Spend (6 , 6))\n\nopaque\n  unfolding Computational-UTXO\n  unfolding collectP2ScriptsWithContext\n  unfolding setToList\n  unfolding outs\n\n  gotScript : lookupScriptHash 777 succeedTx initStateDatum \u2261 just (inj\u2082 succeedIf1Datum)\n  gotScript = refl\n\n  _ : exampleDatum \u2261 just 1\n  _ = refl\n\n  _ : exampleDatum' \u2261 nothing\n  _ = refl\n\n  _ : evalScriptDatum \u2261 true\n  _ = refl\n\n  _ : evalScriptRedeemer \u2261 true\n  _ = refl\n\n  -- Compute the result of running the UTXO rules on the succeedTx transaction\n  succeedExample : ComputationResult String UTxOState\n  succeedExample = UTXO-step initEnv \u27e6 initStateDatum , 0 , \u2205 , 0 \u27e7  succeedTx\n\n  _ : isSuccess succeedExample \u2261 true\n  _  = refl\n\n  -- Compute the result of running the UTXO rules on the failTx transaction\n  failExample : ComputationResult String UTxOState\n  failExample = UTXO-step initEnv \u27e6 initStateRedeemer , 0 , \u2205 , 0 \u27e7  failTx\n\n  _ : isFailure failExample\n  _ = _ , refl\n\n  -- Note that the UTXOS rule succeeds but the UTXO rule fails for failTx\n  failExampleS : Bool\n  failExampleS = case compute Computational-UTXOS initEnv \u27e6 initStateRedeemer , 0 , \u2205 , 0 \u27e7 failTx of \u03bb where\n    (success x) \u2192 true\n    (failure x) \u2192 false\n\n  _ : failExampleS \u2261 true\n  _ = refl\n\n  failExampleU : Bool\n  failExampleU = case compute Computational-UTXO initEnv \u27e6 initStateRedeemer , 0 , \u2205 , 0 \u27e7 failTx of \u03bb where\n    (success x) \u2192 true\n    (failure x) \u2192 false\n\n  _ : failExampleU \u2261 false\n  _ = refl\n</code></pre>"},{"location":"Ledger.Conway.Specification.Test.Examples.html","title":"Examples","text":"<pre><code>{-# OPTIONS --safe #-}\nmodule Ledger.Conway.Specification.Test.Examples where\n\nimport Ledger.Conway.Specification.Test.Examples.SucceedIfNumber\nimport Ledger.Conway.Specification.Test.Examples.HelloWorld\n</code></pre>"},{"location":"Ledger.Conway.Specification.Test.LedgerImplementation.html","title":"LedgerImplementation","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Test.Prelude\nopen import Prelude using (Type)\n\nmodule Ledger.Conway.Specification.Test.LedgerImplementation\n  (T D : Type)\n  (scriptImp : ScriptImplementation T D) (open ScriptImplementation scriptImp)\n  where\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\nimport      Data.Integer as \u2124\nopen import Data.Rational using (0\u211a; \u00bd)\nimport      Data.Rational as \u211a\nopen import Algebra.Morphism    using (module MonoidMorphisms)\nopen import Data.Nat.Properties using (+-0-commutativeMonoid)\nopen import Relation.Binary.Morphism.Structures\nopen import Algebra.Construct.DirectProduct\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Core.Specification.Epoch\nopen import Ledger.Conway.Specification.Gov.Base\n\nmodule _ {A : Type} \u2983 _ : DecEq A \u2984 \u2983 _ : Show A \u2984 where instance\n  \u2200Hashable : Hashable A A\n  \u2200Hashable = \u03bb where .hash \u2192 id\n\n  \u2200isHashableSet : isHashableSet A\n  \u2200isHashableSet = mkIsHashableSet A\n\ninstance\n  Hashable-\u22a4 : Hashable \u22a4 \u2115\n  Hashable-\u22a4 = \u03bb where .hash tt \u2192 0\n\nmodule Implementation where\n  Network          = \u2115\n  SlotsPerEpoch\u1d9c   = 100\n  ActiveSlotCoeff  = \u2124.1\u2124 \u211a./ 20\n  StabilityWindow\u1d9c = 10\n  RandomnessStabilisationWindow\u1d9c = 10\n  MaxLovelaceSupply\u1d9c = 1\n  Quorum           = 1\n  NetworkId        = 0\n\n  SKey = \u2115\n  VKey = \u2115\n  Sig  = \u2115\n  Ser  = \u2115\n\n  isKeyPair  = _\u2261_\n  sign       = _+_\n\n  Data         = D\n  Data\u02b0        = mkHashableSet Data\n  toData : \u2200 {A : Type} \u2192 A \u2192 D\n  toData = toData' -- fix this\n\n  PlutusScript = \u2115 \u00d7 (List Data \u2192 Bool)\n  ScriptHash = \u2115\n\n  ExUnits      = \u2115 \u00d7 \u2115\n  ExUnit-CommutativeMonoid =\n    Conversion.fromBundle (commutativeMonoid +-0-commutativeMonoid +-0-commutativeMonoid)\n  _\u2265\u1d49_ : ExUnits \u2192 ExUnits \u2192 Type\n  _\u2265\u1d49_ = _\u2261_\n  instance\n    Show-ExUnits : Show ExUnits\n    Show-ExUnits = Show-\u00d7\n\n  CostModel    = \u22a4 -- changed from \u22a5\n  Language     = \u22a4\n  LangDepView  = \u22a4\n  Prices       = \u22a4\n\n  TxId            = \u2115\n  Ix              = \u2115\n  AuxiliaryData   = \u2115\n  DocHash         = \u2115\n  tokenAlgebra    = Coin-TokenAlgebra\n    where open import Ledger.Conway.Specification.TokenAlgebra.Coin ScriptHash\n            using (Coin-TokenAlgebra)\n\n\nSVGlobalConstants = GlobalConstants \u220b record {Implementation}\nSVEpochStructure  = EpochStructure  \u220b \u2115EpochStructure SVGlobalConstants\ninstance _ = SVEpochStructure\n\nSVCryptoStructure : CryptoStructure\nSVCryptoStructure = record\n  { Implementation\n  ; pkk = SVPKKScheme\n  }\n  where\n  -- Dummy private key crypto scheme\n  SVPKKScheme : PKKScheme\n  SVPKKScheme = record\n    { Implementation\n    ; isSigned         = \u03bb a b m \u2192 \u22a4\n    ; sign             = \u03bb _ _ \u2192 zero\n    ; isSigned-correct = \u03bb where (sk , sk , refl) _ _ h \u2192 tt\n    }\n\ninstance _ = SVCryptoStructure\n\nopen import Ledger.Conway.Specification.Script it it\nopen import Ledger.Conway.Conformance.Script it it\n\nSVScriptStructure : ScriptStructure\nSVScriptStructure = record\n  { p1s = P1ScriptStructure-HTL\n  ; hashRespectsUnion = hashRespectsUnion\n  ; ps = SVP2ScriptStructure\n  }\n  where\n\n    instance Hashable-PlutusScript : Hashable Implementation.PlutusScript \u2115\n             Hashable-PlutusScript = record { hash = \u03bb x \u2192 proj\u2081 x }\n\n    hashRespectsUnion : \u2200 {A B \u210d}\n      \u2192 Hashable A \u210d \u2192 Hashable B \u210d\n      \u2192 Hashable (A \u228e B) \u210d\n    hashRespectsUnion ha hb = record { hash = \u03bb { (inj\u2081 x) \u2192 Hashable.hash ha x ; (inj\u2082 y) \u2192 Hashable.hash hb y }}\n\n    SVP2ScriptStructure : PlutusStructure\n    SVP2ScriptStructure =  record\n      { Implementation\n      ; validPlutusScript = \u03bb _ _ _ _ \u2192 \u22a4\n      }\n\ninstance _ = SVScriptStructure\n\nopen import Ledger.Conway.Specification.PParams it it it hiding (PParams)\n\nSVGovParams : GovParams\nSVGovParams = record\n  { Implementation\n  ; ppUpd = let open PParamsDiff in \u03bb where\n      .UpdateT                \u2192 \u22a4\n      .updateGroups           \u2192 \u03bb _ \u2192 \u2205\n      .applyUpdate            \u2192 \u03bb p _ \u2192 p\n      .ppWF?                  \u2192 \u2047 yes \u03bb _ \u2192 id\n  }\n\nSVGovStructure : GovStructure\nSVGovStructure = record\n  { Implementation\n  ; epochStructure  = SVEpochStructure\n  ; govParams       = SVGovParams\n  ; cryptoStructure = SVCryptoStructure\n  ; globalConstants = SVGlobalConstants\n  }\ninstance _ = SVGovStructure\n\nopen import Ledger.Conway.Specification.Gov.Actions it hiding (Vote; GovRole; VDeleg; Anchor)\nopen import Ledger.Conway.Conformance.Certs it hiding (StakePoolParams; DCert)\n\nSVTransactionStructure : TransactionStructure\nSVTransactionStructure = record\n  { Implementation\n  ; epochStructure  = SVEpochStructure\n  ; globalConstants = SVGlobalConstants\n  ; adHashingScheme = it\n  ; cryptoStructure = SVCryptoStructure\n  ; govParams       = SVGovParams\n  ; txidBytes       = id\n  ; scriptStructure = SVScriptStructure\n  }\ninstance _ = SVTransactionStructure\n\nopen import Ledger.Conway.Specification.Abstract it\nopen import Ledger.Conway.Specification.Gov it\n\nopen TransactionStructure it\n\nindexOfTxInImp : TxIn \u2192 \u2119 TxIn \u2192 Maybe Ix\nindexOfTxInImp x y = lookup\u1d50? (fromList\u1d50 (setToList y)) (proj\u2081 x)\n\nSVAbstractFunctions : AbstractFunctions\nSVAbstractFunctions = record\n  { Implementation\n  ; txscriptfee = \u03bb tt y \u2192 0\n  ; serSize     = \u03bb v \u2192 0 -- changed to 0\n  ; indexOfImp  = record\n    { indexOfDCert    = \u03bb _ _ \u2192 nothing\n    ; indexOfRwdAddr  = \u03bb _ _ \u2192 nothing\n    ; indexOfTxIn     = indexOfTxInImp\n    ; indexOfPolicyId = \u03bb _ _ \u2192 nothing\n    ; indexOfVote     = \u03bb _ _ \u2192 nothing\n    ; indexOfProposal = \u03bb _ _ \u2192 nothing\n    }\n  ; runPLCScript = \u03bb { x x\u2081 x\u2082 x\u2083 \u2192 proj\u2082 x\u2081 x\u2083 }\n  ; scriptSize = \u03bb _ \u2192 0\n  }\ninstance _ = SVAbstractFunctions\n</code></pre>"},{"location":"Ledger.Conway.Specification.Test.Lib.html","title":"Lib","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (fromList; \u03b5; _/_); open Computational\nopen import Ledger.Conway.Specification.Test.Prelude\n\nmodule Ledger.Conway.Specification.Test.Lib (A D : Type)\n  (scriptImp : ScriptImplementation A D) (open ScriptImplementation scriptImp)\n  where\n\nopen import Ledger.Conway.Specification.Test.LedgerImplementation A D scriptImp\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Transaction\nopen TransactionStructure SVTransactionStructure\nopen import Ledger.Core.Specification.Epoch\nopen import Ledger.Prelude.Numeric using (mkUnitInterval; mk\u2115\u207a)\nopen EpochStructure SVEpochStructure\nopen import Data.Integer using (\u2124; +_)\nopen import Data.Rational using (\u00bd; 1\u211a ; mk\u211a+ ; _/_)\nopen import Data.Nat.Coprimality using (Coprime; gcd\u22611\u21d2coprime)\nopen Implementation\n\ncreateEnv : \u2115 \u2192 UTxOEnv\ncreateEnv s = record { slot = s ; treasury = 0 ;\n                   pparams = record\n                               { maxBlockSize = 90112\n                               ; maxTxSize = 16384\n                               ; maxHeaderSize = 1100\n                               ; maxValSize = 5000\n                               ; maxCollateralInputs = 3\n                               ; pv = 8 , 0\n                               ; maxTxExUnits = 10000000000 , 14000000\n                               ; maxBlockExUnits = 40000000000 , 62000000\n                               ; a = 44\n                               ; b = 155381\n                               ; minUTxOValue = 0\n                               ; poolDeposit = 500000000 -- lovelace\n                               ; keyDeposit = 500000000 -- lovelace\n                               ; monetaryExpansion = mkUnitInterval (+ 3 / 1000)\n                               ; treasuryCut = mkUnitInterval (+ 2 / 10)\n                               ; coinsPerUTxOByte = 0  --lovelace\n                               -- ^^^ was 4310, but that value resulted in failed tests once\n                               -- we replaced `minUTxOValue` with `coinsPerUTxOByte`; see `HelloWorld.agda`\n                               -- line 153: `isSuccess succeedExample \u2261 true`\n                               ; minFeeRefScriptCoinsPerByte = mk\u211a+ 15 1 (gcd\u22611\u21d2coprime refl) -- see [1]\n                               ; prices = tt -- fix this\n                               ; maxRefScriptSizePerTx = 200 * 1024 -- 200KiB\n                               ; maxRefScriptSizePerBlock = 1024 * 1024 -- 1MiB\n                               ; refScriptCostStride  = mk\u2115\u207a 25\n                               ; refScriptCostMultiplier = mk\u211a+ 6 5 (gcd\u22611\u21d2coprime refl) -- see [1]\n                               ; a0 = 1\u211a -- don't know\n                               ; Emax = 18\n                               ; nopt = 0 -- don't know\n                               ; collateralPercentage = 150\n                               ; costmdls = tt -- fix this\n                               ; drepThresholds = record -- unknown so setting all to 50%\n                                                    { P1 = \u00bd\n                                                    ; P2a = \u00bd\n                                                    ; P2b = \u00bd\n                                                    ; P3 = \u00bd\n                                                    ; P4 = \u00bd\n                                                    ; P5a = \u00bd\n                                                    ; P5b = \u00bd\n                                                    ; P5c = \u00bd\n                                                    ; P5d = \u00bd\n                                                    ; P6 = \u00bd\n                                                    }\n                               ; poolThresholds = record\n                                                    { Q1 = \u00bd\n                                                    ; Q2a = \u00bd\n                                                    ; Q2b = \u00bd\n                                                    ; Q4 = \u00bd\n                                                    ; Q5 = \u00bd\n                                                    }\n                               ; govActionLifetime = 10 -- unknown\n                               ; govActionDeposit = 1000000 -- unknown (set to 1 ada)\n                               ; drepDeposit = 1000000 -- unknown (set to 1 ada)\n                               ; drepActivity = 13 -- unknown\n                               ; ccMinSize = 10 -- unknown\n                               ; ccMaxTermLength = 73 -- unknown set to 1 year (73 epochs)\n                               } }\n\ncreateUTxO : (index : \u2115)\n           \u2192 (wallet : \u2115)\n           \u2192 (value : Value)\n           \u2192 Maybe (D \u228e DataHash)\n           \u2192 TxIn \u00d7 TxOut\ncreateUTxO index wallet value d = (index , index)\n                                , (inj\u2081 (record { net = 0 ; pay = KeyHashObj wallet ; stake = just (KeyHashObj wallet) })\n                                  , value , d , nothing)\n\ncreateInitUtxoState : (wallets : \u2115)\n                    \u2192 (value : Value)\n                    \u2192 List (TxIn \u00d7 TxOut)\ncreateInitUtxoState zero value = []\ncreateInitUtxoState (suc wallet) value = createUTxO (suc wallet) (suc wallet) value nothing\n                                         \u2237 createInitUtxoState wallet value\n\nfromList' : List (TxIn \u00d7 TxOut) \u2192 UTxO\nfromList' = fromList\u1d50\n\nfromListIx : List (Implementation.Ix \u00d7 TxOut) \u2192 Implementation.Ix \u21c0 TxOut\nfromListIx = fromList\u1d50\n\napplyScript : (Maybe D \u2192 Maybe D \u2192 Bool) \u2192 List D \u2192 Bool\napplyScript f [] = f nothing nothing\napplyScript f (_ \u2237 []) = f nothing nothing\napplyScript f (redeemer \u2237 valcontext \u2237 []) = f nothing (just redeemer)\napplyScript f (datum \u2237 redeemer \u2237 valcontext \u2237 _) = f (just datum) (just redeemer)\n\nnotEmpty : \u2200 {A : Type} \u2192 List A \u2192 Type\nnotEmpty [] = \u22a5\nnotEmpty (x \u2237 xs) = \u22a4\n\nisSuccess : ComputationResult String UTxOState \u2192 Bool\nisSuccess (success x) = true\nisSuccess (failure x) = false\n\n-- [1] https://github.com/IntersectMBO/cardano-ledger/blob/master/docs/adr/2024-08-14_009-refscripts-fee-change.md\n</code></pre>"},{"location":"Ledger.Conway.Specification.Test.Prelude.html","title":"Prelude","text":"<pre><code>{-# OPTIONS --safe #-}\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\n\nmodule Ledger.Conway.Specification.Test.Prelude where\n\nrecord ScriptImplementation (T D : Type) : Type\u2081 where\n  field serialise : T \u2192 D\n        deserialise : D \u2192 Maybe T\n        toData' : \u2200 {A : Type} \u2192 A \u2192 D -- fix this\n        \u2983 DecEq-Data  \u2984    : DecEq D\n        \u2983 Show-Data  \u2984     : Show D\n</code></pre>"},{"location":"Ledger.Conway.Specification.TokenAlgebra.Coin.html","title":"Coin","text":"<pre><code>{-# OPTIONS --safe #-}\nopen import Ledger.Prelude\n\nmodule Ledger.Conway.Specification.TokenAlgebra.Coin (X : Type) where\n\nopen import Algebra.Morphism.Construct.Identity\n  using (isMonoidHomomorphism)\n\nopen import Ledger.Conway.Specification.TokenAlgebra.Base X\n\nopen TokenAlgebra\n\nCoin-TokenAlgebra : TokenAlgebra\nCoin-TokenAlgebra = \u03bb where\n  .Value                      \u2192 Coin\n  .Value-CommutativeMonoid    \u2192 it\n    -- ^ Agda bug? Without this line, `coinIsMonoidHomomorphism` doesn't type check anymore\n  .coin                       \u2192 id\n  .inject                     \u2192 id\n  .policies                   \u2192 \u03bb _ \u2192 \u2205\n  .size                       \u2192 \u03bb x \u2192 1 -- there is only ada in this token algebra\n  ._\u2264\u1d57_                       \u2192 _\u2264_\n  .coin\u2218inject\u2257id             \u2192 \u03bb _ \u2192 refl\n  .coinIsMonoidHomomorphism   \u2192 isMonoidHomomorphism _ refl\n</code></pre>"},{"location":"Ledger.Conway.Specification.TokenAlgebra.ValueVector.html","title":"ValueVector","text":"<pre><code>{-# OPTIONS --safe #-}\nopen import Ledger.Prelude hiding (_\u2219_; \u03b5)\n\nmodule Ledger.Conway.Specification.TokenAlgebra.ValueVector (PolicyId : Type) (n : \u2115) where\n\nimport Algebra as Alg\nopen import Algebra.Construct.DirectProduct\nopen import stdlib.Algebra.Morphism.Construct.DirectProduct\nopen import Data.Nat.Properties using (+-0-commutativeMonoid)\nimport Data.Product.Relation.Binary.Pointwise.NonDependent as Product\nopen import Data.Vec as Vec\n  hiding (fromList)\nimport stdlib.Data.Vec.Instances as Vec\nimport Data.Vec.Relation.Binary.Pointwise.Inductive as Vec\n\nopen import Ledger.Conway.Specification.TokenAlgebra.Base PolicyId\n\nQuantity = \u2115\n\nVec-commutativeMonoid = Vec.commutativeMonoid n +-0-commutativeMonoid\n\nmodule +-0-commutativeMonoid = Alg.CommutativeMonoid +-0-commutativeMonoid\nmodule Vec-commutativeMonoid = Alg.CommutativeMonoid Vec-commutativeMonoid\n\nmodule _ (Policies : Vec PolicyId n) where\n  Value-TokenAlgebra : TokenAlgebra\n  Value-TokenAlgebra = record {go}\n    where\n      module go where\n        Value : Type\n        Value = Coin \u00d7 Vec Quantity n\n\n        Value-CommutativeMonoid : CommutativeMonoid 0\u2113 0\u2113 Value\n        Value-CommutativeMonoid = Conversion.fromBundle (commutativeMonoid +-0-commutativeMonoid Vec-commutativeMonoid)\n\n        coin : Value \u2192 Coin\n        coin = proj\u2081\n\n        inject : Coin \u2192 Value\n        inject c = c , Vec.replicate n 0\n\n        policies                   = \u03bb _ \u2192 fromList (toList Policies)\n        size                       = \u03bb _ \u2192 1 + n\n        _\u2264\u1d57_                       = Product.Pointwise _\u2264_ (Vec.Pointwise _\u2264_)\n\n        coin\u2218inject\u2257id             = \u03bb _ \u2192 refl\n        coinIsMonoidHomomorphism   = Monoid-Export.proj\u2081 {refl = refl}\n\n        Dec-\u2264\u1d57 : _\u2264\u1d57_ \u2047\u00b2\n        Dec-\u2264\u1d57 {(c\u2081 , v\u2081)} {(c\u2082 , v\u2082)} = Dec-\u00d7 \u2983 \u2115-Dec-\u2264 \u2984 \u2983 \u2047 Vec.decidable dec\u00b2 v\u2081 v\u2082 \u2984\n</code></pre>"},{"location":"Ledger.Conway.Specification.Transaction.html","title":"Transactions","text":"<p>A transaction consists of a transaction body, a collection of witnesses and some optional auxiliary data.</p> <p>Here are some key components of the transaction body.</p> <ul> <li> <p><code>txIns</code> denotes a set of transaction inputs; each input consists of a    transaction id and an index that points to a unique output from a previous transaction.</p> </li> <li> <p><code>txOuts</code> denotes an indexed collection of transaction outputs; each output    consists of an address and a coin value.</p> </li> <li> <p><code>txFee</code> denotes a transaction fee to be added to the fee pot.</p> </li> <li> <p><code>txId</code> denotes the hash of the serialized form of the    transaction---the form in which the transaction is included in a block.</p> </li> </ul> <p>In addition to these, the Conway era introduces some new fields to the transaction body.</p> <ul> <li> <p><code>txGovVotes</code> denotes the list of votes for governance actions.</p> </li> <li> <p><code>txGovProposals</code> denotes the list of governance proposals.</p> </li> <li> <p><code>txDonation</code> denotes the amount of <code>Coin</code> to donate to    treasury, e.g., to return funds to the treasury after a governance action.</p> </li> <li> <p><code>currentTreasury</code> denotes the current value of the treasury; this serves    as a precondition to executing Plutus scripts that access the value of the treasury.</p> </li> </ul>"},{"location":"Ledger.Conway.Specification.Transaction.html#transaction-types","title":"Transaction Types","text":"<pre><code>record TransactionStructure : Type\u2081 where\n  field\n</code></pre> <p>Abstract types <pre><code>    Ix TxId AuxiliaryData : Type\n</code></pre></p> <p>Derived types <pre><code>  TxIn               = TxId \u00d7 Ix\n  TxOut              = Addr \u00d7 Value \u00d7 Maybe (Datum \u228e DataHash) \u00d7 Maybe Script\n  UTxO               = TxIn \u21c0 TxOut\n  RdmrPtr            = Tag \u00d7 Ix\n  ProposedPPUpdates  = KeyHash \u21c0 PParamsUpdate\n  Update             = ProposedPPUpdates \u00d7 Epoch\n</code></pre></p> <p>Transaction types <pre><code>  record TxBody : Type where\n    field\n      txIns                : \u2119 TxIn\n      refInputs            : \u2119 TxIn\n      collateralInputs     : \u2119 TxIn\n      txOuts               : Ix \u21c0 TxOut\n      txId                 : TxId\n      txCerts              : List DCert\n      txFee                : Fees\n      txWithdrawals        : Withdrawals\n      txVldt               : Maybe Slot \u00d7 Maybe Slot\n      txADhash             : Maybe ADHash\n      txDonation           : Donations\n      txGovVotes           : List GovVote\n      txGovProposals       : List GovProposal\n      txNetworkId          : Maybe Network\n      currentTreasury      : Maybe Treasury\n      mint                 : Value\n      reqSignerHashes      : \u2119 KeyHash\n      scriptIntegrityHash  : Maybe ScriptHash\n      -- txup              : Maybe Update   -- deprecated; leave for now\n</code></pre></p> <pre><code>  record TxWitnesses : Type where\n    field\n      vkSigs   : VKey \u21c0 Sig\n      scripts  : \u2119 Script\n      txdats   : \u2119 Datum\n      txrdmrs  : RdmrPtr  \u21c0 Redeemer \u00d7 ExUnits\n\n    scriptsP1 : \u2119 P1Script\n    scriptsP1 = mapPartial toP1Script scripts\n\n  record Tx : Type where\n    field\n      body     : TxBody\n      wits     : TxWitnesses\n      txsize   : \u2115\n      isValid  : Bool\n      txAD     : Maybe AuxiliaryData\n</code></pre>"},{"location":"Ledger.Conway.Specification.Transaction.html#transaction-functions","title":"Transaction Functions","text":"<pre><code>  getValue : TxOut \u2192 Value\n  getValue (_ , v , _) = v\n\n  TxOut\u02b0 = Addr \u00d7 Value \u00d7 Maybe (Datum \u228e DataHash) \u00d7 Maybe ScriptHash\n\n  txOutHash : TxOut \u2192 TxOut\u02b0\n  txOutHash (a , v , d , s) = a , (v , (d , M.map hash s))\n\n  getValue\u02b0 : TxOut\u02b0 \u2192 Value\n  getValue\u02b0 (_ , v , _) = v\n\n  txInsVKey : \u2119 TxIn \u2192 UTxO \u2192 \u2119 TxIn\n  txInsVKey txIns utxo = txIns \u2229 dom (utxo \u2223^' (isVKeyAddr \u2218 proj\u2081))\n\n  scriptOuts : UTxO \u2192 UTxO\n  scriptOuts utxo = filter (\u03bb (_ , addr , _) \u2192 isScriptAddr addr) utxo\n\n  txInsScript : \u2119 TxIn \u2192 UTxO \u2192 \u2119 TxIn\n  txInsScript txIns utxo = txIns \u2229 dom (proj\u2081 (scriptOuts utxo))\n\n  refScripts : Tx \u2192 UTxO \u2192 \u2119 Script\n  refScripts tx utxo =\n    mapPartial (proj\u2082 \u2218 proj\u2082 \u2218 proj\u2082) (range (utxo \u2223 (txIns \u222a refInputs)))\n    where open Tx; open TxBody (tx .body)\n\n  txscripts : Tx \u2192 UTxO \u2192 \u2119 Script\n  txscripts tx utxo = scripts (tx .wits) \u222a refScripts tx utxo\n    where open Tx; open TxWitnesses\n\n  lookupScriptHash : ScriptHash \u2192 Tx \u2192 UTxO \u2192 Maybe Script\n  lookupScriptHash sh tx utxo = lookup\u1d50? m sh\n    where m = setToMap (map\u02e2 &lt; hash , id &gt; (txscripts tx utxo))\n</code></pre>"},{"location":"Ledger.Conway.Specification.Types.GovStructure.html","title":"GovStructure","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Types.GovStructure where\n\nopen import Prelude using (Type)\nopen import Class.DecEq\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Script.Base\nopen import Ledger.Core.Specification.Epoch\nimport Ledger.Conway.Specification.PParams\n\nrecord GovStructure : Type\u2081 where\n  field TxId DocHash : Type\n        \u2983 DecEq-TxId \u2984 : DecEq TxId\n\n  field cryptoStructure : _\n  open CryptoStructure cryptoStructure public\n\n  field epochStructure : _\n  open EpochStructure epochStructure public\n\n  field scriptStructure : ScriptStructure cryptoStructure epochStructure\n  open ScriptStructure scriptStructure public\n\n  open Ledger.Conway.Specification.PParams cryptoStructure epochStructure scriptStructure public\n\n  field govParams : GovParams\n  open GovParams govParams public\n\n  field globalConstants : _\n  open GlobalConstants globalConstants public\n\n  open import Ledger.Core.Specification.Address Network KeyHash ScriptHash public\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.Base.html","title":"Base","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Utxo.Properties.Base\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Prelude; open Equivalence\nopen import Ledger.Prelude hiding (\u2264-trans; \u2264-antisym; All); open Properties\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Utxo txs abs\n\nopen import Tactic.EquationalReasoning using (module \u2261-Reasoning)\nopen import Tactic.Cong using (cong!)\nopen import stdlib-meta.Tactic.MonoidSolver.NonNormalising using (solve-macro)\n\nopen import Data.Nat.Properties hiding (_\u225f_)\nimport Data.Nat as \u2115\nimport Data.Integer as \u2124\nopen import Data.Integer.Properties as Int\n  using ( +-injective; n\u2296n\u22610; distrib\u02b3-\u2296-+-pos; \u2296-swap; pos-+; \u2296-\u2265\n        ; m-n\u2261m\u2296n; +-inverse\u02e1)\n\nopen import Relation.Binary             using (IsEquivalence)\n\nopen import Algebra.Morphism              using (module MonoidMorphisms; IsMagmaHomomorphism)\nopen import Algebra.Definitions.RawMagma +-rawMagma using () renaming (_,_ to _,\u2264_)\n\n\nposPart-negPart\u2261x : {x : \u2124} \u2192 posPart x - negPart x \u2261 x\nposPart-negPart\u2261x {\u2124.+_ n}     = refl\nposPart-negPart\u2261x {\u2124.negsuc n} = refl\n\n\u03c7 : Bool \u2192 \u2115\n\u03c7 false  = 0\n\u03c7 true   = 1\n\nopen MonoidMorphisms.IsMonoidHomomorphism\nprivate\n  \u2219-homo-Coin = IsMagmaHomomorphism.homo (isMagmaHomomorphism coinIsMonoidHomomorphism)\n\nmodule _\n  {txb : _} (open TxBody txb)\n  {utxo : UTxO}\n  where\n  opaque\n    unfolding outs\n    open Tactic.EquationalReasoning.\u2261-Reasoning {A = \u2115} (solve-macro (quoteTerm +-0-monoid))\n\n    newTxid\u21d2disj : txId \u2209 map\u02e2 proj\u2081 (dom utxo)\n                \u2192 disjoint' (dom utxo) (dom (outs txb))\n    newTxid\u21d2disj id\u2209utxo = disjoint\u21d2disjoint' \u03bb h h' \u2192 id\u2209utxo $ to \u2208-map\n      (-, (case from \u2208-map h' of \u03bb where\n            (_ , refl , h'') \u2192 case from \u2208-map h'' of \u03bb where (_ , refl , _) \u2192 refl) , h)\n\n    consumedCoinEquality : \u2200 {utxoState} {pp}\n      \u2192 coin mint \u2261 0\n      \u2192 coin (consumed pp utxoState txb)\n      \u2261 cbalance ((UTxOState.utxo utxoState) \u2223 txIns) + depositRefunds pp utxoState txb + getCoin txWithdrawals\n    consumedCoinEquality {utxoState} {pp} h =\n      let  utxo = UTxOState.utxo utxoState\n           dRefs = depositRefunds pp utxoState txb\n           sWdls = getCoin txWithdrawals\n      in begin\n      coin (balance (utxo \u2223 txIns) + mint + inject dRefs + inject sWdls)\n        \u2261\u27e8 \u2219-homo-Coin _ _ \u27e9\n      coin (balance (utxo \u2223 txIns) + mint + inject dRefs) + coin (inject $ sWdls)\n        \u2261\u27e8 cong (coin (balance (utxo \u2223 txIns) + mint + inject dRefs) +_) (coin\u2218inject\u2257id _) \u27e9\n      coin (balance (utxo \u2223 txIns) + mint + inject dRefs) + sWdls\n        \u2261\u27e8 cong (_+ sWdls) (\u2219-homo-Coin _ _) \u27e9\n      coin (balance (utxo \u2223 txIns) + mint) + coin (inject $ dRefs) + sWdls\n        \u2261\u27e8 cong (\u03bb u \u2192 coin (balance (utxo \u2223 txIns) + mint) + u + sWdls) (coin\u2218inject\u2257id _) \u27e9\n      coin (balance (utxo \u2223 txIns) + mint) + dRefs + sWdls\n        \u2261\u27e8 cong (\u03bb u \u2192 u + dRefs + sWdls) (\u2219-homo-Coin _ _) \u27e9\n      cbalance (utxo \u2223 txIns) + coin mint + dRefs + sWdls\n        \u2261\u27e8 cong (\u03bb x \u2192 cbalance (utxo \u2223 txIns) + x + dRefs + sWdls) h \u27e9\n      cbalance (utxo \u2223 txIns) + 0 + dRefs + sWdls\n        \u2261\u27e8 cong (\u03bb x \u2192 x + dRefs + sWdls) (+-identity\u02b3 (cbalance (utxo \u2223 txIns))) \u27e9\n      cbalance (utxo \u2223 txIns) + dRefs + sWdls\n        \u220e\n\n    producedCoinEquality : \u2200 {utxoState} {pp}\n      \u2192 coin (produced pp utxoState txb)\n      \u2261 cbalance (outs txb) + txFee + newDeposits pp utxoState txb + txDonation\n    producedCoinEquality {utxoState} {pp} =\n        begin\n      coin (balance (outs txb) + inject txFee\n        + inject (newDeposits pp utxoState txb) + inject txDonation)\n        \u2261\u27e8 \u2219-homo-Coin _ _ \u27e9\n      coin (balance (outs txb) + inject txFee\n        + inject (newDeposits pp utxoState txb)) + coin (inject txDonation)\n        \u2261\u27e8 cong (_+ coin (inject txDonation)) (begin\n          coin (balance (outs txb) + inject txFee\n            + inject (newDeposits pp utxoState txb))\n            \u2261\u27e8 \u2219-homo-Coin _ _ \u27e9\n          coin (balance (outs txb) +\u1d5b inject txFee)\n            \u2115.+ coin (inject (newDeposits pp utxoState txb))\n            \u2261\u27e8 cong! (coin\u2218inject\u2257id _) \u27e9\n          coin (balance (outs txb) +\u1d5b inject txFee)\n            \u2115.+ newDeposits pp utxoState txb\n            \u2261\u27e8 cong! (\u2219-homo-Coin _ _) \u27e9\n          coin (balance (outs txb)) \u2115.+ coin (inject txFee)\n            \u2115.+ newDeposits pp utxoState txb\n            \u2261\u27e8 cong (\u03bb x \u2192 cbalance (outs txb) + x + newDeposits pp utxoState txb)\n                  $ coin\u2218inject\u2257id txFee \u27e9\n          cbalance (outs txb) + txFee + newDeposits pp utxoState txb\n            \u220e\n        )\u27e9\n      cbalance (outs txb) + txFee\n        + newDeposits pp utxoState txb + coin (inject txDonation)\n        \u2261\u27e8 cong (cbalance (outs txb) + txFee + newDeposits pp utxoState txb +_)\n              $ coin\u2218inject\u2257id _ \u27e9\n      cbalance (outs txb) + txFee + newDeposits pp utxoState txb + txDonation\n        \u220e\n\n    balValueToCoin : \u2200 {utxoState} {pp}\n      \u2192 coin mint \u2261 0\n      \u2192 consumed pp utxoState txb \u2261 produced pp utxoState txb\n      \u2192 cbalance ((UTxOState.utxo utxoState) \u2223 txIns)\n      + depositRefunds pp utxoState txb + getCoin txWithdrawals\n      \u2261 cbalance (outs txb) + txFee + newDeposits pp utxoState txb + txDonation\n    balValueToCoin {utxoState} {pp} h h' = begin\n      cbalance ((UTxOState.utxo utxoState) \u2223 txIns) + depositRefunds pp utxoState txb + getCoin txWithdrawals\n        \u2261\u02d8\u27e8 consumedCoinEquality {utxoState} {pp} h \u27e9\n      coin (consumed pp utxoState txb)\n        \u2261\u27e8 cong! h' \u27e9\n      coin (produced pp utxoState txb)\n        \u2261\u27e8 producedCoinEquality {utxoState} {pp} \u27e9\n      cbalance (outs txb) + txFee + newDeposits pp utxoState txb + txDonation\n        \u220e\n\nmodule _ {utxo utxo' : UTxO} where\n\n  opaque\n    unfolding balance\n    balance-cong :  \u2223 utxo \u2223 \u2261\u1d49 \u2223 utxo' \u2223 \u2192 balance utxo \u2248 balance utxo'\n    balance-cong eq = indexedSum\u1d50-cong {M = Value} {x = (mapValues txOutHash utxo) \u1da0\u1d50} {(mapValues txOutHash utxo') \u1da0\u1d50} (map-\u2261\u1d49 eq)\n\n    balance-cong-coin : \u2223 utxo \u2223 \u2261\u1d49 \u2223 utxo' \u2223 \u2192 cbalance utxo \u2261 cbalance utxo'\n    balance-cong-coin x =\n      coinIsMonoidHomomorphism .\u27e6\u27e7-cong (balance-cong x)\n      where open MonoidMorphisms.IsMonoidHomomorphism\n\n    balance-\u222a : disjoint (dom utxo) (dom utxo')\n                         \u2192 cbalance (utxo \u222a\u02e1 utxo') \u2261 cbalance utxo + cbalance utxo'\n    balance-\u222a h = begin\n      cbalance (utxo \u222a\u02e1 utxo')\n        \u2261\u27e8 \u27e6\u27e7-cong coinIsMonoidHomomorphism\n        $ indexedSum\u1d50-cong {f = getValue\u02b0 \u2218 proj\u2082} {x = (mapValues txOutHash (utxo \u222a\u02e1 utxo')) \u1da0\u1d50} {((mapValues txOutHash utxo) \u1da0\u1d50) \u222a\u02e1\u1da0 ((mapValues txOutHash utxo') \u1da0\u1d50)} (disjoint-\u222a\u02e1-mapValues {M = utxo} {utxo'} _ h)\n        \u27e9\n      coin (indexedSum\u1d50 _ (((mapValues txOutHash utxo) \u1da0\u1d50) \u222a\u02e1\u1da0 ((mapValues txOutHash utxo') \u1da0\u1d50)))\n        \u2261\u27e8 \u27e6\u27e7-cong coinIsMonoidHomomorphism\n         $ indexedSum\u1d50-\u222a {M = Value} {X = (mapValues txOutHash utxo) \u1da0\u1d50} {(mapValues txOutHash utxo') \u1da0\u1d50}\n         (\u03bb x x\u2081 \u2192 h (dom-map\u02b3\u2286 x) (dom-map\u02b3\u2286 x\u2081))\n         \u27e9\n      coin (balance utxo + balance utxo')\n        \u2261\u27e8 \u2219-homo-Coin _ _ \u27e9\n      cbalance utxo + cbalance utxo'\n        \u220e\n      where open Tactic.EquationalReasoning.\u2261-Reasoning {A = \u2115} (solve-macro (quoteTerm +-0-monoid))\n\n\nmodule _\n  {utxo utxo' : UTxO}\n  {fees fees' : Fees}\n  {deposits deposits' : Deposits}\n  {donations donations' : Donations}\n  {tx : Tx} (let open Tx tx renaming (body to txb); open TxBody txb)\n  {\u0393 : UTxOEnv}\n  (step  : \u0393 \u22a2 \u27e6 utxo  , fees  , deposits  , donations  \u27e7 \u21c0\u2987 tx ,UTXO\u2988\n               \u27e6 utxo' , fees' , deposits' , donations' \u27e7)\n  (h' : txId \u2209 map\u02e2 proj\u2081 (dom utxo))\n  where\n  open Tactic.EquationalReasoning.\u2261-Reasoning {A = \u2115} (solve-macro (quoteTerm +-0-monoid))\n\n  private\n    stepS : \u0393 \u22a2 \u27e6 utxo  , fees  , deposits  , donations  \u27e7 \u21c0\u2987 tx ,UTXOS\u2988\n                \u27e6 utxo' , fees' , deposits' , donations' \u27e7\n    stepS = case step of \u03bb where\n      (UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ h) \u2192 h\n\n    pp : PParams\n    pp = UTxOEnv.pparams \u0393\n    dep : Coin\n    dep = getCoin deposits\n    uDep : Coin\n    uDep = getCoin (updateDeposits pp txb deposits)\n    \u0394dep : \u2124\n    \u0394dep = depositsChange pp txb deposits\n    utxoSt : UTxOState\n    utxoSt = \u27e6 utxo , fees , deposits , donations \u27e7\n    ref tot : Coin\n    ref = depositRefunds pp utxoSt txb\n    wdls = getCoin txWithdrawals\n    tot = newDeposits    pp utxoSt txb\n    h : disjoint (dom (utxo \u2223 txIns \u1d9c)) (dom (outs txb))\n    h = \u03bb h\u2081 h\u2082 \u2192 \u2209-\u2205 $ proj\u2081 (newTxid\u21d2disj {txb} {utxo} h')\n                      $ to \u2208-\u2229 (res-comp-dom\u1d50 h\u2081 , h\u2082)\n    newBal' : \u0393 \u22a2 \u27e6 utxo  , fees  , deposits  , donations  \u27e7 \u21c0\u2987 tx ,UTXO\u2988\n                  \u27e6 utxo' , fees' , deposits' , donations' \u27e7\n            \u2192 consumed pp utxoSt txb \u2261 produced pp utxoSt txb\n    newBal' (UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ x _ _ _ _ _ _ _ _ _ _ _) = x\n    newBal : consumed pp utxoSt txb \u2261 produced pp utxoSt txb\n    newBal = newBal' step\n    noMintAda' : \u0393 \u22a2 \u27e6 utxo  , fees  , deposits  , donations  \u27e7 \u21c0\u2987 tx ,UTXO\u2988\n                     \u27e6 utxo' , fees' , deposits' , donations' \u27e7\n               \u2192 coin (mint) \u2261 0\n    noMintAda' (UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ x _ _ _ _ _ _ _ _ _ _) = x\n    noMintAda : coin mint \u2261 0\n    noMintAda = noMintAda' step\n    remDepTot : Coin\n    remDepTot = getCoin deposits - ref\n\n  deposits-change' : \u0394dep \u2261 tot - ref\n  deposits-change' = sym posPart-negPart\u2261x\n\n  dep-ref : tot \u2261 0 \u2192 uDep + ref \u2261 dep\n  dep-ref tot\u22610 = +-injective $ begin\n    \u2124.+_ (uDep + ref)          \u2261\u27e8 pos-+ uDep ref \u27e9\n    \u2124.+_ uDep \u2124.+ (ref - 0)    \u2261\u02d8\u27e8 cong (\u03bb u \u2192 \u2124.+_ uDep \u2124.+ (ref - u)) tot\u22610 \u27e9\n    \u2124.+_ uDep \u2124.+ (ref - tot)  \u2261\u27e8 cong ((\u2124.+ uDep) +_) (\u2296-swap ref tot) \u27e9\n    \u2124.+_ uDep \u2124.- (tot - ref)  \u2261\u02d8\u27e8 cong (\u03bb u \u2192  \u2124.+_ uDep \u2124.- u) deposits-change' \u27e9\n    \u2124.+_ uDep \u2124.- \u0394dep         \u2261\u02d8\u27e8 cong ((\u2124.+ uDep) +_) (\u2296-swap dep uDep) \u27e9\n    \u2124.+_ uDep + (dep - uDep)   \u2261\u27e8 Int.distrib\u02b3-\u2296-+-pos uDep dep uDep \u27e9\n    (uDep + dep) - uDep        \u2261\u27e8 cong (_- uDep) (+-comm uDep dep) \u27e9\n    (dep + uDep) - uDep        \u2261\u02d8\u27e8 Int.distrib\u02b3-\u2296-+-pos dep uDep uDep \u27e9\n    \u2124.+_ dep \u2124.+ (uDep - uDep) \u2261\u27e8 cong (\u03bb u \u2192 \u2124.+_ dep \u2124.+ u) (n\u2296n\u22610 uDep) \u27e9\n    \u2124.+_ dep \u2124.+ \u2124.0\u2124          \u2261\u27e8 Int.+-identity\u02b3 _ \u27e9\n    \u2124.+_ dep \u220e\n\n  ref-tot-0 : ref \u2262 0 \u2192 tot \u2261 0\n  ref-tot-0 ref\u22620 with \u0394dep\n  ... | \u2124.+_ n     = \u22a5-elim (ref\u22620 refl)\n  ... | \u2124.negsuc n = refl\n\n  ref\u2264dep : ref \u2264 dep\n  ref\u2264dep with ref \u225f 0\n  ... | no \u00acp = \u2264\u2033\u21d2\u2264 $ _ ,\u2264_ $ begin\n    ref + uDep \u2261\u27e8 +-comm ref uDep \u27e9\n    uDep + ref \u2261\u27e8 dep-ref $ ref-tot-0 \u00acp \u27e9\n    dep        \u220e\n  ... | yes p rewrite p = z\u2264n\n\n  deposits-change : uDep \u2261 dep + tot - ref\n  deposits-change = +-injective $ begin\n    \u2124.+_ uDep                                 \u2261\u02d8\u27e8 Int.+-identity\u02b3 _ \u27e9\n    \u2124.+_ uDep \u2124.+ \u2124.0\u2124                        \u2261\u02d8\u27e8 cong! (+-inverse\u02e1 (\u2124.+_ dep)) \u27e9\n    \u2124.+_ uDep \u2124.+ (\u2124.-_ (\u2124.+_ dep) \u2124.+ (\u2124.+_ dep))\n      \u2261\u02d8\u27e8 Int.+-assoc (\u2124.+_ uDep) (\u2124.-_ (\u2124.+_ dep)) (\u2124.+_ dep) \u27e9\n    (\u2124.+_ uDep \u2124.- (\u2124.+_ dep)) \u2124.+ (\u2124.+_ dep) \u2261\u27e8 cong! (m-n\u2261m\u2296n uDep dep) \u27e9\n    \u0394dep \u2124.+ (\u2124.+_ dep)                       \u2261\u27e8 Int.+-comm \u0394dep (\u2124.+_ dep) \u27e9\n    (\u2124.+_ dep) \u2124.+ \u0394dep                       \u2261\u27e8 cong! deposits-change' \u27e9\n    (\u2124.+_ dep) \u2124.+ (tot - ref)                \u2261\u27e8 distrib\u02b3-\u2296-+-pos dep tot ref \u27e9\n    (dep + tot) - ref                         \u2261\u27e8 \u2296-\u2265 (m\u2264n\u21d2m\u2264n+o tot ref\u2264dep) \u27e9\n    \u2124.+_ (dep + tot - ref) \u220e\n\n  split-balance : \u2200 keys \u2192 cbalance utxo \u2261 cbalance (utxo \u2223 keys \u1d9c) + cbalance (utxo \u2223 keys)\n  split-balance keys = begin\n                      cbalance utxo\n                        \u2261\u02d8\u27e8 balance-cong-coin {utxo = (utxo \u2223 keys \u1d9c) \u222a\u02e1 (utxo \u2223 keys)}{utxo}\n                          $ disjoint-\u222a\u02e1-\u222a (disjoint-sym res-ex-disjoint)\n                          \u2261\u1d49-\u2218 \u222a-sym\n                          \u2261\u1d49-\u2218 res-ex-\u222a (_\u2208? keys) \u27e9\n                      cbalance ((utxo \u2223 keys \u1d9c) \u222a\u02e1 (utxo \u2223 keys))\n                        \u2261\u27e8 balance-\u222a {utxo \u2223 keys \u1d9c} {utxo \u2223 keys} $ flip res-ex-disjoint \u27e9\n                      cbalance (utxo \u2223 keys \u1d9c) + cbalance (utxo \u2223 keys)\n                        \u220e\n    where open IsEquivalence \u2261\u1d49-isEquivalence renaming (trans to infixl 4 _\u2261\u1d49-\u2218_)\n\n  module _ (balanceUtxo balanceIns balanceNoIns balanceOuts balanceUtxo' : Coin)\n           (ref txFee txDonation tot : Coin)\n           (splitUtxo : balanceUtxo \u2261 balanceNoIns + balanceIns)\n           (splitUtxo' : balanceUtxo' \u2261 balanceNoIns + balanceOuts)\n           (balanced : balanceIns + ref + wdls \u2261 balanceOuts + txFee + tot + txDonation) where\n\n    utxo-ref-prop-worker :\n      balanceUtxo + ref + wdls \u2261 balanceUtxo' + txFee + txDonation + tot\n    utxo-ref-prop-worker = begin\n      balanceUtxo + ref + wdls\n        \u2261\u27e8 cong (\u03bb u \u2192 u + ref + wdls) splitUtxo \u27e9\n      balanceNoIns \u2115.+ balanceIns \u2115.+ ref \u2115.+ wdls\n        \u2261t\u27e8\u27e9\n      balanceNoIns \u2115.+ (balanceIns \u2115.+ ref \u2115.+ wdls)\n        \u2261\u27e8 cong (balanceNoIns +_) balanced \u27e9\n      balanceNoIns \u2115.+ (balanceOuts \u2115.+ txFee \u2115.+ tot \u2115.+ txDonation)\n        \u2261t\u27e8\u27e9\n      (balanceNoIns \u2115.+ balanceOuts \u2115.+ txFee) \u2115.+ tot \u2115.+ txDonation\n        \u2261\u02d8\u27e8 cong (\u03bb x \u2192 (x + txFee) + tot + txDonation) splitUtxo' \u27e9\n      (balanceUtxo' \u2115.+ txFee) \u2115.+ tot \u2115.+ txDonation\n        \u2261t\u27e8\u27e9\n      balanceUtxo' \u2115.+ txFee \u2115.+ (tot \u2115.+ txDonation)\n        \u2261\u27e8 cong (balanceUtxo' + txFee +_) $ +-comm tot txDonation \u27e9\n      balanceUtxo' \u2115.+ txFee \u2115.+ (txDonation \u2115.+ tot)\n        \u2261t\u27e8\u27e9\n      (balanceUtxo' \u2115.+ txFee) \u2115.+ txDonation \u2115.+ tot\n        \u220e\n\n  utxo-ref-prop :\n    cbalance utxo + ref + wdls \u2261\n    cbalance ((utxo \u2223 txIns \u1d9c) \u222a\u02e1 outs txb) + txFee + txDonation + tot\n  utxo-ref-prop = utxo-ref-prop-worker\n                    (cbalance utxo)\n                    (cbalance (utxo \u2223 txIns))\n                    (cbalance (utxo \u2223 txIns \u1d9c))\n                    (cbalance (outs txb))\n                    (cbalance ((utxo \u2223 txIns \u1d9c) \u222a\u02e1 outs txb))\n                    ref txFee txDonation tot\n                    (split-balance txIns)\n                    (balance-\u222a {utxo \u2223 txIns \u1d9c} {outs txb} h)\n                    (balValueToCoin {utxo = utxo} {utxoSt} {UTxOEnv.pparams \u0393} noMintAda newBal)\n\n  rearrange0 :\n      (bal : \u2115)\n    \u2192 deposits' \u2261 updateDeposits pp txb deposits\n    \u2192 bal + txFee + txDonation + tot + (remDepTot + fees)\n    \u2261 bal + (fees + txFee + getCoin deposits' + txDonation)\n  rearrange0 bal h = begin\n    bal \u2115.+ txFee \u2115.+ txDonation \u2115.+ tot \u2115.+ (remDepTot \u2115.+ fees)\n      \u2261t\u27e8\u27e9\n    bal \u2115.+ (txFee \u2115.+ txDonation \u2115.+ (tot \u2115.+ remDepTot) \u2115.+ fees)\n      \u2261\u27e8 cong (bal +_) $ begin\n        txFee + txDonation + (tot + remDepTot) + fees\n          \u2261\u27e8 +-comm _ fees \u27e9\n        fees \u2115.+ (txFee \u2115.+ txDonation \u2115.+ (tot \u2115.+ remDepTot))\n          \u2261t\u27e8\u27e9\n        (fees \u2115.+ txFee) \u2115.+ (txDonation \u2115.+ (tot \u2115.+ remDepTot))\n          \u2261\u27e8 cong ((fees + txFee) +_) $ +-comm txDonation (tot + remDepTot) \u27e9\n        (fees + txFee) \u2115.+ ((tot + remDepTot) \u2115.+ txDonation)\n          \u2261t\u27e8\u27e9\n        (fees + txFee) \u2115.+ (tot + remDepTot) \u2115.+ txDonation\n          \u2261\u27e8 cong (\u03bb x \u2192 (fees + txFee) + x + txDonation)\n          $ begin tot + (dep - ref) \u2261\u02d8\u27e8 +-\u2238-assoc tot ref\u2264dep \u27e9\n                  (tot + dep) - ref \u2261\u27e8 cong (_- ref) $ +-comm tot dep \u27e9\n                  (dep + tot) - ref \u2261\u02d8\u27e8 deposits-change \u27e9\n                  uDep              \u2261\u27e8 cong getCoin $ sym h \u27e9\n                  getCoin deposits' \u220e \u27e9\n        (fees + txFee) + getCoin deposits' + txDonation\n          \u220e \u27e9\n    bal + ((fees + txFee) + getCoin deposits' + txDonation)\n      \u220e\n\n  module _ (balanceUtxo balanceUtxo' : Coin)\n           (ref-prop : balanceUtxo + ref + wdls \u2261 balanceUtxo' + txFee + txDonation + tot)\n           (h : deposits' \u2261 updateDeposits pp txb deposits)\n           where\n\n    pov-scripts-worker :  isValid \u2261 true\n                          \u2192  balanceUtxo + fees + getCoin deposits + donations + wdls * \u03c7(isValid)\n                             \u2261 balanceUtxo' + (fees + txFee) + getCoin deposits' + (donations + txDonation)\n    pov-scripts-worker valid = begin\n      balanceUtxo + fees + dep + donations + wdls * \u03c7(isValid)\n        \u2261\u27e8 cong (\u03bb x \u2192 balanceUtxo + fees + dep + donations + wdls * \u03c7 x) valid \u27e9\n      balanceUtxo + fees + dep + donations + wdls * 1\n        \u2261\u27e8 cong (balanceUtxo + fees + dep + donations +_) (*-identity\u02b3 wdls) \u27e9\n      balanceUtxo + fees + dep + donations + wdls\n        \u2261\u27e8 +-assoc (balanceUtxo + fees + dep) donations wdls \u27e9\n      balanceUtxo + fees + dep + (donations + wdls)\n        \u2261\u27e8 cong (balanceUtxo + fees + dep +_) (+-comm donations wdls) \u27e9\n      balanceUtxo + fees + dep + (wdls + donations)\n        \u2261\u02d8\u27e8 +-assoc (balanceUtxo + fees + dep) wdls donations  \u27e9\n      balanceUtxo + fees + dep + wdls + donations\n        \u2261\u27e8 cong (_+ donations)\n        $ begin\n            balanceUtxo + fees + dep + wdls\n              \u2261\u02d8\u27e8 cong (\u03bb x \u2192 balanceUtxo + fees + x + wdls) (m+[n\u2238m]\u2261n ref\u2264dep) \u27e9\n            balanceUtxo + fees + (ref + remDepTot) + wdls\n              \u2261\u27e8 cong (_+ wdls) (+-assoc balanceUtxo fees (ref + remDepTot)) \u27e9\n            balanceUtxo + (fees + (ref + remDepTot)) + wdls\n              \u2261\u27e8 cong (\u03bb x \u2192 balanceUtxo + x + wdls) (+-comm fees (ref + remDepTot)) \u27e9\n            balanceUtxo + (ref + remDepTot + fees) + wdls\n              \u2261\u27e8 cong (\u03bb x \u2192 balanceUtxo + x + wdls) (+-assoc ref remDepTot fees) \u27e9 --\n            balanceUtxo + (ref + (remDepTot + fees)) + wdls\n              \u2261\u27e8 +-assoc balanceUtxo (ref + (remDepTot + fees)) wdls \u27e9 --\n            balanceUtxo + (ref + (remDepTot + fees) + wdls)\n              \u2261\u27e8 cong (balanceUtxo +_) (+-assoc ref (remDepTot + fees) wdls) \u27e9\n            balanceUtxo + (ref + ((remDepTot + fees) + wdls))\n              \u2261\u27e8 cong (\u03bb x \u2192 balanceUtxo + (ref + x)) (+-comm (remDepTot + fees) wdls) \u27e9\n            balanceUtxo + (ref + (wdls + (remDepTot + fees)))\n              \u2261\u02d8\u27e8 +-assoc balanceUtxo ref (wdls + (remDepTot + fees)) \u27e9\n            balanceUtxo + ref + (wdls + (remDepTot + fees))\n              \u2261\u02d8\u27e8 +-assoc (balanceUtxo + ref) wdls (remDepTot + fees) \u27e9\n            balanceUtxo + ref + wdls + (remDepTot + fees)\n              \u2261\u27e8 cong (_+ (remDepTot + fees)) ref-prop \u27e9\n            balanceUtxo' + txFee + txDonation + tot + (remDepTot + fees)\n              \u2261\u27e8 rearrange0 (balanceUtxo') h \u27e9\n            balanceUtxo' + (fees + txFee + getCoin deposits' + txDonation)\n              \u220e \u27e9\n      balanceUtxo' \u2115.+ (fees + txFee \u2115.+ getCoin deposits' \u2115.+ txDonation) \u2115.+ donations\n        \u2261t\u27e8\u27e9\n      balanceUtxo' \u2115.+ (fees + txFee) \u2115.+ getCoin deposits' \u2115.+ (txDonation \u2115.+ donations)\n        \u2261\u27e8 cong (balanceUtxo' + (fees + txFee) + getCoin deposits' \u2115.+_)\n         $ +-comm txDonation donations \u27e9\n      balanceUtxo' + (fees + txFee) + getCoin deposits' + (donations + txDonation)\n        \u220e\n\n  pov-scripts :  deposits' \u2261 updateDeposits pp txb deposits\n                 \u2192  isValid \u2261 true\n                 \u2192  cbalance utxo + fees + dep + donations + wdls * \u03c7(isValid)\n                    \u2261  cbalance ((utxo \u2223 txIns \u1d9c) \u222a\u02e1 outs txb)\n                       + (fees + txFee) + getCoin deposits' + (donations + txDonation)\n  pov-scripts h valid = pov-scripts-worker (cbalance utxo) (cbalance ((utxo \u2223 txIns \u1d9c) \u222a\u02e1 outs txb)) utxo-ref-prop h valid\n\n  pov-no-scripts :  isValid \u2261 false\n                    \u2192  cbalance utxo + fees + dep + donations + wdls * \u03c7(isValid)\n                       \u2261 cbalance (utxo \u2223 collateralInputs \u1d9c) + (fees + cbalance (utxo \u2223 collateralInputs)) + dep + donations\n  pov-no-scripts invalid = begin\n    cbalance utxo + fees + dep + donations + wdls * \u03c7(isValid) \u2261\u27e8 cong (\u03bb x \u2192 cbalance utxo + fees + dep + donations + wdls * \u03c7 x) invalid \u27e9\n    cbalance utxo + fees + dep + donations + wdls * 0 \u2261\u27e8 cong (cbalance utxo + fees + dep + donations +_ ) (*-zero\u02b3 wdls) \u27e9\n    cbalance utxo + fees + dep + donations + 0 \u2261\u27e8 +-identity\u02b3 _ \u27e9\n    cbalance utxo + fees + dep + donations \u2261\u27e8 cong (\u03bb x \u2192 x + dep + donations) $ begin\n      cbalance utxo \u2115.+ fees \u2261\u27e8 cong (_+ fees) (split-balance collateralInputs) \u27e9\n      cbalance (utxo \u2223 collateralInputs \u1d9c) \u2115.+ cbalance (utxo \u2223 collateralInputs) \u2115.+ fees \u2261t\u27e8\u27e9\n      cbalance (utxo \u2223 collateralInputs \u1d9c) \u2115.+ (cbalance (utxo \u2223 collateralInputs) \u2115.+ fees) \u2261\u27e8 cong (cbalance (utxo \u2223 collateralInputs \u1d9c) +_) (+-comm _ fees) \u27e9\n      cbalance (utxo \u2223 collateralInputs \u1d9c) \u2115.+ (fees \u2115.+ cbalance (utxo \u2223 collateralInputs)) \u220e \u27e9\n    cbalance (utxo \u2223 collateralInputs \u1d9c) + (fees + cbalance (utxo \u2223 collateralInputs)) + dep + donations\n    \u220e\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.Computational.html","title":"Computational","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Utxo.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Algebra.Morphism              using (module MonoidMorphisms; IsMagmaHomomorphism)\nopen import Data.Integer as \u2124             using (\u2124)\nopen import Data.List.Relation.Unary.All  using (All)\nimport Data.Nat as \u2115\nopen import Data.Nat.Properties           hiding (_\u225f_)\nopen import Data.String.Base              using () renaming (_++_ to _+\u02e2_)\n\nopen import Prelude; open Equivalence\nopen import Ledger.Prelude hiding (\u2264-trans; \u2264-antisym; All); open Properties\n\nopen import Tactic.Cong                 using (cong!)\nopen import Tactic.EquationalReasoning  using (module \u2261-Reasoning)\nopen import stdlib-meta.Tactic.MonoidSolver.NonNormalising using (solve-macro)\n\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Script.Validation txs abs\nopen import Ledger.Conway.Specification.Certs govStructure\n\ninstance\n  _ = TokenAlgebra.Value-CommutativeMonoid tokenAlgebra\n  _ = +-0-monoid\n  _ = Functor-ComputationResult\n\ninstance\n  Computational-UTXOS : Computational _\u22a2_\u21c0\u2987_,UTXOS\u2988_ String\n  Computational-UTXOS = record {go} where\n    module go (\u0393 : UTxOEnv) (s : UTxOState) (tx : Tx)\n      (let open UTxOState s)\n      (let H-Yes , \u2047 H-Yes? = Scripts-Yes-premises {\u0393} {tx} {utxo} {deposits})\n      (let H-No  , \u2047 H-No?  = Scripts-No-premises  {\u0393} {tx} {utxo}) where\n      open Tx tx renaming (body to txb); open TxBody txb\n      open UTxOEnv \u0393 renaming (pparams to pp)\n      sLst = collectP2ScriptsWithContext pp tx utxo\n\n      computeProof =\n        case H-Yes? ,\u2032 H-No? of \u03bb where\n          (yes p , no _ ) \u2192 success (_ , (Scripts-Yes p))\n          (no _  , yes p) \u2192 success (_ , (Scripts-No p))\n          (_     , _    ) \u2192 failure \"isValid check failed\"\n\n      completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n      completeness _ (Scripts-Yes p) with H-No? | H-Yes?\n      ... | yes (_ , refl) | _     = case proj\u2082 p of \u03bb ()\n      ... | no _           | yes _ = refl\n      ... | no _           | no \u00acp = case \u00acp p of \u03bb ()\n      completeness _ (Scripts-No p) with H-Yes? | H-No?\n      ... | yes (_ , _ , refl) | _     = case proj\u2082 p of \u03bb ()\n      ... | no _               | yes _ = refl\n      ... | no _               | no \u00acp = case \u00acp p of \u03bb ()\n\ninstance\n  Computational-UTXO' : Computational _\u22a2_\u21c0\u2987_,UTXO\u2988_ String\n  Computational-UTXO' = record {Go}\n    where\n      module Go \u0393 s tx (let H , \u2047 H? = UTXO-premises {\u0393 = \u0393} {s = s} {tx = tx}) where\n\n        open Computational Computational-UTXOS\n          renaming (computeProof to computeProof'; completeness to completeness')\n\n        genErr : \u00ac H \u2192 String\n        genErr  \u00acp = case dec-de-morgan \u00acp of \u03bb where\n          (inj\u2081 a) \u2192 \"\u00ac TxBody.txIns (Tx.body tx) \u2262 \u2205\"\n          (inj\u2082 b) \u2192 case dec-de-morgan b of \u03bb where\n            (inj\u2081 a\u2081) \u2192 \"\u00ac TxBody.txIns (Tx.body tx) \u2286 dom (UTxOOf s)\"\n            (inj\u2082 b\u2081) \u2192 case dec-de-morgan b\u2081 of \u03bb where\n                (inj\u2081 a\u2081') \u2192 \"\u00ac refInputs \u2286 dom utxo \"\n                (inj\u2082 b\u2082') \u2192 case dec-de-morgan b\u2082' of \u03bb where\n                  (inj\u2081 a\u2082) \u2192 \"\u00ac inInterval (UTxOEnv.slot \u0393) (txvldt (Tx.body tx))\"\n                  (inj\u2082 b\u2082) \u2192 case dec-de-morgan b\u2082 of \u03bb where\n                    (inj\u2081 a\u2083) \u2192 \"\u00ac feesOK pp tx utxo\"\n                    (inj\u2082 b\u2083) \u2192 case dec-de-morgan b\u2083 of \u03bb where\n                        (inj\u2081 a\u2084) \u2192\n                          let\n                            pp = PParamsOf \u0393\n                            txb = TxBodyOf tx\n                            con = consumed pp s txb\n                            prod = produced pp s txb\n                            showValue = show \u2218 coin\n                          in\n                            ( \"\u00acconsumed (UTxOEnv.pparams \u0393) s (Tx.body tx) \u2261 produced (PParamsOf \u0393) s (Tx.body tx)\"\n                            +\u02e2 \"\\n  consumed =\\t\\t\" +\u02e2 showValue con\n                            +\u02e2 \"\\n    ins  =\\t\\t\" +\u02e2 showValue (balance (UTxOOf s \u2223 txb .TxBody.txIns))\n                            +\u02e2 \"\\n    mint =\\t\\t\" +\u02e2 showValue (TxBody.mint txb)\n                            +\u02e2 \"\\n    depositRefunds =\\t\" +\u02e2 showValue (inject (depositRefunds pp s txb))\n                            +\u02e2 \"\\n  produced =\\t\\t\" +\u02e2 showValue prod\n                            +\u02e2 \"\\n    outs =\\t\\t\" +\u02e2 showValue (balance $ outs txb)\n                            +\u02e2 \"\\n    fee  =\\t\\t\" +\u02e2 show (FeesOf tx)\n                            +\u02e2 \"\\n    newDeposits  =\\t\" +\u02e2 show (newDeposits pp s txb)\n                            +\u02e2 \"\\n    donation  =\\t\\t\" +\u02e2 show (DonationsOf txb)\n                            )\n                        (inj\u2082 b\u2084) \u2192 case dec-de-morgan b\u2084 of \u03bb where\n                          (inj\u2081 a\u2085) \u2192 \"\u00ac coin (TxBody.mint (Tx.body tx)) \u2261 0\"\n                          (inj\u2082 b\u2085) \u2192 case dec-de-morgan b\u2085 of \u03bb where\n                              (inj\u2081 a\u2086) \u2192 \"\u00ac((Tx.txsize tx) Data.Nat.Base.\u2264 maxTxSize (UTxOEnv.pparams \u0393))\"\n                              (inj\u2082 b\u2086) \u2192 case dec-de-morgan b\u2086 of \u03bb where\n                                (inj\u2081 a\u2087) \u2192 \"\u2200[ (_ , txout) \u2208 txOuts .proj\u2081 ] inject (utxoEntrySize txout * coinsPerUTxOByte pp) \u2264\u1d57 getValue txout\"\n                                (inj\u2082 b\u2087) \u2192 case dec-de-morgan b\u2087 of \u03bb where\n                                    (inj\u2081 a\u2088) \u2192 \"\u2200[ (_ , txout) \u2208 txOuts .proj\u2081 ] serSize (getValue txout) \u2264 maxValSize pp\"\n                                    (inj\u2082 b\u2088) \u2192 case dec-de-morgan b\u2088 of \u03bb where\n                                      (inj\u2081 a\u2089) \u2192 \"\u2200[ (a , _) \u2208 range txOuts ] Sum.All (const \u22a4) (\u03bb a \u2192 a .BootstrapAddr.attrsSize \u2264 64) a\"\n                                      (inj\u2082 _) \u2192 \"something else broke\"\n\n        computeProofH : Dec H \u2192 ComputationResult String (\u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s')\n        computeProofH (yes (x , y , z , e , k , l , m , c , v , j , n , o , p , q , r , t , u)) =\n            map\u2082\u2032 (UTXO-inductive\u22ef _ _ _ x y z e k l m c v j n o p q r t u) &lt;$&gt; computeProof' \u0393 s tx\n        computeProofH (no \u00acp) = failure $ genErr \u00acp\n\n        computeProof : ComputationResult String (\u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s')\n        computeProof = computeProofH H?\n\n        completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n        completeness s' (UTXO-inductive\u22ef _ _ _ x y z w k l m c v j n o p q r t u h) with H?\n        ... | no \u00acp = \u22a5-elim $ \u00acp (x , y , z , w , k , l , m , c , v , j , n , o , p , q , r , t , u)\n        ... | yes _ with computeProof' \u0393 s tx | completeness' _ _ _ _ h\n        ... | success _ | refl = refl\n\nopen Computational \u2983...\u2984\n\nopaque\n  unfolding List-Model\n  Computational-UTXO : Computational _\u22a2_\u21c0\u2987_,UTXO\u2988_ String\n  Computational-UTXO = Computational-UTXO'\n\nprivate variable\n  tx                    : Tx\n  \u0393                     : UTxOEnv\n  utxoState utxoState'  : UTxOState\n\nUTXO-step : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 ComputationResult String UTxOState\nUTXO-step = compute \u2983 Computational-UTXO \u2984\n\nUTXO-step-computes-UTXO  :  UTXO-step \u0393 utxoState tx \u2261 success utxoState'\n                         \u21d4  \u0393 \u22a2 utxoState \u21c0\u2987 tx ,UTXO\u2988 utxoState'\nUTXO-step-computes-UTXO = \u2261-success\u21d4STS \u2983 Computational-UTXO \u2984\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html","title":"GenMinspend","text":""},{"location":"Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#general-minimum-spending-condition","title":"General Minimum Spending Condition","text":"<pre><code>isRefundCert : DCert \u2192 Bool\nisRefundCert (dereg c _) = true\nisRefundCert (deregdrep c _) = true\nisRefundCert _ = false\n\nnoRefundCert : List DCert \u2192 Type _\nnoRefundCert l = All (\u03bb cert \u2192 isRefundCert cert \u2261 false) l\n\nopaque\n  unfolding List-Model\n  unfolding finiteness\n  fin\u2218list[] : {A : Type} \u2192 proj\u2081 (finiteness{A = A} \u2205) \u2261 []\n  fin\u2218list[] = refl\n  fin\u2218list\u2237[] : {A : Type} {a : A} \u2192 proj\u2081 (finiteness \u2774 a \u2775) \u2261 [ a ]\n  fin\u2218list\u2237[] = refl\n\ncoin\u2205 : getCoin{A = Deposits} \u2205 \u2261 0\ncoin\u2205 = begin\n  foldr (\u03bb x \u2192 (proj\u2082 x) +_) 0 (deduplicate _\u225f_ (proj\u2081 (finiteness \u2205)))\n    \u2261\u27e8 cong (\u03bb u \u2192 (foldr (\u03bb x \u2192 (proj\u2082 x) +_) 0 (deduplicate _\u225f_ u))) fin\u2218list[] \u27e9\n  foldr (\u03bb (x : DepositPurpose \u00d7 Coin) \u2192 (proj\u2082 x) +_) 0 (deduplicate _\u225f_ [])\n    \u2261\u27e8 cong (\u03bb u \u2192 (foldr (\u03bb (x : DepositPurpose \u00d7 Coin) \u2192 (proj\u2082 x) +_) 0  u))\n            {x = deduplicate _\u225f_ []} {y = []} refl \u27e9\n  foldr (\u03bb (x : DepositPurpose \u00d7 Coin) \u2192 (proj\u2082 x) +_) 0 []\n    \u2261\u27e8 refl \u27e9\n  0 \u220e\n  where open Prelude.\u2261-Reasoning\n\ngetCoin-singleton : ((dp , c) : DepositPurpose \u00d7 Coin) \u2192 indexedSum\u1d5b' id \u2774 (dp , c) \u2775 \u2261 c\ngetCoin-singleton _ = indexedSum-singleton' {A = DepositPurpose \u00d7 Coin} {f = proj\u2082} (finiteness _)\n\nmodule _ -- ASSUMPTION --\n         (gc-hom : (d\u2081 d\u2082 : Deposits) \u2192 getCoin (d\u2081 \u222a\u207a d\u2082) \u2261 getCoin d\u2081 + getCoin d\u2082)\n  where\n  \u222a\u207asingleton\u2261 : {deps : Deposits} {(dp , c) : DepositPurpose \u00d7 Coin}\n                 \u2192 getCoin (deps \u222a\u207a \u2774 (dp , c) \u2775\u1d50) \u2261 getCoin deps + c\n  \u222a\u207asingleton\u2261 {deps} {(dp , c)} = begin\n    getCoin (deps \u222a\u207a \u2774 (dp , c) \u2775)\n      \u2261\u27e8 gc-hom deps \u2774 (dp , c) \u2775 \u27e9\n    getCoin deps + getCoin{A = Deposits} \u2774 (dp , c) \u2775\n      \u2261\u27e8 cong (getCoin deps +_) (getCoin-singleton (dp , c)) \u27e9\n    getCoin deps + c\n      \u220e\n    where open Prelude.\u2261-Reasoning\n\n  module _ {deposits : Deposits} {txid : TxId} {gaDep : Coin} where\n\n    \u2264updatePropDeps : (props : List GovProposal)\n      \u2192 getCoin deposits \u2264 getCoin (updateProposalDeposits props txid gaDep deposits)\n    \u2264updatePropDeps [] = \u2264-reflexive refl\n    \u2264updatePropDeps (x \u2237 props) = \u2264-trans (\u2264updatePropDeps props)\n                                          (\u2264-trans (m\u2264m+n _ _)\n                                                   (\u2264-reflexive $ sym $ \u222a\u207asingleton\u2261))\n    updatePropDeps\u2261 : (ps : List GovProposal)\n      \u2192 getCoin (updateProposalDeposits ps txid gaDep deposits) - getCoin deposits \u2261 (length ps) * gaDep\n    updatePropDeps\u2261 [] = n\u2238n\u22610 (getCoin deposits)\n    updatePropDeps\u2261 (_ \u2237 ps) = let\n      upD = updateProposalDeposits ps txid gaDep deposits in\n      begin\n        getCoin (upD \u222a\u207a \u2774 GovActionDeposit (txid , length ps) , gaDep \u2775\u1d50) \u2238 getCoin deposits\n          \u2261\u27e8 cong (_\u2238 getCoin deposits) \u222a\u207asingleton\u2261 \u27e9\n        getCoin upD + gaDep \u2238 getCoin deposits\n          \u2261\u27e8 +-\u2238-comm _ (\u2264updatePropDeps ps) \u27e9\n        (getCoin upD \u2238 getCoin deposits) + gaDep\n          \u2261\u27e8 cong (_+ gaDep) (updatePropDeps\u2261 ps) \u27e9\n        (length ps) * gaDep + gaDep\n          \u2261\u27e8 +-comm ((length ps) * gaDep) gaDep \u27e9\n        gaDep + (length ps) * gaDep\n          \u220e\n        where open Prelude.\u2261-Reasoning\n\n  \u2264certDeps  :  {d : Deposits} {(dp , c) : DepositPurpose \u00d7 Coin}\n             \u2192  getCoin d \u2264 getCoin (d \u222a\u207a \u2774 (dp , c) \u2775)\n\n  \u2264certDeps {d} = begin\n    getCoin d                      \u2264\u27e8 m\u2264m+n (getCoin d) _ \u27e9\n    getCoin d + _                  \u2261\u27e8 sym \u222a\u207asingleton\u2261 \u27e9\n    getCoin (d \u222a\u207a \u2774 _ \u2775)           \u220e\n    where open \u2264-Reasoning\n\n\n  \u2264updateCertDeps : (cs : List DCert) {pp : PParams} {deposits : Deposits}\n    \u2192 noRefundCert cs\n    \u2192 getCoin deposits \u2264 getCoin (updateCertDeposits pp cs deposits)\n  \u2264updateCertDeps [] nrf = \u2264-reflexive refl\n  \u2264updateCertDeps (reg c v \u2237 cs) {pp} {deposits} (_ All.\u2237 nrf) =\n    \u2264-trans \u2264certDeps (\u2264updateCertDeps cs {pp} {deposits \u222a\u207a \u2774 CredentialDeposit c , pp .PParams.keyDeposit \u2775} nrf)\n  \u2264updateCertDeps (delegate c _ _ v \u2237 cs) {pp} {deposits} (_ All.\u2237 nrf) =\n    \u2264-trans \u2264certDeps (\u2264updateCertDeps cs {pp} {deposits \u222a\u207a \u2774 CredentialDeposit c , v \u2775} nrf)\n  \u2264updateCertDeps (regpool _ _ \u2237 cs)       (_ All.\u2237 nrf) = \u2264-trans \u2264certDeps (\u2264updateCertDeps cs nrf)\n  \u2264updateCertDeps (retirepool _ _ \u2237 cs)    (_ All.\u2237 nrf) = \u2264updateCertDeps cs nrf\n  \u2264updateCertDeps (regdrep _ _ _ \u2237 cs)     (_ All.\u2237 nrf) = \u2264-trans \u2264certDeps (\u2264updateCertDeps cs nrf)\n  \u2264updateCertDeps (ccreghot _ _ \u2237 cs)      (_ All.\u2237 nrf) = \u2264updateCertDeps cs nrf\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#main-theorem-general-minimum-spending-condition","title":"Main Theorem: General Minimum Spending Condition","text":"<pre><code>  gmsc :  let open Tx tx renaming (body to txb); open TxBody txb\n              pp = UTxOEnv.pparams \u0393; open PParams pp\n              open UTxOState utxoState\n                renaming (utxo to st; fees to fs; deposits to deps; donations to dons)\n          in\n    \u0393 \u22a2  \u27e6 st   , fs   , deps   , dons   \u27e7 \u21c0\u2987 tx ,UTXO\u2988\n         \u27e6 utxo'  , fees'  , deposits'  , donations'  \u27e7\n\n    \u2192 noRefundCert txCerts -- FINAL ASSUMPTION --\n\n       -------------------------------------------------------------------\n    \u2192  coin (consumed pp utxoState txb) \u2265 length txGovProposals * govActionDeposit\n\n  gmsc step@(UTXO-inductive\u22ef tx \u0393 utxoState _ _ _ _ _ _ c\u2261p cmint\u22610 _ _ _ _ _ _ _ _ _ _) nrf =\n    begin\n    length txGovProposals * govActionDeposit\n      \u2261\u02d8\u27e8 updatePropDeps\u2261 txGovProposals \u27e9\n    getCoin (updateProposalDeposits txGovProposals txId govActionDeposit deps) \u2238 getCoin deps\n      \u2264\u27e8 \u2238-mono\u02e1-\u2264 (getCoin deps) (\u2264updateCertDeps txCerts nrf) \u27e9\n    getCoin (updateDeposits pp txb deps) - getCoin deps\n      \u2261\u27e8 \u2238\u2261posPart\u2296 {getCoin (updateDeposits pp txb deps)} {getCoin deps} \u27e9\n    newDeps\n      \u2264\u27e8 m\u2264n+m newDeps (coin balOut + txFee + txDonation) \u27e9\n    coin balOut + txFee + txDonation + newDeps\n      \u2261\u27e8 +-assoc (coin balOut + txFee) txDonation newDeps \u27e9\n    coin balOut + txFee + (txDonation + newDeps)\n      \u2261\u27e8 cong (coin balOut + txFee +_) (+-comm txDonation newDeps) \u27e9\n    coin balOut + txFee + (newDeps + txDonation)\n      \u2261\u02d8\u27e8 +-assoc (coin balOut + txFee) newDeps txDonation \u27e9\n    coin balOut + txFee + newDeps + txDonation\n      \u2261\u02d8\u27e8 cong (\u03bb x \u2192 x + newDeps + txDonation) coin-inject-lemma \u27e9\n    coin (balOut + inject txFee) + newDeps + txDonation\n      \u2261\u02d8\u27e8 cong (_+ txDonation) coin-inject-lemma \u27e9\n    coin (balOut + inject txFee + inject newDeps) + txDonation\n      \u2261\u02d8\u27e8 coin-inject-lemma \u27e9\n    coin (balOut + inject txFee + inject newDeps + inject txDonation)\n      \u2261\u02d8\u27e8 cong coin c\u2261p \u27e9\n    coin (balIn + mint + inject refunds + inject wdrls) \u220e\n    where\n    open \u2264-Reasoning\n    pp : PParams\n    pp = UTxOEnv.pparams \u0393; open PParams pp\n    open Tx tx renaming (body to txb); open TxBody txb\n    open UTxOState utxoState renaming (utxo to st; fees to fs; deposits to deps; donations to dons)\n\n    newDeps refunds wdrls : Coin\n    newDeps = newDeposits pp utxoState txb\n    refunds = depositRefunds pp utxoState txb\n    wdrls = getCoin txWithdrawals\n\n    balIn balOut : Value\n    balIn = balance (st \u2223 txIns)\n    balOut = balance (outs txb)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.MinSpend.html","title":"MinSpend","text":"<p> Theorem (general spend lower bound).</p> <p>Informally.</p> <p>Let <code>tx</code> : <code>Tx</code> be a valid transaction and let <code>txCerts</code> be its list of <code>DCert</code>s.  Denote by <code>noRefundCert</code> <code>txCerts</code> the assertion that no element in <code>txCerts</code> is one of the two refund types (i.e., an element of <code>l</code> is neither a <code>dereg</code> nor a <code>deregdrep</code>).  Let <code>s</code>, <code>s'</code> : <code>UTxOState</code> be two UTxO states. If <code>s</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,UTXO\u2988</code> <code>s'</code> and if <code>noRefundCert</code> <code>txCerts</code>, then the coin consumed by <code>tx</code> is at least the sum of the governance action deposits of the proposals in <code>tx</code>.</p> <p>Formally.</p> <pre><code>module _\n  -- ASSUMPTION --\n  (gc-hom : (d\u2081 d\u2082 : DepositPurpose \u21c0 Coin) \u2192 getCoin (d\u2081 \u222a\u207a d\u2082) \u2261 getCoin d\u2081 + getCoin d\u2082)\n  {\u0393 : UTxOEnv}\n  where\n    open module \u0393 = UTxOEnv \u0393\n    govActionDeps : Coin\n    govActionDeps = PParams.govActionDeposit \u0393.pparams\n\n    utxoMinSpend : {tx : Tx} {s s' : UTxOState}\n      \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s'\n      \u2192 noRefundCert (DCertsOf tx)\n      \u2192 coin (consumed _ s (TxBodyOf tx)) \u2265 length (GovProposalsOf tx) * govActionDeps\n</code></pre> <p>Proof.</p> <pre><code>    utxoMinSpend step@(UTXO-inductive\u22ef tx \u0393 utxoSt _ _ _ _ _ _ c\u2261p cmint\u22610 _ _ _ _ _ _ _ _ _ _) nrf =\n      begin\n      length txGovProposals * govActionDeps\n        \u2261\u02d8\u27e8 updatePropDeps\u2261 gc-hom txGovProposals \u27e9\n      getCoin (updateProposalDeposits txGovProposals txId (govActionDeps) deposits) \u2238 getCoin deposits\n        \u2264\u27e8 \u2238-mono\u02e1-\u2264 (getCoin deposits) (\u2264updateCertDeps gc-hom txCerts nrf) \u27e9\n      getCoin (updateDeposits (PParamsOf \u0393) txb deposits) - getCoin deposits\n        \u2261\u27e8 \u2238\u2261posPart\u2296 {getCoin (updateDeposits (PParamsOf \u0393) txb deposits)} {getCoin deposits} \u27e9\n      newDeps\n        \u2264\u27e8 m\u2264n+m newDeps (coin balOut + txFee + txDonation) \u27e9\n      coin balOut + txFee + txDonation + newDeps\n        \u2261\u27e8 +-assoc (coin balOut + txFee) txDonation newDeps \u27e9\n      coin balOut + txFee + (txDonation + newDeps)\n        \u2261\u27e8 cong (coin balOut + txFee +_) (+-comm txDonation newDeps) \u27e9\n      coin balOut + txFee + (newDeps + txDonation)\n        \u2261\u02d8\u27e8 +-assoc (coin balOut + txFee) newDeps txDonation \u27e9\n      coin balOut + txFee + newDeps + txDonation\n        \u2261\u02d8\u27e8 cong (\u03bb x \u2192 x + newDeps + txDonation) coin-inject-lemma \u27e9\n      coin (balOut + inject txFee) + newDeps + txDonation\n        \u2261\u02d8\u27e8 cong (_+ txDonation) coin-inject-lemma \u27e9\n      coin (balOut + inject txFee + inject newDeps) + txDonation\n        \u2261\u02d8\u27e8 coin-inject-lemma \u27e9\n      coin (balOut + inject txFee + inject newDeps + inject txDonation)\n        \u2261\u02d8\u27e8 cong coin c\u2261p \u27e9\n      coin (balIn + mint + inject refunds + inject wdrls) \u220e\n      where\n      open \u2264-Reasoning\n      open Tx tx renaming (body to txb); open TxBody txb\n      open UTxOState utxoSt\n\n      newDeps refunds wdrls : Coin\n      newDeps = newDeposits (PParamsOf \u0393) utxoSt txb\n      refunds = depositRefunds (PParamsOf \u0393) utxoSt txb\n      wdrls = getCoin (WithdrawalsOf tx)\n\n      balIn balOut : Value\n      balIn = balance (utxo \u2223 txIns)\n      balOut = balance (outs txb)\n</code></pre> <p> Theorem (spend lower bound for proposals).</p> <p>Preliminary remarks.</p> <ol> <li> <p>Define <code>noRefundCert</code> <code>l</code> and     <code>pp</code> as in the \"min spend\" theorem above.</p> </li> <li> <p>Given a ledger state <code>ls</code> and a transaction     <code>tx</code>, denote by     <code>validTxIn\u2082</code> <code>tx</code> the assertion that there exists     ledger state     <code>ls'</code> such that <code>ls</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,LEDGER\u2988</code> <code>ls'</code>.</p> </li> <li> <p>Assume the following additive property of the <code>\u222a\u207a</code> operator holds: </p> </li> </ol> <pre><code>                           \u2211[ x \u2190 d\u2081 \u222a\u207a d\u2082 ] x \u2261 \u2211[ x \u2190 d\u2081 ] x \u25c7 \u2211[ x \u2190 d\u2082 ] x\n</code></pre> <p>Informally.</p> <p>Let <code>tx</code> : <code>Tx</code> be a valid transaction and let <code>cs</code> : <code>ChainState</code> be a  chain state. If the condition <code>validTxIn\u2082</code> <code>tx</code> (described above) holds, then the coin consumed by <code>tx</code> is at least the sum of the governance action deposits of the proposals in <code>tx</code>.</p> <p>Formally.</p> <pre><code>  propose-minSpend :  {slot : Slot} {tx : Tx} {cs : ChainState}\n                      ( let  pp      = PParamsOf cs\n                             utxoSt  = UTxOStateOf cs )\n</code></pre> <pre><code>    \u2192 noRefundCert txCerts\n    \u2192 validTxIn\u2082 cs slot tx\n    \u2192 coin (consumed pp utxoSt body) \u2265 length txGovProposals * pp .govActionDeposit\n</code></pre> <p>Proof.</p> <pre><code>  propose-minSpend noRef valid = case valid of \u03bb where\n    (_ , LEDGER-V (_ , UTXOW\u21d2UTXO x , _ , _)) \u2192 utxoMinSpend indexedSum-\u222a\u207a-hom x noRef\n    (_ , LEDGER-I (_ , UTXOW\u21d2UTXO x))         \u2192 utxoMinSpend indexedSum-\u222a\u207a-hom x noRef\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.PoV.html","title":"PoV","text":"<p>Lemma (The <code>UTXO</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>s</code> and <code>s'</code> be <code>UTxOState</code>s, let <code>tx</code> : <code>Tx</code> be a fresh transaction with withdrawals <code>txWithdrawals</code>, and suppose <code>s</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,UTXO\u2988</code> <code>s'</code>. If <code>tx</code> is valid.  Then the coin value of <code>s'</code> is equal to the sum of the coin values of <code>s</code> and <code>txWithdrawals</code>. If <code>tx</code> is not valid, then the coin values of <code>s</code> and <code>s'</code> are equal.  We can express this concisely as follows:</p> <pre>getCoin s + getCoin (wdrlsOf tx) * \u03c7 (tx .isValid) \u2261 getCoin s'\n</pre> <p>where <code>\u03c7</code> : <code>Bool</code> \u2192 \\(\\{0, 1\\}\\) is the characteristic function, which returns 0 for false and 1 for true.</p> <p>Formally.</p> <pre><code>UTXOpov : {\u0393 : UTxOEnv} {tx : Tx} {s s' : UTxOState}\n  \u2192 TxIdOf tx \u2209 map\u02e2 proj\u2081 (dom (UTxOOf s))\n  \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s'\n  \u2192 getCoin s + getCoin (WithdrawalsOf tx) * \u03c7 (tx .isValid) \u2261 getCoin s'\n</code></pre> <p>Proof.</p> <pre><code>UTXOpov h' step@(UTXO-inductive\u22ef _ \u0393 _ _ _ _ _ _ _ newBal noMintAda _ _ _ _ _ _ _ _ _ (Scripts-Yes (_ , _ , valid)))\n  = pov-scripts step h' refl valid\n\nUTXOpov h' step@(UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ (Scripts-No (_ , invalid)))\n  = pov-no-scripts step h' invalid\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Utxo.Properties where\n\nopen import Ledger.Conway.Specification.Utxo.Properties.Base\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational\nopen import Ledger.Conway.Specification.Utxo.Properties.GenMinSpend\nopen import Ledger.Conway.Specification.Utxo.Properties.MinSpend\nopen import Ledger.Conway.Specification.Utxo.Properties.PoV\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.html","title":"UTxO","text":"<p>This section is part of the Ledger.Conway.Specification.Utxo module of the formal ledger specification where we define types and functions needed for the UTxO transition system.</p> <p>The UTxO transition system is built up from a number of smaller parts defined in this section, culminating in the <code>UTXO</code> rule given in the final subsection below (UTXO Inference Rule).</p>"},{"location":"Ledger.Conway.Specification.Utxo.html#sec:accounting","title":"Accounting","text":"<p>The deposits have been reworked since the original Shelley design. We now track the amount of every deposit individually. This fixes an issue in the original design: An increase in deposit amounts would allow an attacker to make lots of deposits before that change and refund them after the change. The additional funds necessary would have been provided by the treasury. Since changes to protocol parameters were (and still are) known publicly and guaranteed before they are enacted, this comes at zero risk for an attacker. This means the deposit amounts could realistically never be increased. This issue is gone with the new design. (See also Corduan22.)</p>"},{"location":"Ledger.Conway.Specification.Utxo.html#sec:functions-supporting-utxo-rules","title":"Functions supporting UTxO rules","text":"<pre><code>totExUnits : Tx \u2192 ExUnits\ntotExUnits tx = \u2211[ (_ , eu) \u2190 tx .wits .txrdmrs ] eu\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.html#sec:utxo-transition-system-types","title":"UTxO transition system types","text":"<p>As its name indicates, <code>DepositPurpose</code> specifies the purpose of a deposit.  Deposits are stored in the <code>deposits</code> field of the <code>UTxOState</code> type defined in this section. (The <code>DepositPurpose</code> and <code>Deposits</code> types are defined in the Deposit Types section of the <code>Certs</code> module.)</p> <p>UTxO environment <pre><code>record UTxOEnv : Type where\n  field\n    slot      : Slot\n    pparams   : PParams\n    treasury  : Treasury\n</code></pre></p> <p>UTxO states <pre><code>record UTxOState : Type where\n</code></pre></p> <pre><code>  field\n    utxo       : UTxO\n    fees       : Fees\n    deposits   : Deposits\n    donations  : Donations\n</code></pre> <p>UTxO transitions</p> <pre><code>data _\u22a2_\u21c0\u2987_,UTXO\u2988_ : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 UTxOState \u2192 Type\n</code></pre> <p>(The main constructor of this type, <code>UTXO-inductive</code>, is defined in the UTXO Inference Rule subsection below.)</p>"},{"location":"Ledger.Conway.Specification.Utxo.html#functions-used-in-utxo-rules","title":"Functions used in UTxO rules","text":"<p>Here we define, among other things,</p> <ul> <li> <p>the <code>outs</code> function, which creates the unspent outputs generated by    a transaction; it maps the transaction id and output index to the output;</p> </li> <li> <p>the <code>balance</code> function, which calculates sum total of all the coin in a    given UTxO;</p> </li> <li> <p>the <code>minfee</code> function, which includes the cost for reference    scripts, calculated using the <code>scriptsCost</code> function    defined in the Fees module.</p> </li> </ul> <pre><code>  outs : TxBody \u2192 UTxO\n  outs tx = mapKeys (tx .txId ,_) (tx .txOuts)\n\n  balance : UTxO \u2192 Value\n  balance utxo = \u2211[ x \u2190 mapValues txOutHash utxo ] getValue\u02b0 x\n\n  cbalance : UTxO \u2192 Coin\n  cbalance utxo = coin (balance utxo)\n\n  refScriptsSize : UTxO \u2192 Tx \u2192 \u2115\n  refScriptsSize utxo tx = sum (map scriptSize (setToList (refScripts tx utxo)))\n\n  minfee : PParams \u2192 UTxO \u2192 Tx \u2192 Coin\n  minfee pp utxo tx  = pp .a * tx .txsize + pp .b\n                     + txscriptfee (pp .prices) (totExUnits tx)\n                     + scriptsCost pp (refScriptsSize utxo tx)\n</code></pre> <pre><code>certDeposit : DCert \u2192 PParams \u2192 Deposits\ncertDeposit (delegate c _ _ v) _   = \u2774 CredentialDeposit c , v \u2775\ncertDeposit (reg c _)          pp  = \u2774 CredentialDeposit c , pp .keyDeposit \u2775\ncertDeposit (regpool kh _)     pp  = \u2774 PoolDeposit kh , pp .poolDeposit \u2775\ncertDeposit (regdrep c v _)    _   = \u2774 DRepDeposit c , v \u2775\ncertDeposit _                  _   = \u2205\n\ncertRefund : DCert \u2192 \u2119 DepositPurpose\ncertRefund (dereg c _)      = \u2774 CredentialDeposit c \u2775\ncertRefund (deregdrep c _)  = \u2774 DRepDeposit c \u2775\ncertRefund _                = \u2205\n</code></pre> <p>The type <code>ValidCertDeposits</code> has the following signature:</p> <pre><code>data ValidCertDeposits (pp : PParams) (deps : Deposits) : List DCert \u2192 Set\n</code></pre> <p>Inhabitants of this type are constructed in one of eight ways, corresponding to seven certificate types plus one for an empty list of certificates.  Suffice it to say that <code>ValidCertDeposits</code> is used to check the validity of the deposits in a transaction so that the function <code>updateCertDeposits</code> can correctly register and deregister deposits in the UTxO state based on the certificates in the transaction.</p> <p>The <code>updateDeposits</code> function is responsible for updating this map; it is split into <code>updateCertDeposits</code> and <code>updateProposalDeposits</code>, which are responsible for certificates and proposals, respectively.  These functions iterate over the relevant fields of the transaction body and insert or remove deposits depending on the information seen. Note that some deposits can only be refunded at the epoch boundary and are not removed by these functions.</p> <p>There are two equivalent ways to introduce this tracking of the deposits.  One option would be to populate the <code>deposits</code> field of <code>UTxOState</code> with the correct keys and values that can be extracted from the state of the previous era at the transition into the Conway era.  Alternatively, we can effectively treat the old handling of deposits as an erratum in the Shelley specification, which we fix by implementing the new deposits logic in older eras and then replaying the chain. (The handling of deposits in the Shelley era is discussed in Corduan22 and CVG19.)</p> <pre><code>updateCertDeposits  : PParams \u2192 List DCert \u2192 Deposits \u2192 Deposits\nupdateCertDeposits pp [] deposits = deposits\n</code></pre> <pre><code>updateCertDeposits pp (delegate c vd khs v \u2237 certs) deposits\n  = updateCertDeposits pp certs (deposits \u222a\u207a certDeposit (delegate c vd khs v) pp)\nupdateCertDeposits pp (regpool kh p \u2237 certs) deposits\n  = updateCertDeposits pp certs (deposits \u222a\u207a certDeposit (regpool kh p) pp)\nupdateCertDeposits pp (regdrep c v a \u2237 certs) deposits\n  = updateCertDeposits pp certs (deposits \u222a\u207a certDeposit (regdrep c v a) pp)\nupdateCertDeposits pp (dereg c v \u2237 certs) deposits\n  = updateCertDeposits pp certs (deposits \u2223 certRefund (dereg c v)\u1d9c)\nupdateCertDeposits pp (deregdrep c v \u2237 certs) deposits\n  = updateCertDeposits pp certs (deposits \u2223 certRefund (deregdrep c v)\u1d9c)\nupdateCertDeposits pp (_ \u2237 certs) deposits\n  = updateCertDeposits pp certs deposits\n\nupdateProposalDeposits : List GovProposal \u2192 TxId \u2192 Coin \u2192 Deposits \u2192 Deposits\nupdateProposalDeposits []        _     _      deposits  = deposits\nupdateProposalDeposits (_ \u2237 ps)  txid  gaDep  deposits  =\n  updateProposalDeposits ps txid gaDep deposits\n  \u222a\u207a \u2774 GovActionDeposit (txid , length ps) , gaDep \u2775\n\nupdateDeposits : PParams \u2192 TxBody \u2192 Deposits \u2192 Deposits\nupdateDeposits pp txb = updateCertDeposits pp txCerts\n                        \u2218 updateProposalDeposits txGovProposals txId (pp .govActionDeposit)\n</code></pre> <pre><code>depositsChange : PParams \u2192 TxBody \u2192 Deposits \u2192 \u2124\ndepositsChange pp txb deposits =\n  getCoin (updateDeposits pp txb deposits) - getCoin deposits\n\ndata inInterval (slot : Slot) : (Maybe Slot \u00d7 Maybe Slot) \u2192 Type where\n  both   : \u2200 {l r}  \u2192 l \u2264 slot \u00d7 slot \u2264 r  \u2192  inInterval slot (just l   , just r)\n  lower  : \u2200 {l}    \u2192 l \u2264 slot             \u2192  inInterval slot (just l   , nothing)\n  upper  : \u2200 {r}    \u2192 slot \u2264 r             \u2192  inInterval slot (nothing  , just r)\n  none   :                                    inInterval slot (nothing  , nothing)\n</code></pre> <pre><code>collateralCheck : PParams \u2192 Tx \u2192 UTxO \u2192 Type\ncollateralCheck pp tx utxo =\n  All (\u03bb (addr , _) \u2192 isVKeyAddr addr) (range (utxo \u2223 collateralInputs))\n  \u00d7 isAdaOnly balance\u2032\n  \u00d7 coin balance\u2032 * 100 \u2265 txFee * pp .collateralPercentage\n  \u00d7 collateralInputs \u2262 \u2205\n  where\n    open Tx tx; open TxBody body\n    balance\u2032 = balance (utxo \u2223 collateralInputs)\n</code></pre> <p>We redefine <code>depositRefunds</code> and <code>newDeposits</code> via <code>depositsChange</code>, which computes the difference between the total deposits before and after their application.  This simplifies their definitions and some correctness proofs.  We then add the absolute value of <code>depositsChange</code> to <code>consumed</code> or <code>produced</code> depending on its sign. This is done via <code>negPart</code> and <code>posPart</code>, which satisfy the key property that their difference is the identity function.</p> <pre><code>  depositRefunds : PParams \u2192 UTxOState \u2192 TxBody \u2192 Coin\n  depositRefunds pp st txb = negPart (depositsChange pp txb (st .deposits))\n\n  newDeposits : PParams \u2192 UTxOState \u2192 TxBody \u2192 Coin\n  newDeposits pp st txb = posPart (depositsChange pp txb (st .deposits))\n\n  consumed : PParams \u2192 UTxOState \u2192 TxBody \u2192 Value\n  consumed pp st txb\n    =  balance (st .utxo \u2223 txb .txIns)\n    +  txb .mint\n    +  inject (depositRefunds pp st txb)\n    +  inject (getCoin (txb .txWithdrawals))\n\n  produced : PParams \u2192 UTxOState \u2192 TxBody \u2192 Value\n  produced pp st txb = balance (outs txb)\n                     + inject (txb .txFee)\n                     + inject (newDeposits pp st txb)\n                     + inject (txb .txDonation)\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.html#sec:utxos-rule","title":"The <code>UTXOS</code> rule","text":"<pre><code>data _\u22a2_\u21c0\u2987_,UTXOS\u2988_ : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 UTxOState \u2192 Type where\n\n  Scripts-Yes :\n    let  pp         = \u0393 .pparams\n</code></pre> <pre><code>         p2Scripts  = collectP2ScriptsWithContext pp tx utxo\n      in\n        \u2219 ValidCertDeposits pp deposits txCerts\n        \u2219 evalP2Scripts p2Scripts \u2261 isValid\n        \u2219 isValid \u2261 true\n          \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n          \u0393 \u22a2 \u27e6 utxo , fees , deposits , donations \u27e7 \u21c0\u2987 tx ,UTXOS\u2988 \u27e6 (utxo \u2223 txIns \u1d9c) \u222a\u02e1 (outs txb) , fees + txFee , updateDeposits pp txb deposits , donations + txDonation \u27e7\n  Scripts-No :\n    let  pp         = \u0393 .pparams\n</code></pre> <pre><code>         p2Scripts  = collectP2ScriptsWithContext pp tx utxo\n    in\n        \u2219 evalP2Scripts p2Scripts \u2261 isValid\n        \u2219 isValid \u2261 false\n          \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n          \u0393 \u22a2 \u27e6 utxo , fees , deposits , donations \u27e7 \u21c0\u2987 tx ,UTXOS\u2988 \u27e6 utxo \u2223 collateralInputs \u1d9c , fees + cbalance (utxo \u2223 collateralInputs) , deposits , donations \u27e7\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.html#sec:utxo-inference-rule","title":"UTXO Inference Rule","text":"<p>This section ties all the pieces of the UTXO rule together.</p> <p>(The symbol <code>\u2261?</code> is explained in Section Notation.)</p> <pre><code>data _\u22a2_\u21c0\u2987_,UTXO\u2988_ where\n\n  UTXO-inductive :\n    let pp        = \u0393 .pparams\n        slot      = \u0393 .slot\n        treasury  = \u0393 .treasury\n        utxo      = s .UTxOState.utxo\n</code></pre> <pre><code>        txOuts\u02b0   = mapValues txOutHash txOuts\n        overhead  = 160\n    in\n    \u2219 txIns \u2262 \u2205                              \u2219 txIns \u222a refInputs \u2286 dom utxo\n    \u2219 txIns \u2229 refInputs \u2261 \u2205                  \u2219 inInterval slot txVldt\n    \u2219 minfee pp utxo tx \u2264 txFee              \u2219 (txrdmrs \u02e2 \u2262 \u2205 \u2192 collateralCheck pp tx utxo)\n    \u2219 consumed pp s txb \u2261 produced pp s txb  \u2219 coin mint \u2261 0\n    \u2219 txsize \u2264 maxTxSize pp\n    \u2219 refScriptsSize utxo tx \u2264 pp .maxRefScriptSizePerTx\n    \u2219 \u2200[ (_ , txout) \u2208 \u2223 txOuts\u02b0 \u2223 ]\n        inject ((overhead + utxoEntrySize txout) * coinsPerUTxOByte pp) \u2264\u1d57 getValue\u02b0 txout\n    \u2219 \u2200[ (_ , txout) \u2208 \u2223 txOuts\u02b0 \u2223 ]\n        serSize (getValue\u02b0 txout) \u2264 maxValSize pp\n    \u2219 \u2200[ (a , _) \u2208 range txOuts\u02b0 ]\n        Sum.All (const \u22a4) (\u03bb a \u2192 a .BootstrapAddr.attrsSize \u2264 64) a\n    \u2219 \u2200[ (a , _) \u2208 range txOuts\u02b0 ]  netId a        \u2261 NetworkId\n    \u2219 \u2200[ a \u2208 dom txWithdrawals ]    NetworkIdOf a  \u2261 NetworkId\n    \u2219 txNetworkId  ~ just NetworkId\n    \u2219 currentTreasury  ~ just treasury\n    \u2219 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s'\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxo.html#references","title":"References","text":"<p>[Corduan22]  Jared Corduan. Track individual deposits. 2022.</p> <p>[CVG19]  Jared Corduan and Polina Vinogradova and Matthias G\u00fcdemann. A Formal Specification of the Cardano Ledger. 2019.</p>"},{"location":"Ledger.Conway.Specification.Utxow.Properties.Computational.html","title":"Computational","text":"<pre><code>{-# OPTIONS --safe #-}\n\nimport Data.Maybe as M\n\nopen import Ledger.Prelude\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Utxow.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Utxow txs abs\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational txs abs\n\ninstance\n  Computational-UTXOW : Computational _\u22a2_\u21c0\u2987_,UTXOW\u2988_ String\n  Computational-UTXOW = record {Go}\n    where module Go \u0393 s tx (let H , \u2047 H? = UTXOW-inductive-premises {s = s} {tx = tx}) where\n\n    open Computational Computational-UTXO\n      renaming (computeProof to computeProof'; completeness to completeness')\n\n    genErr : \u00ac H \u2192 String\n    genErr  \u00acp = case dec-de-morgan \u00acp of \u03bb where\n      (inj\u2081 a) \u2192 \"\u00ac \u2200[ (vk , \u03c3) \u2208 vkSigs ] isSigned vk (txidBytes txid) \u03c3\"\n      (inj\u2082 b) \u2192 case dec-de-morgan b of \u03bb where\n        (inj\u2081 a\u2081) \u2192 \"\u2200[ s \u2208 scriptsP1 ] validP1Script witsKeyHashes txvldt s\"\n        (inj\u2082 b\u2081) \u2192 case dec-de-morgan b\u2081 of \u03bb where\n          (inj\u2081 a\u2082) \u2192 \"witsVKeyNeeded utxo txb \u2286 witsKeyHashes\"\n          (inj\u2082 b\u2082) \u2192 case dec-de-morgan b\u2082 of \u03bb where\n            (inj\u2081 a\u2083) \u2192 \"(neededHashes - refScriptHashes) \u2261\u1d49 witsScriptHashes\"\n            (inj\u2082 b\u2083) \u2192 case dec-de-morgan b\u2083 of \u03bb where\n              (inj\u2081 a\u2084) \u2192 \"inputHashes \u2286 txdatsHashes\"\n              (inj\u2082 b\u2084) \u2192 case dec-de-morgan b\u2084 of \u03bb where\n                (inj\u2081 a\u2085) \u2192 \"txdatsHashes \u2286 (inputHashes \u222a allOutHashes \u222a getDataHashes (range (utxo \u2223 refInputs)))\"\n                (inj\u2082 b\u2085) \u2192 case dec-de-morgan b\u2085 of \u03bb where\n                  (inj\u2081 a\u2086) \u2192 \"languages \u2286 allowedLanguages\"\n                  (inj\u2082 b\u2086) \u2192 \"txADhash \u2261 map hash txAD\"\n\n    computeProof : ComputationResult String (\u2203 (\u0393 \u22a2 s \u21c0\u2987 tx ,UTXOW\u2988_))\n    computeProof =\n      case H? of \u03bb where\n        (yes (p\u2081 , p\u2082 , p\u2083 , p\u2084 , p\u2085 , p\u2086 , p\u2087 , p\u2088)) \u2192\n          map (map\u2082\u2032 (UTXOW-inductive\u22ef p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 p\u2087 p\u2088)) (computeProof' \u0393 s tx)\n        (no \u00acp) \u2192 failure $ genErr \u00acp\n\n    completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n                        \u2192 map proj\u2081 computeProof \u2261 success s'\n    completeness s' (UTXOW-inductive\u22ef p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 p\u2087 p\u2088 h) with H?\n    ... | no \u00acp = \u22a5-elim $ \u00acp ((p\u2081 , p\u2082 , p\u2083 , p\u2084 , p\u2085 , p\u2086 , p\u2087 , p\u2088))\n    ... | yes _ with computeProof' \u0393 s tx | completeness' _ _ _ _ h\n    ... | success _ | refl = refl\n</code></pre>"},{"location":"Ledger.Conway.Specification.Utxow.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Utxow.Properties where\n\nopen import Ledger.Conway.Specification.Utxow.Properties.Computational\n</code></pre>"},{"location":"Ledger.Conway.Specification.html","title":"Specification","text":"<pre><code>{-# OPTIONS --safe #-}\nmodule Ledger.Conway.Specification where\n\nimport Ledger.Conway.Specification.BlockBody\nimport Ledger.Conway.Specification.BlockBody.Properties\nimport Ledger.Conway.Specification.Certs\nimport Ledger.Conway.Specification.Certs.Properties\nimport Ledger.Conway.Specification.Chain\nimport Ledger.Conway.Specification.Chain.Properties\nimport Ledger.Conway.Specification.Enact\nimport Ledger.Conway.Specification.Enact.Properties\nimport Ledger.Conway.Specification.Epoch\nimport Ledger.Conway.Specification.Epoch.Properties\nimport Ledger.Conway.Specification.Fees\nimport Ledger.Conway.Specification.Gov\nimport Ledger.Conway.Specification.Gov.Actions\nimport Ledger.Conway.Specification.Gov.Properties\nimport Ledger.Conway.Specification.Gov.Properties.ChangePPGroup\nimport Ledger.Conway.Specification.Ledger\nimport Ledger.Conway.Specification.Ledger.Properties\nimport Ledger.Conway.Specification.PParams\nimport Ledger.Conway.Specification.Properties\nimport Ledger.Conway.Specification.Ratify\nimport Ledger.Conway.Specification.Ratify.Properties\nimport Ledger.Conway.Specification.Rewards\nimport Ledger.Conway.Specification.RewardUpdate\nimport Ledger.Conway.Specification.RewardUpdate.Properties\nimport Ledger.Conway.Specification.Script\nimport Ledger.Conway.Specification.Script.Validation\nimport Ledger.Conway.Specification.Test.Examples\nimport Ledger.Conway.Specification.Test.StructuredContracts\nimport Ledger.Conway.Specification.TokenAlgebra.Base\nimport Ledger.Conway.Specification.TokenAlgebra.Coin\nimport Ledger.Conway.Specification.TokenAlgebra.ValueSet\nimport Ledger.Conway.Specification.TokenAlgebra.ValueVector\nimport Ledger.Conway.Specification.Transaction\nimport Ledger.Conway.Specification.Types.GovStructure\nimport Ledger.Conway.Specification.Utxo\nimport Ledger.Conway.Specification.Utxo.Properties\nimport Ledger.Conway.Specification.Utxow\nimport Ledger.Conway.Specification.Utxow.Properties\n</code></pre>"},{"location":"Ledger.Conway.html","title":"Conway","text":"<pre><code>module Ledger.Conway where\n\n--- ** Cardano ledger in the Conway era\nimport Ledger.Conway.Specification\n\n-- ** Conformance test reconciliation\nimport Ledger.Conway.Conformance\n\n-- ** Haskell code extraction\nimport Ledger.Conway.Foreign.HSLedger\n\n-- ** Not currently used\nimport Foreign.Convertible.DerivingTest\n</code></pre>"},{"location":"Ledger.Core.Specification.Epoch.html","title":"Epoch","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Core.Specification.Epoch where\n\nopen import Ledger.Prelude hiding (compare; Rel)\n\nopen import Agda.Builtin.FromNat\nopen import Algebra using (Semiring)\nopen import Relation.Binary\nopen import Data.Nat.Properties using (+-*-semiring)\nopen import Data.Rational using (\u211a)\nimport      Data.Rational as \u211a\nimport      Data.Rational.Properties as \u211a\n\nadditionVia : \u2200{A : Set} \u2192 (A \u2192 A) \u2192 \u2115 \u2192 A \u2192 A\nadditionVia sucFun zero r = r\nadditionVia sucFun (suc l) r = sucFun (additionVia sucFun l r)\n\nrecord EpochStructure : Type\u2081 where\n  field Slot\u02b3 : Semiring 0\u2113 0\u2113\n        Epoch : Type; \u2983 DecEq-Epoch \u2984 : DecEq Epoch; \u2983 Show-Epoch \u2984 : Show Epoch\n\n  Slot = Semiring.Carrier Slot\u02b3\n\n  field \u2983 DecPo-Slot \u2984   : HasDecPartialOrder\u2261 {A = Slot}\n        \u2983 DecEq-Slot \u2984   : DecEq Slot\n\n        epoch                         : Slot \u2192 Epoch\n        firstSlot                     : Epoch \u2192 Slot\n        RandomnessStabilisationWindow : Slot\n        StabilityWindow               : Slot\n        suc\u1d49                          : Epoch \u2192 Epoch\n\n  _+\u1d49_ = additionVia suc\u1d49\n\n  field\n        _+\u1d49'_           : \u2115 \u2192 Epoch \u2192 Epoch\n        +\u1d49\u2261+\u1d49'          : \u2200 {a b} \u2192 a +\u1d49 b \u2261 a +\u1d49' b\n\n  -- preorders and partial orders\n\n  instance\n    preoEpoch : HasPreorder\n    preoEpoch = hasPreorderFromStrictPartialOrder {_&lt;_ = _&lt;_ on firstSlot}\n      record\n        { isEquivalence = isEquivalence\n        ; irrefl = \u03bb where refl \u2192 &lt;-irrefl {A = Slot} refl\n        ; trans  = &lt;-trans {A = Slot}\n        ; &lt;-resp-\u2248 = (\u03bb where refl \u2192 id) , (\u03bb where refl \u2192 id)\n        }\n\n  _ = _&lt;_ {A = Slot}  \u2047\u00b2 \u220b it\n  _ = _\u2264_ {A = Slot}  \u2047\u00b2 \u220b it\n  _ = _&lt;_ {A = Epoch} \u2047\u00b2 \u220b it\n  _ = _\u2264_ {A = Epoch} \u2047\u00b2 \u220b it\n\n  -- addition\n\n  open Semiring Slot\u02b3 renaming (_+_ to _+\u02e2_)\n\n  \u2115toEpoch : \u2115 \u2192 Epoch\n  \u2115toEpoch zero    = epoch 0#\n  \u2115toEpoch (suc n) = suc\u1d49 (\u2115toEpoch n)\n\n  instance\n    addSlot : HasAdd Slot\n    addSlot ._+_ = _+\u02e2_\n\n    addEpoch : HasAdd Epoch\n    addEpoch ._+_ e e' = epoch (firstSlot e + firstSlot e')\n\n    Number-Epoch : Number Epoch\n    Number-Epoch .Number.Constraint _ = \u22a4\n    Number-Epoch .Number.fromNat    x = \u2115toEpoch x\n\nrecord GlobalConstants : Type\u2081 where\n  field  Network : Type; \u2983 DecEq-Netw \u2984 : DecEq Network; \u2983 Show-Network \u2984 : Show Network\n         SlotsPerEpoch\u1d9c   : \u2115; \u2983 NonZero-SlotsPerEpoch\u1d9c \u2984 : NonZero SlotsPerEpoch\u1d9c\n         ActiveSlotCoeff  : \u211a; \u2983 Positive-ActiveSlotCoeff \u2984 : \u211a.Positive ActiveSlotCoeff\n         RandomnessStabilisationWindow\u1d9c : \u2115\n         StabilityWindow\u1d9c : \u2115\n         MaxLovelaceSupply\u1d9c : Coin\n         Quorum : \u2115\n         NetworkId : Network\n\n  instance\n    NonZero-ActiveSlotCoeff : \u211a.NonZero ActiveSlotCoeff\n    NonZero-ActiveSlotCoeff = \u211a.&gt;-nonZero (\u211a.positive\u207b\u00b9 ActiveSlotCoeff)\n\n  \u2115+\u1d49\u2261+\u1d49' : \u2200 {a b} \u2192 additionVia suc a b \u2261 a + b\n  \u2115+\u1d49\u2261+\u1d49' {zero} {b} = refl\n  \u2115+\u1d49\u2261+\u1d49' {suc a} {b} = cong suc (\u2115+\u1d49\u2261+\u1d49' {a} {b})\n\n  \u2115EpochStructure : EpochStructure\n  \u2115EpochStructure = \u03bb where\n    .Slot\u02b3                         \u2192 +-*-semiring\n    .Epoch                         \u2192 \u2115\n    .epoch slot                    \u2192 slot / SlotsPerEpoch\u1d9c\n    .firstSlot e                   \u2192 e * SlotsPerEpoch\u1d9c\n    .RandomnessStabilisationWindow \u2192 RandomnessStabilisationWindow\u1d9c\n    .StabilityWindow               \u2192 StabilityWindow\u1d9c\n    .suc\u1d49                          \u2192 suc\n    ._+\u1d49'_                         \u2192 _+_\n    .+\u1d49\u2261+\u1d49' {a} {b}                \u2192 \u2115+\u1d49\u2261+\u1d49' {a} {b}\n\n   where open EpochStructure\n\nopen GlobalConstants using (\u2115EpochStructure) public\n</code></pre>"},{"location":"Ledger.Introduction.html","title":"Introduction","text":"Conway specifics <p>This is the specification of the Conway era of the Cardano ledger. As with previous specifications, this document is an incremental specification, so everything that isn\u2019t defined here refers to the most recent definition from an older specification.</p> <p>This is the work-in-progress specification of the Cardano ledger. The Agda source code with which we formalize the ledger specification and which generates this pdf document is open source and resides at the following</p> <p>Repository url: https://github.com/IntersectMBO/formal-ledger-specifications</p> <p>The current status of each individual era is described in Table 1.</p> <p> <p>Table 1. Specification Progress</p> Era Figures Prose Cleanup Shelley\u00a0 Partial Partial Not started Shelley-MA\u00a0 Partial Partial Not started Alonzo\u00a0 Partial Partial Not started Babbage\u00a0 Not started Not started Not started Conway\u00a0 Complete Partial Partial <p></p>"},{"location":"Ledger.Introduction.html#sec:overview","title":"Overview","text":"<p>This document describes, in a precise and executable way, the behavior of the Cardano ledger that can be updated in response to a series of events. Because of the precise nature of the document, it can be dense and difficult to read at times, and it can be helpful to have a high-level understanding of what it is trying to describe, which we present below. Keep in mind that this section focuses on intuition, using terms (set in italics) which may be unfamiliar to some readers, but rest assured that later sections of the document will make the intuition and italicized terms precise.</p>"},{"location":"Ledger.Introduction.html#a-note-on-agda","title":"A Note on Agda","text":"<p>This specification is written using the \u00a0. We have made a considerable effort to ensure that this document is readable by people unfamiliar with Agda (or other proof assistants, functional programming languages, etc.). However, by the nature of working in a formal language we have to play by its rules, meaning that some instances of uncommon notation are very difficult or impossible to avoid. Some are explained in the Notation and [Agda Essentials][] sections, but there is no guarantee that those sections are complete. If the meaning of an expression is confusing or unclear, please open an issue in the formal ledger repository with the \"notation\" label.</p>"},{"location":"Ledger.Introduction.html#separation-of-concerns","title":"Separation of Concerns","text":"<p>The Cardano Node consists of three pieces,</p> <ul> <li> <p>a networking layer responsible for sending messages across the   internet,</p> </li> <li> <p>a consensus layer establishing a common order of valid blocks, and</p> </li> <li> <p>a ledger layer which determines whether a sequence of blocks is   valid.</p> </li> </ul> <p>Because of this separation, the ledger can be modeled as a state machine,</p> \\[s \\xrightarrow[X]{b} s'.\\] <p>More generally, we will consider state machines with an environment,</p> \\[\u0393 \u22a2 s \\xrightarrow[X]{b} s'.\\] <p>These are modelled as 4-ary relations between the environment \\(\u0393\\), an initial state \\(s\\), a signal \\(b\\) and a final state \\(s'\\). The ledger consists of roughly 25 (depending on the version) such relations that depend on each other, forming a directed graph that is almost a tree. STS diagram. Thus each such relation represents the transition rule of the state machine; \\(X\\) is simply a placeholder for the name of the transition rule.</p>"},{"location":"Ledger.Introduction.html#sec:ledger-state-transition-rules","title":"Ledger State Transition Rules","text":"<p>By a ledger we mean a structure that contains information about how funds in the system are distributed accross accounts\u2014that is, account balances, how such balances should be adjusted when transactions and proposals are processed, the ADA currently held in the treasury reserve, a list of stake pools operating the network, and so on.</p> <p>The ledger can be updated in response to certain events, such as receiving a new transaction, time passing and crossing an epoch boundary, enacting a governance proposal, to name a few. This document defines, as part of the behaior of the ledger, a set of rules that determine which events are valid and exactly how the state of the ledger should be updated in response to those events. The primary aim of this document is to provide a precise description of this system\u2014the ledger state, valid events and the rules for processing them.</p> <p>We will model this via a number of state transition systems (STS) which from now on we refer to as \u201ctransition rules\u201d or just \u201crules.\u201d These rules describe the different behaviors that determine how the whole system evolves and, taken together, they comprise a full description of the ledger protocol. Each transition rule consists of the following components:</p> <ul> <li> <p>an environment consisting of data, read from the ledger state or the   outside world, which should be considered constant for the purposes of   the rule;</p> </li> <li> <p>an initial state, consisting of the subset of the full ledger state   that is relevant to the rule and which the rule can update;</p> </li> <li> <p>a signal or event, with associated data, that the rule can receive   or observe;</p> </li> <li> <p>a set of preconditions that must be met in order for the transition   to be valid;</p> </li> <li> <p>a new state that results from the transition rule.</p> </li> </ul> <p>For example, the UTXOW transition rule defined in UTXOW inference rules of the Utxow module checks that, among other things, a given transaction is signed by the appropriate parties.</p> <p>The transition rules can be composed in the sense that they may require other transition rules to hold as part of their preconditions. For example, the UTXOW rule mentioned above requires the UTXO rule, which checks that the inputs to the transaction exist, that the transaction is balanced, and several other conditions.</p> <p>Figure: STS Diagram</p> <p>State transition rules of the ledger specification, presented as a directed graph; each node represents a transition rule; an arrow from rule A to rule B indicates that B appears among the premises of A; a dotted arrow represents a dependency in the sense that the output of the target node is an input to the source node, either as part of the source state, the environment or the event.</p> <p> Rules added in Conway;  Rules modified in Conway</p> <p> </p> <p>A brief description of each transition rule is provided below, with a link to an Agda module and reference to a section where the rule is formally defined.</p> <ul> <li> <p>CHAIN is the top level transition in response to a new block that applies   the NEWEPOCH transition when crossing an epoch boundary, and the   LEDGERS transition on the list of transactions in the body.</p> </li> <li> <p>NEWEPOCH computes the new state as of the start of a new epoch; includes the   previous EPOCH transition.</p> </li> <li> <p>EPOCH computes the new state as of the end of an epoch; includes the ENACT,   RATIFY, and SNAP transition rules.</p> </li> <li> <p>RATIFY decides whether a pending governance action has reached the thresholds   it needs to be ratified.</p> </li> <li> <p>ENACT applies the result of a previously ratified governance action, such as   triggering a hard fork or updating the protocol parameters.</p> </li> <li> <p>SNAP computes new stake distribution snapshots.</p> </li> <li> <p>LEDGERS applies LEDGER repeatedly as needed, for each transaction in a list of   transactions.</p> </li> <li> <p>LEDGER is the full state update in response to a single transaction; it   includes the UTXOW, GOV, and CERTS rules.</p> </li> <li> <p>CERTS applies CERT repeatedly for each certificate in the transaction.</p> </li> <li> <p>CERT combines DELEG, POOL, GOVCERT transition rules, as well as some   additional rules shared by all three.</p> </li> <li> <p>DELEG handles registering stake addresses and delegating to a stake pool.</p> </li> <li> <p>GOVCERT handles registering and delegating to <code>DRep</code>s.</p> </li> <li> <p>POOL handles registering and retiring stake pools.</p> </li> <li> <p>GOV handles voting and submitting governance proposals.</p> </li> <li> <p>UTXOW checks that a transaction is witnessed correctly with the appropriate   signatures, datums, and scripts; includes the UTXO transition rule.</p> </li> <li> <p>UTXO checks core invariants for an individual transaction to be valid, such   as the transaction being balanced, fees being paid, etc; include the   UTXOS transition rule.</p> </li> <li> <p>UTXOS checks that any relevant scripts needed by the transaction evaluate to true.</p> </li> </ul>"},{"location":"Ledger.Introduction.html#reflexive-transitive-closure","title":"Reflexive-transitive Closure","text":"<p>Some state transition rules need to be applied as many times as possible to arrive at a final state. Since we use this pattern multiple times, we define a closure operation which takes a transition rule and applies it as many times as possible.</p> <p>The closure <code>RTCI</code> of a relation <code>RTCB</code> is defined in Reflexive transitive closure. In the remainder of the text, the closure operation is called <code>RTC</code>.</p>"},{"location":"Ledger.Introduction.html#reflexive-transitive-closure_1","title":"Reflexive transitive closure","text":"<p>Closure type</p> <p><pre><code>  data _\u22a2_\u21c0\u27e6_\u27e7*_ : C \u2192 S \u2192 List Sig \u2192 S \u2192 Type where\n</code></pre> Closure rules <pre><code>    RTC-base :\n      \u0393 \u22a2 s \u21c0\u27e6 [] \u27e7* s\n\n    RTC-ind :\n      \u2219 \u0393 \u22a2 s  \u21c0\u27e6 sig  \u27e7  s'\n      \u2219 \u0393 \u22a2 s' \u21c0\u27e6 sigs \u27e7* s''\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 s \u21c0\u27e6 sig \u2237 sigs \u27e7* s''\n</code></pre></p>"},{"location":"Ledger.Introduction.html#computational","title":"Computational","text":"<p>Since all such state machines need to be evaluated by the nodes and all nodes should compute the same states, the relations specified by them should be computable by functions. This can be captured by the definition in Computational relations which is parametrized over the state transition relation.</p>"},{"location":"Ledger.Introduction.html#computational-relations","title":"Computational relations","text":"<pre><code>record Computational (_\u22a2_\u21c0\u2987_,X\u2988_ : C \u2192 S \u2192 Sig \u2192 S \u2192 Type) : Type where\n  field\n    compute     : C \u2192 S \u2192 Sig \u2192 Maybe S\n    \u2261-just\u21d4STS  : compute \u0393 s b \u2261 just s' \u21d4 \u0393 \u22a2 s \u21c0\u2987 b ,X\u2988 s'\n\n  nothing\u21d2\u2200\u00acSTS : compute \u0393 s b \u2261 nothing \u2192 \u2200 s' \u2192 \u00ac \u0393 \u22a2 s \u21c0\u2987 b ,X\u2988 s'\n</code></pre> <p>Unpacking this, we have a <code>compute</code> function that computes a final state from a given environment, state and signal. The second piece is correctness: <code>compute</code> succeeds with some final state if and only if that final state is in relation to the inputs.</p> <p>This has two further implications:</p> <ul> <li> <p>Since <code>compute</code> is a function, the state transition   relation is necessarily a (partial) function; i.e., there is at most   one possible final state for each input data. Otherwise, we could   prove that <code>compute</code> could evaluates to two different   states on the same inputs, which is impossible since it is a function.</p> </li> <li> <p>The actual definition of <code>compute</code> is irrelevant\u2014any two   implementations of <code>compute</code> have to produce the same   result on any input. This is because we can simply chain the   equivalences for two different <code>compute</code> functions   together.</p> </li> </ul> <p>What this all means in the end is that if we give a <code>Computational</code> instance for every relation defined in the ledger, we also have an executable version of the rules which is guaranteed to be correct. This is indeed something we have done, and the same source code that generates this document also generates a Haskell library that lets anyone run this code.</p>"},{"location":"Ledger.Introduction.html#sec:sets-maps","title":"Sets &amp; Maps","text":"<p>The ledger heavily uses set theory. For various reasons it was necessary to implement our own set theory (there will be a paper on this some time in the future). Crucially, the set theory is completely abstract (in a technical sense\u2014Agda has an abstract keyword) meaning that implementation details of the set theory are irrelevant. Additionally, all sets in this specification are finite.</p> <p>We use this set theory to define maps as seen below, which are used in many places. We usually think of maps as partial functions (i.e., functions not necessarily defined everywhere\u2014equivalently, \"left-unique\" relations) and we use the harpoon arrow to distinguish such maps from standard Agda functions which use . The code below also gives notation for the powerset operation, <code>PowerSet</code>, used to form a type of sets with elements in a given type, as well as the subset relation and the equality relation for sets.</p> <p>When we need to convert a list to its set of elements, we write <code>fromList</code>\u00a0.</p> <pre><code>_\u2286_ : {A : Type} \u2192 \u2119 A \u2192 \u2119 A \u2192 Type\nX \u2286 Y = \u2200 {x} \u2192 x \u2208 X \u2192 x \u2208 Y\n\n_\u2261\u1d49_ : {A : Type} \u2192 \u2119 A \u2192 \u2119 A \u2192 Type\nX \u2261\u1d49 Y = X \u2286 Y \u00d7 Y \u2286 X\n\nRel : Type \u2192 Type \u2192 Type\nRel A B = \u2119 (A \u00d7 B)\n\nleft-unique : {A B : Type} \u2192 Rel A B \u2192 Type\nleft-unique R = \u2200 {a b b'} \u2192 (a , b) \u2208 R \u2192 (a , b') \u2208 R \u2192 b \u2261 b'\n\n_\u21c0_ : Type \u2192 Type \u2192 Type\nA \u21c0 B = r \u2208 Rel A B \ufe50 left-unique r\n</code></pre>"},{"location":"Ledger.Introduction.html#sec:prop-as-types","title":"Propositions as Types, Properties and Relations","text":"<p>In type theory we represent propositions as types and proofs of a proposition as elements of the corresponding type. A unary predicate is a function that takes each <code>x</code> (of some type <code>A</code>) and returns a proposition <code>P</code>(<code>x</code>). Thus, a predicate is a function of type <code>A</code> \u2192 <code>Type</code>. A binary relation <code>R</code> between <code>A</code> and <code>B</code> is a function that takes a pair of values <code>x</code> and <code>y</code> and returns a proposition asserting that the relation <code>R</code> holds between <code>x</code> and <code>y</code>. Thus, such a relation is a function of type <code>A</code> <code>\u00d7</code> <code>B</code> \u2192 <code>Type</code> or <code>A</code> \u2192 <code>B</code> \u2192 <code>Type</code>.</p> <p>These relations are typically required to be decidable, which means that there is a boolean-valued function that computes whether the predicate holds or not. This means that it is generally safe to think of predicates simply returning a boolean value instead.</p>"},{"location":"Ledger.PreConway.Conformance.NewPP.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Relation.Nullary.Decidable\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.Conformance.NewPP.Properties (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.PreConway.Conformance.PPUp txs\nopen import Ledger.PreConway.Conformance.NewPP txs\n\ninstance\n  Computational-NEWPP : Computational _\u22a2_\u21c0\u2987_,NEWPP\u2988_ String\n  Computational-NEWPP = record {M} where module M \u0393 s (open NewPParamState s) where\n    computeProof = \u03bb where\n      nothing \u2192 success (_ , NEWPP-Reject)\n      (just upd) \u2192 let newpp = applyUpdate pparams upd in\n        case \u00bf viablePParams newpp \u00bf of \u03bb where\n          (yes p) \u2192 success (_ , NEWPP-Accept p)\n          (no _)  \u2192 failure \"Failed in NEWPP\"\n\n    completeness : _\n    completeness sig s' h with sig | h\n    ... | nothing  | NEWPP-Reject   = refl\n    ... | just upd | NEWPP-Accept p = refl\n</code></pre>"},{"location":"Ledger.PreConway.Conformance.NewPP.html","title":"NewPP","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Relation.Nullary.Decidable\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.Conformance.NewPP (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.PreConway.Conformance.PPUp txs\n\nrecord NewPParamEnv : Type where\n--  field\n\nrecord NewPParamState : Type where\n  field\n    pparams  : PParams\n    ppup     : PPUpdateState\n\ninstance\n  unquoteDecl HasCast-NewPParamState = derive-HasCast\n    [ (quote NewPParamState , HasCast-NewPParamState) ]\n\nupdatePPUp : PParams \u2192 PPUpdateState \u2192 PPUpdateState\nupdatePPUp pparams record { fpup = fpup }\n  with all\u1d47 \u00bf isViableUpdate pparams \u00bf\u00b9 (range fpup)\n... | false  = record { pup = \u2205\u1d50    ; fpup = \u2205\u1d50 }\n... | true   = record { pup = fpup  ; fpup = \u2205\u1d50 }\n\nvotedValue : ProposedPPUpdates \u2192 PParams \u2192 \u2115 \u2192 Maybe PParamsUpdate\nvotedValue pup pparams quorum =\n  case any? (\u03bb u \u2192 length\u02e2 (pup \u2223^ fromList [ u ]) \u2265? quorum) (range pup) of\n    \u03bb  where\n       (no  _)        \u2192 nothing\n       (yes (u , _))  \u2192 just u\n\nprivate variable\n  \u0393 : NewPParamEnv\n  s s' : NewPParamState\n  upd : PParamsUpdate\n\ndata _\u22a2_\u21c0\u2987_,NEWPP\u2988_ : NewPParamEnv \u2192 NewPParamState \u2192 Maybe PParamsUpdate \u2192 NewPParamState \u2192 Type where\n\n  NEWPP-Accept : \u2200 {\u0393} \u2192 let open NewPParamState s; newpp = applyUpdate pparams upd in\n    viablePParams newpp\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u0393 \u22a2 s \u21c0\u2987 just upd ,NEWPP\u2988 \u27e6 newpp , updatePPUp newpp ppup \u27e7\n\n  NEWPP-Reject : \u2200 {\u0393} \u2192\n    \u0393 \u22a2 s \u21c0\u2987 nothing ,NEWPP\u2988 s\n</code></pre>"},{"location":"Ledger.PreConway.Conformance.PPUp.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (_*_)\nopen Computational \u2983...\u2984; open HasDecPartialOrder \u2983...\u2984\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.Conformance.PPUp.Properties (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.PreConway.Conformance.PPUp txs\n\nprivate\n  -- Ring literals\n  open import Agda.Builtin.FromNat\n  open import Algebra; open Semiring Slot\u02b3 using (_*_)\n  open import stdlib.Algebra.Literals; open Semiring-Lit Slot\u02b3\n\n  Current-Property : PPUpdateEnv \u2192 Update \u2192 Type\n  Current-Property \u0393 (pup , e) = let open PPUpdateEnv \u0393 in\n      dom pup \u2286 dom genDelegs\n      \u00d7 All (isViableUpdate pparams) (range pup)\n      \u00d7 slot + 2 * StabilityWindow &lt; firstSlot (epoch slot + 1)\n      \u00d7 epoch slot \u2261 e\n\n  Future-Property : PPUpdateEnv \u2192 Update \u2192 Type\n  Future-Property \u0393 (pup , e) = let open PPUpdateEnv \u0393 in\n      dom pup \u2286 dom genDelegs\n      \u00d7 All (isViableUpdate pparams) (range pup)\n      \u00d7 firstSlot (epoch slot + 1) \u2264 slot + 2 * StabilityWindow\n      \u00d7 epoch slot + 1 \u2261 e\n\ninstance\n  Computational-PPUP : Computational _\u22a2_\u21c0\u2987_,PPUP\u2988_ String\n  Computational-PPUP .computeProof \u0393 s = \u03bb where\n    (just (pup , e)) \u2192\n      case \u00bf Current-Property \u0393 (pup , e) \u00bf\n        ,\u2032 \u00bf Future-Property \u0393 (pup , e) \u00bf of \u03bb where\n        (yes (p\u2081 , p\u2082 , p\u2083 , p\u2084) , _) \u2192 success (-, PPUpdateCurrent p\u2081 p\u2082 p\u2083 p\u2084)\n        (_ , yes (p\u2081 , p\u2082 , p\u2083 , p\u2084)) \u2192 success (-, PPUpdateFuture p\u2081 p\u2082 p\u2083 p\u2084)\n        (no _ , no _)                 \u2192 failure \"Failed in PPUP\"\n    nothing \u2192 success (-, PPUpdateEmpty)\n\n  Computational-PPUP .completeness \u0393 _ .nothing  _     PPUpdateEmpty = refl\n  Computational-PPUP .completeness \u0393 _ (just up) _ p   with p\n  Computational-PPUP .completeness \u0393 _ (just up) _ _ | PPUpdateCurrent p\u2081 p\u2082 p\u2083 p\u2084\n    rewrite dec-yes \u00bf Current-Property \u0393 up \u00bf (p\u2081 , p\u2082 , p\u2083 , p\u2084) .proj\u2082 = refl\n  Computational-PPUP .completeness \u0393 _ (just up) _ _ | PPUpdateFuture p\u2081 p\u2082 p\u2083 p\u2084\n    with \u00bf Current-Property \u0393 up \u00bf | \u00bf Future-Property \u0393 up \u00bf\n  ... | yes (_ , _ , \u00acp\u2083 , _) | _ = \u22a5-elim\n                                  $ &lt;\u21d2\u00ac&gt;\u228e\u2248 {A = Slot} \u00acp\u2083 (\u2264\u21d4&lt;\u2228\u2248 .Equivalence.to p\u2083)\n  ... | no _ | yes p = refl\n  ... | no _ | no \u00acp = \u22a5-elim (\u00acp (p\u2081 , p\u2082 , p\u2083 , p\u2084))\n</code></pre>"},{"location":"Ledger.PreConway.Conformance.PPUp.html","title":"PPUp","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Agda.Builtin.FromNat\nopen import Algebra; open import stdlib.Algebra.Literals\nimport Data.Product.Properties as \u00d7\nimport Data.Nat as \u2115; import Data.Nat.Properties as \u2115\n\nopen import Ledger.Prelude hiding (_*_)\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.Conformance.PPUp (txs : _) (open TransactionStructure txs) where\n\nopen Semiring Slot\u02b3 using (_*_)\nopen Semiring-Lit Slot\u02b3\n\nprivate variable m n : \u2115\n\nGenesisDelegation = KeyHash \u21c0 (KeyHash \u00d7 KeyHash)\n\nrecord PPUpdateState : Type where\n\n  field\n\n    pup   : ProposedPPUpdates\n    fpup  : ProposedPPUpdates\n\nrecord PPUpdateEnv : Type where\n\n  field\n\n    slot       : Slot\n    pparams    : PParams\n    genDelegs  : GenesisDelegation\n\nviablePParams : PParams \u2192 Type\nviablePParams pp = \u22a4 -- TODO: block size check\n\nisViableUpdate : PParams \u2192 PParamsUpdate \u2192 Type\nisViableUpdate pp pup with applyUpdate pp pup\n... | pp' = pvCanFollow (PParams.pv pp) (PParams.pv pp') \u00d7 viablePParams pp'\n\nprivate variable\n  \u0393 : PPUpdateEnv\n  s : PPUpdateState\n  e : Epoch\n  pup pup\u02e2 fpup\u02e2 : ProposedPPUpdates\n\ninstance\n  Dec-pvCanFollow : pvCanFollow \u2047\u00b2\n  Dec-pvCanFollow {(m , n)} {pv} .dec with pv \u225f (m + 1 , 0) | pv \u225f (m , n + 1)\n  ... | no \u00acp    | no \u00acp\u2081   = no $ \u03bb where canFollowMajor \u2192 \u00acp  refl\n                                           canFollowMinor \u2192 \u00acp\u2081 refl\n  ... | no \u00acp    | yes refl = yes canFollowMinor\n  ... | yes refl | no \u00acp    = yes canFollowMajor\n  ... | yes refl | yes p    = \u22a5-elim $ \u2115.m+1+n\u2262m m $ \u00d7.\u00d7-\u2261,\u2261\u2190\u2261 p .proj\u2081\n\ndata _\u22a2_\u21c0\u2987_,PPUP\u2988_ : PPUpdateEnv \u2192 PPUpdateState \u2192 Maybe Update \u2192 PPUpdateState \u2192 Type where\n\n  PPUpdateEmpty : \u0393 \u22a2 s \u21c0\u2987 nothing ,PPUP\u2988 s\n\n  PPUpdateCurrent : let open PPUpdateEnv \u0393 in\n    dom pup \u2286 dom genDelegs\n    \u2192 All (isViableUpdate pparams) (range pup)\n    \u2192 slot + 2 * StabilityWindow &lt; firstSlot (epoch slot + 1)\n    \u2192 epoch slot \u2261 e\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u0393 \u22a2 record { pup = pup\u02e2 ; fpup = fpup\u02e2 } \u21c0\u2987 just (pup , e) ,PPUP\u2988\n        record { pup = pup \u222a\u02e1 pup\u02e2 ; fpup = fpup\u02e2 }\n\n  PPUpdateFuture : let open PPUpdateEnv \u0393 in\n    dom pup \u2286 dom genDelegs\n    \u2192 All (isViableUpdate pparams) (range pup)\n    \u2192 firstSlot (epoch slot + 1) \u2264 slot + 2 * StabilityWindow\n    \u2192 epoch slot + 1 \u2261 e\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u0393 \u22a2 record { pup = pup\u02e2 ; fpup = fpup\u02e2 } \u21c0\u2987 just (pup , e) ,PPUP\u2988\n        record { pup = pup\u02e2 ; fpup = pup \u222a\u02e1 fpup\u02e2 }\n</code></pre>"},{"location":"Ledger.PreConway.NewPP.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Relation.Nullary.Decidable\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.NewPP.Properties (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.PreConway.PPUp txs\nopen import Ledger.PreConway.NewPP txs\n\ninstance\n  Computational-NEWPP : Computational _\u22a2_\u21c0\u2987_,NEWPP\u2988_ String\n  Computational-NEWPP = record {M} where module M \u0393 s (open NewPParamState s) where\n    computeProof = \u03bb where\n      nothing \u2192 success (_ , NEWPP-Reject)\n      (just upd) \u2192 let newpp = applyUpdate pparams upd in\n        case \u00bf viablePParams newpp \u00bf of \u03bb where\n          (yes p) \u2192 success (_ , NEWPP-Accept p)\n          (no _)  \u2192 failure \"Failed in NEWPP\"\n\n    completeness : _\n    completeness sig s' h with sig | h\n    ... | nothing  | NEWPP-Reject   = refl\n    ... | just upd | NEWPP-Accept p = refl\n</code></pre>"},{"location":"Ledger.PreConway.PPUp.Properties.html","title":"Properties","text":"<pre><code>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (_*_)\nopen Computational \u2983...\u2984; open HasDecPartialOrder \u2983...\u2984\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.PPUp.Properties (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.PreConway.PPUp txs\n\nprivate\n  -- Ring literals\n  open import Agda.Builtin.FromNat\n  open import Algebra; open Semiring Slot\u02b3 using (_*_)\n  open import stdlib.Algebra.Literals; open Semiring-Lit Slot\u02b3\n\n  Current-Property : PPUpdateEnv \u2192 Update \u2192 Type\n  Current-Property \u0393 (pup , e) = let open PPUpdateEnv \u0393 in\n      dom pup \u2286 dom genDelegs\n      \u00d7 All (isViableUpdate pparams) (range pup)\n      \u00d7 slot + 2 * StabilityWindow &lt; firstSlot (epoch slot + 1)\n      \u00d7 epoch slot \u2261 e\n\n  Future-Property : PPUpdateEnv \u2192 Update \u2192 Type\n  Future-Property \u0393 (pup , e) = let open PPUpdateEnv \u0393 in\n      dom pup \u2286 dom genDelegs\n      \u00d7 All (isViableUpdate pparams) (range pup)\n      \u00d7 firstSlot (epoch slot + 1) \u2264 slot + 2 * StabilityWindow\n      \u00d7 epoch slot + 1 \u2261 e\n\ninstance\n  Computational-PPUP : Computational _\u22a2_\u21c0\u2987_,PPUP\u2988_ String\n  Computational-PPUP .computeProof \u0393 s = \u03bb where\n    (just (pup , e)) \u2192\n      case \u00bf Current-Property \u0393 (pup , e) \u00bf\n        ,\u2032 \u00bf Future-Property \u0393 (pup , e) \u00bf of \u03bb where\n        (yes (p\u2081 , p\u2082 , p\u2083 , p\u2084) , _) \u2192 success (-, PPUpdateCurrent p\u2081 p\u2082 p\u2083 p\u2084)\n        (_ , yes (p\u2081 , p\u2082 , p\u2083 , p\u2084)) \u2192 success (-, PPUpdateFuture p\u2081 p\u2082 p\u2083 p\u2084)\n        (no _ , no _)                 \u2192 failure \"Failed in PPUP\"\n    nothing \u2192 success (-, PPUpdateEmpty)\n\n  Computational-PPUP .completeness \u0393 _ .nothing  _     PPUpdateEmpty = refl\n  Computational-PPUP .completeness \u0393 _ (just up) _ p   with p\n  Computational-PPUP .completeness \u0393 _ (just up) _ _ | PPUpdateCurrent p\u2081 p\u2082 p\u2083 p\u2084\n    rewrite dec-yes \u00bf Current-Property \u0393 up \u00bf (p\u2081 , p\u2082 , p\u2083 , p\u2084) .proj\u2082 = refl\n  Computational-PPUP .completeness \u0393 _ (just up) _ _ | PPUpdateFuture p\u2081 p\u2082 p\u2083 p\u2084\n    with \u00bf Current-Property \u0393 up \u00bf | \u00bf Future-Property \u0393 up \u00bf\n  ... | yes (_ , _ , \u00acp\u2083 , _) | _ = \u22a5-elim\n                                  $ &lt;\u21d2\u00ac&gt;\u228e\u2248 {A = Slot} \u00acp\u2083 (\u2264\u21d4&lt;\u2228\u2248 .Equivalence.to p\u2083)\n  ... | no _ | yes p = refl\n  ... | no _ | no \u00acp = \u22a5-elim (\u00acp (p\u2081 , p\u2082 , p\u2083 , p\u2084))\n</code></pre>"},{"location":"Ledger.Prelude.Base.html","title":"Base Types of the Cardano Ledger","text":""},{"location":"Ledger.Prelude.Base.html#basic-types","title":"Basic Types","text":"<pre><code>Coin : Type\nCoin = \u2115\n\nDonations Fees Reserves Treasury : Type\nDonations         = Coin\nFees              = Coin\nReserves          = Coin\nTreasury          = Coin\n</code></pre>"},{"location":"Ledger.Prelude.Foreign.HSTypes.html","title":"HSTypes","text":"<pre><code>module Ledger.Prelude.Foreign.HSTypes where\n\n{-# FOREIGN GHC\n  {-# LANGUAGE DeriveGeneric #-}\n  {-# LANGUAGE DeriveFunctor #-}\n#-}\n\nopen import Prelude\n\nopen import Foreign.Haskell\nopen import stdlib.Foreign.Haskell.Empty public\nopen import Foreign.Haskell.Coerce\nopen import Data.Rational.Base\n\n{-# FOREIGN GHC\n  import GHC.Generics (Generic)\n  import Prelude hiding (Rational)\n  import GHC.Real (Ratio(..))\n#-}\n\n-- * Rational\n\ndata Rational : Type where\n  _,_ : \u2124 \u2192 \u2115 \u2192 Rational\n{-# COMPILE GHC Rational = data Rational ((:%)) #-}\n\n-- We'll generate code with qualified references to Rational in this\n-- module, so make sure to define it.\n{-# FOREIGN GHC type Rational = Ratio Integer #-}\n\n-- * Maps and Sets\n\nrecord HSMap K V : Type where\n  constructor MkHSMap\n  field assocList : List (Pair K V)\n\nrecord HSSet A : Type where\n  constructor MkHSSet\n  field elems : List A\n\n{-# FOREIGN GHC\n  newtype HSMap k v = MkHSMap [(k, v)]\n    deriving (Generic, Show, Eq, Ord)\n  newtype HSSet a = MkHSSet [a]\n    deriving (Generic, Show, Eq, Ord)\n#-}\n{-# COMPILE GHC HSMap = data HSMap (MkHSMap) #-}\n{-# COMPILE GHC HSSet = data HSSet (MkHSSet) #-}\n\n-- * ComputationResult\n\ndata ComputationResult E A : Type where\n  Success : A \u2192 ComputationResult E A\n  Failure : E \u2192 ComputationResult E A\n\n{-# FOREIGN GHC\n  data ComputationResult e a = Success a | Failure e\n    deriving (Functor, Eq, Show, Generic)\n\n  instance Applicative (ComputationResult e) where\n    pure = Success\n    (Success f) &lt;*&gt; x = f &lt;$&gt; x\n    (Failure e) &lt;*&gt; _ = Failure e\n\n  instance Monad (ComputationResult e) where\n    return = pure\n    (Success a) &gt;&gt;= m = m a\n    (Failure e) &gt;&gt;= _ = Failure e\n#-}\n{-# COMPILE GHC ComputationResult = data ComputationResult (Success | Failure) #-}\n</code></pre>"},{"location":"Ledger.Prelude.Foreign.Util.html","title":"Util","text":"<pre><code>module Ledger.Prelude.Foreign.Util where\n\nopen import Ledger.Prelude\n\npostulate\n  error : {A : Set} \u2192 String \u2192 A\n{-# FOREIGN GHC import Data.Text #-}\n{-# COMPILE GHC error = \\ _ s -&gt; error (unpack s) #-}\n</code></pre>"},{"location":"Ledger.Prelude.HasCoin.html","title":"HasCoin","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Prelude.HasCoin where\n\nopen import Prelude\nopen import Ledger.Prelude.Base\n\nrecord HasCoin {a} (A : Type a) : Type a where\n  field getCoin : A \u2192 Coin\n\nopen HasCoin \u2983...\u2984 public\n</code></pre>"},{"location":"Ledger.Prelude.Instances.html","title":"Instances","text":"<pre><code>{-# OPTIONS --safe #-}\n\nmodule Ledger.Prelude.Instances where\n\nopen import Prelude\nopen import Ledger.Prelude.Base\nopen import Ledger.Prelude.HasCoin\nopen import Interface.HasSubtract\nopen import Interface.HasSubset\n\nopen import abstract-set-theory.FiniteSetTheory\n  renaming (_\u2286_ to _\u2286\u02e2_)\n\ninstance\n  CommMonoid-\u2115-+ = NonUniqueInstances.CommMonoid-\u2115-+\n\n  HasCoin-Map : \u2200 {A} \u2192 \u2983 DecEq A \u2984 \u2192 HasCoin (A \u21c0 Coin)\n  HasCoin-Map .getCoin s = \u2211[ x \u2190 s ] x\n\n  HasCoin-Set : \u2200 {A} \u2192 \u2983 DecEq A \u2984 \u2192 HasCoin (\u2119 (A \u00d7 Coin))\n  HasCoin-Set .getCoin s = \u2211\u02e2[ (a , c) \u2190 s ] c\n\n  HasSubset-Set : \u2200 {A} \u2192 HasSubset (\u2119 A)\n  HasSubset-Set ._\u2286_ = _\u2286\u02e2_\n\n  HasSubtract-\u2119 : \u2200 {A} \u2192 \u2983 DecEq A \u2984 \u2192 HasSubtract (\u2119 A) (\u2119 A)\n  HasSubtract-\u2119 {A} ._-_ = _\uff3c_\n\n  HasSubset-Map : {A B : Set} \u2192 HasSubset (A \u21c0 B)\n  HasSubset-Map {A} {B} ._\u2286_ m\u2081 m\u2082 = {k : A} {v : B} \u2192 (k , v) \u2208 (m\u2081 \u02e2) \u2192 (k , v) \u2208 (m\u2082 \u02e2)\n</code></pre>"},{"location":"Ledger.Prelude.Numeric.PositiveNat.html","title":"PositiveNat","text":"<pre><code>{-# OPTIONS --safe #-}\nmodule Ledger.Prelude.Numeric.PositiveNat where\n\nopen import Prelude\n  hiding ([_,_]; [_]; _*_)\n\nopen import Class.Show using (Show; show)\n\nopen import Agda.Builtin.FromNat\nopen import Data.Nat using (\u2115; NonZero; _&gt;_)\nopen import Data.Refinement using (Refinement-syntax; value; _,_)\nopen import Data.Irrelevant\n\n-- PosNat: Non zero natural number.\nPosNat : Type\nPosNat = [ x \u2208 \u2115 \u2223 NonZero x ]\n\ninstance\n  Show-PosNat : Show PosNat\n  Show-PosNat .show (n , _) = show n\n\nfromPosNat : PosNat \u2192 \u2115\nfromPosNat = value\n\ntoPosNat : \u2115 \u2192 Maybe PosNat\ntoPosNat n with nonZero? n\n... | yes p = just (n , [ p ])\n... | no \u00acp = nothing\n\nmkPosNat : \u2200 (n : \u2115) \u2192 {T (does (nonZero? n))} \u2192 PosNat\nmkPosNat n {evidence}\n  with nonZero? n in eq\n... | no  _ = \u22a5-elim evidence\n... | yes p = n , [ p ]\n\nPosNat-IsNonZero : (n : PosNat) \u2192 NonZero (fromPosNat n)\nPosNat-IsNonZero (suc n , n&gt;0) .NonZero.nonZero = tt\n\nPosNat-Is&gt;0 : (n : PosNat) \u2192 fromPosNat n &gt; 0\nPosNat-Is&gt;0 (suc n , n&gt;0) = s\u2264s z\u2264n\n\nNumber-PosNat : Number PosNat\nNumber-PosNat = record\n  { Constraint = NonZero\n  ; fromNat = \u03bb n \u2983 p \u2984 \u2192 n , [ p ]\n  }\n</code></pre>"},{"location":"Ledger.Prelude.Numeric.UnitInterval.html","title":"UnitInterval","text":"<pre><code>{-# OPTIONS --safe #-}\n\n-- Rational number in the unit interval.\nmodule Ledger.Prelude.Numeric.UnitInterval where\n\nopen import Prelude\n  hiding ([_,_]; [_]; _*_)\n\nopen import Agda.Builtin.FromNat\nopen import Class.Show using (Show; show)\nopen import Data.Irrelevant using ([_])\nopen import Data.Rational using (\u211a; _\u2264_; _\u2264?_; _*_; nonNegative)\nopen import Data.Rational.Properties\nopen import Data.Rational.Show using () renaming (show to \u211ashow)\nopen import Data.Refinement using (Refinement-syntax; value; _,_)\n\nopen \u2264-Reasoning\n\n-- inUnitInterval predicate\ninUnitInterval : (x : \u211a) \u2192 Type\ninUnitInterval x = (0 \u2264 x) \u00d7 (x \u2264 1)\n\n-- Decide whether a rational number is in the unit interval.\nisInUnitInterval : (x : \u211a) \u2192 Dec (inUnitInterval x)\nisInUnitInterval x = (0 \u2264? x) \u00d7-dec (x \u2264? 1)\n\n-- Multiplying with a number from the unit interval only decreases.\ninUnitInterval-*-\u2264y : \u2200 (x y : \u211a) \u2192 inUnitInterval x \u2192 0 \u2264 y \u2192 x * y \u2264 y\ninUnitInterval-*-\u2264y x y (0\u2264x , x\u22641) 0\u2264y =\n  begin\n    x * y  \u2264\u27e8 *-mono\u02b3-\u2264-nonNeg y \u2983 nonNegative 0\u2264y \u2984 x\u22641 \u27e9\n    1 * y  \u2261\u27e8 *-identity\u02e1 _ \u27e9\n    y      \u220e\n\n-- Left multiplication by unit interval element preserves non-negativity.\ninUnitInterval-*-0\u2264 : \u2200 (x y : \u211a) \u2192 inUnitInterval y \u2192 0 \u2264 x \u2192 0 \u2264 x * y\ninUnitInterval-*-0\u2264 x y (0\u2264y , _) 0\u2264x =\n  begin\n    0      \u2261\u27e8 sym (*-zero\u02b3 x) \u27e9\n    x * 0  \u2264\u27e8 *-mono\u02e1-\u2264-nonNeg x \u2983 nonNegative 0\u2264x \u2984 0\u2264y \u27e9\n    x * y  \u220e\n\n-- Left multiplication by unit interval element preserves being upper boundeded by 1.\ninUnitInterval-*-\u22641 : \u2200 (x y : \u211a) \u2192 inUnitInterval x \u2192 y \u2264 1 \u2192 x * y \u2264 1\ninUnitInterval-*-\u22641 x y (0\u2264x , x\u22641) y\u22641 =\n  begin\n    x * y  \u2264\u27e8 *-mono\u02e1-\u2264-nonNeg x \u2983 nonNegative 0\u2264x \u2984 y\u22641 \u27e9\n    x * 1  \u2261\u27e8 *-identity\u02b3 _ \u27e9\n    x      \u2264\u27e8 x\u22641 \u27e9\n    1      \u220e\n\n-- UnitInterval: rational number in the unit interval [0, 1].\nUnitInterval : Type\nUnitInterval = [ x \u2208 \u211a \u2223 inUnitInterval x ]\n\ninstance\n  Show-UnitInterval : Show UnitInterval\n  Show-UnitInterval .show = \u211ashow \u2218 value\n\n-- In the cardano-ledger codebase:\n--  unboundRational\nfromUnitInterval : UnitInterval \u2192 \u211a\nfromUnitInterval = value\n\n-- In the cardano-ledger codebase:\n--  unboundRational\ntoUnitInterval : \u211a \u2192 Maybe UnitInterval\ntoUnitInterval x with isInUnitInterval x\n... | no \u00acp = nothing\n... | yes p = just (x , [ p ])\n\n-- Helper function to make an element of the Refinement type\n-- that is useful in the case where Agda can infer the evidence\n-- automatically by computation.\n-- Usage example:  mkUnitInterval (+ 2 / 10)\nmkUnitInterval : \u2200 (x : \u211a) \u2192 {T (does (isInUnitInterval x))} \u2192 UnitInterval\nmkUnitInterval x {evidence} with isInUnitInterval x in eq\n... | no  _ rewrite cong does eq = \u22a5-elim evidence\n... | yes p = x , [ p ]\n\n-- Clamp a rational number to the unit interval.\n-- Values below 0 or above 1 are set to 0 or 1, respectively.\nclamp : \u211a \u2192 UnitInterval\nclamp x with 0 \u2264? x\n... | no  _ = mkUnitInterval 0\n... | yes 0\u2264x with x \u2264? 1\n...     | no  _   = mkUnitInterval 1\n...     | yes x\u22641 = (x , [ 0\u2264x , x\u22641 ])\n\n-- UnitInterval Properties\n\n-- The predicate for 'UnitInterval' also holds in a proof-relevant context.\nfromUnitInterval-inUnitInterval\n  : \u2200 (x : UnitInterval) \u2192 inUnitInterval (fromUnitInterval x)\nfromUnitInterval-inUnitInterval (x , [ p0 ]) with isInUnitInterval x\n... | no \u00acp = \u22a5-elim-irr (\u00acp p0)\n... | yes p = p\n\n-- Left multiplication by unit interval element preserves non-negativity.\nUnitInterval-*-0\u2264\n  : \u2200 (x : \u211a) (y : UnitInterval) \u2192 0 \u2264 x \u2192 0 \u2264 x * fromUnitInterval y\nUnitInterval-*-0\u2264 x y 0\u2264x =\n  inUnitInterval-*-0\u2264 x (value y) (fromUnitInterval-inUnitInterval y) 0\u2264x\n\n-- to/from is the identity\nprop-toUnitInterval-fromUnitInterval : \u2200 (x : UnitInterval)\n  \u2192 toUnitInterval (fromUnitInterval x) \u2261 just x\nprop-toUnitInterval-fromUnitInterval (x , [ p0 ]) with isInUnitInterval x\n... | no \u00acp = \u22a5-elim-irr (\u00acp p0)\n... | yes p = refl\n</code></pre>"},{"location":"Ledger.Prelude.Numeric.html","title":"Numeric","text":"<pre><code>{-# OPTIONS --safe #-}\n\n-- Subsets of number types useful for the ledger specification.\nmodule Ledger.Prelude.Numeric where\n\nopen import Ledger.Prelude.Numeric.PositiveNat public\n  renaming (PosNat to \u2115\u207a; fromPosNat to from\u2115\u207a; mkPosNat to mk\u2115\u207a\n           ; PosNat-Is&gt;0 to \u2115\u207a-&gt;0)\nopen import Ledger.Prelude.Numeric.UnitInterval public\n</code></pre>"},{"location":"Ledger.Prelude.html","title":"Prelude","text":"<pre><code>{-# OPTIONS --safe #-}\n\n--------------------------------------------------------------------------------\n-- Ledger prelude\n--\n-- Re-exports modules relating to STS, set theory and other\n-- miscellaneous things used to write the ledger rules. If something\n-- is used in more than two Ledger.* modules, it should probably go\n-- here.\n--------------------------------------------------------------------------------\n\nmodule Ledger.Prelude where\n\nopen import Prelude public\n  hiding (\u2203\u2047)\nopen import Prelude.Init public\n  using (\u2203\u2047)\n\nopen import Ledger.Prelude.Base public\nimport Data.List\n\nopen import Class.HasAdd public\nopen import stdlib-classes.Class.HasCast public\nopen import Class.HasOrder public\nopen import Class.ToBool public\nopen import Interface.ComputationalRelation public\nopen import Interface.Hashable public\nopen import Interface.HasSubset public\nopen import Interface.HasSubtract public\nopen import Interface.HasSubtract.Instances public\nopen import Ledger.Prelude.Instances public\nopen import Ledger.Prelude.HasCoin public\nopen import Tactic.Defaults public\nopen import Tactic.Derive.DecEq public\nopen import Tactic.Inline public\nopen import MyDebugOptions public\nopen import Prelude.STS.GenPremises public\n\nopen import abstract-set-theory.FiniteSetTheory public\n  renaming (_\u2286_ to _\u2286\u02e2_)\n\nimport Data.Integer as \u2124\nimport Data.Rational as \u211a\nopen import Data.Rational using (\u211a)\n\ndec-de-morgan : \u2200{P Q : Type} \u2192 \u2983 P \u2047 \u2984 \u2192 \u00ac (P \u00d7 Q) \u2192 \u00ac P \u228e \u00ac Q\ndec-de-morgan \u2983 \u2047 no \u00acp \u2984 \u00acpq = inj\u2081 \u00acp\ndec-de-morgan \u2983 \u2047 yes p \u2984 \u00acpq = inj\u2082 \u03bb q \u2192 \u00acpq (p , q)\n\n\u2261\u1d49-getCoin : \u2200 {A} \u2192 \u2983 _ : DecEq A \u2984 \u2192 (s s' : A \u21c0 Coin) \u2192 s \u02e2 \u2261\u1d49 s' \u02e2 \u2192 getCoin s \u2261 getCoin s'\n\u2261\u1d49-getCoin {A} \u2983 decEqA \u2984 s s' s\u2261s' = indexedSum\u1d5b'-cong {C = Coin} {x = s} {y = s'} s\u2261s'\n\nsetToMap : \u2200 {A B : Type} \u2192 \u2983 DecEq A \u2984 \u2192 \u2119 (A \u00d7 B) \u2192 A \u21c0 B\nsetToMap = fromList\u1d50 \u2218 setToList\n\n-- division of natural numbers with completion by 0.\nopaque\n  _/\u2080_ : \u2115 \u2192 \u2115 \u2192 \u211a\n  x /\u2080 0 = \u211a.0\u211a\n  x /\u2080 y@(suc _) = \u2124.+ x \u211a./ y\n\n-- Division of rational numbers with completion by 0.\n_\u00f7\u2080_ : \u211a \u2192 \u211a \u2192 \u211a\n_\u00f7\u2080_ x y = case y \u225f \u211a.0\u211a of \u03bb where\n  (yes _) \u2192 \u211a.0\u211a\n  (no y\u22620) \u2192 let instance nonZero-y = \u211a.\u2262-nonZero y\u22620 in x \u211a.\u00f7 y\n\n\u27e6_\u27e7 : \u2200 {A B : Type} \u2983 f : HasCast A B \u2984 \u2192 A \u2192 B\n\u27e6_\u27e7 \u2983 f = f \u2984 = f.cast\n  where module f = HasCast f\n\n\u2223_\u2223 : \u2200 {A B : Type} \u2983 f : HasCast A B \u2984 \u2192 A \u2192 B\n\u2223_\u2223 \u2983 f = f \u2984 = f.cast\n  where module f = HasCast f\n\ninfix 5 \u27e6_\u27e7\ninfix 6 \u2223_\u2223\n\nmodule Filter where\n  filter : \u2200 {a} {p} {A : Type a} \u2192 (P : Pred A p) \u2192 \u2983 P \u2047\u00b9 \u2984 \u2192 List A \u2192 List A\n  filter P = Data.List.filter \u00bf P \u00bf\u00b9\n</code></pre>"},{"location":"Ledger.html","title":"Ledger","text":"<pre><code>module Ledger where\n\nimport Ledger.Introduction\nimport Ledger.PreConway\nimport Ledger.Conway\n</code></pre>"},{"location":"MyDebugOptions.html","title":"MyDebugOptions","text":"<pre><code>{-# OPTIONS --safe --without-K #-}\nmodule MyDebugOptions where\n\nopen import Meta.Init\n\ninstance\n  defaultDebugOptionsI : DebugOptions\n  defaultDebugOptionsI = record defaultDebugOptions\n    { selection = All\n    ; filter = Filter.\u22a5 }\n</code></pre>"},{"location":"Notation.html","title":"Notation","text":"<p>This section introduces some of the notation we use in this document and in our Agda formalization.</p>"},{"location":"Notation.html#propositions-sets-and-types","title":"Propositions, Sets and Types","text":"<p>See Sets &amp; Maps. Note that Agda denotes the primitive notion of type by <code>Set</code>. To avoid confusion, throughout this document and in our Agda code we call this primitive <code>Type</code> and use <code>\u2119</code> for our set type.</p>"},{"location":"Notation.html#lists","title":"Lists","text":"<p>We use the notation <code>a</code> <code>\u2237</code> <code>as</code> for the list with head <code>a</code> and tail <code>as</code>; <code>[]</code> denotes the empty list, and <code>l</code> <code>\u2237\u02b3</code> <code>x</code> appends the element <code>x</code> to the end of the list <code>l</code>.</p>"},{"location":"Notation.html#sums-and-products","title":"Sums and Products","text":"<p>The sum (or disjoint union, coproduct, etc.) of <code>A</code> and <code>B</code> is denoted by <code>A</code> <code>\u228e</code> <code>B</code>, and their product is denoted by <code>A</code> <code>\u00d7</code> <code>B</code>. The projection functions from products are denoted <code>proj\u2081</code> and <code>proj\u2082</code> and the injections are denoted <code>inj\u2081</code> and <code>inj\u2082</code>, respectively. The property of being an element of a coproduct in the left (resp., right) component is called <code>isInj\u2081</code> (resp., <code>isInj\u2082</code>).</p>"},{"location":"Notation.html#addition-of-map-values","title":"Addition of Map Values","text":"<p>The expression <code>\u2211[</code> <code>x</code> <code>\u2190</code> <code>m</code> <code>]</code> <code>f</code> <code>x</code> denotes the sum of the values obtained by applying the function <code>f</code> to the values of the map <code>m</code>.</p>"},{"location":"Notation.html#record-types","title":"Record types","text":"<p>See the official documentation on Agda record types.</p>"},{"location":"Notation.html#postfix-projections","title":"Postfix Projections","text":"<p>Projections can be written using postfix notation. For example, we may write <code>x</code> <code>.</code> <code>proj\u2081</code> instead of</p> <p><code>proj\u2081</code> <code>x</code></p>"},{"location":"Notation.html#restriction-corestriction-and-complements","title":"Restriction, Corestriction and Complements","text":"<p>The restriction of a function or map <code>f</code> to some domain <code>A</code> is denoted by <code>f</code> <code>|</code> <code>A</code>, and the restriction to the complement of <code>A</code> is written <code>f</code> <code>|</code> <code>A</code> <code>\u1d9c</code>.</p> <p>Corestriction or range restriction is denoted similarly, except that <code>|</code> is replaced by <code>\u2223^</code>.</p>"},{"location":"Notation.html#inverse-image","title":"Inverse Image","text":"<p>The expression <code>m</code> <code>\u207b\u00b9</code> <code>B</code> denotes the inverse image of the set <code>B</code> under the map <code>m</code>.</p>"},{"location":"Notation.html#left-biased-union","title":"Left-biased Union","text":"<p>For maps <code>m</code> and <code>m'</code>, we write <code>m</code> <code>\u222a\u02e1</code> <code>m'</code> for their left-biased union. This means that key-value pairs in <code>m</code> are guaranteed to be in the union, while a key-value pair in <code>m'</code> is in the union if and only if the key is not in <code>m</code>.</p>"},{"location":"Notation.html#map-addition","title":"Map Addition","text":"<p>For maps <code>m</code> and <code>m'</code>, we write <code>m</code> <code>\u222a\u207a</code> <code>m'</code> for their union, where keys that appear in both maps have their corresponding values added.</p>"},{"location":"Notation.html#mapping-a-partial-function","title":"Mapping a Partial Function.","text":"<p>A partial function is a function on <code>A</code> which may not be defined for all elements of <code>A</code>.  We denote such a function by <code>f</code> : <code>A</code> \u21c0 <code>B</code>.</p> <p>If we happen to know that the function is total (defined for all elements of <code>A</code>), then we write <code>f</code> : <code>A</code> \u2192 <code>B</code>.</p> <p>The <code>mapPartial</code> operation takes such a function <code>f</code> and a set <code>S</code> of elements of <code>A</code> and applies <code>f</code> to the elements of <code>S</code> at which it is defined; the result is the set</p> <p>{ <code>f</code> <code>x</code> \u2223 <code>x</code> \u2208 <code>S</code> and <code>f</code> is defined at  <code>x</code>.} </p>"},{"location":"Notation.html#the-maybe-type","title":"The Maybe Type","text":"<p>This type represents an optional value and can either be <code>just</code> <code>x</code> (indicating the presence of a value, <code>x</code>) or <code>nothing</code> (indicating the absence of a value).</p> <p>If <code>x</code> has type <code>X</code>, then <code>just</code> <code>x</code> has type <code>Maybe</code> <code>X</code>.</p> <p>The symbol <code>~</code> denotes (pseudo)equality of two values <code>x</code> and <code>y</code> of type <code>Maybe</code> <code>X</code> : if <code>x</code> is of the form <code>just</code> <code>x'</code> and <code>y</code> is of the form <code>just</code> <code>y'</code>, then <code>x'</code> and  <code>y'</code> have to be equal. Otherwise, they are considered \"equal.\"</p>"},{"location":"Notation.html#the-unit-type","title":"The Unit Type","text":"<p><code>\u22a4</code> has a single inhabitant <code>tt</code> and may be thought of as a type that carries no information; it is useful for signifying the completion of an action, the presence of a trivial value, a trivially satisfied requirement, etc.</p>"},{"location":"Notation.html#sec:superscripts-other-special-notation","title":"Superscripts and Other Special Notations","text":"<p>In the current version of this specification, superscript letters are sometimes used for things such as disambiguations or type conversions. These are essentially meaningless, only present for technical reasons and can safely be ignored. However there are the two exceptions:</p> <ul> <li> <p><code>\u222a\u02e1</code> for left-biased union</p> </li> <li> <p><code>\u1d9c</code> in the context of set restrictions, where it indicates the complement</p> </li> </ul> <p>Also, non-letter superscripts do carry meaning.</p> <p>(At some point in the future we hope to be able to remove all those non-essential superscripts. Since we prefer doing this by changing the Agda source code instead of via hiding them in this document, this is a non-trivial problem that will take some time to address.)</p>"},{"location":"Notation.html#tables-of-variable-names-and-name-changes","title":"Tables of Variable Names and Name Changes","text":""},{"location":"Notation.html#renamed-fields-of-txbody","title":"Renamed Fields of <code>TxBody</code>","text":"Old Name New Name Old Type New Type <code>txins</code> <code>txIns</code> (no change) <code>txouts</code> <code>txOuts</code> (no change) <code>txfee</code> <code>txFee</code> <code>Coin</code> <code>Fees</code> <code>txwdrls</code> <code>txWithdrawals</code> <code>Wdrl</code> <code>Withdrawals</code> <code>txvldt</code> <code>txVldt</code> (no change) <code>txcerts</code> <code>txCerts</code> (no change) <code>txvote</code> <code>txGovVotes</code> (no change) <code>txprop</code> <code>txGovProposals</code> (no change) <code>txdonation</code> <code>txDonation</code> <code>Coin</code> <code>Donations</code> <code>curTreasury</code> <code>currentTreasury</code> <code>Maybe Coin</code> <code>Maybe Treasury</code> <code>txid</code> <code>txId</code> (no change) <code>collateral</code> <code>collateralInputs</code> (no change) <code>reqSigHash</code> <code>reqSignerHashes</code> (no change) <code>scriptIntHash</code> <code>scriptIntegrityHash</code> (no change)"},{"location":"Notation.html#renamed-contructors-of-govactiontype","title":"Renamed Contructors of <code>GovActionType</code>","text":"Old Name New Name <code>TriggerHF</code> <code>TriggerHardFork</code> <code>TreasuryWdrl</code> <code>TreasuryWithdrawal</code>"},{"location":"Prelude.html","title":"Agda Prelude","text":"<pre><code>{-# OPTIONS --safe --without-K #-}\n\nmodule Prelude where\n\nopen import Agda.Primitive using (lzero) renaming (Set to Type) public\n\nopen import Level public\n  hiding (lower)\n  renaming (_\u2294_ to _\u2294\u02e1_; suc to suc\u02e1; zero to zero\u02e1)\nopen import Function public\n\nopen import Data.Bool public\n  hiding (_\u225f_; _\u2264_; _\u2264?_; _&lt;_; _&lt;?_; if_then_else_)\nopen import Data.Bool.ListAction public\nopen import Data.Empty public\nopen import Data.List public\n  hiding (all; and; any; align; alignWith; filter; fromMaybe; map; or; product; sum; zip; zipWith)\nopen import Data.List.Membership.Propositional public\n  using () renaming (_\u2208_ to _\u2208\u02e1_; _\u2209_ to _\u2209\u02e1_)\nopen import Data.Maybe public\n  hiding (_&gt;&gt;=_; align; alignWith; ap; fromMaybe; map; zip; zipWith)\nopen import Data.Unit public\n  using (\u22a4; tt)\nopen import Data.Unit.Polymorphic public\n  using ()\n  renaming (\u22a4 to \u22a4\u2191; tt to tt\u2191)\ninstance Poly-tt = tt\u2191\nopen import Data.Sum public\n  hiding (assoc\u02b3; assoc\u02e1; map; map\u2081; map\u2082; reduce; swap)\nopen import Data.Product public\n  hiding (assoc\u02b3; assoc\u02e1; map; map\u2081; map\u2082; map\u2082\u2032; swap; _&lt;*&gt;_)\nopen import Data.Nat public\n  hiding (_\u225f_; _\u2264_; _\u2264?_; _&lt;_; _&lt;?_; _\u2264\u1d47_; _\u2261\u1d47_; _\u2265_; _&gt;_; less-than-or-equal)\n  renaming (_+_ to _+\u2115_)\nopen import Data.Nat.ListAction public\nopen import Data.Integer as \u2124 public\n  using (\u2124)\n  renaming (_+_ to _+\u2124_)\nopen import Data.String public\n  using (String; _&lt;+&gt;_)\n\nopen import Relation.Nullary public\nopen import Relation.Nullary.Negation public\nopen import Relation.Nullary.Decidable public\n  using (Dec; yes; no; dec-yes; dec-no; \u230a_\u230b; \u00ac?; toWitness; fromWitness)\n  renaming (map\u2032 to mapDec)\nopen import Relation.Unary public\n  using (Pred) renaming (Decidable to Decidable\u00b9)\nopen import Relation.Binary public\n  using () renaming (Decidable to Decidable\u00b2)\nopen import Relation.Binary.PropositionalEquality public\n  hiding (preorder; isPreorder; setoid; [_])\n\nopen import Class.Core public\n  using (Type\u2191)\nopen import Class.Functor public\n  renaming (fmap to map)\nopen import Class.Bifunctor public\nopen import Class.Semigroup public\nopen import Class.Monoid public\nopen import Class.CommutativeMonoid public\nopen import Class.Applicative public\nopen import Class.Monad public\nopen import Class.DecEq public; instance DecEq-\u00d7\u2032 = DecEq-\u00d7\nopen import Class.Decidable public\n\u2203\u2047 : \u2200 {\u2113} \u2192 Set (suc\u02e1 \u2113)\n\u2203\u2047 {\u2113} = \u03a3 (Set \u2113) _\u2047\nopen import Class.Show public\n\n\u2203\u2082-syntax : \u2200 {a b c} {A : Set a} {B : Set b}\n     (C : A \u2192 B \u2192 Set c) \u2192 Set _\n\u2203\u2082-syntax C = \u2203 \u03bb a \u2192 \u2203 \u03bb b \u2192 C a b\n\ninfix 2 \u2203\u2082-syntax\nsyntax \u2203\u2082-syntax (\u03bb x y \u2192 C) = \u2203\u2082[ x , y ] C\n\n-- Instance for number literals, not enabled by default\nimport Data.Nat.Literals as \u2115\nimport Data.Integer.Literals as \u2124\nimport Data.Rational.Literals as \u211a\n\ninstance Number-\u2115 = \u2115.number\ninstance Number-\u2124 = \u2124.number\ninstance Number-\u211a = \u211a.number\n\n-- (Pseudo)equality (for Maybe)\nopen import Data.Maybe.Relation.Binary.Connected\n  using (Connected; connected?)\n\n_~_ : {A : Type} \u2192 Maybe A \u2192 Maybe A \u2192 Type\n_~_ = Connected _\u2261_\n\ninstance\n  ~? : {A : Type} {x y : Maybe A} \u2192 \u2983 DecEq A \u2984 \u2192 (x ~ y) \u2047\n  ~? {A} {x} {y} \u2983 deqEq \u2984 = \u2047 (connected? (DecEq._\u225f_ deqEq) x y)\n\n-- Positive and negative part of integers\nopen import Data.Integer using (sign; \u2223_\u2223; _\u2296_)\nopen import Data.Integer.Properties using ([1+m]\u2296[1+n]\u2261m\u2296n)\nopen import Data.Sign using (Sign)\n\nposPart : \u2124 \u2192 \u2115\nposPart x with sign x\n... | Sign.+ = \u2223 x \u2223\n... | Sign.- = 0\n\nnegPart : \u2124 \u2192 \u2115\nnegPart x with sign x\n... | Sign.- = \u2223 x \u2223\n... | Sign.+ = 0\n\n\u2238\u2261posPart\u2296 : {m n : \u2115} \u2192 (m \u2238 n) \u2261 posPart (m \u2296 n)\n\u2238\u2261posPart\u2296 {zero} {zero} = _\u2261_.refl\n\u2238\u2261posPart\u2296 {zero} {\u2115.suc n} = _\u2261_.refl\n\u2238\u2261posPart\u2296 {\u2115.suc m} {zero} = _\u2261_.refl\n\u2238\u2261posPart\u2296 {\u2115.suc m} {\u2115.suc n} = trans (\u2238\u2261posPart\u2296{m}{n}) (sym (cong posPart (([1+m]\u2296[1+n]\u2261m\u2296n m n))))\n</code></pre>"},{"location":"Properties.html","title":"Properties","text":""},{"location":"Properties.html#properties","title":"Properties","text":"<p>This section presents the properties of the ledger that we have formally proved in Agda or plan to do so in the near future.  We indicate in which Agda module each property is formally stated and (possibly) proved. A \"Claim\" is a property that is not yet proved, while a \"Theorem\" is one for which we have a formal proof.</p>"},{"location":"Properties.html#preservation-of-value","title":"Preservation of Value","text":"<p>There are several \"preservation of value\" proofs throughout this formal specificaition.  These can be found in the following modules:</p> <ul> <li>Ledger.Properties.PoV</li> <li>Utxo.Properties.PoV</li> <li>Certs.Properties.PoV</li> <li>Certs.Properties.PoVLemmas</li> </ul>"},{"location":"Properties.html#invariance-properties","title":"Invariance Properties","text":"<p>To say that a predicate <code>P</code> is an invariant of a transition rule <code>R</code> means the following: if the rule <code>R</code> relates states <code>s</code> and <code>s'</code> and if <code>P</code> holds at state <code>s</code>, then <code>P</code> holds at state <code>s'</code>.</p> <p>Examples of invariance properties are found in</p> <ul> <li>Chain.Properties.CredDepsEqualDomRwds</li> <li>Chain.Properties.PParamsWellFormed</li> </ul>"},{"location":"Properties.html#matching-governance-action-deposits","title":"Matching Governance Action Deposits","text":"<p>ChainGovDepsMatch, LedgerGovDepsMatch, and EpochGovDepsMatch assert that a certain predicate is an invariant of the <code>CHAIN</code>, <code>LEDGER</code>, and <code>EPOCH</code> rules, respectively.</p> <p>Given a ledger state <code>s</code>, we focus on deposits in the <code>UTxOState</code> of <code>s</code> that are <code>GovActionDeposit</code>s and we compare that set of deposits with the <code>GovActionDeposit</code>s of the <code>GovState</code> of <code>s</code>. When these two sets are the same, we write <code>govDepsMatch</code> <code>s</code> and say the <code>govDepsMatch</code> relation holds for <code>s</code>. The formal definition of <code>govDepsMatch</code> is given in Ledger.Properties.</p> <p>The assertion, \"the <code>govDepsMatch</code> relation is an invariant of the <code>LEDGER</code> rule,\" means the following: if <code>govDepsMatch</code> <code>s</code> and <code>s</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,LEDGER\u2988</code> <code>s'</code>, then <code>govDepsMatch</code> <code>s'</code>.</p> <p>The following are examples of this assertion:</p> <ul> <li>Chain.Properties.GovDepsMatch</li> <li>Ledger.Properties.GovDepsMatch</li> <li>Epoch.Properties.GovDepsMatch</li> </ul>"},{"location":"Properties.html#minimum-spending-conditions","title":"Minimum Spending Conditions","text":"<p>A minimum spending condition is proved in Utxo.Properties.MinSpend.</p>"},{"location":"Properties.html#other-miscellaneous-properties","title":"Other Miscellaneous Properties","text":"<ul> <li> <p>Certs.Properties.VoteDelegsVDeleg: The set of <code>VDeleg</code>s    resulting from the application of    <code>credVoter</code> <code>DRep</code> to the    domain of the <code>voteDelegs</code> of a <code>DState</code> contains the    range of the <code>voteDelegs</code> of that <code>DState</code>.</p> </li> <li> <p>Chain.Properties.EpochStep:    If <code>cs</code> <code>\u21c0\u2987</code> <code>b</code> <code>,CHAIN\u2988</code> <code>cs'</code> and    if the enact states of <code>cs</code> and <code>cs'</code> differ, then the    epoch of the slot of <code>b</code> is the successor of the last epoch of <code>cs</code>.</p> </li> <li> <p>Epoch.Properties.ConstRwds: The <code>NEWEPOCH</code> rule leaves rewards unchanged.</p> </li> <li> <p>Epoch.Properties.NoPropSameDReps:    If <code>es</code> is a <code>NewEpochState</code>, and if the    <code>GovState</code> of <code>es</code> contains no governance proposals,    then the set of <code>activeDReps</code> of <code>es</code> in    <code>Epoch</code> <code>e</code> is equal to the set of    <code>activeDReps</code> of <code>es</code> in the next epoch.</p> </li> <li> <p>Gov.Properties.ChangePPGroup: <code>PParam</code> updates have non-empty groups.</p> </li> </ul>"},{"location":"guide.html","title":"Contributing to the Formal Ledger Specifications","text":"<p>Brief Contents</p> <p>\ud83d\udd8a\ufe0f\ufe0f Style Guidelines \ud83d\uddfa\ufe0f Project Overview \ud83d\udcbb Development Environment Setup \ud83c\udfd7\ufe0f Building Project Artifacts \ud83d\udcd6 HTML Documentation \ud83d\udda5\ufe0f IDE Integration \ud83e\uddd1\u200d\ud83d\udd27 Working on the Agda source code \ud83d\udd01 CI/CD Workflow \ud83c\udf9b\ufe0f\ufe0f Setup Without Nix \ud83d\udd75\ufe0f\u200d\u2640\ufe0f Conformance Testing \ud83d\uddc3\ufe0f Miscellanea \ud83d\udc77 Maintainers</p> <p></p>"},{"location":"guide.html#style-guidelines","title":"\ud83d\udd8a\ufe0f\ufe0f Style Guidelines","text":"<p>We adhere to the Agda standard library style guide where practical. However, because we use literate Agda to produce html documentation, readability of the latter takes precedence over code formatting.</p>"},{"location":"guide.html#miscellaneous-conventions","title":"Miscellaneous conventions","text":"<ol> <li> <p>Type classes for accessing fields of records should be named after the type of     the field and not the name of the field.  For example, suppose     <pre><code>Fees : Type\nFees = \u2115\n</code></pre>     and suppose we have a record type <code>A</code> with a field called <code>fee</code>:     <pre><code>record A : Type where\n  field\n    fee : Fees\n    ...\n</code></pre>     Then we would make a type class called <code>HasFees</code> (since the type is called <code>Fees</code>)     <pre><code>record HasFees {a} (A : Type a) : Type a where\n  field FeesOf : A \u2192 Fees\nopen HasFees \u2983...\u2984 public\n</code></pre>     and define the following instance of the <code>HasFees</code> type class for the type <code>A</code>:     <pre><code>  instance\n    HasFees-A : HasFees A\n    HasFees-A .FeesOf = A.fee\n</code></pre>     then, if <code>a : A</code>, we can access the <code>fee</code> field of <code>a</code> via <code>FeesOf a</code>.  From this     contrived example, you might think type classes are overkill here, and you're not     all wrong.  However, they can come in handy in practice, expecially when we have     many different types that have, say, fees or donations associated with them, and     we want to be able to access those values in a consistent way.  Moreover, we have     many examples of nested records that contain fees or donations, and the \"getter type     class\" instances allow us to access those values without having to remember the     specific paths to the field names of those record types.  Another example of the     getter type class pattern is given in the     \ud83d\uddc3\ufe0f Miscellanea section below.</p> </li> <li> <p>Use camel case for field names (e.g., <code>txNetworkId</code> instead of <code>txnetworkid</code>).</p> </li> </ol> <p></p>"},{"location":"guide.html#project-overview","title":"\ud83d\uddfa\ufe0f Project Overview","text":"<p>This repository uses Nix and Shake to provide a reproducible, declarative, and portable development environment.</p>"},{"location":"guide.html#nix-flakes","title":"Nix Flakes","text":"<p>We use Nix Flakes to manage dependencies, build processes, and development shells.</p>"},{"location":"guide.html#dependency-management","title":"Dependency Management","text":"<p>All external Nix dependencies (like <code>nixpkgs</code>) and Agda libraries are pinned to specific versions (e.g., Git commits).</p> <p>The core Agda dependencies include:</p> <ul> <li>agda-stdlib: standard library;</li> <li>agda-stdlib-classes: type-class extensions for the standard library;</li> <li>agda-stdlib-meta: meta-programming utilities;</li> <li>agda-sets: abstract set theory library;</li> <li>iog-agda-prelude: supplementary prelude.</li> </ul>"},{"location":"guide.html#directory-structure","title":"Directory Structure","text":"<p>The main directories and files involved in the build process are as follows. (A more detailed version of this annotated tree can be found at the bottom of this page.)</p> <pre><code>\u251c\u2500\u2500 flake.nix                  # Nix flake\n\u2514\u2500\u2500 build-tools/\n    \u251c\u2500\u2500 agda/\n    \u2502   \u251c\u2500\u2500 flake.nix          # Nix flake\n    \u2502   \u251c\u2500\u2500 data/\n    \u2502   \u2502   \u251c\u2500\u2500 Agda.css       # for styling Agda HTML output\n    \u2502   \u2502   \u2514\u2500\u2500 AgdaKaTeX.js   # for integrating Agda's HTML with KaTeX\n    \u2502   \u251c\u2500\u2500 fls-agda.cabal     # for building fls-agda Haskell package\n    \u2502   \u251c\u2500\u2500 nix/\n    \u2502   \u2502   \u2514\u2500\u2500 fls-agda.nix   # Nix derivation for fls-agda package\n    \u2502   \u2514\u2500\u2500 src/\n    \u2502       \u2514\u2500\u2500 Main.hs        # Main entry point for fls-agda executable\n    \u2502\n    \u251c\u2500\u2500 nix                    # Nix derivations for exported packages\n    \u2502   \u251c\u2500\u2500 formal-ledger.nix\n    \u2502   \u251c\u2500\u2500 hs-src.nix\n    \u2502   \u251c\u2500\u2500 html.nix\n    \u2502   \u2514\u2500\u2500 mkdocs.nix\n    \u2502\n    \u2514\u2500\u2500 shake/\n        \u251c\u2500\u2500 flake.nix          # Nix flake\n        \u251c\u2500\u2500 fls-shake.cabal    # for building fls-shake Haskell package\n        \u251c\u2500\u2500 nix/\n        \u2502   \u2514\u2500\u2500 fls-shake.nix  # Nix derivation for fls-shake package\n        \u2514\u2500\u2500 src/\n            \u2514\u2500\u2500 Main.hs        # Main entry point for fls-shake build system\n</code></pre> <p></p>"},{"location":"guide.html#development-environment-setup","title":"\ud83d\udcbb Development Environment Setup","text":"<p>We provide several development shells tailored for different tasks. You can enter them using <code>nix develop</code>.</p> <ul> <li> <p>\ud83d\udc1a Default Shell</p> <p>This is the primary environment for Agda development. It includes Agda, all required libraries, and the <code>fls-shake</code> build tool.</p> <pre><code># Enter the default development shell\nnix develop\n</code></pre> <p>\u2692\ufe0f Available Tools</p> <ul> <li><code>agda</code> (with all project libraries)</li> <li><code>fls-shake</code> (our custom build tool)</li> <li><code>python311</code> (Python version 3.11)</li> <li><code>hpack</code> (the Haskell package helper)</li> </ul> </li> <li> <p>\ud83d\udc1a CI Shell</p> <p>A minimal environment designed for automated builds, containing only the <code>fls-shake</code> build tool and its runtime dependencies.</p> <pre><code># Enter the CI shell\nnix develop .#ci\n</code></pre> </li> <li> <p>\ud83d\udc1a Documentation Shell</p> <p>A comprehensive environment for working on documentation, including the full documentation generation pipeline.</p> <pre><code># Enter the documentation shell\nnix develop .#mkdocs\n</code></pre> <p>\u2692\ufe0f Available Tools</p> <p>Everything from the default shell plus</p> <ul> <li><code>pandoc</code> (the document conversion tool)</li> <li><code>latex</code> (the typesetting language)</li> <li><code>mkdocs</code> (with Python dependencies)</li> </ul> </li> </ul> <p></p>"},{"location":"guide.html#building-project-artifacts","title":"\ud83c\udfd7\ufe0f Building Project Artifacts","text":"<p>You can build project artifacts in several ways. The recommended method is using <code>nix build</code>.</p> <p>The <code>flake.nix</code> file exposes all buildable artifacts as packages.</p> <p>(How to view or use what these commands build is explained below; see Building and viewing the formal specification and Browsing the source code.)</p> <pre><code># Type-check the Agda specification (default package)\nnix build .#formal-ledger\n# or simply:\nnix build\n\n# Generate the (HTML version of the) formal specification\nnix build .#mkdocs\n\n# Generate browseable HTML version of Agda code\nnix build .#html\n\n# Generate Haskell source code for conformance testing\nnix build .#hs-src\n</code></pre> <p>Build outputs are symlinked in the <code>result/</code> directory.</p>"},{"location":"guide.html#using-the-fls-shake-build-tool","title":"Using the <code>fls-shake</code> Build Tool","text":"<p>For more granular control, you can use our Shake-based build tool, <code>fls-shake</code>, from within a development shell.</p> <pre><code># Enter the default development shell\nnix develop\n\n# Build specific artifacts using fls-shake\nfls-shake html                # Build HTML docs\nfls-shake hs                  # Build Haskell source\n\n# See all available targets\nfls-shake --help\n</code></pre> <p></p>"},{"location":"guide.html#html-documentation","title":"\ud83d\udcd6 HTML Documentation","text":""},{"location":"guide.html#building-and-viewing-the-formal-specification","title":"Building and viewing the formal specification","text":"<p>There are two ways to do this.</p> <ol> <li> <p>With Nix</p> <p>Enter the command <code>nix build .#mkdocs</code> then open the file <code>result/site/index.html</code> in a browser. This type-checks the Agda code, and generates the HTML documentation from scratch.</p> <p>Note. This currently works in Chrome but may not work in Brave or Firefox.  If you want to use one of those browsers to view the generated documentation, you can run a local server on the result, <code>cd result/site; python3 -m http.server</code>, and then point your browser to http://127.0.0.1:8000/.</p> </li> <li> <p>Manually</p> <p>This method only type-checks the Agda code that has changed since last time and then generates the HTML documentation.</p> <pre><code>nix develop .#mkdocs\npython build-tools/scripts/md/build.py --run-agda\ncd _build/md/mkdocs\nmkdocs serve\n</code></pre> <p>Then point your browser to  http://127.0.0.1:8000/.</p> </li> </ol>"},{"location":"guide.html#generating-images","title":"Generating images","text":"<p>The diagrams in our documentation come from legacy tikz source code files that live in the <code>build-tools/static/latex/Diagrams</code> directory.  To generate svg images from a tikz source code file, we create a standalone LaTeX document for it (e.g., <code>build-tools/static/latex/STS-Diagram.tex</code>) and</p> <ol> <li> <p>run the following commands:</p> <pre><code>lualatex -halt-on-error -interaction=batchmode STS-Diagram.tex\ndvisvgm --pdf --page=1 -n -a -o STS-Diagram.svg STS-Diagram.pdf\n</code></pre> </li> <li> <p>copy the resulting <code>.svg</code> file into the <code>build-tools/static/md/common/src/img/</code> directory.</p> </li> </ol> <p>To include the diagram in the markdown documentation, we add it to a <code>.lagda.md</code> file as follows: <code>![STS-Diagram](img/STS-Diagram.svg)</code>.</p> <p>(The Python pipeline for markdown migration and mkdocs site generation can now handle steps 1 and 2 above.  Specifically, when you build the html documentation site using the second (\"manual\") method above, the program looks in the <code>build-tools/static/latex/</code> directory for LaTeX files with names matching the pattern <code>*-Diagram.tex</code>; it processes each such file with the <code>lualatex</code> and <code>dvisvgm</code> commands shown above and then copies the resulting <code>.svg</code> image file into the <code>build-tools/static/md/common/src/img</code> directory.)</p> <p>Important Notes</p> <ul> <li> <p>For each tikz source file in <code>build-tools/static/latex/Diagrams</code>, to generate the    corresponding svg image file, we must create a standalone LaTeX file    <code>*-Diagram.tex</code> file that <code>\\include</code>s the tikz source file.  Also, we need to    include the svg image in the appropriate <code>.lagda.md</code> file by hand, either</p> <ul> <li> <p>using the standard Markdown syntax for including images, that is, <code>![...](...)</code>; e.g.,</p> <p><code>![Rewards flowchart](img/Rewards-Diagram.svg \"Rewards flowchart\")</code></p> <p>OR</p> </li> <li> <p>using our custom <code>svg-card</code> css class; e.g.,</p> <pre><code>&lt;figure class=\"svg-card\"&gt;\n  &lt;img src=\"img/RewardsTiming-Diagram.svg\" alt=\"Rewards timeline\"&gt;\n&lt;/figure&gt;\n</code></pre> </li> </ul> </li> <li> <p>Each <code>.tex</code> file in the <code>build-tools/static/latex/</code> directory that should not be    converted to Markdown by the pipeline must be added to the <code>excluded_prefixes</code>    list in the <code>convert_all_static_tex</code> function of the Python script    <code>build-tools/scripts/md/modules/static_tex_processor.py</code>.</p> </li> </ul>"},{"location":"guide.html#browsing-the-source-code","title":"Browsing the source code","text":"<p>After generating the HTML version of the source code with <code>nix build .#html</code>, you can view the result by pointing your browser to <code>result/html/index.html</code>.  If this fails, then you may have to run a local server, as follows:</p> <pre><code>cd result/html\npython3 -m http.server\n</code></pre> <p>Then point your browser to http://127.0.0.1:8000.</p> <p></p>"},{"location":"guide.html#ide-integration","title":"\ud83d\udda5\ufe0f IDE Integration","text":"<p>For the best development experience, you should configure your IDE to use the Agda executable provided by this project's Nix environment.</p> <p>First, build <code>agdaWithPackages</code> and create a stable symlink to it in your home directory. This prevents you from having to update your IDE settings every time the project's dependencies change.</p> <pre><code>nix build ./#agdaWithPackages -o ~/ledger-agda\n</code></pre> <p>Then make sure that the <code>~/ledger-agda/bin</code> directory is in your <code>PATH</code> when starting your editor.</p>"},{"location":"guide.html#setting-up-multiple-versions-with-update-alternatives-optional","title":"Setting up multiple versions with <code>update-alternatives</code> (OPTIONAL)","text":"<p>For Linux users.</p> <p>If you have <code>update-alternatives</code> installed, then, instead of creating a symlink from your home directory (or some other directory that's in your <code>PATH</code>) to our version of agda in <code>~/ledger-agda/bin/agda</code>, you can configure multiple versions of <code>agda</code> and <code>agda-mode</code> as follows:</p> <pre><code>sudo update-alternatives --install /usr/bin/agda agda ~/ledger-agda/bin/agda 1\n</code></pre> <p>Do the same for any other versions of Agda that you have installed, and want to make available, on your system.</p> <p>For example,</p> <pre><code>sudo update-alternatives --install /usr/bin/agda agda ~/.cabal/bin/agda-2.8.0 10\n</code></pre> <p>Now, install the associated version of <code>agda-mode</code>, which is required for using Agda (versions &lt; 2.8.0) in Emacs:</p> <pre><code>sudo update-alternatives --install /usr/bin/agda-mode agda-mode ~/ledger-agda/bin/agda-mode 1\n</code></pre> <p>Finally, choose which Agda version you want to use:</p> <pre><code>sudo update-alternatives --config agda\n</code></pre> <p>and, if you choose a version below 2.8.0, be sure to select the appropriate <code>agda-mode</code> version to accompany it!</p> <pre><code>sudo update-alternatives --config agda-mode\n</code></pre>"},{"location":"guide.html#emacs","title":"Emacs","text":"<p>(This section does not assume you followed the optional <code>update-alternative</code> setup instructions above.  However, even if you did, you can still carry out the customization instructions in the present section, which do not conflict with the <code>update-alternatives</code> approach.)</p> <ol> <li> <p>Configure Emacs for version switching.</p> <p>Add the following to your Emacs init file (highlight and <code>M-x eval-region</code> to load without restarting):</p> <pre><code>;; Defines a function `my/switch-agda' that switches between different\n;; `agda' executables defined in `my/agda-versions'. The first entry of\n;; `my/agda-versions' is assumed to be the default Agda.\n;;\n;; If there are two entries in `my/agda-versions', `my/switch-agda' toggles\n;; between the two. If there are more entries, it will ask which one\n;; to choose.\n(setq my/agda-versions `((\"System Agda\"  \"2.8.0\" \"agda\")  ; Adjust version as needed\n                         (\"Ledger Agda\"  \"2.7.0.1\" \"~/ledger-agda/bin/agda\")))\n(setq my/selected-agda (caar my/agda-versions))\n\n(defun my/switch-agda (name version path)\n  (interactive\n   (cond ((&gt; (length my/agda-versions) 2)\n          (assoc (completing-read \"Agda: \" my/agda-versions '(lambda (x) 't) 't) my/agda-versions))\n         ((= (length my/agda-versions) 2)\n          (car (seq-filter '(lambda (x) (not (string= my/selected-agda (car x)))) my/agda-versions)))\n         (t (error \"my/agda-versions needs to have at least two elements!\"))))\n  (message \"Selecting %s, version %s\" name version)\n  (setq my/selected-agda   name\n        agda2-version      version\n        agda2-program-name path)\n  (agda2-restart))\n\n;; Bind the switch function to C-c C-x C-t in agda2-mode\n(with-eval-after-load 'agda2-mode\n  (define-key agda2-mode-map (kbd \"C-c C-x C-t\") 'my/switch-agda))\n</code></pre> <p>Notes</p> <ul> <li>Update the system Agda version in <code>my/agda-versions</code> to match your installation.</li> <li>Check your system Agda with <code>which agda &amp;&amp; agda --version</code>.</li> <li>Once configured, use <code>M-x my/switch-agda</code> (or <code>C-c C-x C-t</code>) to switch between Agda versions.</li> <li>This works with most Emacs distributions (Doom, Spacemacs, vanilla, etc.).</li> </ul> </li> <li> <p>Launch Emacs from within the project's Nix shell to make it aware of the environment:</p> <pre><code>nix develop\nemacs src/Ledger.agda\n</code></pre> </li> <li> <p>Use standard <code>agda-mode</code> commands (e.g., <code>C-c C-l</code> to load a file).</p> </li> </ol>"},{"location":"guide.html#visual-studio-code","title":"Visual Studio Code","text":"<ol> <li> <p>Install the official Agda Language Server extension from the marketplace.</p> </li> <li> <p>Configure the extension to use the project's Agda executable. Open your <code>settings.json</code> (<code>Ctrl+Shift+P</code> &gt; \"Preferences: Open User Settings (JSON)\") and add the path to the symlink:     <pre><code>{\n  \"agdaMode.connection.paths\": [\n    \"~/ledger-agda/bin/agda\",\n    \"agda\"\n  ]\n}\n</code></pre> (Note: VS Code may not expand <code>~</code>, so you might need to use the full path, e.g., <code>/home/user/ledger-agda/bin/agda</code>).</p> </li> <li> <p>Use <code>Ctrl+C Ctrl+R</code> to switch between Agda versions if you have multiple configured.</p> </li> </ol> <p></p>"},{"location":"guide.html#working-on-the-agda-source-code","title":"\ud83e\uddd1\u200d\ud83d\udd27 Working on the Agda source code","text":""},{"location":"guide.html#editing-the-source-files","title":"Editing the source files","text":"<p>You can use either Emacs or VSCode to edit the source code files under the main <code>src</code> directory.  Currently, we have a mixture of plain Agda (<code>.agda</code>), LaTeX-based literate Agda (<code>.lagda</code>), and Markdown-based literate Agda (<code>.lagda.md</code>), but eventually all Agda files under <code>src</code> will be of the Markdown flavor and as such will have the <code>.lagda.md</code> extension.</p> <p>Markdown-flavored literate Agda files contain English prose, formatted using Markdown syntax, along with code blocks each of which is delimited by an Agda code fence. For example,</p> <pre><code>```agda\n-- Agda code goes here\n```\n</code></pre> <p>We also use \"hidden\" code blocks, inside of which is code that is type-checked by Agda but does not (by default) appear on web pages generated by from the <code>.lagda.md</code> source file.<sup>1</sup>  A normal Agda code block is hidden by simply surrounding a normal code block with the standard HTML comment delimiters.  For example,</p> <pre><code>&lt;!--\n```agda\n-- Agda code here will be type-checked but not shown on the web page by default.\n```\n--&gt;\n</code></pre> <p>See also: the Agda documentation section on literate markdown.</p>"},{"location":"guide.html#checking-how-your-code-looks-on-the-site","title":"Checking how your code looks on the site","text":"<p>An important step in contributing any code to the repository is to check how it will appear when run through our custom mkdocs site generator and rendered on our website. This section explains how to use the tools we have created to monitor the effects your changes to the code will have on the appearance of the corresponding web pages.</p> <ol> <li> <p>First, generate the mkdocs site Manually (as described in option 2 of the     Building and viewing the formal specification section):</p> <p><pre><code>nix develop .#mkdocs\npython build-tools/scripts/md/build.py --run-agda\ncd _build/md/mkdocs\nmkdocs serve\n</code></pre> 2.  In another terminal window, enter the default Nix shell with <code>nix develop</code> and then run <code>fls-shake --watch</code>.</p> </li> <li> <p>Now, instead of directly editing a file (or creating a new file) under the main <code>src</code>     directory, make your changes to (or create) <code>.lagda.md</code> files under <code>_build/md/md.in/src</code>.</p> </li> <li> <p>Check your work by viewing the corresponding page at http://127.0.0.1:8000/.</p> </li> <li> <p>Once you are satisfied with your changes.  Replace the corresponding file under     <code>src</code> with your new version from <code>_build/md/md.in/src</code>.</p> </li> </ol> <p>How this works.  The <code>fls-shake --watch</code> command watches for changes to files in <code>_build/md/md.in/src</code> and, whenever a change occurs, generates a new corresponding page in the mkdocs site directory.  Since the mkdocs server is listening for changes to files in the mkdocs site directory, you will see the effect of your changes in the browser.</p> <p></p>"},{"location":"guide.html#cicd-workflow","title":"\ud83d\udd01 CI/CD Workflow","text":"<p>Our CI/CD pipeline, defined in <code>.github/workflows/</code>, automates the building and publishing of artifacts. Here are some key details:</p> <ul> <li>Caching</li> </ul> <p>The initial <code>formal-ledger-agda</code> job type-checks the code and uploads the resulting <code>_build</code> directory as a GitHub artifact. Subsequent jobs download this artifact to avoid re-compiling Agda code.</p> <ul> <li>Artifact Branches</li> </ul> <p>For every push to <code>master</code> or a pull request branch, the CI creates a corresponding <code>&lt;branch-name&gt;-artifacts</code> branch. This branch stores the generated artifacts (PDFs, HTML, Haskell code).</p> <ul> <li>PDF Generation Note</li> </ul> <p>The CI workflow does not build PDFs from the current source. Instead, it checks out the <code>legacy-latex-artifacts</code> branch and copies the PDFs from there. This is a temporary measure to ensure the stability of the published documents. You can still build PDFs locally from source using the commands described above.</p> <p></p>"},{"location":"guide.html#setup-without-nix","title":"\ud83c\udf9b\ufe0f\ufe0f Setup Without Nix","text":"<p>While we recommend using Nix for the best experience, it's possible to work with this repository without Nix. Those making nontrivial contributions are advised to use the Nix-based approach, but these instructions are provided for those who prefer not to use Nix.</p>"},{"location":"guide.html#installing-agda-and-dependencies-manually","title":"Installing Agda and Dependencies Manually","text":"<ol> <li> <p>Install Agda 2.7.0.1.</p> <p>Follow the instructions at https://agda.readthedocs.io/en/v2.7.0/getting-started/installation.html#step-1-install-agda</p> </li> <li> <p>Clone the required Agda libraries.</p> <pre><code>mkdir -p LIB &amp;&amp; cd LIB\n\n# Clone exact versions used by the project\ngit clone --config advice.detachedHead=false --single-branch -b \"v2.2\" \\\n  https://github.com/agda/agda-stdlib.git\ngit clone --config advice.detachedHead=false --single-branch \\\n  https://github.com/agda/agda-stdlib-classes.git\ngit clone --config advice.detachedHead=false --single-branch \\\n  https://github.com/agda/agda-stdlib-meta.git\ngit clone --config advice.detachedHead=false --single-branch -b \"master\" \\\n  https://github.com/input-output-hk/agda-sets.git\ngit clone --config advice.detachedHead=false --single-branch -b \"main\" \\\n  https://github.com/input-output-hk/iog-agda-prelude.git\n\n# Checkout specific commits (check sources.json for exact versions)\ncd agda-stdlib-classes &amp;&amp; git checkout aa62ce6348d39c554ef89487079871d5590e155e &amp;&amp; cd ..\ncd agda-stdlib-meta &amp;&amp; git checkout 5ff853375180ef69f243ce72f2d3f6294bdb6aff &amp;&amp; cd ..\ncd agda-sets &amp;&amp; git checkout f517d0d0c1ff1fd6dbac8b34309dea0e1aea6fc6 &amp;&amp; cd ..\ncd iog-agda-prelude &amp;&amp; git checkout 20e4ab42fd6a980233053c8c3b1b8b2ab42946c9 &amp;&amp; cd ..\n</code></pre> </li> <li> <p>Create library configuration.</p> <p>Create a file <code>LIB/libraries</code> with the following content:</p> <pre><code>LIB/agda-stdlib/standard-library.agda-lib\nLIB/agda-stdlib-classes/agda-stdlib-classes.agda-lib\nLIB/agda-stdlib-meta/agda-stdlib-meta.agda-lib\nLIB/agda-sets/abstract-set-theory.agda-lib\nLIB/iog-agda-prelude/iog-prelude.agda-lib\n</code></pre> </li> <li> <p>Use Agda with the libraries.</p> <pre><code># Type-check the formal specification\nAGDA_DIR=LIB agda src/Everything.agda\n\n# Build artifacts (requires fls-shake, see below)\nAGDA_DIR=LIB fls-shake cardano-ledger.pdf\n</code></pre> </li> </ol>"},{"location":"guide.html#building-fls-shake-without-nix","title":"Building fls-shake Without Nix","text":"<p>The build system <code>fls-shake</code> can be compiled manually by following the steps described in this subsection.</p> <ol> <li> <p>Install GHC and Cabal.</p> <p>Follow the official Haskell instructions.</p> <p>Verify installation and update:</p> <pre><code>ghc --version\ncabal --version\ncabal update\n</code></pre> </li> <li> <p>Compile fls-shake.</p> <pre><code>cd build-tools/shake\ncabal build fls-shake\n</code></pre> </li> <li> <p>Run fls-shake:</p> <pre><code># Build PDF documents\ncabal run fls-shake -- -C '../..' cardano-ledger.pdf\ncabal run fls-shake -- -C '../..' conway-ledger.pdf\n\n# Build HTML and Haskell outputs\ncabal run fls-shake -- -C '../..' html\ncabal run fls-shake -- -C '../..' hs\n</code></pre> <p>Note: The <code>-C '../..'</code> option makes fls-shake run from the repository's main directory.</p> </li> </ol>"},{"location":"guide.html#required-system-dependencies","title":"Required System Dependencies","text":"<p>For non-Nix users, you'll also need to install the following:</p> <ul> <li>LaTeX (for PDF generation)</li> </ul> <pre><code># Ubuntu/Debian\nsudo apt install texlive-full latexmk\n\n# Or minimal installation\nsudo apt install texlive-latex-extra latexmk\n</code></pre> <ul> <li>Python and dependencies (for documentation tools)</li> </ul> <pre><code>pip install mkdocs mkdocs-material pymdown-extensions pyyaml\n</code></pre> <ul> <li>Other tools</li> </ul> <p>pandoc, basic utilities (cp, mkdir, etc.)</p> <p></p>"},{"location":"guide.html#conformance-testing","title":"\ud83d\udd75\ufe0f\u200d\u2640\ufe0f Conformance Testing","text":"<p>After producing the Agda-generated Haskell code with <code>nix build .#hs-src</code>, you can run the conformance tests.</p> <p>See the <code>conformance-example</code> directory.</p> <p></p>"},{"location":"guide.html#miscellanea","title":"\ud83d\uddc3\ufe0f Miscellanea","text":""},{"location":"guide.html#plotting-typechecking-times","title":"Plotting typechecking times","text":"<p>The script <code>scripts/plot_typecheck_time.py</code> can be used to generate an <code>html</code> file that plots the typechecking times as recorded in the <code>master-artifacts</code> branch.</p> <p>The script uses <code>python</code> and <code>pandas</code>, and the generated <code>html</code> uses <code>chart.js</code> for plotting.</p> <p>Frome the git repository, run, <pre><code>python scripts/plot_typecheck_time.py &gt; index.html\n</code></pre> and open <code>index.html</code> in your browser.</p> <p></p>"},{"location":"guide.html#another-example-of-the-getter-type-class-pattern","title":"Another Example of the Getter Type Class Pattern","text":"<p>Here's a more realistic example of how we use type classes to make accessing fields of records easier and more consistent.</p> <p>Let</p> <pre><code>VoteDelegs : Type\nVoteDelegs = Credential \u21c0 VDeleg\n\nrecord HasVoteDelegs {a} (A : Type a) : Type a where\n  field VoteDelegsOf : A \u2192 VoteDelegs\nopen HasVoteDelegs \u2983...\u2984 public\n\nrecord DState : Type where\n  field\n    voteDelegs   : VoteDelegs\n    ...\n\nrecord HasDState {a} (A : Type a) : Type a where\n  field DStateOf : A \u2192 DState\nopen HasDState \u2983...\u2984 public\n\nrecord CertState : Type where\n  field\n    dState : DState\n    ...\n\ninstance\n  HasVoteDelegs-DState : HasVoteDelegs DState\n  HasVoteDelegs-DState .VoteDelegsOf = DState.voteDelegs\n\n  HasDState-CertState : HasDState CertState\n  HasDState-CertState .DStateOf = CertState.dState\n\n  HasVoteDelegs-CertState : HasVoteDelegs CertState\n  HasVoteDelegs-CertState .VoteDelegsOf = VoteDelegsOf \u2218 DStateOf\n</code></pre> <p>Now, if we have <code>cs : CertState</code>, we can fetch the <code>voteDelegs</code> field of (the <code>dState</code> of) <code>cs</code> as follows: <code>VoteDelegsOf cs</code>.</p> <p>Without type classes we would have to <code>open DState</code> and <code>open CertState</code> and then write <code>cs .dState .voteDelegs</code>, or, if we want to avoid <code>open</code> clutter, <code>DState.voteDelegs CertState.dState cs</code>.</p>"},{"location":"guide.html#build-tools","title":"Build-tools","text":"<p>Here is the complete annotated subtree of the <code>build-tools</code> directory.</p> <pre><code>\u251c\u2500\u2500 build-tools/                                     # All build-related utilities and static assets\n\u2502   \u251c\u2500\u2500 agda/                                        # Source for the custom `fls-agda` Agda backend\n\u2502   \u2502   \u251c\u2500\u2500 data/                                    # Static assets used by the fls-agda backend\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Agda.css                             # Base CSS for styling Agda HTML output\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 AgdaKaTeX.js                         # JS for integrating Agda's HTML with KaTeX\n\u2502   \u2502   \u251c\u2500\u2500 fls-agda.cabal                           # Cabal file for building the fls-agda Haskell package\n\u2502   \u2502   \u251c\u2500\u2500 nix/                                     # Nix-specific build files for fls-agda\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 fls-agda.nix                         # Nix derivation for the fls-agda package\n\u2502   \u2502   \u251c\u2500\u2500 src/                                     # Haskell source code for the fls-agda backend\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Main.hs                              # Main entry point for the fls-agda executable\n\u2502   \u2502   \u2514\u2500\u2500 test/                                    # Test files for the fls-agda backend\n\u2502   \u2502       \u2514\u2500\u2500 Test0.agda                           # Agda file for testing the backend's functionality\n\u2502   \u251c\u2500\u2500 nix/                                         # General Nix configuration for the project\n\u2502   \u2502   \u251c\u2500\u2500 sources.json                             # Niv-managed file pinning exact dependency versions\n\u2502   \u2502   \u2514\u2500\u2500 sources.nix                              # Niv-generated file to load pinned dependencies\n\u2502   \u251c\u2500\u2500 scripts/                                     # Various utility scripts for building and processing\n\u2502   \u2502   \u251c\u2500\u2500 agda2vec.py                              # Python script for post-processing Agda-generated LaTeX\n\u2502   \u2502   \u251c\u2500\u2500 checkTypeChecked.sh                      # Shell script to verify Agda type-checking success\n\u2502   \u2502   \u251c\u2500\u2500 hldiff.py                                # Python script for highlighting differences in LaTeX\n\u2502   \u2502   \u251c\u2500\u2500 md/                                      # Scripts for the Markdown documentation pipeline\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 agda-filter.lua                      # Pandoc Lua filter for processing Agda code blocks\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 build.py                             # Main entry point for the Markdown build script\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 config/                              # Configuration modules for the build script\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 build_config.py                  # Defines dataclasses for build paths and settings\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 modules/                             # Core logic modules for the build script\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 agda_processing.py               # Handles interaction with the Agda compiler\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 bibtex_processor.py              # Processes BibTeX citations\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 content_staging.py               # Manages intermediate build files\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 latex_pipeline.py                # Orchestrates LaTeX-to-Markdown conversion\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 latex_preprocessor.py            # Pre-processes LaTeX files before conversion\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 site_assembly.py                 # Assembles the final MkDocs/MdBook site\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 test/                                # Tests for the Markdown build pipeline\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 test_bibtex_processor.py         # Unit tests for the BibTeX processor\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 utils/                               # Utility functions used by the build script\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 command_runner.py                # Helper for running external commands\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 file_ops.py                      # Helpers for file system operations\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 pipeline_types.py                # Defines custom types used in the pipeline\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 text_processing.py               # Helpers for text manipulation\n\u2502   \u2502   \u251c\u2500\u2500 plot_typecheck_time.py                   # Script to plot Agda type-checking performance\n\u2502   \u2502   \u2514\u2500\u2500 prepare-conf-test.sh                     # Script to prepare for conformance testing\n\u2502   \u251c\u2500\u2500 shake/                                       # Source for the `fls-shake` build tool\n\u2502   \u2502   \u251c\u2500\u2500 fls-shake.cabal                          # Cabal file for building the fls-shake Haskell package\n\u2502   \u2502   \u251c\u2500\u2500 nix/                                     # Nix-specific build files for fls-shake\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 fls-shake.nix                        # Nix derivation for the fls-shake package\n\u2502   \u2502   \u2514\u2500\u2500 src/                                     # Haskell source code for fls-shake\n\u2502   \u2502       \u2514\u2500\u2500 Main.hs                              # Main entry point for the fls-shake build system\n\u2502   \u2514\u2500\u2500 static/                                      # Static assets copied into builds\n\u2502       \u251c\u2500\u2500 hs-src/                                  # Template for the extracted Haskell source code\n\u2502       \u2502   \u251c\u2500\u2500 package.yaml                         # hpack file to generate the .cabal file\n\u2502       \u2502   \u2514\u2500\u2500 src/MAlonzo/Code/Ledger/Foreign/API.hs # Manual Haskell FFI to Agda code\n\u2502       \u251c\u2500\u2500 latex/                                   # Static LaTeX files for (legacy) PDF generation\n\u2502       \u2502   \u251c\u2500\u2500 cardano-ledger.tex                   # Main TeX file for the full specification PDF\n\u2502       \u2502   \u251c\u2500\u2500 ...                                  # Other TeX includes, diagrams, fonts, etc.\n\u2502       \u2502   \u2514\u2500\u2500 references.bib                       # BibTeX file for all citations\n\u2502       \u2514\u2500\u2500 md/                                      # Static assets for Markdown documentation sites\n\u2502           \u251c\u2500\u2500 common/                              # Assets shared between MkDocs and MdBook\n\u2502           \u2502   \u251c\u2500\u2500 nav.yml                          # Template for the MkDocs navigation structure\n\u2502           \u2502   \u2514\u2500\u2500 src/                             # Source assets (CSS, JS, images, etc.)\n\u2502           \u2502       \u251c\u2500\u2500 css/custom.css               # Custom stylesheet for documentation sites\n\u2502           \u2502       \u2514\u2500\u2500 js/custom.js                 # Custom JavaScript for documentation sites\n\u2502           \u2514\u2500\u2500 mkdocs/                              # Configuration and templates for MkDocs\n\u2502               \u251c\u2500\u2500 docs/index.md                    # Homepage/landing page for the MkDocs site\n\u2502               \u251c\u2500\u2500 includes/links.md                # Common Markdown link references\n\u2502               \u2514\u2500\u2500 mkdocs.yml                       # Main configuration file for the MkDocs site\n\u251c\u2500\u2500 TEX2MD_MIGRATION.md                              # Guide for the LaTeX to Markdown migration process\n\u2514\u2500\u2500 TROUBLESHOOTING.md                               # Guide for resolving common build issues\n</code></pre> <p></p>"},{"location":"guide.html#maintainers","title":"\ud83e\uddd1\u200d\ud83d\udd27 Maintainers","text":"<p>This repository is maintained by @carlostome, @WhatisRT, and @williamdemeo.</p> <p>If you encounter any problems, please open a New Issue.</p> <ol> <li> <p>However, our custom mkdocs configuration provides a toggle button that allows the reader to view hidden code blocks if desired.)\u00a0\u21a9</p> </li> </ol>"}]}