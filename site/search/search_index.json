{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"The Cardano Formal Ledger Specification","text":"<p>This is the formal ledger specifications for the Cardano blockchain. It is written in Agda and is executable; Haskell code can be extracted and run for conformance testing.</p> <p>The project consists entirely of literate Agda code from which the HTML documentation is generated.  Thus the latest human-readable Cardano ledger specification is a collection of HTML files; these replace the PDF documents of previous eras.</p> <p>The formal ledger GitHub repository contains formal ledger specifications for all eras, starting with Shelley, up to and including the Conway era. While the Agda formalization of the Conway era is complete, some pieces of the ledgers from previous eras have yet to be formalized.  We hope to finish formalizing the outstanding pieces in the near future.</p>"},{"location":"index.html#where-to-go-from-here","title":"Where to go from here?","text":"<p>You can</p> <ul> <li> <p>read the Introduction module of the HTML version of the formal specification</p> </li> <li> <p>dive into one of the modules in the Conway/ &gt; Specification/ section of the website; for instance, you can read about how rewards are calculated in the Conway/Specification/Rewards module</p> </li> <li> <p>view the HTML version of the Agda source code</p> </li> <li> <p>interact with and/or contribute to the formal specification; instructions for    building the artifacts, generating Haskell source code for conformance testing, or    exploring the literate Agda files in a development environment are available in    the Contributing Guide.</p> </li> </ul>"},{"location":"index.html#published-artifacts","title":"\ud83d\udcdc Published Artifacts","text":"<p>The table below provides links to the full formal ledger specification (as browsable HTML), as well as the legacy PDF artifacts.</p> Artifact Link Description Source Code HTML Interactive, hyperlinked version of the Agda source code Formal Specification HTML cardano-ledger.pdf<sup>\u2020</sup> Complete specification of the Cardano Ledger Conway-Era PDF conway-ledger.pdf<sup>\u2020</sup> Covers what's new in the Conway era <p>\u2020 As we are migrating from a LaTeX-based to a Markdown-based documentation workflow, building PDFs from source is currently deprecated and unsupported.  Please use the links above to access the pre-built PDF documents.</p>"},{"location":"index.html#contributions-and-feedback","title":"\ud83e\udd1d Contributions and Feedback","text":"<p>We welcome contributions and feedback!</p> <p>For detailed instructions on setting up a development environment, running tests, and understanding the project structure, please see our Contributing Guide.</p> <p>If you encounter any issues, please check the Troubleshooting Guide or submit a new issue in this repository.</p>"},{"location":"ConwayBootstrap.html","title":"Bootstrapping the Governance System","text":"<p>As described in CIP-1694, the governance system needs to be bootstrapped.  During the bootstrap period, the following changes will be made to the ledger described in this document.</p> <ul> <li> <p>Transactions containing any proposal except <code>TriggerHardFork</code>, <code>ChangePParams</code>, or <code>Info</code> will be rejected.</p> </li> <li> <p>Transactions containing a vote other than a <code>CC</code> vote, a <code>SPO</code> vote on a <code>TriggerHardFork</code> action, or any vote on an <code>Info</code> action will be rejected.</p> </li> <li> <p><code>Q4</code>, <code>P5</code>, and <code>Q5e</code> are set to \\(0\\).</p> </li> <li> <p>An SPO that does not vote is assumed to have voted <code>abstain</code>.</p> </li> </ul> <p>This allows for a governance mechanism similar to the old, Shelley-era governance during the bootstrap phase, where the constitutional committee is mostly in charge (Team18, ). These restrictions will be removed during a subsequent hard fork, once enough DRep stake is present in the system to properly govern and secure itself.</p> <p>[Team18]  IOHK Formal Methods Team. Design Specification for Delegation and Incentives in Cardano, IOHK Deliverable SL-D1. 2018.</p>"},{"location":"ConwayBootstrapEnact.html","title":"Bootstrapping EnactState","text":"<p>To form an <code>EnactState</code>, some governance action IDs need to be provided. However, at the time of the initial hard fork into Conway there are no such previous actions. There are effectively two ways to solve this issue:</p> <ul> <li> <p>populate those fields with IDs chosen in some manner (e.g. random, all zeros, etc.), or</p> </li> <li> <p>add a special value to the types to indicate this situation.</p> </li> </ul> <p>In the Haskell implementation the latter solution was chosen. This means that everything that deals with <code>GovActionID</code> needs to be aware of this special case and handle it properly.</p> <p>This specification could have mirrored this choice, but it is not necessary here: since it is already necessary to assume the absence of hash-collisions (specifically first pre-image resistance) for various properties, we could pick arbitrary initial values to mirror this situation. Then, since <code>GovActionID</code> contains a hash, that arbitrary initial value behaves just like a special case.</p>"},{"location":"Definitions.html","title":"Definitions","text":"<p>To keep this site somewhat self-contained, we define some technical terms that arise when defining and describing the Cardano blockchain and ledger. This is not meant to be comprehensive and the reader may wish to consult online resources to fill in any gaps. Here are a few such resources that might be helpful.</p> <ul> <li> <p>https://docs.cardano.org/;</p> </li> <li> <p>https://cardano.org/docs/glossary#cardano-glossary;</p> </li> <li> <p>https://www.ledger.com/academy/glossary;</p> </li> <li> <p>https://www.essentialcardano.io/glossary;</p> </li> <li> <p>(Re)introduction to Cardano, by Eduardo Garrido and the Cardano community;</p> </li> <li> <p>Ouroboros Chronos blog post, by Olga Hryniuk;</p> </li> <li> <p>Cardano Staking: How To Stake ADA.</p> </li> </ul>"},{"location":"Definitions.html#sec:cardano-time-handling","title":"Cardano Time Handling","text":"<p>For more details, see the Time handling on Cardano section of https://docs.cardano.org.</p> <p>In Cardano, the Ouroboros proof-of-stake (PoS) consensus protocol models the passage of physical time as an infinite sequence of time slots and epochs.</p> <ul> <li> <p>The actual time interval between blocks, or block time, is the     slot length (in seconds) divided by the block coefficient f, which     is the expected block frequency (blocks per second). For example, if     f is 0.05, then on average 5% of slots contain blocks. If the slot     length is 1 second, then the block time is 20 seconds.</p> </li> <li> <p>An epoch is a period of time, containing some number of slots,     used to select block-producing nodes. For example, in Shelley and     later eras, an epoch consists of roughly 432,000 slots (or five days     if we assume a slot length of 1 second).</p> </li> <li> <p>The genesis block of Cardano was created on the 23<sup>rd</sup> of     September 2017. As the first block in the blockchain, it set the     foundation for the network, it does not reference any previous     blocks, and it generated the initial supply of Ada.</p> </li> <li> <p>A slot is a discrete time interval in which a single block may be     produced; it is the fundamental time unit within the blockchain's     consensus protocol. Slots should be long enough for a new block to     have a good chance to reach the next slot leader in time. For     example, the slot length in the Byron era was 20 seconds, while in     Shelley and later eras it is 1 second. Not every slot results in a     new block. Indeed, in any given slot, one or more block-producing     nodes are nominated (probabilistically based on stake distribution)     to be slot leaders and given the opportunity to produce a new     block. For example, in Shelley and later eras, on average only 0.05     of slots will produce a block (resulting in 20-second intervals     between blocks). Slot number may refer to a slot's position within     the current epoch or it may mean the absolute slot count since the     genesis block. The context should make clear which meaning is     intended.</p> </li> </ul> <p>The parameter values mentioned in the examples above,</p> <ul> <li> <p>block time = 20 seconds,</p> </li> <li> <p>slot length = 1 second,</p> </li> <li> <p>block coefficient = 0.05,</p> </li> <li> <p>slots/epoch = 432,000,</p> </li> </ul> <p>are unlikely to change in the short-term. However, the longer term plan is to replace the current Ouroboros protocol with Ouroboros Chronos, which addresses timekeeping challenges by providing the first high-resilience cryptographic time source based on blockchain technology (see the Ouroboros Chronos blog post).</p>"},{"location":"EssentialAgda.html","title":"Essential Agda","text":"<p>Here we describe some of the essential concepts and syntax of the Agda programming language and proof assistant. The goal is to provide some background for readers who are not already familiar with Agda, to help them understand the other sections of the specification. For more details, the reader is encouraged to consult the official Agda documentation Team24.</p> <pre>{-# OPTIONS --safe #-}\n\nmodule EssentialAgda where\n\nopen import Prelude using (Type)\nopen import Data.Nat\n</pre>"},{"location":"EssentialAgda.html#record-types","title":"Record Types","text":"<p>A record is a product with named accessors for the individual fields. It provides a way to define a type that groups together inhabitants of other types.</p> <p>Example.</p> <pre>record Pair (A B : Type) : Type where\n  constructor \u2985_,_\u2986\n  field\n    fst : A\n    snd : B\n</pre> <p>We can construct an element of the type <code>Pair</code> <code>\u2115</code> <code>\u2115</code> (i.e., a pair of natural numbers) as follows:</p> <pre>p23 : Pair \u2115 \u2115\np23 = record { fst = 2; snd = 3 }\n</pre> <p>Since our definition of the <code>Pair</code> type provides an (optional) constructor <code>\u2985_,_\u2986</code>, we could have defined <code>p23</code> as follows:</p> <pre>_ : Pair \u2115 \u2115\n_ = \u2985 2 , 3 \u2986\n</pre> <p>Finally, we can \"update\" a record by deriving from it a new record whose fields may contain new values.  The syntax is best explained by way of example.</p> <pre>p24 : Pair \u2115 \u2115\np24 = record p23 { snd = 4 }\n</pre> <p>This results a new record, <code>p24</code>, which denotes the pair <code>\u2985</code> <code>2</code> <code>,</code> <code>4</code> <code>\u2986</code>. See also agda.readthedocs.io/record-types.</p>"},{"location":"EssentialAgda.html#references","title":"References","text":"<p>[Team24]  Agda team. Agda 2.7.0 documentation. 2024.</p>"},{"location":"Foreign.Convertible.Deriving.html","title":"Deriving","text":"<pre>module Foreign.Convertible.Deriving where\n\nopen import Level\nopen import Meta.Prelude\nopen import Meta.Init\n\nimport Data.List as L\nimport Data.List.NonEmpty as NE\nimport Data.String as S\nimport Data.Product as P\n\nopen import Relation.Nullary\nopen import Relation.Nullary.Decidable\n\nopen import Reflection.Tactic\nopen import Reflection.AST.Term\nopen import Reflection.AST.DeBruijn\nimport Reflection.TCM as R\nopen import Reflection.Utils\nopen import Reflection.Utils.TCI\nopen import Reflection.Utils.Substitute\nimport Function.Identity.Effectful as Identity\n\nopen import Class.DecEq\nopen import Class.DecEq\nopen import Class.Functor\nopen import Class.Monad\nopen import Class.MonadTC.Instances\nopen import Class.Traversable\nopen import Class.Show\nopen import Class.MonadReader\n\nopen import Foreign.Convertible\nopen import Foreign.HaskellTypes\nopen import Foreign.HaskellTypes.Deriving\n\nprivate instance\n  _ = Functor-M {TC}\n\nprivate\n\n  open MonadReader \u2983...\u2984\n\n  TyViewTel = List (Abs (Arg Type))\n\n  substTel : Subst TyViewTel\n  substTel x s [] = []\n  substTel x s (abs z t \u2237 tel) = abs z (substArg x s t) \u2237 (substTel (\u2115.suc x) s tel)\n    -- Note: `abs` is abused in TyViewTel and doesn't actually scope over the `t`\n\n  -- Substitute leading level parameters with lzero\n  smashLevels : TyViewTel \u2192 \u2115 \u00d7 TyViewTel\n  smashLevels (abs s (arg i (def (quote Level) [])) \u2237 tel) =\n    P.map \u2115.suc (substTel 0 (quote 0\u2113 \u2219)) $ smashLevels tel\n  smashLevels tel = (0 , tel)\n\n  tyViewToTel : TyViewTel \u2192 Telescope\n  tyViewToTel = L.map \u03bb where (abs s a) \u2192 s , a\n\n  hideTyView : Abs (Arg A) \u2192 Abs (Arg A)\n  hideTyView (abs s (arg (arg-info _ m) x)) = abs s (arg (arg-info hidden m) x)\n\n  -- The type of a Convertible instance. For parameterised types adds the appropriate instance\n  -- arguments and instantiates level arguments to lzero. For instance,\n  -- instanceType _\u228e_ Hs.Either = {A B : Set} {a b : Set} \u2192 \u2983 Convertible A a \u2984 \u2192 \u2983 Convertible B b \u2984\n  --                              Convertible (A \u228e B) (Hs.Either a b)\n  instanceType : (agdaName hsName : Name) \u2192 TC TypeView\n  instanceType agdaName hsName = do\n    aLvls , agdaParams \u2190 smashLevels &lt;$&gt; getParamsAndIndices agdaName\n    hLvls , hsParams   \u2190 smashLevels &lt;$&gt; getParamsAndIndices hsName\n    true \u2190 return (length agdaParams == length hsParams)\n      where false \u2192 liftTC $ R.typeErrorFmt \"%q and %q have different number of parameters\" agdaName hsName\n    let n = length agdaParams\n        l\u2080 = quote 0\u2113 \u2219\n    agdaTy \u2190 applyWithVisibility agdaName $ L.replicate aLvls l\u2080 ++ L.map \u266f (take n (downFrom (n + n)))\n    hsTy   \u2190 applyWithVisibility hsName   $ L.replicate hLvls l\u2080 ++ L.map \u266f (downFrom n)\n    let instHead = weaken n $ quote Convertible \u2219\u27e6 agdaTy \u2223 hsTy \u27e7\n        tel      = L.map hideTyView (agdaParams ++ hsParams) ++\n                   L.replicate n (abs \"_\" (iArg (quote Convertible \u2219\u27e6 \u266f (n + n \u2238 1) \u2223 \u266f (n \u2238 1) \u27e7)))\n    return $ tel , instHead\n\n  -- Compute one clause of the Convertible instance. For instance,\n  -- conversionClause Convertible.to to ((c\u2081 , _) , (c\u2082 , _)) generates\n  -- .to (c\u2081 x\u2081 .. xn) = c\u2082 (to x\u2081) .. (to xn)\n  -- where the xi are the visible constructor arguments.\n  conversionClause : Name \u2192 Name \u2192 (Name \u00d7 Type) \u00d7 (Name \u00d7 Type) \u2192 TC Clause\n  conversionClause prjP prjE ((fromC , fromTy) , (toC , toTy)) = do\n    let isVis   = \u03bb { (abs _ (arg (arg-info visible _) _)) \u2192 true; _ \u2192 false }\n        fromTel = L.filter\u1d47 isVis (proj\u2081 (viewTy fromTy))\n        toTel   = L.filter\u1d47 isVis (proj\u2081 (viewTy toTy))\n        n       = length fromTel\n        mkCon  c mkArg = Term.con c    $ L.map (vArg \u2218 mkArg \u2218 \u266f)  (downFrom n)\n        mkConP c mkArg = Pattern.con c $ L.map (vArg \u2218 mkArg \u2218 `_) (downFrom n)\n    true \u2190 return (n == length toTel)\n      where false \u2192 liftTC $ R.typeErrorFmt \"%q and %q have different number of arguments\" fromC toC\n    return $ clause (tyViewToTel $ L.map (\u03bb where (abs x (arg i _)) \u2192 abs x (arg i unknown)) fromTel)\n                    (vArg (proj prjP) \u2237 vArg (mkConP fromC id) \u2237 [])\n                    (mkCon toC (prjE \u2219\u27e6_\u27e7))\n\n  -- Compute the clauses of a convertible instance.\n  instanceClauses : (agdaName hsName : Name) \u2192 TC (List Clause)\n  instanceClauses agdaName hsName = do\n    agdaCons \u2190 getConstrs agdaName\n    hsCons   \u2190 getConstrs hsName\n    agdaPars \u2190 length &lt;$&gt; getParamsAndIndices agdaName\n    hsPars   \u2190 length &lt;$&gt; getParamsAndIndices hsName\n    true \u2190 return (length agdaCons == length hsCons)\n      where false \u2192 liftTC $ R.typeErrorFmt \"%q and %q have different number of constructors\" agdaName hsName\n    toClauses   \u2190 mapM (conversionClause (quote Convertible.to)   (quote to)  ) (L.zip agdaCons hsCons)\n    fromClauses \u2190 mapM (conversionClause (quote Convertible.from) (quote from)) (L.zip hsCons agdaCons)\n    return $ toClauses ++ fromClauses\n\n  absurdClause : Name \u2192 Clause\n  absurdClause prj = absurd-clause ((\"x\" , vArg unknown) \u2237 []) (vArg (proj prj) \u2237 vArg (absurd 0) \u2237 [])\n\n  -- Compute conversion clauses for the current goal and wrap them in a pattern lambda.\n  patternLambda : TC Term\n  patternLambda = do\n    quote Convertible \u2219\u27e6 `A \u2223 `B \u27e7 \u2190 reduce =&lt;&lt; goalTy\n      where t \u2192 liftTC $ R.typeErrorFmt \"Expected Convertible A B, got %t\" t\n    agdaCons \u2190 getConstrsForType `A\n    hsCons   \u2190 getConstrsForType `B\n    toClauses   \u2190 mapM (conversionClause (quote Convertible.to)   (quote to)  ) (L.zip agdaCons hsCons)\n    fromClauses \u2190 mapM (conversionClause (quote Convertible.from) (quote from)) (L.zip hsCons agdaCons)\n    case toClauses ++ fromClauses of \u03bb where\n      []  \u2192 return $ pat-lam (absurdClause (quote Convertible.to) \u2237 absurdClause (quote Convertible.from) \u2237 []) []\n      cls \u2192 return $ pat-lam cls []\n\ndoPatternLambda : Term \u2192 R.TC Term\ndoPatternLambda hole = patternLambda =&lt;&lt; initTCEnvWithGoal hole\n\n-- Deriving a Convertible instance. Usage\n--   unquoteDecl iName = deriveConvertible iName (quote AgdaTy) (quote HsTy)\nderiveConvertible : Name \u2192 Name \u2192 Name \u2192 R.TC \u22a4\nderiveConvertible instName agdaName hsName = initUnquoteWithGoal \u2983 defaultTCOptions \u2984 (sort (lit 0)) do\n  agdaDef \u2190 getDefinition agdaName\n  hsDef   \u2190 getDefinition hsName\n  -- instName \u2190 freshName $ \"Convertible\" S.++ show hsName\n  instTel , instTy \u2190 instanceType agdaName hsName\n  inst    \u2190 declareDef (iArg instName) (tyView (instTel , instTy))\n  clauses \u2190 instanceClauses agdaName hsName\n  defineFun instName clauses\n  return _\n\n-- Macros providing an alternative interface. Usage\n--   iName : ConvertibleType AgdaTy HsTy\n--   iName = autoConvertible\n-- or\n--   iName = autoConvert AgdaTy\nmacro\n  ConvertibleType : Name \u2192 Name \u2192 Tactic\n  ConvertibleType agdaName hsName = initTac \u2983 defaultTCOptions \u2984 $\n    unifyWithGoal \u2218 tyView =&lt;&lt; instanceType agdaName hsName\n\n  autoConvertible : Tactic\n  autoConvertible = initTac \u2983 defaultTCOptions \u2984 $\n    unifyWithGoal =&lt;&lt; patternLambda\n\n  autoConvert : Name \u2192 Tactic\n  autoConvert d hole = do\n    hsTyMeta \u2190 R.newMeta `Set\n    R.checkType hole $ quote Convertible \u2219\u27e6 d \u2219 \u2223 hsTyMeta \u27e7\n    hsTy \u2190 solveHsType (d \u2219)\n    R.unify hsTyMeta hsTy\n    R.unify hole =&lt;&lt; doPatternLambda hole\n</pre>"},{"location":"Foreign.Convertible.DerivingTest.html","title":"DerivingTest","text":"<pre>\nmodule Foreign.Convertible.DerivingTest where\n\nopen import Level\nopen import Meta.Prelude\nopen import Meta.Init\n\nimport Data.List as L\nimport Data.List.NonEmpty as NE\nimport Data.String as S\nimport Data.Product as P\n\nopen import Relation.Nullary\nopen import Relation.Nullary.Decidable\n\nopen import Reflection.Tactic\nopen import Reflection.AST.Term\nopen import Reflection.AST.DeBruijn\nimport Reflection.TCM as R\nopen import Reflection.Utils\nopen import Reflection.Utils.TCI\nimport Function.Identity.Effectful as Identity\n\nopen import Class.DecEq\nopen import Class.DecEq\nopen import Class.Functor\nopen import Class.Monad\nopen import Class.MonadTC.Instances\nopen import Class.Traversable\nopen import Class.Show\nopen import Class.MonadReader\n\nopen import Foreign.Convertible\nopen import Foreign.Convertible.Deriving\n\n-- Tests\n\nopen import Data.Maybe.Base\nopen import Data.Sum.Base\n\ndata HsMaybe (a : Set) : Set where\n  just    : (x : a) \u2192 HsMaybe a\n  nothing : HsMaybe a\n\ndata HsEither (a b : Set) : Set where\n  left : a \u2192 HsEither a b\n  right : b \u2192 HsEither a b\n\n-- We should be able to generate this\nConvertibleMaybe : \u2200 {a a'} \u2192 \u2983 Convertible a a' \u2984 \u2192 Convertible (Maybe a) (HsMaybe a')\nConvertibleMaybe .to (just x)   = just (to x)\nConvertibleMaybe .to nothing    = nothing\nConvertibleMaybe .from (just x) = just (from x)\nConvertibleMaybe .from nothing  = nothing\n\n-- With deriveConvertible\nunquoteDecl iConvertMaybe  = deriveConvertible iConvertMaybe (quote Maybe) (quote HsMaybe)\n\n-- or with ConvertibleType and autoConvertible\ninstance\n  iConvertEither : ConvertibleType _\u228e_ HsEither\n  iConvertEither = autoConvertible\n\ninstance\n  ConvertibleNat = Convertible-Refl {\u2115}\n\ntest : \u2115 \u228e Maybe \u2115 \u2192 HsEither \u2115 (HsMaybe \u2115)\ntest = to\n\n_ : test (inj\u2082 (just 5)) \u2261 right (just 5)\n_ = refl\n\n-- There was a problem due to Agda#7182 with record types in parameterised modules.\n\nmodule Param (A : Set) where\n  record AgdaThing : Set where\n    field theThing : A\n\nrecord HsThing : Set where\n  field theThing : \u2115\n\nopen Param \u2115\nunquoteDecl iConvertThing = deriveConvertible iConvertThing (quote AgdaThing) (quote HsThing)\n\nconvThing : Convertible AgdaThing HsThing\nconvThing = autoConvertible\n</pre>"},{"location":"Foreign.Convertible.html","title":"Convertible","text":"<pre>module Foreign.Convertible where\n\nopen import Ledger.Prelude\nopen import Foreign.HaskellTypes\n\nrecord Convertible (A B : Type) : Type where\n  field to   : A \u2192 B\n        from : B \u2192 A\nopen Convertible \u2983...\u2984 public\n\nHsConvertible : (A : Set) \u2192 \u2983 HasHsType A \u2984 \u2192 Set\nHsConvertible A = Convertible A (HsType A)\n\nConvertible-Refl : \u2200 {A} \u2192 Convertible A A\nConvertible-Refl = \u03bb where .to \u2192 id; .from \u2192 id\n\nConvertible\u2081 : (Type \u2192 Type) \u2192 (Type \u2192 Type) \u2192 Type\u2081\nConvertible\u2081 T U = \u2200 {A B} \u2192 \u2983 Convertible A B \u2984 \u2192 Convertible (T A) (U B)\n\nConvertible\u2082 : (Type \u2192 Type \u2192 Type) \u2192 (Type \u2192 Type \u2192 Type) \u2192 Type\u2081\nConvertible\u2082 T U = \u2200 {A B} \u2192 \u2983 Convertible A B \u2984 \u2192 Convertible\u2081 (T A) (U B)\n\nFunctor\u21d2Convertible : \u2200 {F : Type\u2191} \u2192 \u2983 Functor F \u2984 \u2192 Convertible\u2081 F F\nFunctor\u21d2Convertible = \u03bb where\n  .to   \u2192 map to\n  .from \u2192 map from\n\nBifunctor\u21d2Convertible : \u2200 {F} \u2192 \u2983 Bifunctor F \u2984 \u2192 Convertible\u2082 F F\nBifunctor\u21d2Convertible = \u03bb where\n  .to   \u2192 bimap to to\n  .from \u2192 bimap from from\n\n_\u2a3e_ : \u2200 {A B C} \u2192 Convertible A B \u2192 Convertible B C \u2192 Convertible A C\n(c \u2a3e c') .to   = c' .to   \u2218 c  .to\n(c \u2a3e c') .from = c  .from \u2218 c' .from\n\n-- ** instances\n\nopen import Foreign.Haskell\nopen import Foreign.Haskell.Coerce using (coerce)\n\ninstance\n  Convertible-Maybe : Convertible\u2081 Maybe Maybe\n  Convertible-Maybe = Functor\u21d2Convertible\n\n  Convertible-\u00d7 : Convertible\u2082 _\u00d7_ _\u00d7_\n  Convertible-\u00d7 = Bifunctor\u21d2Convertible\n\n  Convertible-Pair : Convertible\u2082 _\u00d7_ Pair\n  Convertible-Pair = \u03bb where\n    .to   \u2192 coerce \u2218 bimap to to\n    .from \u2192 bimap from from \u2218 coerce\n\n  Convertible-\u228e : Convertible\u2082 _\u228e_ _\u228e_\n  Convertible-\u228e = Bifunctor\u21d2Convertible\n\n  Convertible-Either : Convertible\u2082 _\u228e_ Either\n  Convertible-Either = \u03bb where\n    .to   \u2192 coerce \u2218 bimap to to\n    .from \u2192 bimap from from \u2218 coerce\n\n  Convertible-FinSet : Convertible\u2081 \u2119_ List\n  Convertible-FinSet = \u03bb where\n    .to   \u2192 map to   \u2218 setToList\n    .from \u2192 fromList \u2218 map from\n\n  Convertible-Map : \u2200 {K K' V V'} \u2192 \u2983 DecEq K \u2984\n    \u2192 \u2983 Convertible K K' \u2984 \u2192 \u2983 Convertible V V' \u2984\n    \u2192 Convertible (K \u21c0 V) (List $ Pair K' V')\n  Convertible-Map = \u03bb where\n    .to   \u2192 to        \u2218 proj\u2081\n    .from \u2192 fromList\u1d50 \u2218 map from\n\n  Convertible-List : Convertible\u2081 List List\n  Convertible-List = \u03bb where\n    .to   \u2192 map to\n    .from \u2192 map from\n\n  Convertible-Fun : \u2200 {A A' B B'} \u2192 \u2983 Convertible A A' \u2984 \u2192 \u2983 Convertible B B' \u2984 \u2192 Convertible (A \u2192 B) (A' \u2192 B')\n  Convertible-Fun = \u03bb where\n    .to   \u2192 \u03bb f \u2192 to   \u2218 f \u2218 from\n    .from \u2192 \u03bb f \u2192 from \u2218 f \u2218 to\n</pre>"},{"location":"Foreign.HaskellTypes.Deriving.html","title":"Deriving","text":"<pre>\nmodule Foreign.HaskellTypes.Deriving where\n\nopen import Meta.Init hiding (TC; Monad-TC; MonadError-TC)\n\nopen import Level using (Level; 0\u2113)\nopen import Agda.Builtin.Reflection using (declareData; defineData; pragmaForeign; pragmaCompile;\n                                           solveInstanceConstraints)\nopen import Reflection as R hiding (showName; _&gt;&gt;=_; _&gt;&gt;_)\nopen import Reflection.AST hiding (showName)\nopen import Reflection.AST.DeBruijn\nopen import Data.Maybe using (Maybe; nothing; just; fromMaybe; maybe\u2032; _&lt;\u2223&gt;_)\nopen import Data.Unit using (\u22a4; tt)\nopen import Data.Integer.Base using (\u2124)\nopen import Data.Sum using (_\u228e_; inj\u2081; inj\u2082)\nopen import Data.String using (String) renaming (_++_ to _&amp;_)\nopen import Data.Product hiding (map; zip; zipWith)\nimport Data.String as String\nopen import Data.Bool\nopen import Data.Nat\nopen import Data.List hiding (lookup; fromMaybe)\nopen import Data.Char using (toUpper; toLower)\nopen import Foreign.Haskell\nopen import Function\nopen import Text.Printf\n\nopen import Class.DecEq\nopen import Class.Functor\nopen import Class.Monad\nopen import Class.MonadError\nopen import Class.MonadReader\nopen import Class.Show\nopen import Class.Show.Instances\nopen import Tactic.Derive.Show using (showName)\n\nopen import Reflection.Utils\nopen import Reflection.Utils.TCI\nopen import Foreign.HaskellTypes\nopen import Foreign.Haskell.Pair using (Pair)\n\n{-\nNeed to generate:\n  - a data type that can be compiled to a Haskell data type\n  - the corresponding Haskell type (in a FOREIGN pragma)\n  - the COMPILE pragma binding them together\n-}\n\nprivate variable\n  l : Level\n  A B : Set l\n\nprivate\n  mapHead : (A \u2192 A) \u2192 List A \u2192 List A\n  mapHead f []       = []\n  mapHead f (x \u2237 xs) = f x \u2237 xs\n\n  capitalize : String \u2192 String\n  capitalize = String.fromList \u2218 mapHead toUpper \u2218 String.toList\n\n  uncapitalize : String \u2192 String\n  uncapitalize = String.fromList \u2218 mapHead toLower \u2218 String.toList\n\n  joinStrings : String \u2192 List String \u2192 String\n  joinStrings sep ss = foldr _&amp;_ \"\" $ intersperse sep ss\n\n  _\u203c_ : List A \u2192 \u2115 \u2192 Maybe A\n  []       \u203c i     = nothing\n  (x \u2237 xs) \u203c zero  = just x\n  (x \u2237 xs) \u203c suc i = xs \u203c i\n\n  lookup : \u2983 DecEq A \u2984 \u2192 A \u2192 List (A \u00d7 B) \u2192 Maybe B\n  lookup x xs = proj\u2082 &lt;$&gt; find\u1d47 ((x ==_) \u2218 proj\u2081) xs\n\n-- * Controlling the names of the generated types\n\nrecord Env : Set where\n  field\n    customNames : List (Name \u00d7 String)\n    tName       : Name \u2192 Maybe String\n    cName       : Name \u2192 Maybe String\n    fName       : Name \u2192 Maybe String\n    typeclassDeriving : List String \u2192 List String\n\nprivate\n  lookupEnv : (Env \u2192 Name \u2192 Maybe String) \u2192 Env \u2192 Name \u2192 Maybe String\n  lookupEnv fn env x = lookup x (Env.customNames env) &lt;\u2223&gt; fn env x\n\n  lookupTypeName  = lookupEnv Env.tName\n  lookupConName   = lookupEnv Env.cName\n  lookupFieldName = lookupEnv Env.fName\n\n  emptyEnv : Env\n  emptyEnv = record{ customNames = []\n                   ; tName = const nothing\n                   ; cName = const nothing\n                   ; fName = const nothing\n                   ; typeclassDeriving = id }\n\n  customName : Name \u2192 String \u2192 Env\n  customName x s = record emptyEnv { customNames = (x , s) \u2237 [] }\n\nonTypes : (String \u2192 String) \u2192 Env\nonTypes f = record emptyEnv { tName = just \u2218 f \u2218 showName }\n\nonConstructors : (String \u2192 String) \u2192 Env\nonConstructors f = record emptyEnv { cName = just \u2218 f \u2218 showName }\n\nwithName : String \u2192 Env\nwithName t = onTypes (const t)\n\n-- Only use for single constructor types obviously\nwithConstructor : String \u2192 Env\nwithConstructor c = onConstructors (const c)\n\nonFields : (String \u2192 String) \u2192 Env\nonFields f = record emptyEnv { fName = just \u2218 f \u2218 showName }\n\n\nfieldPrefix : String \u2192 Env\nfieldPrefix pre = onFields $ (pre String.++_) \u2218 capitalize\n\nderiving : List String \u2192 Env\nderiving xs = record emptyEnv { typeclassDeriving = const xs }\n\nwithDefaultDeriving : Env\nwithDefaultDeriving = deriving (\"Show\" \u2237 \"Eq\" \u2237 \"Generic\" \u2237 [])\n\ninfixr 5 _\u2022_\n_\u2022_ : Env \u2192 Env \u2192 Env\nenv \u2022 env\u2081 = record\n  { customNames = env.customNames ++ env\u2081.customNames\n  ; tName       = \u03bb x \u2192 env.tName x &lt;\u2223&gt; env\u2081.tName x\n  ; cName       = \u03bb x \u2192 env.cName x &lt;\u2223&gt; env\u2081.cName x\n  ; fName       = \u03bb x \u2192 env.fName x &lt;\u2223&gt; env\u2081.fName x\n  ; typeclassDeriving = env\u2081.typeclassDeriving \u2218 env.typeclassDeriving\n  }\n  where\n    module env  = Env env\n    module env\u2081 = Env env\u2081\n\n\n-- * The inner workings\n\nsolveHsType : Term \u2192 TC Term\nsolveHsType tm = do\n  hsTy \u2190 checkType (quote HsType \u2219\u27e6 tm \u27e7) `Set\n  solveInstanceConstraints\n  normalise hsTy &gt;&gt;= \u03bb where\n    (def (quote HsType) _) \u2192 typeErrorFmt \"Failed to solve HsType %t\" tm\n    hsTy                   \u2192 return hsTy\n\nprivate\n  debug = debugPrintFmt \"tactic.hs-types\"\n\n  specialHsTypes : List (Name \u00d7 String)\n  specialHsTypes = (quote \u22a4      , \"()\")\n                 \u2237 (quote \u2115      , \"Integer\")\n                 \u2237 (quote \u2124      , \"Integer\")\n                 \u2237 (quote Bool   , \"Bool\")\n                 \u2237 (quote List   , \"[]\")\n                 \u2237 (quote Pair   , \"(,)\")\n                 \u2237 (quote Maybe  , \"Maybe\")\n                 \u2237 (quote Either , \"Either\")\n                 \u2237 (quote String , \"Data.Text.Text\")\n                 \u2237 []\n\n  hsTypeName : Env \u2192 Name \u2192 String\n  hsTypeName env d = fromMaybe (capitalize $ showName d) (lookupTypeName env d)\n\n  freshHsTypeName : Env \u2192 Name \u2192 TC Name\n  freshHsTypeName env d = freshName (hsTypeName env d)\n\n  hsConName : Env \u2192 Name \u2192 String\n  hsConName env c = fromMaybe (capitalize $ showName c) (lookupConName env c)\n\n  hsFieldName : Env \u2192 Name \u2192 String\n  hsFieldName env f = fromMaybe (uncapitalize $ showName f) (lookupFieldName env f)\n\n  freshHsConName : Env \u2192 Name \u2192 Name \u2192 TC Name\n  freshHsConName env tyName c =\n    if showName c == \"constructor\"\n    then freshName (hsConName env tyName) -- Unnamed record constructor: use type name\n    else freshName (hsConName env c)\n\n  isThis : Name \u2192 Term \u2192 Bool\n  isThis f (def g _) = f == g\n  isThis _ _ = false\n\n  computeHsType : Name \u2192 Name \u2192 Term \u2192 TC Term\n  computeHsType aThis hThis tm with isThis aThis tm\n  ... | true = pure (hThis \u2219)\n  computeHsType aThis hThis (\u03a0[ x \u2236 arg (arg-info visible _) a ] b) | false = do\n    dom \u2190 computeHsType aThis hThis a\n    rng \u2190 extendContext x (vArg a) $ computeHsType aThis hThis b\n    pure (v\u03a0[ x \u2236 dom ] rng)\n  computeHsType aThis hThis (\u03a0[ x \u2236 a ] b) | false = do\n    ty \u2190 extendContext x a $ computeHsType aThis hThis b\n    just ty\u2032 \u2190 pure (strengthen ty)\n      where nothing \u2192 extendContext x a $ typeErrorFmt \"%s free in computed HsType %t\" x ty\n    pure ty\u2032\n  -- Hack to get recursive occurrences under lists to work\n  computeHsType aThis hThis (def (quote List) (_ \u2237 vArg a \u2237 [])) | false = do\n    ty \u2190 computeHsType aThis hThis a\n    pure (quote List \u2219\u27e6 ty \u27e7)\n  computeHsType _ _ tm | false = do\n    debug 10 \"solving HsType %t\" tm\n    ty \u2190 solveHsType tm\n    debug 10 \"HsType %t = %t\" tm ty\n    pure ty\n\n  makeHsCon : Env \u2192 Name \u2192 Name \u2192 Name \u2192 TC (Name \u00d7 Agda.Builtin.Reflection.Quantity \u00d7 Type)\n  makeHsCon env agdaName hsName c = do\n    debug 10 \"Making constructor %q : %q\" c agdaName\n    def agdaName' _ \u2190 normalise (def agdaName [])\n      where _ \u2192 typeErrorFmt \"Failed to compute source type for %q\" agdaName\n    hsC  \u2190 freshHsConName env hsName c\n    cTy  \u2190 getType c\n    debug 10 \"cTy = %t\" cTy\n    hsTy \u2190 computeHsType agdaName' hsName cTy\n    debug 10 \"hsTy = %t\" hsTy\n    pure (hsC , quantity-\u03c9 , hsTy)\n\n  makeHsData : Env \u2192 Name \u2192 \u2115 \u2192 List Name \u2192 TC Name\n  makeHsData env agdaName nPars constrs = do\n    hsName \u2190 freshHsTypeName env agdaName\n    declareData hsName 0 `Set\n    hsCons \u2190 mapM (makeHsCon env agdaName hsName) constrs\n    defineData hsName hsCons\n    pure hsName\n\n  makeHsType : Env \u2192 Name \u2192 TC Name\n  makeHsType env d = getDefinition d &gt;&gt;= \u03bb where\n      (data-type pars cs) \u2192 makeHsData env d pars cs\n      (record-type c fs)  \u2192 makeHsData env d 0 (c \u2237 [])\n      _                   \u2192 typeErrorFmt \"%q is not a data or record type\" d\n\n  compilePragma : Name \u2192 List Name \u2192 String\n  compilePragma d cs = printf \"= data %s (%s)\" (showName d) (joinStrings \" | \" (map showName cs))\n\n  renderHsTypeName : Name \u2192 String\n  renderHsTypeName d = fromMaybe (\"MAlonzo.Code.\" String.++ R.showName d) (lookup d specialHsTypes)\n\n  renderHsType : Term \u2192 String\n  renderHsArgs : List (Arg Term) \u2192 List String\n\n  renderHsType (def (quote List) (_ \u2237 vArg a \u2237 [])) = printf \"[%s]\" (renderHsType a)\n  renderHsType (def (quote Pair) (_ \u2237 _ \u2237 vArg a \u2237 vArg b \u2237 [])) = printf \"(%s, %s)\" (renderHsType a) (renderHsType b)\n  renderHsType (def d []) = renderHsTypeName d\n  renderHsType (def d vs) = printf \"(%s %s)\" (renderHsTypeName d) (joinStrings \" \" (renderHsArgs vs))\n  renderHsType t = printf \"(TODO: renderHsType %s)\" (show t)\n\n  renderHsArgs [] = []\n  renderHsArgs (vArg a \u2237 as) = renderHsType a \u2237 renderHsArgs as\n  renderHsArgs (_ \u2237 as) = renderHsArgs as\n\n  renderTypeclassDeriving : List String \u2192 String\n  renderTypeclassDeriving [] = \"\"\n  renderTypeclassDeriving xs = printf \"deriving (%s)\" (joinStrings \", \" xs)\n\n  foreignPragma : Env \u2192 Name \u2192 List Name \u2192 TC String\n  foreignPragma env d cs = do\n    cons \u2190 forM cs \u03bb c \u2192 do\n            tel , _ \u2190 viewTy &lt;$&gt; getType c\n            let args = map unAbs tel\n            pure $ printf \"%s %s\" (showName c) (joinStrings \" \" $ renderHsArgs args)\n    pure $ printf \"data %s = %s\\n  %s\"\n                  (showName d) (joinStrings \" | \" cons) (renderTypeclassDeriving (Env.typeclassDeriving env []))\n\n  -- Record types\n  foreignPragmaRec : Env \u2192 Name \u2192 List Name \u2192 List Name \u2192 TC String\n  foreignPragmaRec _ d [] _ = typeErrorFmt \"impossible: %q is a record type with no constructors\" d\n  foreignPragmaRec env d (c \u2237 _) fs = do\n    tel , _ \u2190 viewTy &lt;$&gt; withNormalisation true (getType c)\n    let fNames = map (hsFieldName env) fs\n    let args = map unAbs tel\n        renderField f ty = printf \"%s :: %s\" f (renderHsType $ unArg ty)\n        con = printf \"%s {%s}\" (showName c) (joinStrings \", \" $ zipWith renderField fNames args)\n    pure $ printf \"data %s = %s\\n %s\"\n                  (showName d) con (renderTypeclassDeriving (Env.typeclassDeriving env []))\n\n  hsImports : String\n  hsImports = \"import GHC.Generics (Generic)\"\n\n  -- Take the name of a simple data type and generate the COMPILE and\n  -- FOREIGN pragmas to bind to Haskell.\n  bindHsType : Env \u2192 Name \u2192 Name \u2192 TC \u22a4\n  bindHsType env agdaName hsName = getDefinition hsName &gt;&gt;= \u03bb where\n    (data-type pars cs) \u2192 do\n      pragmaForeign \"GHC\" hsImports\n      pragmaCompile \"GHC\" hsName $ compilePragma hsName cs\n      getDefinition agdaName &gt;&gt;= \u03bb where\n        (data-type _ _)    \u2192 pragmaForeign \"GHC\" =&lt;&lt; foreignPragma env hsName cs\n        (record-type _ fs) \u2192 pragmaForeign \"GHC\" =&lt;&lt; foreignPragmaRec env hsName cs (map unArg fs)\n        _ \u2192 typeErrorFmt \"%q is not a data or record type\" agdaName\n    _ \u2192 typeErrorFmt \"%q is not a data type (impossible)\" hsName\n\n  computeProjections : \u2115 \u2192 Name \u2192 TC (List Term)\n  computeProjections npars c = do\n    argTys , _ \u2190 viewTy &lt;$&gt; getType c\n    let is  = downFrom (length argTys)\n        tel = map (\u03bb where (abs x ty) \u2192 x , ty) argTys\n        lhs = vArg (con c (map (\u03bb where (i , abs x (arg info _)) \u2192 arg info (var i))\n                               (drop npars (zip is argTys)))) \u2237 []\n    return $ map (\u03bb i \u2192 pat-lam (clause tel lhs (var i []) \u2237 []) []) (drop npars is)\n\n  makeTypeAlias : Name \u2192 Env \u2192 Term \u2192 TC \u22a4\n  makeTypeAlias agdaName env hole = do\n    hsTy \u2190 solveHsType (def agdaName [])\n    pragmaForeign \"GHC\" $ printf \"type %s = %s\" (hsTypeName env agdaName) (renderHsType hsTy)\n    unify hole (quote return \u2219\u27e6 con (quote tt) [] \u27e7)\n\n-- * Exported macros\n\ndoAutoHsType : Env \u2192 Name \u2192 Term \u2192 TC Term\ndoAutoHsType env d hole = do\n  checkType hole (quote HasHsType \u2219\u27e6 d \u2219 \u27e7)\n  hs \u2190 makeHsType env d\n  debug 50 \"  HsType %q = %q\" d hs\n  bindHsType env d hs\n  unify hole (`\u03bb\u27e6 proj (quote HasHsType.HsType) \u21d2 hs \u2219 \u27e7)\n  pure (hs \u2219)\n\nmacro\n  autoHsType : Name \u2192 Term \u2192 TC \u22a4\n  autoHsType d hole = _ &lt;$ doAutoHsType withDefaultDeriving d hole\n\n  infix 0 autoHsType_\u22a3_\n  autoHsType_\u22a3_ : Name \u2192 Env \u2192 Term \u2192 TC \u22a4\n  autoHsType_\u22a3_ d env hole = _ &lt;$ doAutoHsType (withDefaultDeriving \u2022 env) d hole\n\n  infix 9 _\u21a6_\n  _\u21a6_ : Name \u2192 String \u2192 Term \u2192 TC \u22a4\n  x \u21a6 s = unify (quote customName \u2219\u27e6 lit (name x) \u2223 lit (string s) \u27e7)\n\n  -- Generate a Haskell type synonym for the HsType of the given type\n  -- Usage `unquoteDecl = do hsTypeSynonym Foo; hsTypeSynonym Bar`\n  hsTypeAlias : Name \u2192 Term \u2192 TC \u22a4\n  hsTypeAlias agdaName = makeTypeAlias agdaName emptyEnv\n\n  -- The only Env that's useful here is `withName`.\n  hsTypeAlias_\u22a3_ : Name \u2192 Env \u2192 Term \u2192 TC \u22a4\n  hsTypeAlias agdaName \u22a3 env = makeTypeAlias agdaName env\n\n  -- * Macros for constructing and deconstructing generated types\n\n  hsCon : Term \u2192 \u2115 \u2192 Term \u2192 TC \u22a4\n  hsCon agdaTy i hole = do\n    hsTy@(def hsName _) \u2190 solveHsType agdaTy\n      where _ \u2192 typeErrorFmt \"Failed to compute HsType of %t\" agdaTy\n    cs \u2190 getDefinition hsName &gt;&gt;= \u03bb where\n      (data-type _ cs)  \u2192 return cs\n      _ \u2192 typeErrorFmt \"Expected HsType %t to be a data type, but got %t\" agdaTy hsTy\n    c \u2190 maybe\u2032 return  (typeErrorFmt \"%q has only %u constructors\" hsName (length cs)) (cs \u203c i)\n    unify hole (con c [])\n\n  hsProj : Term \u2192 \u2115 \u2192 Term \u2192 TC \u22a4\n  hsProj agdaTy i hole = do\n    hsTy@(def hsName _) \u2190 solveHsType agdaTy\n      where _ \u2192 typeErrorFmt \"Failed to compute HsType of %t\" agdaTy\n    prjs \u2190 getDefinition hsName &gt;&gt;= \u03bb where\n      (data-type npars (c \u2237 [])) \u2192 computeProjections npars c\n      _ \u2192 typeErrorFmt \"Expected HsType %t to be a single constructor data type, but got %t\" agdaTy hsTy\n    prj \u2190 maybe\u2032 return (typeErrorFmt \"%q has only %u fields\" hsName (length prjs)) (prjs \u203c i)\n    target \u2190 newMeta `Set\n    checkType hole (pi (vArg hsTy) (abs \"_\" target))\n    unify hole prj\n\n  hsTyName : Term \u2192 Term \u2192 TC \u22a4\n  hsTyName agdaTy hole = do\n    hsTy@(def hsName _) \u2190 solveHsType agdaTy\n      where _ \u2192 typeErrorFmt \"Failed to compute HsType of %t\" agdaTy\n    unify hole (lit (name hsName))\n</pre>"},{"location":"Foreign.HaskellTypes.html","title":"HaskellTypes","text":"<pre>\nmodule Foreign.HaskellTypes where\n\nopen import Level using (Level)\nopen import Data.Bool.Base using (Bool)\nopen import Data.Nat.Base using (\u2115)\nopen import Data.String.Base using (String)\nopen import Data.List.Base using (List)\nopen import Data.Maybe.Base using (Maybe)\nopen import Data.Sum.Base using (_\u228e_)\nopen import Data.Product.Base using (_\u00d7_)\nopen import Data.Unit using (\u22a4)\n\nopen import Foreign.Haskell.Pair using (Pair)\nopen import Foreign.Haskell.Either using (Either)\n\nprivate variable\n  l : Level\n  A B : Set l\n\nrecord HasHsType (A : Set l) : Set\u2081 where\n  field\n    HsType : Set\n\nHsType : (A : Set l) \u2192 \u2983 HasHsType A \u2984 \u2192 Set\nHsType _ \u2983 i \u2984 = i .HasHsType.HsType\n\nMkHsType : (A : Set l) (Hs : Set) \u2192 HasHsType A\nMkHsType A Hs .HasHsType.HsType = Hs\n\ninstance\n\n  iHsTy-\u2115      = MkHsType \u2115 \u2115\n  iHsTy-Bool   = MkHsType Bool Bool\n  iHsTy-\u22a4      = MkHsType \u22a4 \u22a4\n  iHsTy-String = MkHsType String String\n\n  -- Could make a macro for these kind of congruence instances.\n  iHsTy-List : \u2983 HasHsType A \u2984 \u2192 HasHsType (List A)\n  iHsTy-List {A = A} .HasHsType.HsType = List (HsType A)\n\n  iHsTy-Maybe : \u2983 HasHsType A \u2984 \u2192 HasHsType (Maybe A)\n  iHsTy-Maybe {A = A} .HasHsType.HsType = Maybe (HsType A)\n\n  iHsTy-Fun : \u2983 HasHsType A \u2984 \u2192 \u2983 HasHsType B \u2984 \u2192 HasHsType (A \u2192 B)\n  iHsTy-Fun {A = A} {B = B} .HasHsType.HsType = HsType A \u2192 HsType B\n\n  iHsTy-Sum : \u2983 HasHsType A \u2984 \u2192 \u2983 HasHsType B \u2984 \u2192 HasHsType (A \u228e B)\n  iHsTy-Sum {A = A} {B = B} .HasHsType.HsType = Either (HsType A) (HsType B)\n\n  iHsTy-Pair : \u2983 HasHsType A \u2984 \u2192 \u2983 HasHsType B \u2984 \u2192 HasHsType (A \u00d7 B)\n  iHsTy-Pair {A = A} {B = B} .HasHsType.HsType = Pair (HsType A) (HsType B)\n</pre>"},{"location":"Interface.ComputationalRelation.html","title":"Computational Relations for Trace Semantics","text":"<p>This module provides a generic computational interface for relations of the form <code>C \u2192 S \u2192 B \u2192 S \u2192 Type</code> where</p> <ul> <li><code>C</code> is an environment,</li> <li><code>S</code> is the state type,</li> <li><code>B</code> is the signal type (e.g., a single signal,    <code>Sig</code>, or a trace, <code>List Sig</code>).</li> </ul> <p>The interface supplies</p> <ol> <li> <p>a result type <code>ComputationResult</code> and its Functor/Applicative/Monad instances;</p> </li> <li> <p>a <code>Computational</code> record that captures an executable interpreter     (<code>compute</code>/<code>computeProof</code>) and a correctness     equivalence relating the interpreter to the relational specification;</p> </li> <li> <p>derived properties (right\u2011uniqueness, a decidability principle under     <code>DecEq S</code>, and an extensionality lemma for two implementations), and</p> </li> <li> <p>instances that lift a small\u2011step computational specification to our     trace runners from <code>Interface.STS</code>:</p> <ul> <li><code>RunTraceAndThen</code> for lists of signals,</li> <li><code>RunTraceAfterAndThen</code> for a one\u2011off init step then a trace, then a final step.</li> </ul> </li> </ol> <p>The intent is that once we define a <code>Computational</code> instance for the single step relation (and, in the second case, the init and final steps), we automatically obtain computational instances for the trace semantics.</p> <pre>{-# OPTIONS --safe #-}\n\nmodule Interface.ComputationalRelation where\n\nopen import Prelude\nopen import Interface.STS public\n\nprivate variable\n  a : Level\n  C S Sig : Type\n  Err Err\u2081 Err\u2082 : Type\n  c : C\n  s s' s'' : S\n  sig : Sig\n</pre> More Details <p>Big Picture.</p> <ul> <li> <p><code>STS</code> <code>\u0393</code> <code>s</code> <code>b</code> <code>s'</code>    is a specification; it's a logical relation that says,    \"Under environment <code>\u0393</code>, states <code>s</code> and <code>s'</code>    are related via <code>b</code>.\"  By itself this is not executable; it's just a    type (proposition) that may or may not be inhabited (by a proof).</p> </li> <li> <p><code>Computational</code> <code>STS</code> <code>Err</code>    is the executable counterpart; it packages a program (<code>compute</code>) that attempts    to produce the next state, together with facts that connect that program back to    the spec (<code>STS</code>).    Think: spec + interpreter + proof the interpreter is correct.</p> </li> <li> <p><code>ComputationResult</code> <code>Err</code> <code>R</code>    = <code>success</code> <code>R</code> <code>|</code> <code>failure</code> <code>Err</code> is just a    \"Maybe-with-error\" wrapper.  We use it as the return type of    <code>compute</code> and <code>computeProof</code> so we can represent    either \"I found a next state\" or \"this step is impossible/failed and here's why.\"</p> </li> </ul> <p>What each field really means.</p> <ol> <li> <p>Functor, Applicative, Monad of <code>ComputationResult</code></p> <p>These are small but very useful conveniences.</p> <ul> <li>Functor lets us map a pure function over a successful result without   touching failures.  In our code, we use it to define:</li> </ul> <p><code>compute</code> <code>\u0393</code> <code>s</code> <code>b</code>   = <code>map proj\u2081</code> (<code>computeProof</code> <code>\u0393</code> <code>s</code> <code>b</code>)</p> <p>Here, <code>computeProof</code> gives</p> <p><code>success</code> (<code>s'</code> , <code>proof</code>) or</p> <p><code>failure</code> <code>e</code>.</p> <p>Mapping <code>proj\u2081</code> turns that into   <code>success</code> <code>s'</code>   or keeps the same <code>failure</code> <code>e</code>.   Without this functor, we'd have to pattern-match every time.</p> <ul> <li> <p>Applicative lets us combine independent computations. We're not leaning on    this much here, but it's standard to provide it with a functor and monad.</p> </li> <li> <p>Monad lets us sequence computations where later steps depend on earlier    results.  This is the key when we run a trace: do a step, if it succeeds get the    new state, then continue on the rest of the list; if it fails, stop with that    failure.  Our <code>computeProof</code> for <code>RunTraceAndThen</code>    essentially implements a monadic fold (left-to-right) by pattern matching; having    a monad means we can express and reason about that sequencing uniformly, without    awkward error/exception handling.</p> </li> </ul> <p>So these instances are not cases of \"category theory for its own sake;\" they let us write and prove things about the interpreter more cleanly.</p> <ul> <li><code>map proj\u2081</code> keeps proofs around when we need them, but derives a state-only    function when we don't.</li> <li>Monadic sequencing matches the structure of trace execution.</li> </ul> </li> <li> <p>Executable Interpreter</p> <ul> <li><code>computeProof</code> : (<code>\u0393</code> <code>s</code> <code>b</code>)    <code>\u2192</code> <code>ComputationResult</code> <code>Err</code>    (<code>\u03a3</code> <code>s'</code> . <code>STS</code> <code>\u0393</code> <code>s</code> <code>b</code> <code>s'</code>)</li> </ul> <p>This is an interpreter that tries to run the spec and, if successful, returns both</p> <ol> <li>the output state <code>s'</code>, and</li> <li>a proof that        <code>STS</code> <code>\u0393</code> <code>s</code> <code>b</code> <code>s'</code> holds.</li> </ol> <p>If it can't run (the step is impossible for those inputs), it returns    <code>failure</code> <code>e</code>.</p> <p>Think: a function that either says, \"I can't do this for reason <code>e</code>\",    or, \"I can do this and here's the state and a proof it's correct.\"</p> <ul> <li><code>compute</code> : (<code>\u0393</code> <code>s</code> <code>b</code>)    <code>\u2192</code> <code>ComputationResult</code> <code>Err</code> <code>S</code></li> </ul> <p>This is the plain executable version.  It throws away the proof and just returns   the state, via the functor mapping discussed above.  We use it when all we need is the   state for execution code paths; we keep <code>computeProof</code> when a proof is helpful   downstream.</p> </li> <li> <p>Correctness Equivalence</p> <p>We want our interpreter to exactly match the spec. There are two directions:</p> <ul> <li>Completeness (what we provide as a field)</li> </ul> <p>If the spec says <code>STS \u0393 s b s'</code>, then the interpreter must return that same state:</p> <p><code>completeness</code>    : <code>STS</code> <code>\u0393</code> <code>s</code> <code>b</code> <code>s'</code>    \u2192 <code>compute</code> <code>\u0393</code> <code>s</code> <code>b</code>    \u2261 <code>success</code> <code>s'</code></p> <p>This prevents two different outputs for the same input; the spec and the    interpreter are aligned at least in this direction. (It also implies functional    determinism of the relation, via a standard argument we will see below.)</p> <ul> <li>Soundness (the converse)</li> </ul> <p>If the interpreter returns <code>success</code> <code>s'</code><code>, then</code>STS<code>{.AgdaBound}</code>\u0393<code>{.AgdaBound}</code>s<code>{.AgdaBound}</code>b<code>{.AgdaBound}</code>s'`{.AgdaBound} must hold.</p> <p>We derive this from <code>computeProof</code> because    <code>computeProof</code> returns not only the state, <code>s'</code>, but also    the proof, <code>proofOfSTS</code>. From that, we build</p> <p><code>compute</code> <code>\u0393</code> <code>s</code> <code>b</code> <code>\u2261</code> <code>success</code> <code>s'</code><code></code>\u21d4<code></code>STS<code>{.AgdaBound}</code>\u0393<code>{.AgdaBound}</code>s<code>{.AgdaBound}</code>b<code>{.AgdaBound}</code>s'`{.AgdaBound}</p> <p>in our code as <code>\u2261-success\u21d4STS</code>, by combining    <code>completeness</code> (the \u2192 direction) with the witness from    <code>computeProof</code> (the \u2190 direction).</p> <p>Intuition. The function and the relation say the exact same thing. One is executable, one is declarative; the equivalence ties them together.</p> </li> </ol> <p>How this plays out for traces.</p> <p>Given a <code>Computational</code> instance for the step relation <code>Step</code> : <code>C</code> \u2192 <code>S</code> \u2192 <code>Sig</code> \u2192 <code>S</code> \u2192 <code>Type</code>, the instances for:</p> <ul> <li><code>RunTraceAndThen</code> <code>Step</code> <code>Last</code></li> <li><code>RunTraceAfterAndThen</code> <code>Init</code> <code>Step</code> <code>Last</code></li> <li><code>RunIndexedTrace</code> <code>Step\u1d62</code></li> </ul> <p>are all just folds.</p> <ul> <li> <p>If the list is empty: succeed (via a initial step).</p> </li> <li> <p>If the list is <code>sig \u2237 sigs</code>, run one step</p> </li> </ul> <p><code>computeProof</code> <code>\u0393</code> <code>s</code> <code>sig</code></p> <ul> <li>if failure \u2192 whole run fails</li> <li> <p>if success <code>(s\u2081 , step-proof)</code> \u2192 recurse on <code>sigs</code> from <code>s\u2081</code>, and then stitch       the proofs with the corresponding constructor (e.g., <code>run-\u2237</code>).</p> </li> <li> <p>Completeness for traces is a structural induction using the single-step    completeness and the induction hypothesis.</p> </li> </ul> <p>Toy Example</p> <p>Suppose <code>S = \u2115</code>, <code>Sig = Bool</code>, and the spec says:</p> <p>if <code>sig = true</code>, increment the state, otherwise leave it alone:</p> <p><code>Step \u0393 s sig s'  \u225c  (sig \u2261 true \u00d7 s' \u2261 suc s) \u228e (sig \u2261 false \u00d7 s' \u2261 s)</code></p> <p>A <code>Computational Step Err</code> could implement:</p> <p><code>compute</code> <code>\u0393</code> <code>s</code> <code>true</code> = <code>success</code>  (suc s)`</p> <p><code>compute</code> <code>\u0393</code> <code>s</code> <code>false</code> = <code>success</code> <code>s</code></p> <p>and <code>computeProof</code> returns (<code>s'</code>, <code>proof</code>) with the obvious proof term.</p> <p>Then <code>Computational-RunTraceAndThen</code> just runs that function over the list of booleans; its completeness proof is the standard list induction: head step complete by <code>completeness</code> for <code>Step</code>, tail by inductive hypothesis.</p>"},{"location":"Interface.ComputationalRelation.html#a-computation-result-type","title":"A Computation Result Type","text":"<pre>data ComputationResult {a : Level} (Err : Type) (R : Type a) : Type a where\n  success : R   \u2192 ComputationResult Err R\n  failure : Err \u2192 ComputationResult Err R\n\nisFailure : \u2200 {A : Type a} \u2192 ComputationResult Err A \u2192 Type a\nisFailure x = \u2203[ e ] x \u2261 failure e\n\nmodule _ {a b} {E : Type} {A : Type a} {B : Type b} where\n  caseCR_\u2223_\u2223_ : (ma : ComputationResult E A) \u2192 (\u2200 {a} \u2192 ma \u2261 success a \u2192 B) \u2192 (isFailure ma \u2192 B) \u2192 B\n  caseCR ma \u2223 f \u2223 g with ma\n  ... | success _ = f refl\n  ... | failure e = g (e , refl)\n\n  caseCR-success : \u2200 {a} {ma : ComputationResult E A} {f : \u2200 {a} \u2192 ma \u2261 success a \u2192 B} {g : isFailure ma \u2192 B}\n    \u2192 (eq : ma \u2261 success a)\n    \u2192 caseCR ma \u2223 f \u2223 g \u2261 f eq\n  caseCR-success refl = refl\n\n  caseCR-failure : {ma : ComputationResult E A} {f : \u2200 {a} \u2192 ma \u2261 success a \u2192 B} {g : isFailure ma \u2192 B}\n    \u2192 (eq : isFailure ma)\n    \u2192 caseCR ma \u2223 f \u2223 g \u2261 g eq\n  caseCR-failure (_ , refl) = refl\n\ninstance\n  Bifunctor-ComputationResult : \u2200 {a : Level} \u2192 Bifunctor {_} {a} ComputationResult\n  Bifunctor-ComputationResult .bimap _ f (success x) = success $ f x\n  Bifunctor-ComputationResult .bimap f _ (failure x) = failure $ f x\n\n  Functor-ComputationResult : \u2200 {E : Type} \u2192 Functor (ComputationResult E)\n  Functor-ComputationResult ._&lt;$&gt;_ f (success x) = success $ f x\n  Functor-ComputationResult ._&lt;$&gt;_ _ (failure x) = failure x\n\n  Applicative-ComputationResult : \u2200 {E : Type} \u2192 Applicative (ComputationResult E)\n  Applicative-ComputationResult .pure = success\n  Applicative-ComputationResult ._&lt;*&gt;_ (success f) x = f &lt;$&gt; x\n  Applicative-ComputationResult ._&lt;*&gt;_ (failure e) _ = failure e\n\n  Monad-ComputationResult : \u2200 {E : Type} \u2192 Monad (ComputationResult E)\n  Monad-ComputationResult .return = success\n  Monad-ComputationResult ._&gt;&gt;=_ (success a) m = m a\n  Monad-ComputationResult ._&gt;&gt;=_ (failure e) _ = failure e\n\nmap-failure : \u2200 {A B C : Type} {f : A \u2192 B} {x : C} {ma} \u2192 ma \u2261 failure x \u2192 map f ma \u2261 failure x\nmap-failure refl = refl\n\nsuccess-maybe : \u2200 {R : Type} \u2192 ComputationResult Err R \u2192 Maybe R\nsuccess-maybe (success x) = just x\nsuccess-maybe (failure _) = nothing\n\nfailure-maybe : \u2200 {R : Type} \u2192 ComputationResult Err R \u2192 Maybe Err\nfailure-maybe (success _) = nothing\nfailure-maybe (failure x) = just x\n\n_\u2248\u1d9c\u02b3_ : \u2200 {A} \u2192 ComputationResult Err A \u2192 ComputationResult Err A \u2192 Type\nx \u2248\u1d9c\u02b3 y = success-maybe x \u2261 success-maybe y\n</pre>"},{"location":"Interface.ComputationalRelation.html#computational-interface","title":"Computational Interface","text":"<p>We parametrize the interface by a relation <code>STS : C \u2192 S \u2192 B \u2192 S \u2192 Type</code>. The record provides both an executable <code>compute</code> and a two\u2011way equivalence between <code>compute</code> returning <code>success s'</code> and the relational judgment.</p> <pre>module _ (STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type) where\n\n  ExtendedRel : C \u2192 S \u2192 Sig \u2192 ComputationResult Err S \u2192 Type\n  ExtendedRel c s sig (success s') = STS c s sig s'\n  ExtendedRel c s sig (failure _ ) = \u2200 s' \u2192 \u00ac STS c s sig s'\n\n  record Computational Err : Type\u2081 where\n    constructor MkComputational\n    field\n      computeProof : (c : C) (s : S) (sig : Sig) \u2192 ComputationResult Err (\u2203[ s' ] STS c s sig s')\n\n    compute : C \u2192 S \u2192 Sig \u2192 ComputationResult Err S\n    compute c s sig = map proj\u2081 $ computeProof c s sig\n\n    field\n      completeness : (c : C) (s : S) (sig : Sig) (s' : S)\n        \u2192 STS c s sig s' \u2192 compute c s sig \u2261 success s'\n\n    open \u2261-Reasoning\n\n    computeFail : C \u2192 S \u2192 Sig \u2192 Type\n    computeFail c s sig = isFailure $ compute c s sig\n\n    \u2261-success\u21d4STS : compute c s sig \u2261 success s' \u21d4 STS c s sig s'\n    \u2261-success\u21d4STS {c} {s} {sig} {s'} with computeProof c s sig in eq\n    ... | success (s'' , h) = mk\u21d4 (\u03bb where refl \u2192 h) \u03bb h' \u2192\n      begin success s''     \u2261\u02d8\u27e8 completeness _ _ _ _ h \u27e9\n            compute c s sig \u2261\u27e8 completeness _ _ _ _ h' \u27e9\n            success s'      \u220e\n    ... | failure y = mk\u21d4 (\u03bb ()) \u03bb h \u2192\n      begin failure _       \u2261\u02d8\u27e8 map-failure eq \u27e9\n            compute c s sig \u2261\u27e8 completeness _ _ _ _ h \u27e9\n            success s'      \u220e\n\n    failure\u21d2\u2200\u00acSTS : computeFail c s sig \u2192 \u2200 s' \u2192 \u00ac STS c s sig s'\n    failure\u21d2\u2200\u00acSTS comp\u2261nothing s' h rewrite \u2261-success\u21d4STS .Equivalence.from h =\n      case comp\u2261nothing of \u03bb ()\n\n    \u2200\u00acSTS\u21d2failure : (\u2200 s' \u2192 \u00ac STS c s sig s') \u2192 computeFail c s sig\n    \u2200\u00acSTS\u21d2failure {c = c} {s} {sig} \u00acsts with computeProof c s sig\n    ... | success (x , y) = \u22a5-elim (\u00acsts x y)\n    ... | failure y = (y , refl)\n\n    failure\u21d4\u2200\u00acSTS : computeFail c s sig \u21d4 \u2200 s' \u2192 \u00ac STS c s sig s'\n    failure\u21d4\u2200\u00acSTS = mk\u21d4 failure\u21d2\u2200\u00acSTS \u2200\u00acSTS\u21d2failure\n\n    recomputeProof : \u2200 {\u0393 s sig s'} \u2192 STS \u0393 s sig s' \u2192 ComputationResult Err (\u2203[ s'' ] STS \u0393 s sig s'')\n    recomputeProof _ = computeProof _ _ _\n</pre>"},{"location":"Interface.ComputationalRelation.html#consequences-of-the-interface","title":"Consequences of the Interface","text":"<p>From a <code>Computational STS Err</code>, we get:</p> <pre>module _ {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} (comp : Computational STS Err) where\n\n  open Computational comp\n\n  ExtendedRelSTS = ExtendedRel STS\n\n  ExtendedRel-compute : ExtendedRelSTS c s sig (compute c s sig)\n  ExtendedRel-compute {c} {s} {sig} with compute c s sig in eq\n  ... | success s' = Equivalence.to \u2261-success\u21d4STS eq\n  ... | failure _  = \u03bb s' h \u2192 case trans (sym $ Equivalence.from \u2261-success\u21d4STS h) eq of \u03bb ()\n\n  open \u2261-Reasoning\n\n  ExtendedRel-rightUnique : ExtendedRelSTS c s sig s' \u2192 ExtendedRelSTS c s sig s'' \u2192 _\u2248\u1d9c\u02b3_ {Err = Err} s' s''\n  ExtendedRel-rightUnique {s' = success x}  {success x'} h h'\n    with trans (sym $ Equivalence.from \u2261-success\u21d4STS h) (Equivalence.from \u2261-success\u21d4STS h')\n  ... | refl = refl\n\n  ExtendedRel-rightUnique {s' = success x} {failure _}  h h' = \u22a5-elim $ h' x h\n  ExtendedRel-rightUnique {s' = failure _} {success x'} h h' = \u22a5-elim $ h x' h'\n  ExtendedRel-rightUnique {s' = failure a} {failure b}  h h' = refl\n\n  computational\u21d2rightUnique : STS c s sig s' \u2192 STS c s sig s'' \u2192 s' \u2261 s''\n  computational\u21d2rightUnique h h' with ExtendedRel-rightUnique h h'\n  ... | refl = refl\n\n  Computational\u21d2Dec : \u2983 _ : DecEq S \u2984 \u2192 Dec (STS c s sig s')\n  Computational\u21d2Dec {c} {s} {sig} {s'}\n    with compute c s sig | ExtendedRel-compute {c} {s} {sig}\n  ... | failure _ | ExSTS = no (ExSTS s')\n  ... | success x  | ExSTS with x \u225f s'\n  ... | no \u00acp    = no  \u03bb h \u2192 \u00acp $ sym $ computational\u21d2rightUnique h ExSTS\n  ... | yes refl = yes ExSTS\n</pre> <p>Two computational instances for the same relation are extensionally equal on successful results.</p> <pre>module _ {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} (comp comp' : Computational STS Err) where\n\n  open Computational comp  renaming (compute to compute\u2081)\n  open Computational comp' renaming (compute to compute\u2082)\n\n  compute-ext\u2261 : compute\u2081 c s sig \u2248\u1d9c\u02b3 compute\u2082 c s sig\n  compute-ext\u2261 = ExtendedRel-rightUnique comp\n    (ExtendedRel-compute comp) (ExtendedRel-compute comp')\n\nopen Computational \u2983...\u2984\n\nComputational\u21d2Dec' :\n  {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2983 comp : Computational STS Err \u2984 \u2192 Dec (\u2203[ s' ] STS c s sig s')\nComputational\u21d2Dec' with computeProof _ _ _ in eq\n... | success x = yes x\n... | failure x = no \u03bb (_ , h) \u2192 failure\u21d2\u2200\u00acSTS (-, cong (map proj\u2081) eq) _ h\n</pre>"},{"location":"Interface.ComputationalRelation.html#error-injection-helper","title":"Error Injection Helper","text":"<p>When combining a base interpreter with a step interpreter, their error spaces may differ.  We provide a tiny class to inject either error into a common sum-like error used by the combined interpreter.</p> <pre>record InjectError Err\u2081 Err\u2082 : Type where\n  field injectError : Err\u2081 \u2192 Err\u2082\n\nopen InjectError\n\ninstance\n  InjectError-\u22a5 : InjectError \u22a5 Err\n  InjectError-\u22a5 = \u03bb where\n    .injectError ()\n\n  InjectError-Id : InjectError Err Err\n  InjectError-Id = \u03bb where\n    .injectError \u2192 id\n</pre>"},{"location":"Interface.ComputationalRelation.html#basic-instance-identity-relation","title":"Basic Instance: identity relation","text":"<p>For the identity relation <code>IdSTS</code> (from <code>Interface.STS</code>), computing always succeeds with the input state.</p> <pre>instance\n  Computational-Id : {C S : Type} \u2192 Computational (IdSTS {C} {S}) \u22a5\n  Computational-Id .computeProof _ s _ = success (s , Id-nop)\n  Computational-Id .completeness _ _ _ _ Id-nop = refl\n</pre>"},{"location":"Interface.ComputationalRelation.html#computational-instances-for-the-original-reflexive-transitive-closure-relations","title":"Computational Instances for the Original \"Reflexive Transitive Closure\" Relations","text":"<pre>module _ {BSTS : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} \u2983 _ : Computational BSTS Err\u2081 \u2984 where\n  module _ {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2983 _ : Computational STS Err\u2082 \u2984\n     \u2983 _ : InjectError Err\u2081 Err \u2984 \u2983 _ : InjectError Err\u2082 Err \u2984 where instance\n    Computational-ReflexiveTransitiveClosure\u1d47 : Computational (ReflexiveTransitiveClosure\u1d47 {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = BSTS}{STS}) (Err)\n    Computational-ReflexiveTransitiveClosure\u1d47 .computeProof c s [] = bimap (injectError it) (map\u2082\u2032 BS-base) (computeProof c s tt)\n    Computational-ReflexiveTransitiveClosure\u1d47 .computeProof c s (sig \u2237 sigs) with computeProof c s sig\n    ... | success (s\u2081 , h) with computeProof c s\u2081 sigs\n    ...   | success (s\u2082 , hs) = success (s\u2082 , BS-ind h hs)\n    ...   | failure a = failure (injectError it a)\n    Computational-ReflexiveTransitiveClosure\u1d47 .computeProof c s (sig \u2237 sigs) | failure a = failure (injectError it a)\n    Computational-ReflexiveTransitiveClosure\u1d47 .completeness c s [] s' (BS-base p)\n      with computeProof {STS = BSTS} c s tt | completeness _ _ _ _ p\n    ... | success x | refl = refl\n    Computational-ReflexiveTransitiveClosure\u1d47 .completeness c s (sig \u2237 sigs) s' (BS-ind h hs)\n      with computeProof c s sig | completeness _ _ _ _ h\n    ... | success (s\u2081 , _) | refl\n      with computeProof \u2983 Computational-ReflexiveTransitiveClosure\u1d47 \u2984 c s\u2081 sigs | completeness _ _ _ _ hs\n    ... | success (s\u2082 , _) | p = p\n\n  module _ {STS : C \u00d7 \u2115 \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2983 Computational-STS : Computational STS Err\u2082 \u2984\n    \u2983 InjectError-Err\u2081 : InjectError Err\u2081 Err \u2984 \u2983 InjectError-Err\u2082 : InjectError Err\u2082 Err \u2984\n    where instance\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' : Computational (_\u22a2_\u21c0\u27e6_\u27e7\u1d62*'_ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = BSTS}{STS}) Err\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .computeProof c s [] =\n      bimap (injectError it) (map\u2082\u2032 BS-base) (computeProof (proj\u2081 c) s tt)\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .computeProof c s (sig \u2237 sigs) with computeProof c s sig\n    ... | success (s\u2081 , h) with computeProof (proj\u2081 c , suc (proj\u2082 c)) s\u2081 sigs\n    ... | success (s\u2082 , hs) = success (s\u2082 , BS-ind h hs)\n    ... | failure a = failure a\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .computeProof c s (sig \u2237 sigs) | failure a = failure (injectError it a)\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .completeness c s [] s' (BS-base p)\n      with computeProof {STS = BSTS} (proj\u2081 c) s tt | completeness _ _ _ _ p\n    ... | success x | refl = refl\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .completeness c s (sig \u2237 sigs) s' (BS-ind h hs)\n      with computeProof {STS = STS} {Err = Err\u2082} c s sig | completeness _ _ _ _ h\n    ... | success (s\u2081 , _) | refl\n      with computeProof (proj\u2081 c , suc (proj\u2082 c)) s\u2081 sigs | completeness _ _ _ _ hs\n    ...   | success (s\u2082 , _) | p = p\n\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47 : Computational (ReflexiveTransitiveClosure\u1d62\u1d47 {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = BSTS}{STS}) Err\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47 .computeProof c =\n      Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .computeProof (c , 0)\n    Computational-ReflexiveTransitiveClosure\u1d62\u1d47 .completeness c =\n      Computational-ReflexiveTransitiveClosure\u1d62\u1d47' .completeness (c , 0)\n</pre>"},{"location":"Interface.ComputationalRelation.html#convenience-exports","title":"Convenience exports","text":"<p>For projects that still use the historical names, the following shims maintain compatibility with the new definitions in <code>Interface.STS</code>:</p> <pre>Computational-ReflexiveTransitiveClosure : {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2192 \u2983 Computational STS Err \u2984\n  \u2192 Computational (ReflexiveTransitiveClosure {sts = STS}) Err\nComputational-ReflexiveTransitiveClosure = it\n\nComputational-ReflexiveTransitiveClosure\u1d62 : {STS : C \u00d7 \u2115 \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2192 \u2983 Computational STS Err \u2984\n  \u2192 Computational (ReflexiveTransitiveClosure\u1d62 {sts = STS}) Err\nComputational-ReflexiveTransitiveClosure\u1d62 = it\n</pre>"},{"location":"Interface.ComputationalRelation.html#lifting-a-step-interpreter-to-traces","title":"Lifting a Step Interpreter to Traces","text":"<p>Given a <code>Computational</code> instance for a single-step relations <code>Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type</code> (and instances for <code>Init : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type</code> and <code>Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type</code>, as needed), we execute traces in two flavors.</p>"},{"location":"Interface.ComputationalRelation.html#1-trace-with-final-step-runtraceandthen","title":"1. Trace with Final Step: RunTraceAndThen","text":"<pre>module _ {Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2983 serr : Computational Step Err\u2081 \u2984 where\n  module _  {Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} \u2983 lerr : Computational Last Err\u2082 \u2984\n            \u2983 _ : InjectError Err\u2081 Err \u2984 \u2983 _ : InjectError Err\u2082 Err \u2984\n    where\n\n    instance\n\n      Computational-RunTraceAndThen : Computational (RunTraceAndThen Step Last) Err\n\n      Computational-RunTraceAndThen .computeProof \u0393 s []\n        with computeProof {STS = Last} \u0393 s tt\n      ... | failure e = failure (injectError it e)\n      ... | success (s' , h) = success (s' , run-[] h)\n\n\n      Computational-RunTraceAndThen .computeProof \u0393 s (sig \u2237 sigs)\n        with computeProof {STS = Step} \u0393 s sig\n      ... | failure e = failure (injectError it e)\n      ... | success (s\u2081 , h) with computeProof {STS = RunTraceAndThen Step Last} \u0393 s\u2081 sigs\n      ... | failure e = failure (injectError it e)\n      ... | success (s\u2082 , hs) = success (s\u2082 , run-\u2237 h hs)\n\n      Computational-RunTraceAndThen .completeness \u0393 s sigs s'' (run-[] x)\n        with computeProof {STS = Last} \u0393 s tt | completeness _ _ _ _ x\n      ... | success (s' , h) | refl = refl\n\n      Computational-RunTraceAndThen .completeness \u0393 s (sig \u2237 sigs) s'' (run-\u2237 x x\u2081)\n        with computeProof {STS = Step} \u0393 s sig | completeness _ _ _ _ x\n      ... | success (s\u2081 , _) | refl\n        with computeProof {STS = RunTraceAndThen Step Last} \u0393 s\u2081 sigs | completeness _ _ _ _ x\u2081\n      ... | success (s\u2082 , _) | p = p\n</pre>"},{"location":"Interface.ComputationalRelation.html#2-seeded-trace-with-final-step-runtraceafterandthen","title":"2. Seeded Trace with Final Step: RunTraceAfterAndThen","text":"<pre>module _ {Init : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} \u2983 _ : Computational Init Err\u2082 \u2984 where\n  module _ {Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2983 _ : Computational Step Err\u2081 \u2984 where\n    module _ {Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} \u2983 _ : Computational Last Err\u2082 \u2984\n             \u2983 _ : InjectError Err\u2081 Err \u2984 \u2983 _ : InjectError Err\u2082 Err \u2984 where\n\n      instance\n        Computational-RunTraceAfterAndThen : Computational (RunTraceAfterAndThen Init Step Last) Err\n\n        Computational-RunTraceAfterAndThen .computeProof \u0393 s sigs\n          with computeProof {STS = Init} \u0393 s tt\n        ... | failure e = failure (injectError it e)\n        ... | success (s' , h)\n              with computeProof {STS = RunTraceAndThen Step Last} {Err = Err} \u0393 s' sigs\n        ...   | failure e = failure (injectError it e)\n        ...   | success (t , r) = success (t , run (h , r))\n\n        Computational-RunTraceAfterAndThen .completeness \u0393 s sigs t (run (init , rtat))\n          with computeProof {STS = Init} \u0393 s tt | completeness _ _ _ _ init\n        ... | success (s' , h) | refl\n              with computeProof {STS = RunTraceAndThen Step Last} {Err = Err} \u0393 s' sigs\n              | completeness {Err = Err} _ _ _ _ rtat\n        ...   | success (t' , r) | refl = refl\n</pre>"},{"location":"Interface.STS.html","title":"State Transition System","text":"<p>This module introduces the abstract types we use to define a generic state transition system (STS) along with reusable trace runners (folds over lists of signals) and standard properties (totality and invariant preservation).</p> <pre>{-# OPTIONS --safe #-}\n\nmodule Interface.STS where\n\nopen import Prelude\nopen import Prelude.InferenceRules public\n\nprivate\n  variable C S Sig : Type\n           \u0393 : C\n           s s' s'' : S\n           sig : Sig\n           sigs : List Sig\n           n : \u2115\n</pre>"},{"location":"Interface.STS.html#a-note-on-recent-changes","title":"A Note on Recent Changes","text":"<p>We refactored the <code>STS</code> module to reflect what the code actually does\u2014it processes a list of signals, transforming state.</p> <ul> <li> <p>Clearer names</p> </li> <li> <p><code>RunTraceAndThen</code>: run a given transition (<code>Step</code>) on a list of signals and       then, once the list is empty, run a final transition (<code>Last</code>).</p> </li> <li><code>RunTraceAfterAndThen</code>: run a given transition (<code>Init</code>), then run a transition       (<code>Step</code>) for a each signal in a given list, then, once the list is empty, run a       final (<code>Last</code>) transition.</li> </ul>"},{"location":"Interface.STS.html#high-level-picture","title":"High-level picture","text":"<ul> <li>A trace is a list of signals <code>sigs : List Sig</code>.</li> <li>Let <code>Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type</code> be a step relation and <code>Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type</code> a relation.</li> <li><code>RunTraceAndThen Step Last \u0393 s sigs s'</code> means: starting in <code>s</code>, running <code>sigs</code>    (left-to-right) under environment <code>\u0393</code>, then perform <code>Last</code>, to yield <code>s'</code>.</li> </ul> <p>A variation that is sometimes useful involves indexed steps\u2014that is, it allows the step relation to depend on the position in the trace via an index <code>n : \u2115</code>.</p>"},{"location":"Interface.STS.html#state-transition-sytem-types","title":"State Transition Sytem Types","text":"<pre>data RunTraceAndThen (Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type) (Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type) :\n  C \u2192 S \u2192 List Sig \u2192 S \u2192 Type where\n\n    run-[] : Last \u0393 s tt s' \u2192 RunTraceAndThen Step Last \u0393 s [] s'\n\n    run-\u2237 :  Step \u0393 s sig s'\n             \u2192 RunTraceAndThen Step Last \u0393 s' sigs s''\n             \u2192 RunTraceAndThen Step Last \u0393 s (sig \u2237 sigs) s''\n\ndata RunTraceAfterAndThen (Init : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type)\n                          (Step : C \u2192 S \u2192 Sig \u2192 S \u2192 Type)\n                          (Last : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type) :\n  C \u2192 S \u2192 List Sig \u2192 S \u2192 Type where\n\n    run :\n        \u2219 Init \u0393 s tt s'\n        \u2219 RunTraceAndThen Step Last \u0393 s' sigs s''\n        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        RunTraceAfterAndThen Init Step Last \u0393 s sigs s''\n</pre>"},{"location":"Interface.STS.html#the-original-transition-relation-types","title":"The Original Transition Relation Types","text":"<p>The transition relations defined in this subsection are used in various places in the ledger formalization.</p> <pre>module _ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} {_\u22a2_\u21c0\u27e6_\u27e7_ : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} where\n  data _\u22a2_\u21c0\u27e6_\u27e7*_ : C \u2192 S \u2192 List Sig \u2192 S \u2192 Type where\n\n    BS-base :\n      \u0393 \u22a2 s \u21c0\u27e6 _ \u27e7\u1d47 s'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 s \u21c0\u27e6 [] \u27e7* s'\n\n    BS-ind :\n        \u0393 \u22a2 s  \u21c0\u27e6 sig  \u27e7  s'\n      \u2192 \u0393 \u22a2 s' \u21c0\u27e6 sigs \u27e7* s''\n        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        \u0393 \u22a2 s  \u21c0\u27e6 sig \u2237 sigs \u27e7* s''\n</pre>"},{"location":"Interface.STS.html#indexed-variant","title":"Indexed Variant","text":"<p>An indexed variant of the <code>_\u22a2_\u21c0\u27e6_\u27e7*_</code> type allows the step relation to depend on the position in the trace by threading an index through the environment. The index counts how many elements have already been consumed.</p> <pre>module _ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type} {_\u22a2_\u21c0\u27e6_\u27e7_ : C \u00d7 \u2115 \u2192 S \u2192 Sig \u2192 S \u2192 Type} where\n  data _\u22a2_\u21c0\u27e6_\u27e7\u1d62*'_ : C \u00d7 \u2115 \u2192 S \u2192 List Sig \u2192 S \u2192 Type where\n\n    BS-base :\n      \u0393 \u22a2 s \u21c0\u27e6 _ \u27e7\u1d47 s'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      (\u0393 , n) \u22a2 s \u21c0\u27e6 [] \u27e7\u1d62*' s'\n\n    BS-ind :\n        (\u0393 , n)     \u22a2 s  \u21c0\u27e6 sig  \u27e7  s'\n      \u2192 (\u0393 , suc n) \u22a2 s' \u21c0\u27e6 sigs \u27e7\u1d62*' s''\n        \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        (\u0393 , n)     \u22a2 s  \u21c0\u27e6 sig \u2237 sigs \u27e7\u1d62*' s''\n</pre> <p>The following defines a convenience wrapper that starts at index <code>0</code>.</p> <pre>  _\u22a2_\u21c0\u27e6_\u27e7\u1d62*_ : C \u2192 S \u2192 List Sig \u2192 S \u2192 Type\n  _\u22a2_\u21c0\u27e6_\u27e7\u1d62*_ \u0393 = _\u22a2_\u21c0\u27e6_\u27e7\u1d62*'_ (\u0393 , 0)\n</pre> <p>Other convenience wrappers are defined, as follows:</p> <pre>-- with a trivial base case\ndata IdSTS {C S} : C \u2192 S \u2192 \u22a4 \u2192 S \u2192 Type where\n  Id-nop : IdSTS \u0393 s _ s\n\nReflexiveTransitiveClosure : {sts : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2192 C \u2192 S \u2192 List Sig \u2192 S \u2192 Type\nReflexiveTransitiveClosure {sts = sts} = _\u22a2_\u21c0\u27e6_\u27e7*_ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = IdSTS}{sts}\n\nReflexiveTransitiveClosure\u1d62 : {sts : C \u00d7 \u2115 \u2192 S \u2192 Sig \u2192 S \u2192 Type} \u2192 C \u2192 S \u2192 List Sig \u2192 S \u2192 Type\nReflexiveTransitiveClosure\u1d62 {sts = sts} = _\u22a2_\u21c0\u27e6_\u27e7\u1d62*_ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = IdSTS}{sts}\n\nReflexiveTransitiveClosure\u1d62\u1d47 = _\u22a2_\u21c0\u27e6_\u27e7\u1d62*_\nReflexiveTransitiveClosure\u1d47 = _\u22a2_\u21c0\u27e6_\u27e7*_\n</pre>"},{"location":"Interface.STS.html#totality","title":"Totality","text":"<p>We say a single-step relation is total if every input has some output.</p> <pre>STS-total : (C \u2192 S \u2192 Sig \u2192 S \u2192 Type) \u2192 Type\nSTS-total _\u22a2_\u21c0\u27e6_\u27e7_ = \u2200 {\u0393 s sig} \u2192 \u2203[ s' ] \u0393 \u22a2 s \u21c0\u27e6 sig \u27e7 s'\n\nReflexiveTransitiveClosure-total : {_\u22a2_\u21c0\u27e6_\u27e7_ : C \u2192 S \u2192 Sig \u2192 S \u2192 Type}\n  \u2192 STS-total _\u22a2_\u21c0\u27e6_\u27e7_ \u2192 STS-total (ReflexiveTransitiveClosure {sts = _\u22a2_\u21c0\u27e6_\u27e7_})\nReflexiveTransitiveClosure-total SS-total {\u0393} {s} {[]} = s , BS-base Id-nop\nReflexiveTransitiveClosure-total SS-total {\u0393} {s} {x \u2237 sig} =\n  case SS-total of \u03bb where\n    (s' , Ps') \u2192 map\u2082\u2032 (BS-ind Ps') $ ReflexiveTransitiveClosure-total SS-total\n</pre>"},{"location":"Interface.STS.html#invariants","title":"Invariants","text":"<p>A predicate <code>P : S \u2192 Type</code> is an invariant of a step relation <code>STS</code> if it is preserved by every step.</p> <pre>LedgerInvariant : (C \u2192 S \u2192 Sig \u2192 S \u2192 Type) \u2192 (S \u2192 Type) \u2192 Type\nLedgerInvariant STS P = \u2200 {c s sig s'} \u2192 STS c s sig s' \u2192 P s \u2192 P s'\n\nRTC-preserves-inv : \u2200 {STS : C \u2192 S \u2192 Sig \u2192 S \u2192 Type} {P}\n                  \u2192 LedgerInvariant STS P \u2192 LedgerInvariant (ReflexiveTransitiveClosure {sts = STS}) P\nRTC-preserves-inv inv (BS-base Id-nop) = id\nRTC-preserves-inv inv (BS-ind p\u2081 p\u2082)   = RTC-preserves-inv inv p\u2082 \u2218 inv p\u2081\n</pre>"},{"location":"Interface.TypeClasses.HasSubset.html","title":"HasSubset","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Interface.TypeClasses.HasSubset where\n\nopen import Level using (Level; suc)\n</pre> <pre>record HasSubset {a} (A : Set a) : Set (suc a) where\n  field _\u2286_ : A \u2192 A \u2192 Set a\n  infix 4 _\u2286_\n</pre> <pre>open HasSubset \u2983...\u2984 public\n</pre>"},{"location":"Interface.TypeClasses.HasSubtract.Instances.html","title":"Instance","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Interface.TypeClasses.HasSubtract.Instances where\n\nopen import Interface.TypeClasses.HasSubtract\n\nopen import Data.Integer as \u2124 using (\u2124)\nopen import Data.Nat     as \u2115 using (\u2115)\n</pre> <pre>instance\n  HasSubtract-\u2115 : HasSubtract \u2115 \u2115\n  HasSubtract-\u2115 ._-_ = \u2115._\u2238_\n\n  HasSubtract-\u2124 : HasSubtract \u2124 \u2124\n  HasSubtract-\u2124 ._-_ = \u2124._-_\n\n  HasSubtract-\u2115-\u2124 : HasSubtract \u2115 \u2124\n  HasSubtract-\u2115-\u2124 ._-_ = \u2124._\u2296_\n</pre>"},{"location":"Interface.TypeClasses.HasSubtract.html","title":"HasSubtract","text":"<pre>{-# OPTIONS --safe --cubical-compatible #-}\nmodule Interface.TypeClasses.HasSubtract where\n\nopen import Agda.Primitive using () renaming (Set to Type)\n</pre> <pre>record HasSubtract (A B : Type) : Type where\n  infixl 6 _-_\n  field _-_ : A \u2192 A \u2192 B\n</pre> <p>&lt;!--</p> <pre>open HasSubtract \u2983 ... \u2984 public\n</pre>"},{"location":"Interface.TypeClasses.Hashable.html","title":"TypeClasses","text":"<pre>{-# OPTIONS --safe #-}\nmodule Interface.TypeClasses.Hashable where\n\nopen import Agda.Builtin.Equality\nopen import Agda.Primitive using () renaming (Set to Type)\n</pre> <pre>record Hashable (T THash : Type) : Type where\n  field hash    : T \u2192 THash\n</pre> <pre>open Hashable \u2983...\u2984 public\n</pre> <pre>Hashable\u2081 : (Type \u2192 Type) \u2192 Type \u2192 Type\u2081\nHashable\u2081 F THash = {A : Type} \u2192 \u2983 Hashable A THash \u2984 \u2192 Hashable (F A) THash\n\nHashable\u2082 : (Type \u2192 Type \u2192 Type) \u2192 Type \u2192 Type\u2081\nHashable\u2082 F THash = {A B : Type} \u2192 \u2983 Hashable A THash \u2984 \u2192 \u2983 Hashable B THash \u2984 \u2192 Hashable (F A B) THash\n</pre>"},{"location":"Ledger.Conway.Conformance.Certs.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Gov.Base using (GovStructure)\n\nmodule Ledger.Conway.Conformance.Certs.Properties (gs : _) (open GovStructure gs) where\n\nopen import Data.Maybe.Properties\nopen import Relation.Nullary.Decidable\n\nopen import Ledger.Conway.Specification.Certs.Properties.Computational gs\n  using (Computational-POOL)\nopen import Ledger.Conway.Specification.Gov.Actions gs hiding (yes; no)\nopen import Ledger.Conway.Conformance.Certs gs\n\nopen Computational \u2983...\u2984\n\nopen import stdlib-meta.Tactic.GenError using (genErrors)\n\nopen DCert ; open PState\nopen GovVote\n\nlookupDeposit :\n  (dep : DepositPurpose \u21c0 Coin) (c : DepositPurpose) \u2192\n  Dec (Any (\u03bb (c' , _) \u2192 c \u2261 c') (dep \u02e2))\nlookupDeposit dep c = any? (\u03bb { _ \u2192 \u00bf _ \u00bf }) (dep \u02e2)\n\ninstance\n  Computational-DELEG : Computational _\u22a2_\u21c0\u2987_,DELEG\u2988_ String\n  Computational-DELEG .computeProof de ds =\n    let open DelegEnv de; open DState ds in\n    \u03bb where\n    (delegate c mv mc d) \u2192 case \u00bf (c \u2209 dom rewards \u2192 d \u2261 pparams .PParams.keyDeposit)\n                                \u00d7 (c \u2208 dom rewards \u2192 d \u2261 0)\n                                \u00d7 mv \u2208 map\u02e2 (just \u2218 vDelegCredential) delegatees \u222a\n                                    fromList ( nothing \u2237 just vDelegAbstain \u2237 just vDelegNoConfidence \u2237 [] )\n                                \u00d7 mc \u2208 map\u02e2 just (dom (DelegEnv.pools de)) \u222a \u2774 nothing \u2775 \u00bf of \u03bb where\n      (yes p) \u2192 success (-, DELEG-delegate p )\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    (dereg c md) \u2192 case lookupDeposit deposits (CredentialDeposit c) of \u03bb where\n      (yes ((k , d) , _)) \u2192\n        case\n          \u00bf (c , 0) \u2208 rewards\n          \u00d7 (CredentialDeposit c , d) \u2208 deposits\n          \u00d7 (md \u2261 nothing \u228e md \u2261 just d)\n          \u00bf of \u03bb where\n            (yes q) \u2192 success (-, DELEG-dereg q)\n            (no \u00acq) \u2192 failure (genErrors \u00acq)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    (reg c d) \u2192 case \u00bf c \u2209 dom rewards \u00d7 (d \u2261 pparams .PParams.keyDeposit \u228e d \u2261 0) \u00bf of \u03bb where\n      (yes p) \u2192 success (-, DELEG-reg p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    _ \u2192 failure \"Unexpected certificate in DELEG\"\n\n  Computational-DELEG .completeness de ds (delegate c mv mc d)\n    s' (DELEG-delegate p) rewrite dec-yes (\u00bf (c \u2209 dom (DState.rewards ds) \u2192 d \u2261 DelegEnv.pparams de .PParams.keyDeposit)\n                                           \u00d7 (c \u2208 dom (DState.rewards ds) \u2192 d \u2261 0)\n                                           \u00d7 mv \u2208 map\u02e2 (just \u2218 vDelegCredential) (DelegEnv.delegatees de) \u222a\n                                               fromList ( nothing \u2237 just vDelegAbstain \u2237 just vDelegNoConfidence \u2237 [] )\n                                           \u00d7 mc \u2208 map\u02e2 just (dom (DelegEnv.pools de)) \u222a \u2774 nothing \u2775 \u00bf) p .proj\u2082 = refl\n  Computational-DELEG .completeness _ ds (dereg c nothing) _ (DELEG-dereg h@(p , q , r))\n    with lookupDeposit (DState.deposits ds) (CredentialDeposit c)\n  ... | (yes ((_ , d') , s\u2082 , refl)) rewrite dec-yes\n          (\u00bf (c , 0) \u2208 (DState.rewards ds)\n           \u00d7 (CredentialDeposit c , d') \u2208 (DState.deposits ds)\n           \u00d7 (nothing \u2261 nothing {A = \u2115} \u228e nothing \u2261 just d')\n           \u00bf) (p , s\u2082 , inj\u2081 refl) .proj\u2082 = refl\n  Computational-DELEG .completeness _ ds (dereg c nothing) _ (DELEG-dereg h@(p , q , r))\n      | (no \u00acs) = \u22a5-elim (\u00acs (_ , q , refl))\n  Computational-DELEG .completeness _ ds (dereg c (just d)) _ (DELEG-dereg h@(p , q , inj\u2082 refl))\n    with lookupDeposit (DState.deposits ds) (CredentialDeposit c)\n  ... | (yes ((_ , d') , q' , refl)) rewrite dec-yes\n          (\u00bf (c , 0) \u2208 (DState.rewards ds)\n           \u00d7 (CredentialDeposit c , d') \u2208 (DState.deposits ds)\n           \u00d7 (just d \u2261 nothing {A = \u2115} \u228e just d \u2261 just d')\n           \u00bf) (p , q' , inj\u2082 (cong just (proj\u2082 (DState.deposits ds) q q'))) .proj\u2082 = refl\n  ... | (no \u00acs) = \u22a5-elim (\u00acs (_ , q , refl))\n  Computational-DELEG .completeness de ds (reg c d) _ (DELEG-reg p)\n    rewrite dec-yes (\u00bf c \u2209 dom (DState.rewards ds) \u00d7 (d \u2261 DelegEnv.pparams de .PParams.keyDeposit \u228e d \u2261 0) \u00bf) p .proj\u2082 = refl\n\n  Computational-GOVCERT : Computational _\u22a2_\u21c0\u2987_,GOVCERT\u2988_ String\n  Computational-GOVCERT .computeProof ce gs (regdrep c d _) =\n    let open CertEnv ce; open GState gs; open PParams pp in\n    case \u00bf (d \u2261 drepDeposit \u00d7 c \u2209 dom dreps)\n         \u228e (d \u2261 0 \u00d7 c \u2208 dom dreps) \u00bf of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-regdrep p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof ce gs (deregdrep c d) =\n    case \u00bf c \u2208 dom (GState.dreps gs) \u00d7 (DRepDeposit c , d) \u2208  (GState.deposits gs) \u00bf of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-deregdrep p)\n      (no \u00acp)  \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof ce gs (ccreghot c _) =\n    let open CertEnv ce; open GState gs in\n    case \u00bf ((c , nothing) \u2209 ccHotKeys \u02e2) \u00d7 c \u2208 coldCreds \u00bf of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-ccreghot p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof _ _ _ = failure \"Unexpected certificate in GOVCERT\"\n  Computational-GOVCERT .completeness ce gs\n    (regdrep c d _) _ (GOVCERT-regdrep p)\n    rewrite dec-yes\n      \u00bf (let open CertEnv ce; open PParams pp in\n        (d \u2261 drepDeposit \u00d7 c \u2209 dom (GState.dreps gs)) \u228e (d \u2261 0 \u00d7 c \u2208 dom (GState.dreps gs)))\n      \u00bf p .proj\u2082 = refl\n  Computational-GOVCERT .completeness _ gs\n    (deregdrep c d) _ (GOVCERT-deregdrep p)\n    rewrite dec-yes \u00bf c \u2208 dom (GState.dreps gs) \u00d7 (DRepDeposit c , d) \u2208 (GState.deposits gs) \u00bf p .proj\u2082 = refl\n  Computational-GOVCERT .completeness ce gs\n    (ccreghot c _) _ (GOVCERT-ccreghot p)\n    rewrite dec-yes (\u00bf (((c , nothing) \u2209 (GState.ccHotKeys gs) \u02e2) \u00d7 c \u2208 CertEnv.coldCreds ce) \u00bf) p .proj\u2082 = refl\n\n  Computational-CERT : Computational _\u22a2_\u21c0\u2987_,CERT\u2988_ String\n  Computational-CERT .computeProof ce cs dCert\n    with computeProof $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#4070}{\\htmlId{5869}{\\htmlClass{Field}{\\text{CertEnv.pp}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#5833}{\\htmlId{5880}{\\htmlClass{Bound}{\\text{ce}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{5885}{\\htmlClass{Field}{\\text{PState.pools}}}}\\, \\,\\htmlId{5898}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1128}{\\htmlId{5899}{\\htmlClass{Field}{\\text{CertState.pState}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#5836}{\\htmlId{5916}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{5918}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{5922}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{5926}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#936}{\\htmlId{5927}{\\htmlClass{Field}{\\text{GState.dreps}}}}\\, \\,\\htmlId{5940}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1148}{\\htmlId{5941}{\\htmlClass{Field}{\\text{CertState.gState}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#5836}{\\htmlId{5958}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{5960}{\\htmlClass{Symbol}{\\text{))}}}\\, \\end{pmatrix}$\n                      (CertState.dState cs) dCert\n         | computeProof (CertEnv.pp ce) (CertState.pState cs) dCert\n         | computeProof ce (CertState.gState cs) dCert\n  ... | success (_ , h) | _               | _               = success (-, CERT-deleg h)\n  ... | failure _       | success (_ , h) | _               = success (-, CERT-pool h)\n  ... | failure _       | failure _       | success (_ , h) = success (-, CERT-vdel h)\n  ... | failure e\u2081      | failure e\u2082      | failure e\u2083      = failure $\n    \"DELEG: \" &lt;&gt; e\u2081 &lt;&gt; \"\\nPOOL: \" &lt;&gt; e\u2082 &lt;&gt; \"\\nVDEL: \" &lt;&gt; e\u2083\n  Computational-CERT .completeness ce cs\n    dCert@(delegate c mv mc d) cs' (CERT-deleg h)\n    with computeProof $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#4070}{\\htmlId{6647}{\\htmlClass{Field}{\\text{CertEnv.pp}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#6567}{\\htmlId{6658}{\\htmlClass{Bound}{\\text{ce}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{6663}{\\htmlClass{Field}{\\text{PState.pools}}}}\\, \\,\\htmlId{6676}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1128}{\\htmlId{6677}{\\htmlClass{Field}{\\text{CertState.pState}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#6570}{\\htmlId{6694}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{6696}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{6700}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{6704}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#936}{\\htmlId{6705}{\\htmlClass{Field}{\\text{GState.dreps}}}}\\, \\,\\htmlId{6718}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1148}{\\htmlId{6719}{\\htmlClass{Field}{\\text{CertState.gState}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#6570}{\\htmlId{6736}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{6738}{\\htmlClass{Symbol}{\\text{))}}}\\, \\end{pmatrix}$\n                      (CertState.dState cs) dCert\n         | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(reg c d) cs' (CERT-deleg h)\n    with computeProof $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#4070}{\\htmlId{6963}{\\htmlClass{Field}{\\text{CertEnv.pp}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#6894}{\\htmlId{6974}{\\htmlClass{Bound}{\\text{ce}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{6979}{\\htmlClass{Field}{\\text{PState.pools}}}}\\, \\,\\htmlId{6992}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1128}{\\htmlId{6993}{\\htmlClass{Field}{\\text{CertState.pState}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#6897}{\\htmlId{7010}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{7012}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{7016}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{7020}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#936}{\\htmlId{7021}{\\htmlClass{Field}{\\text{GState.dreps}}}}\\, \\,\\htmlId{7034}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1148}{\\htmlId{7035}{\\htmlClass{Field}{\\text{CertState.gState}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#6897}{\\htmlId{7052}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{7054}{\\htmlClass{Symbol}{\\text{))}}}\\, \\end{pmatrix}$\n                      (CertState.dState cs) dCert\n         | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(dereg c _) cs' (CERT-deleg h)\n    with computeProof $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#4070}{\\htmlId{7281}{\\htmlClass{Field}{\\text{CertEnv.pp}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#7210}{\\htmlId{7292}{\\htmlClass{Bound}{\\text{ce}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{7297}{\\htmlClass{Field}{\\text{PState.pools}}}}\\, \\,\\htmlId{7310}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1128}{\\htmlId{7311}{\\htmlClass{Field}{\\text{CertState.pState}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#7213}{\\htmlId{7328}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{7330}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{7334}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{7338}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#936}{\\htmlId{7339}{\\htmlClass{Field}{\\text{GState.dreps}}}}\\, \\,\\htmlId{7352}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1148}{\\htmlId{7353}{\\htmlClass{Field}{\\text{CertState.gState}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#7213}{\\htmlId{7370}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{7372}{\\htmlClass{Symbol}{\\text{))}}}\\, \\end{pmatrix}$\n                      (CertState.dState cs) dCert\n         | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(regpool c poolParams) cs' (CERT-pool h)\n    with completeness _ _ _ _ h\n  ... | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(retirepool c e) cs' (CERT-pool h)\n    with completeness _ _ _ _ h\n  ... | refl = refl\n  Computational-CERT .completeness \u0393 cs\n    dCert@(regdrep c d an)\n    cs' (CERT-vdel h)\n    with computeProof \u0393 (CertState.gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness \u0393 cs\n    dCert@(deregdrep c _) cs' (CERT-vdel h)\n    with computeProof \u0393 (CertState.gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness \u0393 cs\n    dCert@(ccreghot c mkh) cs' (CERT-vdel h)\n    with computeProof \u0393 (CertState.gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n\n\n  Computational-PRE-CERT : Computational _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ String\n  Computational-PRE-CERT .computeProof ce cs _ =\n    let open CertEnv ce; open PParams pp\n        open GState (CertState.gState cs); open DState (CertState.dState cs)\n        refresh = mapPartial (isGovVoterDRep \u2218 voter) (fromList votes)\n        refreshedDReps  = mapValueRestricted (const (CertEnv.epoch ce + drepActivity)) dreps refresh\n    in case \u00bf filter\u02e2 isKeyHash (map\u02e2 RwdAddr.stake (dom wdrls)) \u2286 dom voteDelegs\n              \u00d7 map\u02e2 (map\u2081 RwdAddr.stake) (wdrls \u02e2) \u2286 rewards \u02e2 \u00bf of \u03bb where\n      (yes p) \u2192 success (-, CERT-pre p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-PRE-CERT .completeness ce st _ st' (CERT-pre p)\n    rewrite let dState = CertState.dState st; open DState dState in\n      dec-yes \u00bf filter\u02e2 isKeyHash (map\u02e2 RwdAddr.stake (dom (CertEnv.wdrls ce))) \u2286 dom voteDelegs\n                \u00d7 map\u02e2 (map\u2081 RwdAddr.stake) (CertEnv.wdrls ce \u02e2) \u2286 rewards \u02e2 \u00bf\n        p .proj\u2082 = refl\n\n  -- POST-CERT has no premises, so computing always succeeds\n  -- with the unique post-state and proof CERT-post.\n  Computational-POST-CERT : Computational _\u22a2_\u21c0\u2987_,POST-CERT\u2988_ String\n  Computational-POST-CERT .computeProof ce cs tt = success ( cs' , CERT-post)\n    where\n      dreps : DReps\n      dreps = GState.dreps (CertState.gState cs)\n      validVoteDelegs : VoteDelegs\n      validVoteDelegs = (DState.voteDelegs (CertState.dState cs)) \u2223^ ( map\u02e2 vDelegCredential (dom dreps) \u222a fromList (vDelegNoConfidence \u2237 vDelegAbstain \u2237 []) )\n      cs' : CertState\n      cs' = $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#9683}{\\htmlId{9910}{\\htmlClass{Function}{\\text{validVoteDelegs}}}}\\, \\\\ \\,\\htmlId{9928}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{9932}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#1128}{\\htmlId{9938}{\\htmlClass{Field}{\\text{CertState.pState}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#9563}{\\htmlId{9955}{\\htmlClass{Bound}{\\text{cs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#1148}{\\htmlId{9960}{\\htmlClass{Field}{\\text{CertState.gState}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.Properties.html#9563}{\\htmlId{9977}{\\htmlClass{Bound}{\\text{cs}}}}\\, \\end{pmatrix}$\n\n  -- Completeness: the relational proof pins s' to exactly `post`,\n  -- and computeProof returns success at that same state; so refl.\n  Computational-POST-CERT .completeness ce cs _ cs' CERT-post = refl\n\n\nComputational-CERTS : Computational _\u22a2_\u21c0\u2987_,CERTS\u2988_ String\nComputational-CERTS = it\n</pre>"},{"location":"Ledger.Conway.Conformance.Certs.html","title":"Certs","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Gov.Base\nimport Ledger.Conway.Specification.Certs\n\nmodule Ledger.Conway.Conformance.Certs\n  (gs : _) (open GovStructure gs)\n  where\n\n\nopen import Ledger.Conway.Specification.Gov.Actions gs\nprivate module Certs = Ledger.Conway.Specification.Certs gs\nopen Certs public\n  hiding (DState; GState; CertState; HasCast-DState; HasCast-GState; HasCast-CertState;\n          _\u22a2_\u21c0\u2987_,DELEG\u2988_; _\u22a2_\u21c0\u2987_,GOVCERT\u2988_;\n          _\u22a2_\u21c0\u2987_,CERT\u2988_; _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_; _\u22a2_\u21c0\u2987_,POST-CERT\u2988_; _\u22a2_\u21c0\u2987_,CERTS\u2988_; \u27e6_,_,_\u27e7\u1d48)\nopen RwdAddr\n\nrecord DState : Type where\n  constructor \u27e6_,_,_,_\u27e7\u1d48\n  field\n    voteDelegs   : VoteDelegs\n    stakeDelegs  : Credential \u21c0 KeyHash\n    rewards      : Rewards\n    deposits     : Deposits\n\nrecord GState : Type where\n  constructor \u27e6_,_,_\u27e7\u1d5b\n  field\n    dreps      : Credential \u21c0 Epoch\n    ccHotKeys  : Credential \u21c0 Maybe Credential\n    deposits   : Deposits\n\nrecord CertState : Type where\n  constructor \u27e6_,_,_\u27e7\u1d9c\u02e2\n  field\n    dState : DState\n    pState : PState\n    gState : GState\n\ninstance\n  unquoteDecl HasCast-DState HasCast-GState HasCast-CertState = derive-HasCast\n    (   (quote DState , HasCast-DState)\n    \u2237   (quote GState , HasCast-GState)\n    \u2237 [ (quote CertState , HasCast-CertState) ])\n\ncertDeposit : DCert \u2192 PParams \u2192 Deposits\ncertDeposit (delegate c _ _ v) _   = \u2774 CredentialDeposit c , v \u2775\ncertDeposit (regdrep c v _)    _   = \u2774 DRepDeposit c , v \u2775\ncertDeposit (reg c v)          pp  = \u2774 CredentialDeposit c , pp .PParams.keyDeposit \u2775\ncertDeposit _                  _   = \u2205\n-- handled in the Utxo module:\n-- certDeposit (regpool kh _)     pp  = \u2774 PoolDeposit kh , pp .poolDeposit \u2775\n\ncertRefund : DCert \u2192 \u2119 DepositPurpose\ncertRefund (dereg c _)      = \u2774 CredentialDeposit c \u2775\ncertRefund (deregdrep c _)  = \u2774 DRepDeposit c \u2775\ncertRefund _                = \u2205\n\nupdateCertDeposit  : PParams \u2192 DCert \u2192 Deposits \u2192 Deposits\nupdateCertDeposit pp (delegate c _ _ v) deposits = deposits \u222a\u207a \u2774 CredentialDeposit c , v \u2775\nupdateCertDeposit pp (reg c _)          deposits = deposits \u222a\u207a \u2774 CredentialDeposit c , pp .PParams.keyDeposit \u2775\nupdateCertDeposit pp (regdrep c v _)    deposits = deposits \u222a\u207a \u2774 DRepDeposit c , v \u2775\nupdateCertDeposit pp (dereg c _)        deposits = deposits \u2223 \u2774 CredentialDeposit c \u2775 \u1d9c\nupdateCertDeposit pp (deregdrep c _)    deposits = deposits \u2223 \u2774 DRepDeposit c \u2775 \u1d9c\nupdateCertDeposit pp (regpool kh _)     deposits = deposits \u222a\u207a \u2774 PoolDeposit kh , pp .PParams.poolDeposit \u2775\nupdateCertDeposit _ (retirepool _ _)    deposits = deposits\nupdateCertDeposit _ (ccreghot _ _)      deposits = deposits\n-- updateCertDeposit pp cert deposits\n--   = (deposits \u222a\u207a certDeposit cert pp) \u2223 certRefund cert \u1d9c\n\nprivate variable\n  rwds rewards           : Rewards\n  dReps                  : Credential \u21c0 Epoch\n  sDelegs stakeDelegs    : Credential \u21c0 KeyHash\n  ccKeys ccHotKeys       : Credential \u21c0 Maybe Credential\n  vDelegs voteDelegs     : VoteDelegs\n  pools fPools           : Pools\n  retiring               : KeyHash \u21c0 Epoch\n  wdrls                  : Withdrawals\n\n  an             : Anchor\n  \u0393              : CertEnv\n  d              : Coin\n  md             : Maybe Coin\n  c              : Credential\n  mc             : Maybe Credential\n  delegatees cc  : \u2119 Credential\n  dCert          : DCert\n  dep ddep gdep  : Deposits\n  e              : Epoch\n  vs             : List GovVote\n  kh             : KeyHash\n  mkh            : Maybe KeyHash\n  poolParams     : StakePoolParams\n  pp             : PParams\n  mv             : Maybe VDeleg\n\n  st\u1d48 st\u1d48' : DState\n  st\u1d4d st\u1d4d' : GState\n  st\u1d56 st\u1d56' : PState\n\nopen GovVote\n\ndata _\u22a2_\u21c0\u2987_,DELEG\u2988_ : DelegEnv \u2192 DState \u2192 DCert \u2192 DState \u2192 Type\n\ndata _\u22a2_\u21c0\u2987_,DELEG\u2988_ where\n  DELEG-delegate : let open PParams pp in\n    \u2219 (c \u2209 dom rwds \u2192 d \u2261 keyDeposit)\n    \u2219 (c \u2208 dom rwds \u2192 d \u2261 0)\n    \u2219 mv \u2208 map\u02e2 (just \u2218 vDelegCredential) delegatees \u222a\n        fromList\n          ( nothing\n          \u2237 just vDelegAbstain\n          \u2237 just vDelegNoConfidence\n          \u2237 []\n          )\n    \u2219 mkh \u2208 map\u02e2 just (dom pools) \u222a \u2774 nothing \u2775\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{4183}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3043}{\\htmlId{4188}{\\htmlClass{Generalizable}{\\text{pools}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3332}{\\htmlId{4196}{\\htmlClass{Generalizable}{\\text{delegatees}}}}\\, \\end{pmatrix}$ \u22a2\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3005}{\\htmlId{4219}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2900}{\\htmlId{4229}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2819}{\\htmlId{4239}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{4246}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$\n      \u21c0\u2987 delegate c mv mkh d ,DELEG\u2988\n      $\\begin{pmatrix} \\,\\href{Axiom.Set.Map.html#9260}{\\htmlId{4297}{\\htmlClass{Function}{\\text{insertIfJust}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{4310}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3596}{\\htmlId{4312}{\\htmlClass{Generalizable}{\\text{mv}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3005}{\\htmlId{4315}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\\\ \\,\\href{Axiom.Set.Map.html#9260}{\\htmlId{4325}{\\htmlClass{Function}{\\text{insertIfJust}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{4338}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3501}{\\htmlId{4340}{\\htmlClass{Generalizable}{\\text{mkh}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#2900}{\\htmlId{4344}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2819}{\\htmlId{4354}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{4359}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{4362}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{4364}{\\htmlClass{Generalizable}{\\text{c}}}}\\, , \\,\\htmlId{4368}{\\htmlClass{Number}{\\text{0}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{4370}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\,\n      \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#1955}{\\htmlId{4380}{\\htmlClass{Function}{\\text{updateCertDeposit}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{4398}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\,\\htmlId{4401}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#2476}{\\htmlId{4402}{\\htmlClass{InductiveConstructor}{\\text{delegate}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{4411}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3596}{\\htmlId{4413}{\\htmlClass{Generalizable}{\\text{mv}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3501}{\\htmlId{4416}{\\htmlClass{Generalizable}{\\text{mkh}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3212}{\\htmlId{4420}{\\htmlClass{Generalizable}{\\text{d}}}}\\,\\,\\htmlId{4421}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{4423}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$\n\n  DELEG-dereg :\n    \u2219 (c , 0) \u2208 rwds\n    \u2219 (CredentialDeposit c , d) \u2208 dep\n    \u2219 md \u2261 nothing \u228e md \u2261 just d\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{4585}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3043}{\\htmlId{4590}{\\htmlClass{Generalizable}{\\text{pools}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3332}{\\htmlId{4598}{\\htmlClass{Generalizable}{\\text{delegatees}}}}\\, \\end{pmatrix}$ \u22a2\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3005}{\\htmlId{4621}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2900}{\\htmlId{4631}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2819}{\\htmlId{4641}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{4648}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$\n      \u21c0\u2987 dereg c md ,DELEG\u2988\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3005}{\\htmlId{4690}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{4698}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{4700}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{4702}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{4704}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{4706}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2900}{\\htmlId{4710}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{4718}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{4720}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{4722}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{4724}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{4726}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2819}{\\htmlId{4730}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{4735}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{4737}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{4739}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{4741}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{4743}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\n      \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#1955}{\\htmlId{4753}{\\htmlClass{Function}{\\text{updateCertDeposit}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{4771}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\,\\htmlId{4774}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#2549}{\\htmlId{4775}{\\htmlClass{InductiveConstructor}{\\text{dereg}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{4781}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3236}{\\htmlId{4783}{\\htmlClass{Generalizable}{\\text{md}}}}\\,\\,\\htmlId{4785}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{4787}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$\n\n  DELEG-reg : let open PParams pp in\n    \u2219 c \u2209 dom rwds\n    \u2219 d \u2261 keyDeposit \u228e d \u2261 0\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{4926}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3043}{\\htmlId{4931}{\\htmlClass{Generalizable}{\\text{pools}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3332}{\\htmlId{4939}{\\htmlClass{Generalizable}{\\text{delegatees}}}}\\, \\end{pmatrix}$ \u22a2\n        $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3005}{\\htmlId{4964}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2900}{\\htmlId{4974}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2819}{\\htmlId{4984}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{4991}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$ \u21c0\u2987 reg c d ,DELEG\u2988\n        $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3005}{\\htmlId{5026}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2900}{\\htmlId{5036}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2819}{\\htmlId{5046}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{5051}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{5054}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{5056}{\\htmlClass{Generalizable}{\\text{c}}}}\\, , \\,\\htmlId{5060}{\\htmlClass{Number}{\\text{0}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{5062}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\,\n        \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#1955}{\\htmlId{5074}{\\htmlClass{Function}{\\text{updateCertDeposit}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{5092}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\,\\htmlId{5095}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#3184}{\\htmlId{5096}{\\htmlClass{InductiveConstructor}{\\text{reg}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{5100}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3212}{\\htmlId{5102}{\\htmlClass{Generalizable}{\\text{d}}}}\\,\\,\\htmlId{5103}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{5105}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$\n\ndata _\u22a2_\u21c0\u2987_,GOVCERT\u2988_ : CertEnv \u2192 GState \u2192 DCert \u2192 GState \u2192 Type where\n  GOVCERT-regdrep : \u2200 {pp} \u2192 let open PParams pp in\n    \u2219 (d \u2261 drepDeposit \u00d7 c \u2209 dom dReps) \u228e (d \u2261 0 \u00d7 c \u2208 dom dReps)\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3417}{\\htmlId{5348}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#5206}{\\htmlId{5352}{\\htmlClass{Bound}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3442}{\\htmlId{5357}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3119}{\\htmlId{5362}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3343}{\\htmlId{5370}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#2854}{\\htmlId{5385}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2948}{\\htmlId{5393}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{5402}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$\n        \u21c0\u2987 regdrep c d an ,GOVCERT\u2988\n      $\\begin{pmatrix} \\,\\href{Class.HasSingleton.html#288}{\\htmlId{5452}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{5454}{\\htmlClass{Generalizable}{\\text{c}}}}\\, , \\,\\href{Ledger.Conway.Conformance.Certs.html#3417}{\\htmlId{5458}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{5460}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.PParams.html#7468}{\\htmlId{5462}{\\htmlClass{Field}{\\text{drepActivity}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{5475}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{5477}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#2854}{\\htmlId{5480}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2948}{\\htmlId{5488}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\,\n      \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#1955}{\\htmlId{5503}{\\htmlClass{Function}{\\text{updateCertDeposit}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#5206}{\\htmlId{5521}{\\htmlClass{Bound}{\\text{pp}}}}\\, \\,\\htmlId{5524}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#2687}{\\htmlId{5525}{\\htmlClass{InductiveConstructor}{\\text{regdrep}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{5533}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3212}{\\htmlId{5535}{\\htmlClass{Generalizable}{\\text{d}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3159}{\\htmlId{5537}{\\htmlClass{Generalizable}{\\text{an}}}}\\, \\,\\htmlId{5540}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{5542}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$\n\n  GOVCERT-deregdrep :\n    \u2219 c \u2208 dom dReps\n    \u2219 (DRepDeposit c , d) \u2208 dep\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3417}{\\htmlId{5670}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{5674}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3442}{\\htmlId{5679}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3119}{\\htmlId{5684}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3343}{\\htmlId{5692}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#2854}{\\htmlId{5701}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2948}{\\htmlId{5709}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{5718}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$\n          \u21c0\u2987 deregdrep c d ,GOVCERT\u2988\n          $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#2854}{\\htmlId{5773}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{5779}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{5781}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{5783}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{5785}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{5787}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2948}{\\htmlId{5791}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#1955}{\\htmlId{5800}{\\htmlClass{Function}{\\text{updateCertDeposit}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{5818}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\,\\htmlId{5821}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#2738}{\\htmlId{5822}{\\htmlClass{InductiveConstructor}{\\text{deregdrep}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{5832}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3212}{\\htmlId{5834}{\\htmlClass{Generalizable}{\\text{d}}}}\\,\\,\\htmlId{5835}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{5837}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$\n\n  GOVCERT-ccreghot :\n    \u2219 (c , nothing) \u2209 ccKeys\n    \u2219 c \u2208 cc\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3417}{\\htmlId{5954}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{5958}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3442}{\\htmlId{5963}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3119}{\\htmlId{5968}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3343}{\\htmlId{5976}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#2854}{\\htmlId{5985}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2948}{\\htmlId{5993}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{6002}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$\n          \u21c0\u2987 ccreghot c mc ,GOVCERT\u2988\n          $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#2854}{\\htmlId{6057}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Class.HasSingleton.html#288}{\\htmlId{6065}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{6067}{\\htmlClass{Generalizable}{\\text{c}}}}\\, , \\,\\href{Ledger.Conway.Conformance.Certs.html#3296}{\\htmlId{6071}{\\htmlClass{Generalizable}{\\text{mc}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{6074}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{6076}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#2948}{\\htmlId{6079}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#1955}{\\htmlId{6088}{\\htmlClass{Function}{\\text{updateCertDeposit}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{6106}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\,\\htmlId{6109}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#2780}{\\htmlId{6110}{\\htmlClass{InductiveConstructor}{\\text{ccreghot}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3266}{\\htmlId{6119}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3296}{\\htmlId{6121}{\\htmlClass{Generalizable}{\\text{mc}}}}\\,\\,\\htmlId{6123}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3389}{\\htmlId{6125}{\\htmlClass{Generalizable}{\\text{dep}}}}\\, \\end{pmatrix}$\n\ndata _\u22a2_\u21c0\u2987_,CERT\u2988_ : CertEnv \u2192 CertState \u2192 DCert \u2192 CertState \u2192 Type where\n  CERT-deleg :\n    \u2219 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{6229}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{6234}{\\htmlClass{Field}{\\text{PState.pools}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3669}{\\htmlId{6247}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{6253}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{6257}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#936}{\\htmlId{6258}{\\htmlClass{Field}{\\text{GState.dreps}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3649}{\\htmlId{6271}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\,\\,\\htmlId{6274}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$ \u22a2 st\u1d48 \u21c0\u2987 dCert ,DELEG\u2988 st\u1d48'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3417}{\\htmlId{6353}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{6357}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3442}{\\htmlId{6362}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3119}{\\htmlId{6367}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3343}{\\htmlId{6375}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3629}{\\htmlId{6384}{\\htmlClass{Generalizable}{\\text{st\u1d48}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3669}{\\htmlId{6390}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3649}{\\htmlId{6396}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$ \u21c0\u2987 dCert ,CERT\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3633}{\\htmlId{6420}{\\htmlClass{Generalizable}{\\text{st\u1d48'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3669}{\\htmlId{6427}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3649}{\\htmlId{6433}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$\n\n  CERT-pool :\n    \u2219 pp \u22a2 st\u1d56 \u21c0\u2987 dCert ,POOL\u2988 st\u1d56'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3417}{\\htmlId{6537}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{6541}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3442}{\\htmlId{6546}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3119}{\\htmlId{6551}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3343}{\\htmlId{6559}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3629}{\\htmlId{6568}{\\htmlClass{Generalizable}{\\text{st\u1d48}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3669}{\\htmlId{6574}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3649}{\\htmlId{6580}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$ \u21c0\u2987 dCert ,CERT\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3629}{\\htmlId{6604}{\\htmlClass{Generalizable}{\\text{st\u1d48}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3673}{\\htmlId{6610}{\\htmlClass{Generalizable}{\\text{st\u1d56'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3649}{\\htmlId{6617}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$\n\n  CERT-vdel :\n    \u2219 \u0393 \u22a2 st\u1d4d \u21c0\u2987 dCert ,GOVCERT\u2988 st\u1d4d'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3629}{\\htmlId{6727}{\\htmlClass{Generalizable}{\\text{st\u1d48}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3669}{\\htmlId{6733}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3649}{\\htmlId{6739}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$ \u21c0\u2987 dCert ,CERT\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3629}{\\htmlId{6763}{\\htmlClass{Generalizable}{\\text{st\u1d48}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3669}{\\htmlId{6769}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3653}{\\htmlId{6775}{\\htmlClass{Generalizable}{\\text{st\u1d4d'}}}}\\, \\end{pmatrix}$\n\ndata _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ : CertEnv \u2192 CertState \u2192 \u22a4 \u2192 CertState \u2192 Type where\n\n  CERT-pre :\n    let open PParams pp\n        refresh         = mapPartial (isGovVoterDRep \u2218 voter) (fromList vs)\n        refreshedDReps  = mapValueRestricted (const (e + drepActivity)) dReps refresh\n        wdrlCreds       = map\u02e2 stake (dom wdrls)\n    in\n    \u2219 filter\u02e2 isKeyHash wdrlCreds \u2286 dom voteDelegs\n    \u2219 map\u02e2 (map\u2081 stake) (wdrls \u02e2) \u2286 rewards \u02e2\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3417}{\\htmlId{7257}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{7261}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3442}{\\htmlId{7266}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3119}{\\htmlId{7271}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3343}{\\htmlId{7279}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3013}{\\htmlId{7290}{\\htmlClass{Generalizable}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2908}{\\htmlId{7303}{\\htmlClass{Generalizable}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2824}{\\htmlId{7317}{\\htmlClass{Generalizable}{\\text{rewards}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3393}{\\htmlId{7327}{\\htmlClass{Generalizable}{\\text{ddep}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3669}{\\htmlId{7336}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#2854}{\\htmlId{7344}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2955}{\\htmlId{7352}{\\htmlClass{Generalizable}{\\text{ccHotKeys}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3398}{\\htmlId{7364}{\\htmlClass{Generalizable}{\\text{gdep}}}}\\, \\end{pmatrix} \\end{pmatrix}$\n      \u21c0\u2987 _ ,PRE-CERT\u2988\n      $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3013}{\\htmlId{7405}{\\htmlClass{Generalizable}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2908}{\\htmlId{7418}{\\htmlClass{Generalizable}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Axiom.Set.Map.html#11986}{\\htmlId{7432}{\\htmlClass{Function}{\\text{constMap}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#7065}{\\htmlId{7441}{\\htmlClass{Bound}{\\text{wdrlCreds}}}}\\, \\,\\htmlId{7451}{\\htmlClass{Number}{\\text{0}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{7453}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#2824}{\\htmlId{7456}{\\htmlClass{Generalizable}{\\text{rewards}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3393}{\\htmlId{7466}{\\htmlClass{Generalizable}{\\text{ddep}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3669}{\\htmlId{7475}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#6979}{\\htmlId{7483}{\\htmlClass{Bound}{\\text{refreshedDReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2955}{\\htmlId{7500}{\\htmlClass{Generalizable}{\\text{ccHotKeys}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3398}{\\htmlId{7512}{\\htmlClass{Generalizable}{\\text{gdep}}}}\\, \\end{pmatrix} \\end{pmatrix}$\n\ndata _\u22a2_\u21c0\u2987_,POST-CERT\u2988_ : CertEnv \u2192 CertState \u2192 \u22a4 \u2192 CertState \u2192 Type where\n\n  CERT-post :\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3417}{\\htmlId{7620}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3569}{\\htmlId{7624}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3442}{\\htmlId{7629}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3119}{\\htmlId{7634}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3343}{\\htmlId{7642}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$\n      \u22a2 $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3013}{\\htmlId{7659}{\\htmlClass{Generalizable}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2908}{\\htmlId{7672}{\\htmlClass{Generalizable}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#2824}{\\htmlId{7686}{\\htmlClass{Generalizable}{\\text{rewards}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3393}{\\htmlId{7696}{\\htmlClass{Generalizable}{\\text{ddep}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3669}{\\htmlId{7705}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#3649}{\\htmlId{7711}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$\n        \u21c0\u2987 _ ,POST-CERT\u2988\n        $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#3013}{\\htmlId{7754}{\\htmlClass{Generalizable}{\\text{voteDelegs}}}}\\, \\,\\href{Axiom.Set.Map.html#17773}{\\htmlId{7765}{\\htmlClass{Function Operator}{\\text{\u2223\\^{}}}}}\\, \\,\\htmlId{7768}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{abstract-set-theory.FiniteSetTheory.html#519}{\\htmlId{7769}{\\htmlClass{Function}{\\text{map\u02e2}}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#6846}{\\htmlId{7774}{\\htmlClass{InductiveConstructor}{\\text{vDelegCredential}}}}\\, \\,\\htmlId{7791}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Class.IsSet.html#916}{\\htmlId{7792}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{7796}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#936}{\\htmlId{7797}{\\htmlClass{Field}{\\text{GState.dreps}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#3649}{\\htmlId{7810}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\,\\,\\htmlId{7813}{\\htmlClass{Symbol}{\\text{))}}}\\, \\,\\href{Axiom.Set.html#9137}{\\htmlId{7816}{\\htmlClass{Function Operator}{\\text{\u222a}}}}\\, \\,\\href{Axiom.Set.html#5903}{\\htmlId{7818}{\\htmlClass{Function}{\\text{fromList}}}}\\, \\,\\htmlId{7827}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Actions.html#6919}{\\htmlId{7828}{\\htmlClass{InductiveConstructor}{\\text{vDelegNoConfidence}}}}\\, \\,\\href{Agda.Builtin.List.html#199}{\\htmlId{7847}{\\htmlClass{InductiveConstructor Operator}{\\text{\u2237}}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#6889}{\\htmlId{7849}{\\htmlClass{InductiveConstructor}{\\text{vDelegAbstain}}}}\\, \\,\\href{Agda.Builtin.List.html#199}{\\htmlId{7863}{\\htmlClass{InductiveConstructor Operator}{\\text{\u2237}}}}\\, \\,\\href{Agda.Builtin.List.html#184}{\\htmlId{7865}{\\htmlClass{InductiveConstructor}{\\text{[]}}}}\\,\\,\\htmlId{7867}{\\htmlClass{Symbol}{\\text{))}}}\\,\n          , \\,\\href{Ledger.Conway.Conformance.Certs.html#2908}{\\htmlId{7882}{\\htmlClass{Generalizable}{\\text{stakeDelegs}}}}\\, , \\,\\href{Ledger.Conway.Conformance.Certs.html#2824}{\\htmlId{7896}{\\htmlClass{Generalizable}{\\text{rewards}}}}\\, , \\,\\href{Ledger.Conway.Conformance.Certs.html#3393}{\\htmlId{7906}{\\htmlClass{Generalizable}{\\text{ddep}}}}\\, \\end{pmatrix} , \\,\\href{Ledger.Conway.Conformance.Certs.html#3669}{\\htmlId{7915}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, , \\,\\href{Ledger.Conway.Conformance.Certs.html#3649}{\\htmlId{7921}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$\n\n_\u22a2_\u21c0\u2987_,CERTS\u2988_  : CertEnv \u2192 CertState  \u2192 List DCert  \u2192 CertState  \u2192 Type\n_\u22a2_\u21c0\u2987_,CERTS\u2988_ = RunTraceAfterAndThen _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ _\u22a2_\u21c0\u2987_,CERT\u2988_ _\u22a2_\u21c0\u2987_,POST-CERT\u2988_\n</pre>"},{"location":"Ledger.Conway.Conformance.Chain.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Conformance.Chain.Properties\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Conformance.Chain txs abs\nopen import Ledger.Conway.Conformance.Epoch txs abs\nopen import Ledger.Conway.Conformance.Epoch.Properties txs abs\nopen import Ledger.Conway.Conformance.Ledger.Properties txs abs\n\nopen Computational \u2983...\u2984\n\nmodule _ {nes : NewEpochState} {e : Epoch} where\n\ninstance\n  Computational-CHAIN : Computational _\u22a2_\u21c0\u2987_,CHAIN\u2988_ String\n  Computational-CHAIN .computeProof \u0393 s b = do\n    _ , neStep \u2190 map\u2081 \u22a5-elim $ computeProof {STS = _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_} _ _ _\n    _ , lsStep \u2190 computeProof _ _ _\n    success (_ , CHAIN neStep lsStep)\n  Computational-CHAIN .completeness \u0393 s b s' (CHAIN neStep lsStep)\n    with recomputeProof neStep | completeness _ _ _ _ neStep\n  ... | _         | refl\n    with recomputeProof lsStep | completeness _ _ _ _ lsStep\n  ... | success _ | refl = refl\n</pre>"},{"location":"Ledger.Conway.Conformance.Chain.html","title":"Chain","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Algebra\nopen import Data.Nat.Properties using (+-0-monoid)\n\nopen import Ledger.Prelude; open Equivalence\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Conformance.Chain\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Epoch txs abs\nopen import Ledger.Conway.Conformance.Certs govStructure\n\nrecord ChainState : Type where\n\n  field\n\n    newEpochState  : NewEpochState\n\nrecord Block : Type where\n\n  field\n\n    ts    : List Tx\n    slot  : Slot\n\nprivate variable\n  s : ChainState\n  b : Block\n  ls' : LState\n  nes : NewEpochState\n\ninstance _ = +-0-monoid\n\n-- TODO: do we still need this for anything?\nmaybePurpose : DepositPurpose \u2192 (DepositPurpose \u00d7 Credential) \u2192 Coin \u2192 Maybe Coin\nmaybePurpose prps (prps' , _) c with prps \u225f prps'\n... | yes _ = just c\n... | no _ = nothing\n\nmaybePurpose-prop : \u2200 {prps} {x} {y}\n  \u2192 (m : (DepositPurpose \u00d7 Credential) \u21c0 Coin)\n  \u2192 (x , y) \u2208 dom ((mapMaybeWithKey\u1d50 (maybePurpose prps) m) \u02e2)\n  \u2192 x \u2261 prps\nmaybePurpose-prop {prps = prps} {x} {y} _ xy\u2208dom with from dom\u2208 xy\u2208dom\n... | z , \u2208mmwk with prps \u225f x | \u2208-mapMaybeWithKey {f = maybePurpose prps} \u2208mmwk\n... | yes refl | _ = refl\n\nfilterPurpose : DepositPurpose \u2192 (DepositPurpose \u00d7 Credential) \u21c0 Coin \u2192 Credential \u21c0 Coin\nfilterPurpose prps m = mapKeys proj\u2082 (mapMaybeWithKey\u1d50 (maybePurpose prps) m)\n  {\u03bb where x\u2208dom y\u2208dom refl \u2192 cong (_, _)\n                            $ trans (maybePurpose-prop {prps = prps} m x\u2208dom)\n                            $ sym   (maybePurpose-prop {prps = prps} m y\u2208dom)}\n\ngovActionDeposits : LState \u2192 VDeleg \u21c0 Coin\ngovActionDeposits ls =\n  let open LState ls; open CertState certState; open PState pState\n      open UTxOState utxoSt; open DState dState\n   in foldl _\u222a\u207a_ \u2205 $ setToList $\n    mapPartial\n      (\u03bb where (gaid , record { returnAddr = record {stake = c} }) \u2192 do\n        vd \u2190 lookup\u1d50? voteDelegs c\n        dep \u2190 lookup\u1d50? (DState.deposits dState) (GovActionDeposit gaid)\n        just \u2774 vd , dep \u2775 )\n      (fromList govSt)\n\ndata\n\n  _\u22a2_\u21c0\u2987_,CHAIN\u2988_ : \u22a4 \u2192 ChainState \u2192 Block \u2192 ChainState \u2192 Type\n\n  where\n\n  CHAIN :\n    let open ChainState s; open Block b; open NewEpochState nes\n        open EpochState epochState; open EnactState es\n    in\n       _ \u22a2 newEpochState \u21c0\u2987 epoch slot ,NEWEPOCH\u2988 nes\n    \u2192  $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Chain.html#952}{\\htmlId{2738}{\\htmlClass{Function}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Prelude.html#2381}{\\htmlId{2745}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.Enact.html#1739}{\\htmlId{2747}{\\htmlClass{Function}{\\text{constitution}}}}\\, \\,\\href{Ledger.Prelude.html#2381}{\\htmlId{2760}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\\\ \\,\\href{Ledger.Prelude.html#2381}{\\htmlId{2764}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.Enact.html#1844}{\\htmlId{2766}{\\htmlClass{Function}{\\text{pparams}}}}\\, \\,\\href{Ledger.Prelude.html#2381}{\\htmlId{2774}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#1464}{\\htmlId{2778}{\\htmlClass{Function}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.PParams.html#3084}{\\htmlId{2783}{\\htmlClass{Field}{\\text{Acnt.treasury}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#1391}{\\htmlId{2797}{\\htmlClass{Function}{\\text{acnt}}}}\\,\n       \\end{pmatrix}$ \u22a2 ls \u21c0\u2987 ts ,LEDGERS\u2988 ls'\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    _ \u22a2 s \u21c0\u2987 b ,CHAIN\u2988\n        record s { newEpochState = record nes { epochState = record epochState { ls = ls'} } }\n</pre>"},{"location":"Ledger.Conway.Conformance.Epoch.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nopen import Agda.Builtin.FromNat\n\nmodule Ledger.Conway.Conformance.Epoch.Properties\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Conformance.Epoch txs abs\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Specification.Ratify.Properties.Computational txs\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Ledger.Conway.Conformance.Rewards txs abs\n\nopen import Data.List using (filter)\nimport Relation.Binary.PropositionalEquality as PE\n\nopen Computational \u2983...\u2984\n\nmodule _ {lstate : LState} {ss : Snapshots} where\n  SNAP-total : \u2203[ ss' ] lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n  SNAP-total = -, SNAP\n\n  SNAP-complete : \u2200 ss' \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss' \u2192 proj\u2081 SNAP-total \u2261 ss'\n  SNAP-complete ss' SNAP = refl\n\n  SNAP-deterministic : \u2200 {ss' ss''}\n                     \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n                     \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'' \u2192 ss' \u2261 ss''\n  SNAP-deterministic SNAP SNAP = refl\n\n\nmodule _ {eps : EpochState} {e : Epoch} where\n\n  open EpochState eps hiding (es)\n  open RatifyState fut using (removed) renaming (es to esW)\n  open LState ls; open CertState certState; open Acnt acnt\n  es         = record esW { withdrawals = \u2205 }\n  govSt'     = filter (\u03bb x \u2192 \u00bf \u00ac proj\u2081 x \u2208 map\u02e2 proj\u2081 removed \u00bf) govSt\n\n  EPOCH-total : \u2203[ eps' ] _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n  EPOCH-total = -, EPOCH (RATIFIES-total' .proj\u2082) (SNAP-total .proj\u2082)\n\n  EPOCH-deterministic : \u2200 eps' eps''\n                      \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n                      \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps''\n                      \u2192 eps' \u2261 eps''\n  EPOCH-deterministic eps' eps'' (EPOCH p\u2081 p\u2082) (EPOCH p\u2081' p\u2082') =\n    cong\u2082 (\u03bb ss fut \u2192 record { acnt = _ ; ss = ss ; ls = _ ; es = _ ; fut = fut })\n          ss'\u2261ss''\n          fut'\u2261fut''\n    where\n      ss'\u2261ss'' : EpochState.ss eps' \u2261 EpochState.ss eps''\n      ss'\u2261ss'' = SNAP-deterministic p\u2082 p\u2082'\n\n      fut'\u2261fut'' : EpochState.fut eps' \u2261 EpochState.fut eps''\n      fut'\u2261fut'' = RATIFIES-deterministic-\u2261\n                    (cong (\u03bb x \u2192 record\n                                   { stakeDistrs = _\n                                   ; currentEpoch = _\n                                   ; dreps = _\n                                   ; ccHotKeys = _\n                                   ; treasury = _\n                                   }) ss'\u2261ss'')\n                                   refl refl p\u2081 p\u2081'\n\n\n  EPOCH-complete : \u2200 eps' \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps' \u2192 proj\u2081 EPOCH-total \u2261 eps'\n  EPOCH-complete eps' p = EPOCH-deterministic (proj\u2081 EPOCH-total) eps' (proj\u2082 EPOCH-total) p\n\n  abstract\n    EPOCH-total' : \u2203[ eps' ] _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n    EPOCH-total' = EPOCH-total\n\n    EPOCH-complete' : \u2200 eps' \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps' \u2192 proj\u2081 EPOCH-total' \u2261 eps'\n    EPOCH-complete' = EPOCH-complete\n\ninstance\n  Computational-EPOCH : Computational _\u22a2_\u21c0\u2987_,EPOCH\u2988_ \u22a5\n  Computational-EPOCH .computeProof \u0393 s sig = success EPOCH-total'\n  Computational-EPOCH .completeness \u0393 s sig s' h = cong success (EPOCH-complete' s' h)\n\nmodule _ {e : Epoch} where\n\n  NEWEPOCH-total : \u2200 nes'' \u2192 \u2203[ nes' ] _ \u22a2 nes'' \u21c0\u2987 e ,NEWEPOCH\u2988 nes'\n  NEWEPOCH-total nes with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | inspect NewEpochState.ru nes\n  ... | yes p | just ru | PE.[ refl ] =  $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.Properties.html#3394}{\\htmlId{3641}{\\htmlClass{Bound}{\\text{e}}}}\\, \\\\ \\,\\htmlId{3645}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{3649}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.Properties.html#2959}{\\htmlId{3653}{\\htmlClass{Function}{\\text{EPOCH-total'}}}}\\, \\,\\htmlId{3666}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Data.Product.Base.html#636}{\\htmlId{3667}{\\htmlClass{Field}{\\text{proj\u2081}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#194}{\\htmlId{3675}{\\htmlClass{InductiveConstructor}{\\text{nothing}}}}\\, \\\\ \\,\\htmlId{3685}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$\n                                      , NEWEPOCH-New (p , EPOCH-total' .proj\u2082)\n  ... | yes p | nothing | PE.[ refl ] = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.Properties.html#3394}{\\htmlId{3810}{\\htmlClass{Bound}{\\text{e}}}}\\, \\\\ \\,\\htmlId{3814}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{3818}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Data.Product.Base.html#636}{\\htmlId{3822}{\\htmlClass{Field}{\\text{proj\u2081}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.Properties.html#2959}{\\htmlId{3828}{\\htmlClass{Function}{\\text{EPOCH-total'}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#194}{\\htmlId{3843}{\\htmlClass{InductiveConstructor}{\\text{nothing}}}}\\, \\\\ \\,\\htmlId{3853}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$\n                                      , NEWEPOCH-No-Reward-Update (p , EPOCH-total' .proj\u2082)\n  ... | no \u00acp | _ | _ = -, NEWEPOCH-Not-New \u00acp\n\n  NEWEPOCH-complete : \u2200 nes nes' \u2192 _ \u22a2 nes \u21c0\u2987 e ,NEWEPOCH\u2988 nes' \u2192 proj\u2081 (NEWEPOCH-total nes) \u2261 nes'\n  -- NEWEPOCH-complete nes nes' h with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | h\n  NEWEPOCH-complete nes nes' h with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | inspect NewEpochState.ru nes | h\n  ... | yes p | just ru | PE.[ refl ] | NEWEPOCH-New (x , x\u2081) rewrite EPOCH-complete' _ x\u2081 = refl\n  ... | yes p | ru | PE.[ refl ] | NEWEPOCH-Not-New x = \u22a5-elim $ x p\n  ... | yes p | nothing | PE.[ refl ] | NEWEPOCH-No-Reward-Update (x , x\u2081) rewrite EPOCH-complete' _ x\u2081 = refl\n  ... | no \u00acp | ru | PE.[ refl ] | NEWEPOCH-New (x , x\u2081)  = \u22a5-elim $ \u00acp x\n  ... | no \u00acp | ru | PE.[ refl ] | NEWEPOCH-Not-New x = refl\n  ... | no \u00acp | nothing | PE.[ refl ] | NEWEPOCH-No-Reward-Update (x , x\u2081) = \u22a5-elim $ \u00acp x\n\ninstance\n  Computational-NEWEPOCH : Computational _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_ \u22a5\n  Computational-NEWEPOCH .computeProof \u0393 s sig = success (NEWEPOCH-total _)\n  Computational-NEWEPOCH .completeness \u0393 s sig s' h = cong success (NEWEPOCH-complete _ s' h)\n\n</pre>"},{"location":"Ledger.Conway.Conformance.Epoch.html","title":"Epoch","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Epoch\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Prelude\nopen import Data.Integer using () renaming (+_ to pos)\nimport Data.Integer as \u2124\n\nopen import Data.Nat.Properties using (+-0-monoid; +-0-commutativeMonoid)\nopen import Data.List using (filter)\n\nopen import Agda.Builtin.FromNat\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Conformance.Equivalence txs abs\nopen import Ledger.Conway.Conformance.Equivalence.Convert\nopen import Ledger.Conway.Conformance.Equivalence.Deposits txs abs\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Ledger.Conway.Conformance.Rewards txs abs\nopen import Ledger.Conway.Specification.Epoch txs abs\n  using (getStakeCred; getOrphans; mkStakeDistrs; toRwdAddr) public\nimport Ledger.Conway.Specification.Epoch txs abs as EpochSpec\n\nrecord EpochState : Type where\n  constructor \u27e6_,_,_,_,_\u27e7\u1d49'\n  field\n    acnt       : Acnt\n    ss         : Snapshots\n    ls         : LState\n    es         : EnactState\n    fut        : RatifyState\n\nPoolDelegatedStake : Type\nPoolDelegatedStake = KeyHash \u21c0 Coin\n\nrecord NewEpochState : Type where\n  field\n    lastEpoch   : Epoch\n    bprev       : BlocksMade\n    bcur        : BlocksMade\n    epochState  : EpochState\n    ru          : Maybe RewardUpdate\n    pd          : PoolDelegatedStake\n\ninstance\n  unquoteDecl HasCast-EpochState HasCast-NewEpochState = derive-HasCast\n    ( (quote EpochState     , HasCast-EpochState)\n    \u2237 [ (quote NewEpochState  , HasCast-NewEpochState)])\n\n  EpochStateFromConf : EpochState \u2b46 EpochSpec.EpochState\n  EpochStateFromConf .conv\u2071 _ epochState =\n    let open EpochState epochState in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#1391}{\\htmlId{2142}{\\htmlClass{Field}{\\text{acnt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#1413}{\\htmlId{2149}{\\htmlClass{Field}{\\text{ss}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#559}{\\htmlId{2154}{\\htmlClass{Function}{\\text{conv}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#1440}{\\htmlId{2159}{\\htmlClass{Field}{\\text{ls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#1464}{\\htmlId{2164}{\\htmlClass{Field}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#1492}{\\htmlId{2169}{\\htmlClass{Field}{\\text{fut}}}}\\, \\end{pmatrix}$\n\n  EpochStateToConf : EpochSpec.EpochState \u2b46 EpochState\n  EpochStateToConf .conv\u2071 deposits epochSt =\n    let open EpochSpec.EpochState epochSt in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#2305}{\\htmlId{2327}{\\htmlClass{Field}{\\text{acnt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#2327}{\\htmlId{2334}{\\htmlClass{Field}{\\text{ss}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12902}{\\htmlId{2339}{\\htmlClass{Function}{\\text{certDeposits}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#2354}{\\htmlId{2352}{\\htmlClass{Field}{\\text{ls}}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#377}{\\htmlId{2355}{\\htmlClass{Function Operator}{\\text{\u22a2conv}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#2354}{\\htmlId{2361}{\\htmlClass{Field}{\\text{ls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#2378}{\\htmlId{2366}{\\htmlClass{Field}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#2406}{\\htmlId{2371}{\\htmlClass{Field}{\\text{fut}}}}\\, \\end{pmatrix}$\n\n  NewEpochStateFromConf : NewEpochState \u2b46 EpochSpec.NewEpochState\n  NewEpochStateFromConf .conv\u2071 _ newEpochState =\n    let open NewEpochState newEpochState in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#1627}{\\htmlId{2545}{\\htmlClass{Field}{\\text{lastEpoch}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#1651}{\\htmlId{2557}{\\htmlClass{Field}{\\text{bprev}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#1680}{\\htmlId{2565}{\\htmlClass{Field}{\\text{bcur}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#559}{\\htmlId{2572}{\\htmlClass{Function}{\\text{conv}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#1709}{\\htmlId{2577}{\\htmlClass{Field}{\\text{epochState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#1738}{\\htmlId{2590}{\\htmlClass{Field}{\\text{ru}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#1775}{\\htmlId{2595}{\\htmlClass{Field}{\\text{pd}}}}\\, \\end{pmatrix}$\n\n  NewEpochStateToConf : EpochSpec.NewEpochState \u2b46 NewEpochState\n  NewEpochStateToConf .conv\u2071 deposits newEpochSt =\n    let open EpochSpec.NewEpochState newEpochSt in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#4077}{\\htmlId{2773}{\\htmlClass{Field}{\\text{lastEpoch}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#4130}{\\htmlId{2785}{\\htmlClass{Field}{\\text{bcur}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#4101}{\\htmlId{2792}{\\htmlClass{Field}{\\text{bprev}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#559}{\\htmlId{2800}{\\htmlClass{Function}{\\text{conv}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#4159}{\\htmlId{2805}{\\htmlClass{Field}{\\text{epochState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#4188}{\\htmlId{2818}{\\htmlClass{Field}{\\text{ru}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#4225}{\\htmlId{2823}{\\htmlClass{Field}{\\text{pd}}}}\\, \\end{pmatrix}$\n\n\napplyRUpd : RewardUpdate \u2192 EpochState \u2192 EpochState\napplyRUpd rewardUpdate\n  $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#2910}{\\htmlId{2910}{\\htmlClass{Bound}{\\text{treasury}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#2921}{\\htmlId{2921}{\\htmlClass{Bound}{\\text{reserves}}}}\\, \\end{pmatrix}\n  \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#2937}{\\htmlId{2937}{\\htmlClass{Bound}{\\text{ss}}}}\\,\n  \\\\ \\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#2948}{\\htmlId{2948}{\\htmlClass{Bound}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#2955}{\\htmlId{2955}{\\htmlClass{Bound}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#2962}{\\htmlId{2962}{\\htmlClass{Bound}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#2973}{\\htmlId{2973}{\\htmlClass{Bound}{\\text{donations}}}}\\, \\end{pmatrix}\n    \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#2992}{\\htmlId{2992}{\\htmlClass{Bound}{\\text{govSt}}}}\\,\n    \\\\ \\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#3008}{\\htmlId{3008}{\\htmlClass{Bound}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3021}{\\htmlId{3021}{\\htmlClass{Bound}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3035}{\\htmlId{3035}{\\htmlClass{Bound}{\\text{rewards}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3045}{\\htmlId{3045}{\\htmlClass{Bound}{\\text{deposits'}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3060}{\\htmlId{3060}{\\htmlClass{Bound}{\\text{pState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3069}{\\htmlId{3069}{\\htmlClass{Bound}{\\text{gState}}}}\\, \\end{pmatrix} \\end{pmatrix}\n  \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3087}{\\htmlId{3087}{\\htmlClass{Bound}{\\text{es}}}}\\,\n  \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3094}{\\htmlId{3094}{\\htmlClass{Bound}{\\text{fut}}}}\\,\n  \\end{pmatrix}$ =\n  $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Prelude.html#3352}{\\htmlId{3112}{\\htmlClass{Function}{\\text{posPart}}}}\\, \\,\\htmlId{3120}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Epoch.html#450}{\\htmlId{3121}{\\htmlClass{InductiveConstructor}{\\text{pos}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#2910}{\\htmlId{3125}{\\htmlClass{Bound}{\\text{treasury}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{3134}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Rewards.html#18002}{\\htmlId{3136}{\\htmlClass{Function}{\\text{\u0394t}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{3139}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#450}{\\htmlId{3141}{\\htmlClass{InductiveConstructor}{\\text{pos}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#3519}{\\htmlId{3145}{\\htmlClass{Function}{\\text{unregRU'}}}}\\,\\,\\htmlId{3153}{\\htmlClass{Symbol}{\\text{)}}}\\,\n    \\\\ \\,\\href{Prelude.html#3352}{\\htmlId{3161}{\\htmlClass{Function}{\\text{posPart}}}}\\, \\,\\htmlId{3169}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Epoch.html#450}{\\htmlId{3170}{\\htmlClass{InductiveConstructor}{\\text{pos}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#2921}{\\htmlId{3174}{\\htmlClass{Bound}{\\text{reserves}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{3183}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Rewards.html#18005}{\\htmlId{3185}{\\htmlClass{Function}{\\text{\u0394r}}}}\\,\\,\\htmlId{3187}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}\n  \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#2937}{\\htmlId{3195}{\\htmlClass{Bound}{\\text{ss}}}}\\,\n  \\\\ \\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#2948}{\\htmlId{3206}{\\htmlClass{Bound}{\\text{utxo}}}}\\, \\\\ \\,\\href{Prelude.html#3352}{\\htmlId{3213}{\\htmlClass{Function}{\\text{posPart}}}}\\, \\,\\htmlId{3221}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Epoch.html#450}{\\htmlId{3222}{\\htmlClass{InductiveConstructor}{\\text{pos}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#2955}{\\htmlId{3226}{\\htmlClass{Bound}{\\text{fees}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{3231}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Rewards.html#18008}{\\htmlId{3233}{\\htmlClass{Function}{\\text{\u0394f}}}}\\,\\,\\htmlId{3235}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#2962}{\\htmlId{3239}{\\htmlClass{Bound}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#2973}{\\htmlId{3250}{\\htmlClass{Bound}{\\text{donations}}}}\\, \\end{pmatrix}\n    \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#2992}{\\htmlId{3268}{\\htmlClass{Bound}{\\text{govSt}}}}\\,\n    \\\\ \\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#3008}{\\htmlId{3284}{\\htmlClass{Bound}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3021}{\\htmlId{3297}{\\htmlClass{Bound}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3035}{\\htmlId{3311}{\\htmlClass{Bound}{\\text{rewards}}}}\\, \\,\\href{Axiom.Set.Map.Dec.html#2149}{\\htmlId{3319}{\\htmlClass{Function Operator}{\\text{\u222a\u207a}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#3451}{\\htmlId{3322}{\\htmlClass{Function}{\\text{regRU}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3045}{\\htmlId{3330}{\\htmlClass{Bound}{\\text{deposits'}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3060}{\\htmlId{3344}{\\htmlClass{Bound}{\\text{pState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3069}{\\htmlId{3353}{\\htmlClass{Bound}{\\text{gState}}}}\\, \\end{pmatrix} \\end{pmatrix}\n  \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3087}{\\htmlId{3368}{\\htmlClass{Bound}{\\text{es}}}}\\,\n  \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#3094}{\\htmlId{3375}{\\htmlClass{Bound}{\\text{fut}}}}\\, \\end{pmatrix}$\n  where\n    open RewardUpdate rewardUpdate using (\u0394t; \u0394r; \u0394f; rs)\n    regRU     = rs \u2223 dom rewards\n    unregRU   = rs \u2223 dom rewards \u1d9c\n    unregRU'  = \u2211[ x \u2190 unregRU ] x\n\nopaque\n  calculatePoolDelegatedStake : Snapshot \u2192 PoolDelegatedStake\n  calculatePoolDelegatedStake ss =\n      -- Shelley spec: the output map must contain keys appearing in both\n      -- sd and the pool parameters.\n      sd \u2223 dom (ss .pools)\n    where\n      open Snapshot\n\n      -- stake credentials delegating to each pool\n      stakeCredentialsPerPool : Rel KeyHash Credential\n      stakeCredentialsPerPool = (StakeDelegsOf ss \u02e2) \u207b\u00b9\u02b3\n\n      -- delegated stake per pool\n      sd : KeyHash \u21c0 Coin\n      sd = aggregate\u208a ((stakeCredentialsPerPool \u2218\u02b3 (StakeOf ss \u02e2)) \u1da0\u02e2)\n\n\nprivate variable\n  nes nes' : NewEpochState\n  e lastEpoch : Epoch\n  fut fut' : RatifyState\n  eps eps' eps'' : EpochState\n  ls : LState\n  acnt : Acnt\n  es\u2080 : EnactState\n  mark set go : Snapshot\n  feeSS : Coin\n  lstate : LState\n  ss ss' : Snapshots\n  ru : RewardUpdate\n  mru : Maybe RewardUpdate\n  certState' : CertState\n\ndata _\u22a2_\u21c0\u2987_,EPOCH\u2988_ : \u22a4 \u2192 EpochState \u2192 Epoch \u2192 EpochState \u2192 Type where\n\n  EPOCH : let\n      open LState ls\n      open CertState certState\n      open RatifyState fut renaming (es to esW)\n      open UTxOState\n      open PState; open DState; open GState\n      open Acnt; open EnactState; open GovActionState\n\n      es : EnactState\n      es = record esW { withdrawals = \u2205 }\n\n      tmpGovSt = filter (\u03bb x \u2192 \u00bf proj\u2081 x \u2209 map\u02e2 proj\u2081 removed \u00bf) govSt\n\n      orphans : \u2119 (GovActionID \u00d7 GovActionState)\n      orphans  = fromList (getOrphans es tmpGovSt)\n\n      removed' : \u2119 (GovActionID \u00d7 GovActionState)\n      removed' = removed \u222a orphans\n\n      govSt' = filter (\u03bb x \u2192 \u00bf proj\u2081 x \u2209 map\u02e2 proj\u2081 removed' \u00bf) govSt\n\n      removedGovActions : \u2119 (RwdAddr \u00d7 DepositPurpose \u00d7 Coin)\n      removedGovActions =\n        flip concatMap\u02e2 removed' \u03bb (gaid , gaSt) \u2192\n          map\u02e2\n            (returnAddr gaSt ,_)\n            ((utxoSt .deposits \u2223 \u2774 GovActionDeposit gaid \u2775) \u02e2)\n\n      govActionReturns : RwdAddr \u21c0 Coin\n      govActionReturns =\n        aggregate\u208a (map\u02e2 (\u03bb (a , _ , d) \u2192 a , d) removedGovActions \u1da0\u02e2)\n\n      trWithdrawals   = esW .withdrawals\n      totWithdrawals  = \u2211[ x \u2190 trWithdrawals ] x\n\n      retired    = (pState .retiring) \u207b\u00b9 e\n      payout     = govActionReturns \u222a\u207a trWithdrawals\n      refunds    = pullbackMap payout toRwdAddr (dom (dState .rewards))\n      unclaimed  = getCoin payout - getCoin refunds\n      vDeposits  = gState .deposits\n\n      dState' : DState\n      dState' = record dState { rewards = dState .rewards \u222a\u207a refunds }\n\n      pState' : PState\n      pState' = $\\begin{pmatrix} \\,\\htmlId{6014}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1128}{\\htmlId{6015}{\\htmlClass{Function}{\\text{pState}}}}\\, \\,\\htmlId{6022}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{6023}{\\htmlClass{Field}{\\text{pools}}}}\\,\\,\\htmlId{6028}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{6030}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#5627}{\\htmlId{6032}{\\htmlClass{Bound}{\\text{retired}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{6040}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\n                \\\\ \\,\\htmlId{6060}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1128}{\\htmlId{6061}{\\htmlClass{Function}{\\text{pState}}}}\\, \\,\\htmlId{6068}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4420}{\\htmlId{6069}{\\htmlClass{Field}{\\text{fPools}}}}\\,\\,\\htmlId{6075}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{6077}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#5627}{\\htmlId{6079}{\\htmlClass{Bound}{\\text{retired}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{6087}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\n                \\\\ \\,\\htmlId{6107}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1128}{\\htmlId{6108}{\\htmlClass{Function}{\\text{pState}}}}\\, \\,\\htmlId{6115}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4442}{\\htmlId{6116}{\\htmlClass{Field}{\\text{retiring}}}}\\,\\,\\htmlId{6124}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{6126}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#5627}{\\htmlId{6128}{\\htmlClass{Bound}{\\text{retired}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{6136}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\n                \\end{pmatrix}$\n\n      gState' : GState\n      gState' = $\\begin{pmatrix} \\,\\htmlId{6198}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Class.ToBool.html#342}{\\htmlId{6199}{\\htmlClass{Function Operator}{\\text{if}}}}\\, \\,\\href{Data.List.Base.html#4681}{\\htmlId{6202}{\\htmlClass{Function}{\\text{null}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#5077}{\\htmlId{6207}{\\htmlClass{Bound}{\\text{govSt'}}}}\\, \\,\\href{Class.ToBool.html#342}{\\htmlId{6214}{\\htmlClass{Function Operator}{\\text{then}}}}\\, \\,\\href{Axiom.Set.Map.html#7106}{\\htmlId{6219}{\\htmlClass{Function}{\\text{mapValues}}}}\\, \\,\\htmlId{6229}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\htmlId{6230}{\\htmlClass{Number}{\\text{1}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{6232}{\\htmlClass{Field Operator}{\\text{+\\_}}}}\\,\\,\\htmlId{6234}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\htmlId{6236}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1148}{\\htmlId{6237}{\\htmlClass{Function}{\\text{gState}}}}\\, \\,\\htmlId{6244}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#936}{\\htmlId{6245}{\\htmlClass{Field}{\\text{dreps}}}}\\,\\,\\htmlId{6250}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Class.ToBool.html#342}{\\htmlId{6252}{\\htmlClass{Function Operator}{\\text{else}}}}\\, \\,\\htmlId{6257}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1148}{\\htmlId{6258}{\\htmlClass{Function}{\\text{gState}}}}\\, \\,\\htmlId{6265}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#936}{\\htmlId{6266}{\\htmlClass{Field}{\\text{dreps}}}}\\,\\,\\htmlId{6271}{\\htmlClass{Symbol}{\\text{))}}}\\,\n                , \\,\\htmlId{6292}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1148}{\\htmlId{6293}{\\htmlClass{Function}{\\text{gState}}}}\\, \\,\\htmlId{6300}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#972}{\\htmlId{6301}{\\htmlClass{Field}{\\text{ccHotKeys}}}}\\,\\,\\htmlId{6310}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Axiom.Set.Map.html#13534}{\\htmlId{6312}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.Enact.html#2583}{\\htmlId{6314}{\\htmlClass{Function}{\\text{ccCreds}}}}\\, \\,\\htmlId{6322}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Conformance.Epoch.html#4753}{\\htmlId{6323}{\\htmlClass{Bound}{\\text{es}}}}\\, \\,\\htmlId{6326}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Enact.html#1670}{\\htmlId{6327}{\\htmlClass{Field}{\\text{cc}}}}\\,\\,\\htmlId{6329}{\\htmlClass{Symbol}{\\text{)}}}\\,\n                , \\,\\href{Ledger.Conway.Conformance.Epoch.html#5847}{\\htmlId{6349}{\\htmlClass{Bound}{\\text{vDeposits}}}}\\,\n                \\end{pmatrix}$\n\n      certState' : CertState\n      certState' = record { dState = dState' ; pState = pState' ; gState = gState' }\n\n      utxoSt' = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Ledger.html#928}{\\htmlId{6511}{\\htmlClass{Function}{\\text{utxoSt}}}}\\, \\,\\htmlId{6518}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Utxo.html#2998}{\\htmlId{6519}{\\htmlClass{Field}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Ledger.html#928}{\\htmlId{6526}{\\htmlClass{Function}{\\text{utxoSt}}}}\\, \\,\\htmlId{6533}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Utxo.html#3020}{\\htmlId{6534}{\\htmlClass{Field}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Ledger.html#928}{\\htmlId{6541}{\\htmlClass{Function}{\\text{utxoSt}}}}\\, \\,\\htmlId{6548}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{6549}{\\htmlClass{Field}{\\text{deposits}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{6558}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{abstract-set-theory.FiniteSetTheory.html#519}{\\htmlId{6560}{\\htmlClass{Function}{\\text{map\u02e2}}}}\\, \\,\\htmlId{6565}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Data.Product.Base.html#636}{\\htmlId{6566}{\\htmlClass{Field}{\\text{proj\u2081}}}}\\, \\,\\href{Function.Base.html#1134}{\\htmlId{6572}{\\htmlClass{Function Operator}{\\text{\u2218}}}}\\, \\,\\href{Data.Product.Base.html#650}{\\htmlId{6574}{\\htmlClass{Field}{\\text{proj\u2082}}}}\\,\\,\\htmlId{6579}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#5148}{\\htmlId{6581}{\\htmlClass{Bound}{\\text{removedGovActions}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{6599}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\\\ \\,\\htmlId{6603}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$\n\n      acnt' = record acnt\n        { treasury  = acnt .treasury \u2238 totWithdrawals + utxoSt .donations + unclaimed }\n\n      stakeDistrs : StakeDistrs\n      stakeDistrs = mkStakeDistrs (Snapshots.mark ss') e utxoSt' govSt' (record { GState (CertState.gState (LState.certState ls)) })\n                                                                        (record { DState (CertState.dState (LState.certState ls)) })\n\n    in\n    record { currentEpoch = e\n           ; stakeDistrs = stakeDistrs\n           ; treasury = acnt .treasury ; GState gState\n           ; pools = pState .pools ; delegatees = dState .voteDelegs }\n        \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#4753}{\\htmlId{7236}{\\htmlClass{Bound}{\\text{es}}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{7241}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\href{Agda.Builtin.Bool.html#192}{\\htmlId{7245}{\\htmlClass{InductiveConstructor}{\\text{false}}}}\\, \\end{pmatrix}$ \u21c0\u2987 govSt' ,RATIFIES\u2988 fut'\n      \u2192 ls \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    _ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#4258}{\\htmlId{7359}{\\htmlClass{Generalizable}{\\text{acnt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4349}{\\htmlId{7366}{\\htmlClass{Generalizable}{\\text{ss}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4244}{\\htmlId{7371}{\\htmlClass{Generalizable}{\\text{ls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4272}{\\htmlId{7376}{\\htmlClass{Generalizable}{\\text{es\u2080}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4189}{\\htmlId{7382}{\\htmlClass{Generalizable}{\\text{fut}}}}\\, \\end{pmatrix}$ \u21c0\u2987 e ,EPOCH\u2988\n        $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#6614}{\\htmlId{7411}{\\htmlClass{Bound}{\\text{acnt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4352}{\\htmlId{7419}{\\htmlClass{Generalizable}{\\text{ss'}}}}\\, \\\\ \\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#6499}{\\htmlId{7427}{\\htmlClass{Bound}{\\text{utxoSt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#5077}{\\htmlId{7437}{\\htmlClass{Bound}{\\text{govSt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#6384}{\\htmlId{7446}{\\htmlClass{Bound}{\\text{certState'}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4753}{\\htmlId{7461}{\\htmlClass{Bound}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4193}{\\htmlId{7466}{\\htmlClass{Generalizable}{\\text{fut'}}}}\\, \\end{pmatrix}$\n\ndata _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_ : \u22a4 \u2192 NewEpochState \u2192 Epoch \u2192 NewEpochState \u2192 Type where\n\n  NEWEPOCH-New :\n    \u2200 {bprev bcur : BlocksMade} {pd : PoolDelegatedStake} \u2192\n    let\n       eps' = applyRUpd ru eps\n       ss   = EpochState.ss eps''\n       pd'  = calculatePoolDelegatedStake (Snapshots.set ss)\n     in\n       \u2219 e \u2261 lastEpoch + 1\n       \u2219 _ \u22a2 eps' \u21c0\u2987 e ,EPOCH\u2988 eps''\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       _ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#4169}{\\htmlId{7891}{\\htmlClass{Generalizable}{\\text{lastEpoch}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#7579}{\\htmlId{7903}{\\htmlClass{Bound}{\\text{bprev}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#7585}{\\htmlId{7911}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4214}{\\htmlId{7918}{\\htmlClass{Generalizable}{\\text{eps}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#173}{\\htmlId{7924}{\\htmlClass{InductiveConstructor}{\\text{just}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#4370}{\\htmlId{7929}{\\htmlClass{Generalizable}{\\text{ru}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#7605}{\\htmlId{7934}{\\htmlClass{Bound}{\\text{pd}}}}\\, \\end{pmatrix}$ \u21c0\u2987 e ,NEWEPOCH\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#4167}{\\htmlId{7957}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#7585}{\\htmlId{7961}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Axiom.Set.Map.html#2671}{\\htmlId{7968}{\\htmlClass{Function}{\\text{\u2205\u1d50}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4223}{\\htmlId{7974}{\\htmlClass{Generalizable}{\\text{eps''}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#194}{\\htmlId{7982}{\\htmlClass{InductiveConstructor}{\\text{nothing}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#7712}{\\htmlId{7992}{\\htmlClass{Bound}{\\text{pd'}}}}\\, \\end{pmatrix}$\n\n  NEWEPOCH-Not-New : \u2200 {bprev bcur : BlocksMade} {pd : PoolDelegatedStake} \u2192\n    \u2219 e \u2262 lastEpoch + 1\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#4169}{\\htmlId{8151}{\\htmlClass{Generalizable}{\\text{lastEpoch}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#8023}{\\htmlId{8163}{\\htmlClass{Bound}{\\text{bprev}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#8029}{\\htmlId{8171}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4214}{\\htmlId{8178}{\\htmlClass{Generalizable}{\\text{eps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4390}{\\htmlId{8184}{\\htmlClass{Generalizable}{\\text{mru}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#8049}{\\htmlId{8190}{\\htmlClass{Bound}{\\text{pd}}}}\\, \\end{pmatrix}$ \u21c0\u2987 e ,NEWEPOCH\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#4169}{\\htmlId{8213}{\\htmlClass{Generalizable}{\\text{lastEpoch}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#8023}{\\htmlId{8225}{\\htmlClass{Bound}{\\text{bprev}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#8029}{\\htmlId{8233}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4214}{\\htmlId{8240}{\\htmlClass{Generalizable}{\\text{eps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4390}{\\htmlId{8246}{\\htmlClass{Generalizable}{\\text{mru}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#8049}{\\htmlId{8252}{\\htmlClass{Bound}{\\text{pd}}}}\\, \\end{pmatrix}$\n\n  NEWEPOCH-No-Reward-Update :\n    \u2200 {bprev bcur : BlocksMade} {pd : PoolDelegatedStake} \u2192\n    let\n      ss  = EpochState.ss eps'\n      pd' = calculatePoolDelegatedStake (Snapshots.set ss)\n    in\n      \u2219 e \u2261 lastEpoch + 1\n      \u2219 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#4169}{\\htmlId{8564}{\\htmlClass{Generalizable}{\\text{lastEpoch}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#8295}{\\htmlId{8576}{\\htmlClass{Bound}{\\text{bprev}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#8301}{\\htmlId{8584}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4214}{\\htmlId{8591}{\\htmlClass{Generalizable}{\\text{eps}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#194}{\\htmlId{8597}{\\htmlClass{InductiveConstructor}{\\text{nothing}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#8321}{\\htmlId{8607}{\\htmlClass{Bound}{\\text{pd}}}}\\, \\end{pmatrix}$ \u21c0\u2987 e ,NEWEPOCH\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Epoch.html#4167}{\\htmlId{8630}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#8301}{\\htmlId{8634}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Axiom.Set.Map.html#2671}{\\htmlId{8641}{\\htmlClass{Function}{\\text{\u2205\u1d50}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#4218}{\\htmlId{8646}{\\htmlClass{Generalizable}{\\text{eps'}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#194}{\\htmlId{8653}{\\htmlClass{InductiveConstructor}{\\text{nothing}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#8393}{\\htmlId{8663}{\\htmlClass{Bound}{\\text{pd'}}}}\\, \\end{pmatrix}$\n</pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Bisimilarity.html","title":"Bisimilarity","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Conformance.Equivalence.Bisimilarity where\n\nopen import Data.Product.Base\n\nrecord Bisimilar {C Sig S\u2081 S\u2082 : Set} (_\u22a2_\u21c0\u2987_\u2988\u2081_ : C \u2192 S\u2081 \u2192 Sig \u2192 S\u2081 \u2192 Set) (_\u22a2_\u21c0\u2987_\u2988\u2082_ : C \u2192 S\u2082 \u2192 Sig \u2192 S\u2082 \u2192 Set) : Set\u2081 where\n  field\n    _\u2248_  : S\u2081 \u2192 S\u2082 \u2192 Set\n    to   : \u2200 {\u0393 sig s\u2081 s\u2081' s\u2082}\n         \u2192 s\u2081 \u2248 s\u2082\n         \u2192 \u0393 \u22a2 s\u2081 \u21c0\u2987 sig \u2988\u2081 s\u2081'\n         \u2192 \u2203[ s\u2082' ] s\u2081' \u2248 s\u2082' \u00d7 \u0393 \u22a2 s\u2082 \u21c0\u2987 sig \u2988\u2082 s\u2082'\n    from : \u2200 {\u0393 sig s\u2081 s\u2082 s\u2082'}\n         \u2192 s\u2081 \u2248 s\u2082\n         \u2192 \u0393 \u22a2 s\u2082 \u21c0\u2987 sig \u2988\u2082 s\u2082'\n         \u2192 \u2203[ s\u2081' ] s\u2081' \u2248 s\u2082' \u00d7 \u0393 \u22a2 s\u2081 \u21c0\u2987 sig \u2988\u2081 s\u2081'\n</pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Certs.html","title":"Certs","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Data.Product using (_\u00d7_; _,_)\nopen import Relation.Binary.PropositionalEquality\n\nopen import Ledger.Conway.Conformance.Equivalence.Convert\n\nmodule Ledger.Conway.Conformance.Equivalence.Certs\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Certs govStructure public\n\n  module C where\n    open import Ledger.Conway.Conformance.Certs govStructure public\n\ninstance\n\n  DStateToConf : L.Deposits \u22a2 L.DState \u2b46 C.DState\n  DStateToConf .conv\u2071 deposits st\u1d48 =\n    let open L.DState st\u1d48 in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#4274}{\\htmlId{919}{\\htmlClass{Field}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4304}{\\htmlId{932}{\\htmlClass{Field}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4335}{\\htmlId{946}{\\htmlClass{Field}{\\text{rewards}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#869}{\\htmlId{956}{\\htmlClass{Bound}{\\text{deposits}}}}\\, \\end{pmatrix}$\n\n  DStateFromConf : C.DState \u2b46 L.DState\n  DStateFromConf .conv\u2071 _ dState =\n    let open C.DState dState in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#752}{\\htmlId{1080}{\\htmlClass{Field}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#782}{\\htmlId{1093}{\\htmlClass{Field}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#822}{\\htmlId{1107}{\\htmlClass{Field}{\\text{rewards}}}}\\, \\end{pmatrix}$\n\n  GStateToConf : L.Deposits \u22a2 L.GState \u2b46 C.GState\n  GStateToConf .conv\u2071 deposits st\u1d4d =\n    let open L.GState st\u1d4d in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#4566}{\\htmlId{1240}{\\htmlClass{Field}{\\text{dreps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4589}{\\htmlId{1248}{\\htmlClass{Field}{\\text{ccHotKeys}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#1190}{\\htmlId{1260}{\\htmlClass{Bound}{\\text{deposits}}}}\\, \\end{pmatrix}$\n\n  GStateFromConf : C.GState \u2b46 L.GState\n  GStateFromConf .conv\u2071 deposits gState =\n    let open C.GState gState in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Certs.html#936}{\\htmlId{1391}{\\htmlClass{Field}{\\text{dreps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#972}{\\htmlId{1399}{\\htmlClass{Field}{\\text{ccHotKeys}}}}\\, \\end{pmatrix}$\n\ndata ValidDeps\u1d48 (pp : PParams) (deps : L.Deposits) : List L.DCert \u2192 Set where\n  []         : ValidDeps\u1d48 pp deps []\n  delegate   : \u2200 {c del kh v certs}\n             \u2192 ValidDeps\u1d48 pp (C.updateCertDeposit pp (L.delegate c del kh v) deps) certs\n             \u2192 ValidDeps\u1d48 pp deps (L.delegate c del kh v \u2237 certs)\n  dereg      : \u2200 {c md d certs}\n             \u2192 (L.CredentialDeposit c , d) \u2208 deps\n             \u2192 md \u2261 nothing \u228e md \u2261 just d\n             \u2192 ValidDeps\u1d48 pp (C.updateCertDeposit pp (L.dereg c md) deps) certs\n             \u2192 ValidDeps\u1d48 pp deps (L.dereg c md \u2237 certs)\n  regdrep    : \u2200 {c v a certs}\n             \u2192 ValidDeps\u1d48 pp deps certs\n             \u2192 ValidDeps\u1d48 pp deps (L.regdrep c v a \u2237 certs)\n  deregdrep  : \u2200 {c d certs}\n             \u2192 ValidDeps\u1d48 pp deps certs\n             \u2192 ValidDeps\u1d48 pp deps (L.deregdrep c d \u2237 certs)\n  regpool    : \u2200 {kh p certs}\n             \u2192 ValidDeps\u1d48 pp deps certs\n             \u2192 ValidDeps\u1d48 pp deps (L.regpool kh p \u2237 certs)\n  retirepool : \u2200 {kh e certs}\n             \u2192 ValidDeps\u1d48 pp deps certs\n             \u2192 ValidDeps\u1d48 pp deps (L.retirepool kh e  \u2237 certs)\n  ccreghot   : \u2200 {c v certs}\n             \u2192 ValidDeps\u1d48 pp deps certs\n             \u2192 ValidDeps\u1d48 pp deps (L.ccreghot c v \u2237 certs)\n  reg        : \u2200 {c d certs}\n             \u2192 ValidDeps\u1d48 pp (C.updateCertDeposit pp (L.reg c d) deps) certs\n             \u2192 ValidDeps\u1d48 pp deps (L.reg c d \u2237 certs)\n\ndata ValidDeps\u1d4d (pp : PParams) (deps : L.Deposits) : List L.DCert \u2192 Set where\n  []         : ValidDeps\u1d4d pp deps []\n  regdrep    : \u2200 {c v a certs}\n             \u2192 ValidDeps\u1d4d pp (C.updateCertDeposit pp (L.regdrep c v a) deps) certs\n             \u2192 ValidDeps\u1d4d pp deps (L.regdrep c v a \u2237 certs)\n  deregdrep  : \u2200 {c d certs}\n             \u2192 (L.DRepDeposit c , d) \u2208 deps\n             \u2192 ValidDeps\u1d4d pp (C.updateCertDeposit pp (L.deregdrep c d) deps) certs\n             \u2192 ValidDeps\u1d4d pp deps (L.deregdrep c d \u2237 certs)\n  delegate   : \u2200 {c del kh v certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.delegate c del kh v \u2237 certs)\n  dereg      : \u2200 {c d certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.dereg c d \u2237 certs)\n  regpool    : \u2200 {kh p certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.regpool kh p \u2237 certs)\n  retirepool : \u2200 {kh e certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.retirepool kh e  \u2237 certs)\n  ccreghot   : \u2200 {c v certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.ccreghot c v \u2237 certs)\n  reg        : \u2200 {c d certs}\n             \u2192 ValidDeps\u1d4d pp deps certs\n             \u2192 ValidDeps\u1d4d pp deps (L.reg c d \u2237 certs)\n\nrecord CertDeps* (pp : PParams) (dcerts : List L.DCert) : Set where\n  constructor \u27e6_,_,_,_\u27e7*\n  field\n    deps\u1d48 : L.Deposits\n    deps\u1d4d : L.Deposits\n    -- Invariants\n    valid\u1d48 : ValidDeps\u1d48 pp deps\u1d48 dcerts\n    valid\u1d4d : ValidDeps\u1d4d pp deps\u1d4d dcerts\n\npattern delegate*    ddeps gdeps = $\\begin{pmatrix} \\,\\htmlId{4359}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4363}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4367}{\\htmlClass{InductiveConstructor}{\\text{delegate}}}\\,   \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4378}{\\htmlId{4378}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\htmlId{4386}{\\htmlClass{InductiveConstructor}{\\text{delegate}}}\\,    \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4398}{\\htmlId{4398}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\npattern dereg*  v w  ddeps gdeps = $\\begin{pmatrix} \\,\\htmlId{4444}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4448}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4452}{\\htmlClass{InductiveConstructor}{\\text{dereg}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4458}{\\htmlId{4458}{\\htmlClass{Bound}{\\text{v}}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4460}{\\htmlId{4460}{\\htmlClass{Bound}{\\text{w}}}}\\,  \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4463}{\\htmlId{4463}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\htmlId{4471}{\\htmlClass{InductiveConstructor}{\\text{dereg}}}\\,       \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4483}{\\htmlId{4483}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\npattern regpool*     ddeps gdeps = $\\begin{pmatrix} \\,\\htmlId{4529}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4533}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4537}{\\htmlClass{InductiveConstructor}{\\text{regpool}}}\\,    \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4548}{\\htmlId{4548}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\htmlId{4556}{\\htmlClass{InductiveConstructor}{\\text{regpool}}}\\,     \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4568}{\\htmlId{4568}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\npattern retirepool*  ddeps gdeps = $\\begin{pmatrix} \\,\\htmlId{4614}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4618}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4622}{\\htmlClass{InductiveConstructor}{\\text{retirepool}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4633}{\\htmlId{4633}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\htmlId{4641}{\\htmlClass{InductiveConstructor}{\\text{retirepool}}}\\,  \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4653}{\\htmlId{4653}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\npattern regdrep*     ddeps gdeps = $\\begin{pmatrix} \\,\\htmlId{4699}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4703}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4707}{\\htmlClass{InductiveConstructor}{\\text{regdrep}}}\\,    \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4718}{\\htmlId{4718}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\htmlId{4726}{\\htmlClass{InductiveConstructor}{\\text{regdrep}}}\\,     \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4738}{\\htmlId{4738}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\npattern deregdrep* v ddeps gdeps = $\\begin{pmatrix} \\,\\htmlId{4784}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4788}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4792}{\\htmlClass{InductiveConstructor}{\\text{deregdrep}}}\\,  \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4803}{\\htmlId{4803}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\htmlId{4811}{\\htmlClass{InductiveConstructor}{\\text{deregdrep}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4821}{\\htmlId{4821}{\\htmlClass{Bound}{\\text{v}}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4823}{\\htmlId{4823}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\npattern ccreghot*    ddeps gdeps = $\\begin{pmatrix} \\,\\htmlId{4869}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4873}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4877}{\\htmlClass{InductiveConstructor}{\\text{ccreghot}}}\\,   \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4888}{\\htmlId{4888}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\htmlId{4896}{\\htmlClass{InductiveConstructor}{\\text{ccreghot}}}\\,    \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4908}{\\htmlId{4908}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\npattern reg*         ddeps gdeps = $\\begin{pmatrix} \\,\\htmlId{4954}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4958}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{4962}{\\htmlClass{InductiveConstructor}{\\text{reg}}}\\,        \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4973}{\\htmlId{4973}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\htmlId{4981}{\\htmlClass{InductiveConstructor}{\\text{reg}}}\\,         \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#4993}{\\htmlId{4993}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\n\nopen CertDeps*\n\ngetCertDeps* : \u2200 {pp dcert} \u2192 CertDeps* pp dcert \u2192 L.Deposits \u00d7 L.Deposits\ngetCertDeps* deps = deps .deps\u1d48 , deps .deps\u1d4d\n\nupdateCertDeps : \u2200 {pp dcert dcerts} \u2192 CertDeps* pp (dcert \u2237 dcerts) \u2192 CertDeps* pp dcerts\nupdateCertDeps (delegate*    ddeps gdeps) = $\\begin{pmatrix} \\,\\htmlId{5278}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{5282}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5261}{\\htmlId{5286}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5267}{\\htmlId{5294}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\nupdateCertDeps (dereg* _ _   ddeps gdeps) = $\\begin{pmatrix} \\,\\htmlId{5349}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{5353}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5332}{\\htmlId{5357}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5338}{\\htmlId{5365}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\nupdateCertDeps (regpool*     ddeps gdeps) = $\\begin{pmatrix} \\,\\htmlId{5420}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{5424}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5403}{\\htmlId{5428}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5409}{\\htmlId{5436}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\nupdateCertDeps (retirepool*  ddeps gdeps) = $\\begin{pmatrix} \\,\\htmlId{5491}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{5495}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5474}{\\htmlId{5499}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5480}{\\htmlId{5507}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\nupdateCertDeps (regdrep*     ddeps gdeps) = $\\begin{pmatrix} \\,\\htmlId{5562}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{5566}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5545}{\\htmlId{5570}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5551}{\\htmlId{5578}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\nupdateCertDeps (deregdrep* _ ddeps gdeps) = $\\begin{pmatrix} \\,\\htmlId{5633}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{5637}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5616}{\\htmlId{5641}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5622}{\\htmlId{5649}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\nupdateCertDeps (ccreghot*    ddeps gdeps) = $\\begin{pmatrix} \\,\\htmlId{5704}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{5708}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5687}{\\htmlId{5712}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5693}{\\htmlId{5720}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\nupdateCertDeps (reg*         ddeps gdeps) = $\\begin{pmatrix} \\,\\htmlId{5775}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{5779}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5758}{\\htmlId{5783}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#5764}{\\htmlId{5791}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$\n\nupdateCertDeps* : \u2200 {pp} dcerts \u2192 CertDeps* pp dcerts \u2192 CertDeps* pp []\nupdateCertDeps* []               deps = deps\nupdateCertDeps* (dcert \u2237 dcerts) deps = updateCertDeps* dcerts (updateCertDeps deps)\n\ninstance\n\n  CertStToConf : L.Deposits \u00d7 L.Deposits \u22a2 L.CertState \u2b46 C.CertState\n  CertStToConf .conv\u2071 (ddeps , gdeps) certState =\n    let open L.CertState certState in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#6106}{\\htmlId{6177}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#377}{\\htmlId{6183}{\\htmlClass{Function Operator}{\\text{\u22a2conv}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#4734}{\\htmlId{6189}{\\htmlClass{Field}{\\text{dState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4754}{\\htmlId{6198}{\\htmlClass{Field}{\\text{pState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Certs.html#6114}{\\htmlId{6207}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#377}{\\htmlId{6213}{\\htmlClass{Function Operator}{\\text{\u22a2conv}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#4774}{\\htmlId{6219}{\\htmlClass{Field}{\\text{gState}}}}\\, \\end{pmatrix}$\n\n  CertStFromConf : C.CertState \u2b46 L.CertState\n  CertStFromConf .conv\u2071 _ certState =\n    let open C.CertState certState in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#559}{\\htmlId{6356}{\\htmlClass{Function}{\\text{conv}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#1108}{\\htmlId{6361}{\\htmlClass{Field}{\\text{dState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#1128}{\\htmlId{6370}{\\htmlClass{Field}{\\text{pState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#559}{\\htmlId{6379}{\\htmlClass{Function}{\\text{conv}}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#1148}{\\htmlId{6384}{\\htmlClass{Field}{\\text{gState}}}}\\, \\end{pmatrix}$\n\n  PRE-CERTToConf : \u2200 {\u0393 s s'}\n                 \u2192 L.Deposits \u00d7 L.Deposits\n                   \u22a2 \u0393 L.\u22a2 s \u21c0\u2987 _ ,PRE-CERT\u2988 s' \u2b46\u2071 \u03bb deposits _ \u2192\n                     \u0393 C.\u22a2 (deposits \u22a2conv s) \u21c0\u2987 _ ,PRE-CERT\u2988 (deposits \u22a2conv s')\n  PRE-CERTToConf .conv\u2071 deposits (L.CERT-pre h) = C.CERT-pre h\n\n  POST-CERTToConf : \u2200 {\u0393 s s'}\n                 \u2192 L.Deposits \u00d7 L.Deposits\n                   \u22a2 \u0393 L.\u22a2 s \u21c0\u2987 _ ,POST-CERT\u2988 s' \u2b46\u2071 \u03bb deposits _ \u2192\n                     \u0393 C.\u22a2 (deposits \u22a2conv s) \u21c0\u2987 _ ,POST-CERT\u2988 (deposits \u22a2conv s')\n  POST-CERTToConf .conv\u2071 deposits L.CERT-post = C.CERT-post\n\n  DELEGToConf : \u2200 {\u0393 s dcert dcerts s'}\n                  (open L.DelegEnv \u0393 renaming (pparams to pp))\n              \u2192 CertDeps* pp (dcert \u2237 dcerts) \u22a2\n                 \u0393 L.\u22a2 s \u21c0\u2987 dcert ,DELEG\u2988 s' \u2b46\u2071 \u03bb deposits _ \u2192\n                 \u0393 C.\u22a2 (deposits .deps\u1d48 \u22a2conv s) \u21c0\u2987 dcert ,DELEG\u2988 (updateCertDeps deposits .deps\u1d48 \u22a2conv s')\n  DELEGToConf .conv\u2071 (delegate* _ _) (L.DELEG-delegate h) = C.DELEG-delegate h\n  DELEGToConf .conv\u2071 (dereg* v w _ _)  (L.DELEG-dereg h)    = C.DELEG-dereg (h , v , w)\n  DELEGToConf .conv\u2071 (reg* _ _) (L.DELEG-reg h) = C.DELEG-reg h\n\n  POOLToConf : \u2200 {pp s dcert s'} \u2192 pp L.\u22a2 s \u21c0\u2987 dcert ,POOL\u2988 s' \u2b46 pp C.\u22a2 s \u21c0\u2987 dcert ,POOL\u2988 s'\n  POOLToConf .conv\u2071 _ L.POOL-regpool = C.POOL-regpool\n  POOLToConf .conv\u2071 _ L.POOL-retirepool  = C.POOL-retirepool\n\n  GOVCERTToConf : \u2200 {\u0393 s dcert dcerts s'}\n                  (open L.CertEnv \u0393 using (pp))\n                \u2192 CertDeps* pp (dcert \u2237 dcerts) \u22a2\n                   \u0393 L.\u22a2 s \u21c0\u2987 dcert ,GOVCERT\u2988 s' \u2b46\u2071 \u03bb deposits _ \u2192\n                   \u0393 C.\u22a2 (deposits .deps\u1d4d \u22a2conv s) \u21c0\u2987 dcert ,GOVCERT\u2988 (updateCertDeps deposits .deps\u1d4d \u22a2conv s')\n  GOVCERTToConf .conv\u2071 (regdrep* _ _)     (L.GOVCERT-regdrep h) = C.GOVCERT-regdrep h\n  GOVCERTToConf .conv\u2071 (deregdrep* v _ _) (L.GOVCERT-deregdrep h) = C.GOVCERT-deregdrep (h , v)\n  GOVCERTToConf .conv\u2071 (ccreghot* _ _)    (L.GOVCERT-ccreghot h)  = C.GOVCERT-ccreghot h\n\n  CERTToConf : \u2200 {\u0393 s dcert dcerts s'} (open L.CertEnv \u0393 using (pp))\n             \u2192 CertDeps* pp (dcert \u2237 dcerts) \u22a2\n                \u0393 L.\u22a2 s \u21c0\u2987 dcert ,CERT\u2988 s' \u2b46\u2071 \u03bb deposits _ \u2192\n                \u0393 C.\u22a2 (getCertDeps* deposits \u22a2conv s) \u21c0\u2987 dcert ,CERT\u2988 (getCertDeps* (updateCertDeps deposits) \u22a2conv s')\n  CERTToConf .conv\u2071 deposits@(delegate* _ _)    (L.CERT-deleg deleg)  = C.CERT-deleg (deposits \u22a2conv deleg)\n  CERTToConf .conv\u2071 deposits@(dereg* _ _ _ _)   (L.CERT-deleg deleg)  = C.CERT-deleg (deposits \u22a2conv deleg)\n  CERTToConf .conv\u2071 deposits@(regpool* _ _)     (L.CERT-pool pool)    = C.CERT-pool (conv pool)\n  CERTToConf .conv\u2071 deposits@(retirepool* _ _)  (L.CERT-pool pool)    = C.CERT-pool (conv pool)\n  CERTToConf .conv\u2071 deposits@(regdrep* _ _)     (L.CERT-vdel govcert) = C.CERT-vdel (deposits \u22a2conv govcert)\n  CERTToConf .conv\u2071 deposits@(deregdrep* _ _ _) (L.CERT-vdel govcert) = C.CERT-vdel (deposits \u22a2conv govcert)\n  CERTToConf .conv\u2071 deposits@(ccreghot* _ _)    (L.CERT-vdel govcert) = C.CERT-vdel (deposits \u22a2conv govcert)\n  CERTToConf .conv\u2071 deposits@(reg* _ _)         (L.CERT-deleg deleg)  = C.CERT-deleg (deposits \u22a2conv deleg)\n\n  CERT-POST-CERTToConf : \u2200 {\u0393 s dcerts s'} (let open L.CertEnv \u0393)\n    \u2192 CertDeps* pp dcerts\n      \u22a2 RunTraceAndThen L._\u22a2_\u21c0\u2987_,CERT\u2988_ L._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s dcerts s'\n        \u2b46\u2071 \u03bb deposits _ \u2192 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_\n                            \u0393 (getCertDeps* deposits \u22a2conv s) dcerts\n                              (getCertDeps* (updateCertDeps* dcerts deposits) \u22a2conv s')\n  CERT-POST-CERTToConf .conv\u2071 deposits (run-[] x) = run-[] ((deposits .deps\u1d48 , deposits .deps\u1d4d) \u22a2conv x)\n  CERT-POST-CERTToConf .conv\u2071 deposits (run-\u2237 x x\u2081) = run-\u2237 (deposits \u22a2conv x) (updateCertDeps deposits \u22a2conv x\u2081)\n\n\n  CERTSToConf : \u2200 {\u0393 s dcerts s'} (let open L.CertEnv \u0393)\n    \u2192 CertDeps* pp dcerts\n      \u22a2 RunTraceAfterAndThen L._\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ L._\u22a2_\u21c0\u2987_,CERT\u2988_ L._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s dcerts s'\n      \u2b46\u2071 \u03bb deposits _ \u2192 RunTraceAfterAndThen C._\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_\n                          \u0393 (getCertDeps* deposits \u22a2conv s) dcerts\n                            (getCertDeps* (updateCertDeps* dcerts deposits) \u22a2conv s')\n  CERTSToConf .conv\u2071 deposits (run (pre , cert-post)) = run (getCertDeps* deposits \u22a2conv pre , deposits \u22a2conv cert-post)\n\n-- Converting form Conformance is easier since the deposit tracking disappears.\ninstance\n  DELEGFromConf : \u2200 {\u0393 s dcert s'}\n                \u2192 \u0393 C.\u22a2 s \u21c0\u2987 dcert ,DELEG\u2988 s' \u2b46\n                  \u0393 L.\u22a2 conv s \u21c0\u2987 dcert ,DELEG\u2988 conv s'\n  DELEGFromConf .conv\u2071 _ (C.DELEG-delegate h)    = L.DELEG-delegate h\n  DELEGFromConf .conv\u2071 _ (C.DELEG-dereg (h , _)) = L.DELEG-dereg h\n  DELEGFromConf .conv\u2071 _ (C.DELEG-reg h)         = L.DELEG-reg h\n\n  GOVCERTFromConf : \u2200 {\u0393 s dcert s'}\n                  \u2192 \u0393 C.\u22a2 s \u21c0\u2987 dcert ,GOVCERT\u2988 s' \u2b46\n                    \u0393 L.\u22a2 conv s \u21c0\u2987 dcert ,GOVCERT\u2988 conv s'\n  GOVCERTFromConf .conv\u2071 _ (C.GOVCERT-regdrep h)   = C.GOVCERT-regdrep h\n  GOVCERTFromConf .conv\u2071 _ (C.GOVCERT-deregdrep (h , _)) = C.GOVCERT-deregdrep h\n  GOVCERTFromConf .conv\u2071 _ (C.GOVCERT-ccreghot h)  = C.GOVCERT-ccreghot h\n\n  CERTFromConf : \u2200 {\u0393 s dcert s'} \u2192 \u0393 C.\u22a2 s \u21c0\u2987 dcert ,CERT\u2988 s' \u2b46 \u0393 L.\u22a2 conv s \u21c0\u2987 dcert ,CERT\u2988 conv s'\n  CERTFromConf .conv\u2071 _ (C.CERT-deleg deleg)  = L.CERT-deleg (conv deleg)\n  CERTFromConf .conv\u2071 _ (C.CERT-pool pool)    = L.CERT-pool (conv pool)\n  CERTFromConf .conv\u2071 _ (C.CERT-vdel govcert) = L.CERT-vdel (conv govcert)\n\n  PRE-CERTFromConf : \u2200 {\u0393 s s'}\n                   \u2192 \u0393 C.\u22a2 s \u21c0\u2987 _ ,PRE-CERT\u2988 s' \u2b46\n                     \u0393 L.\u22a2 (conv s) \u21c0\u2987 _ ,PRE-CERT\u2988 (conv s')\n  PRE-CERTFromConf .conv\u2071 _ (C.CERT-pre h) = L.CERT-pre h\n\n  POST-CERTFromConf : \u2200 {\u0393 s s'}\n                   \u2192 \u0393 C.\u22a2 s \u21c0\u2987 _ ,POST-CERT\u2988 s' \u2b46\n                     \u0393 L.\u22a2 (conv s) \u21c0\u2987 _ ,POST-CERT\u2988 (conv s')\n  POST-CERTFromConf .conv\u2071 _ C.CERT-post = L.CERT-post\n\n\n  CERT-POST-CERTFromConf : \u2200 {\u0393 s dcerts s'}\n    \u2192 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s dcerts s'\n      \u2b46 RunTraceAndThen L._\u22a2_\u21c0\u2987_,CERT\u2988_ L._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 (conv s) dcerts (conv s')\n  CERT-POST-CERTFromConf .conv\u2071 _ (run-[] x) = run-[] (conv x)\n  CERT-POST-CERTFromConf .conv\u2071 _ (run-\u2237 x xs) = run-\u2237 (conv x) (conv xs)\n\n\n  CERTSFromConf : \u2200 {\u0393 s dcerts s'}\n                 \u2192 RunTraceAfterAndThen C._\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s dcerts s' \u2b46\n                   RunTraceAfterAndThen L._\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ L._\u22a2_\u21c0\u2987_,CERT\u2988_ L._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 (conv s) dcerts (conv s')\n  CERTSFromConf .conv\u2071 _ (run (pre , cert-post)) = run ((conv pre) , conv cert-post)\n</pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Convert.html","title":"Convert","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Conformance.Equivalence.Convert where\n\nopen import Data.Unit.Base using (\u22a4)\n\ninfixr 1 _\u22a2_\u2b46\u2071_ _\u22a2_\u2b46_ _\u2b46_\nrecord _\u22a2_\u2b46\u2071_ (I L : Set) (C : I \u2192 L \u2192 Set) : Set where\n  field\n    conv\u2071 : (i : I) (l : L) \u2192 C i l\n\nopen _\u22a2_\u2b46\u2071_ public\n\n_\u22a2conv_ : \u2200 {I L C} \u2192 \u2983 I \u22a2 L \u2b46\u2071 C \u2984 \u2192 \u2200 i l \u2192 C i l\n_\u22a2conv_ \u2983 c \u2984 = c .conv\u2071\n\n_\u22a2_\u2b46_ : (I L C : Set) \u2192 Set\nI \u22a2 L \u2b46 C = I \u22a2 L \u2b46\u2071 \u03bb _ _ \u2192 C\n\n_\u2b46_ : (L C : Set) \u2192 Set\nL \u2b46 C = \u22a4 \u22a2 L \u2b46 C\n\nconv : \u2200 {L C} \u2192 \u2983 \u22a4 \u22a2 L \u2b46\u2071 C \u2984 \u2192 \u2200 l \u2192 C _ l\nconv l = _ \u22a2conv l\n</pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Deposits.html","title":"Deposits","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Data.Unit using (\u22a4)\nopen import Data.Product using (_\u00d7_; _,_)\nopen import Data.Product.Relation.Binary.Pointwise.NonDependent using (Pointwise)\nopen import Relation.Binary.PropositionalEquality\nimport Relation.Binary.Reasoning.Setoid as SetoidReasoning\nopen import Relation.Binary using (Setoid; IsEquivalence)\nimport Algebra.Structures as AlgStruct\n\nmodule Ledger.Conway.Conformance.Equivalence.Deposits\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Ledger txs abs public\n    open import Ledger.Conway.Specification.Utxo txs abs public\n    open import Ledger.Conway.Specification.Certs govStructure public\n\n  module C where\n    open import Ledger.Conway.Conformance.Ledger txs abs public\n    open import Ledger.Conway.Conformance.Utxo txs abs public\n    open import Ledger.Conway.Conformance.Certs govStructure public\n\nopen Tx\nopen import Ledger.Conway.Conformance.Equivalence.Map\nopen import Ledger.Conway.Conformance.Equivalence.Certs txs abs\nopen import Axiom.Set.Properties th using (\u2261\u1d49-Setoid; \u2261\u1d49-isEquivalence)\n\n-- TODO: some hoop-jumping required since the Map proofs needs the\n-- stdlib IsCommutativeSemigroup for Coin.\nopen AlgStruct {A = Coin} _\u2261_ using (IsCommutativeSemigroup)\nopen import Data.Nat.Properties using (+-isCommutativeSemigroup)\ninstance\n  Coin-Semigroup : IsCommutativeSemigroup _+_\n  Coin-Semigroup = +-isCommutativeSemigroup\n\n-- TODO: The proofs in this module are kind of a mess! They've grown organically based on\n--       the specific needs of the equivalence proof and could really use some cleaning up.\n--       Both when it comes to naming and when it comes to not proving the same thing several\n--       times.\n\nupdateDDep : PParams \u2192 L.DCert \u2192 L.Deposits \u2192 L.Deposits\nupdateDDep pp cert@(L.delegate _ _ _ _) deps = C.updateCertDeposit pp cert deps\nupdateDDep pp cert@(L.dereg _ _)        deps = C.updateCertDeposit pp cert deps\nupdateDDep pp cert@(L.reg _ _)          deps = C.updateCertDeposit pp cert deps\nupdateDDep pp cert                      deps = deps\n\nupdateDDeps : PParams \u2192 List L.DCert \u2192 L.Deposits \u2192 L.Deposits\nupdateDDeps pp []             deps = deps\nupdateDDeps pp (cert \u2237 certs) deps = updateDDeps pp certs (updateDDep pp cert deps)\n\nupdateGDep : PParams \u2192 L.DCert \u2192 L.Deposits \u2192 L.Deposits\nupdateGDep pp cert@(L.regdrep _ _ _) deps = C.updateCertDeposit pp cert deps\nupdateGDep pp cert@(L.deregdrep _ _) deps = C.updateCertDeposit pp cert deps\nupdateGDep pp cert                   deps = deps\n\nupdateGDeps : PParams \u2192 List L.DCert \u2192 L.Deposits \u2192 L.Deposits\nupdateGDeps pp []             deps = deps\nupdateGDeps pp (cert \u2237 certs) deps = updateGDeps pp certs (updateGDep pp cert deps)\n\nupdateLedgerDeps : PParams \u2192 Tx \u2192 L.Deposits \u00d7 L.Deposits \u2192 L.Deposits \u00d7 L.Deposits\nupdateLedgerDeps pp tx deps@(ddeps , gdeps) = updateDDeps pp certs ddeps , updateGDeps pp certs gdeps\n  where\n    certs = DCertsOf tx\n\ndata DPurpose : L.DepositPurpose \u2192 Set where\n  CredentialDeposit : \u2200 {c} \u2192 DPurpose (L.CredentialDeposit c)\n\ndata GPurpose : L.DepositPurpose \u2192 Set where\n  DRepDeposit : \u2200 {c} \u2192 GPurpose (L.DRepDeposit c)\n\ninstance\n  Dec-DPurpose? : \u2200 {p} \u2192 DPurpose p \u2047\n  Dec-DPurpose? {L.CredentialDeposit _} = \u2047 yes CredentialDeposit\n  Dec-DPurpose? {L.PoolDeposit       _} = \u2047 no \u03bb ()\n  Dec-DPurpose? {L.DRepDeposit       _} = \u2047 no \u03bb ()\n  Dec-DPurpose? {L.GovActionDeposit  _} = \u2047 no \u03bb ()\n\n  Dec-GPurpose? : \u2200 {p} \u2192 GPurpose p \u2047\n  Dec-GPurpose? {L.CredentialDeposit _} = \u2047 no \u03bb ()\n  Dec-GPurpose? {L.PoolDeposit       _} = \u2047 no \u03bb ()\n  Dec-GPurpose? {L.DRepDeposit       _} = \u2047 yes DRepDeposit\n  Dec-GPurpose? {L.GovActionDeposit  _} = \u2047 no \u03bb ()\n\n-- Compute DDeps for the CertState from full Deposits\ncertDDeps : L.Deposits \u2192 L.Deposits\ncertDDeps deps = filter\u1d50 (\u03bb (k , _) \u2192 DPurpose k) deps\n\n-- Compute GDeps for the CertState from full Deposits\ncertGDeps : L.Deposits \u2192 L.Deposits\ncertGDeps deps = filter\u1d50 (\u03bb (k , _) \u2192 GPurpose k) deps\n\ncong-updateCertDeposit : \u2200 pp cert {deps\u2081 deps\u2082}\n                       \u2192 deps\u2081 \u2261\u1d50 deps\u2082\n                       \u2192 C.updateCertDeposit pp cert deps\u2081 \u2261\u1d50 C.updateCertDeposit pp cert deps\u2082\ncong-updateCertDeposit pp (L.delegate c kh del v)            eq = \u222a\u207a-cong-r eq\ncong-updateCertDeposit pp (L.dereg x x\u2081) {deps\u2081} {deps\u2082}     eq = restrict-cong deps\u2081 deps\u2082 eq\ncong-updateCertDeposit pp (L.regpool x x\u2081)                   eq = \u222a\u207a-cong-r eq\ncong-updateCertDeposit pp (L.retirepool x x\u2081)                eq = eq\ncong-updateCertDeposit pp (L.regdrep x x\u2081 x\u2082)                eq = \u222a\u207a-cong-r eq\ncong-updateCertDeposit pp (L.deregdrep x x\u2081) {deps\u2081} {deps\u2082} eq = restrict-cong deps\u2081 deps\u2082 eq\ncong-updateCertDeposit pp (L.ccreghot x x\u2081)                  eq = eq\ncong-updateCertDeposit pp (L.reg x x\u2081)                       eq = \u222a\u207a-cong-r eq\n\ncong-certDDeps : \u2200 deps\u2081 deps\u2082 \u2192 deps\u2081 \u2261\u1d50 deps\u2082 \u2192 certDDeps deps\u2081 \u2261\u1d50 certDDeps deps\u2082\ncong-certDDeps = cong-filter\u1d50\n\ncong-certGDeps : \u2200 deps\u2081 deps\u2082 \u2192 deps\u2081 \u2261\u1d50 deps\u2082 \u2192 certGDeps deps\u2081 \u2261\u1d50 certGDeps deps\u2082\ncong-certGDeps = cong-filter\u1d50\n\ncastValidDeps\u1d48 : \u2200 {pp deps\u2081 deps\u2082 certs} \u2192 deps\u2081 \u2261\u1d50 deps\u2082 \u2192 ValidDeps\u1d48 pp deps\u2081 certs \u2192 ValidDeps\u1d48 pp deps\u2082 certs\ncastValidDeps\u1d48                         eq [] = []\ncastValidDeps\u1d48 {pp} {certs = cert \u2237 _} eq (delegate   deps) = delegate           (castValidDeps\u1d48 (cong-updateCertDeposit pp cert eq) deps)\ncastValidDeps\u1d48 {pp} {deps\u2081} {deps\u2082} {certs = cert \u2237 _} eq (dereg h h' deps) =\n  dereg (proj\u2081 eq h) h'\n        (castValidDeps\u1d48 (cong-updateCertDeposit pp cert {deps\u2081} {deps\u2082} eq) deps)\n--castValidDeps\u1d48 {pp} {deps\u2081} {deps\u2082}\n--                    {certs = cert \u2237 _} eq (dereg h    deps) = dereg (map\u2082 (proj\u2081 eq) h) (castValidDeps\u1d48 (cong-updateCertDeposit\n--                                                                                                    pp cert {deps\u2081} {deps\u2082} eq) deps)\ncastValidDeps\u1d48 {pp} {certs = cert \u2237 _} eq (reg        deps) = reg (castValidDeps\u1d48 (cong-updateCertDeposit pp cert eq) deps)\ncastValidDeps\u1d48                         eq (regdrep    deps) = regdrep            (castValidDeps\u1d48 eq deps)\ncastValidDeps\u1d48                         eq (deregdrep  deps) = deregdrep          (castValidDeps\u1d48 eq deps)\ncastValidDeps\u1d48                         eq (regpool    deps) = regpool            (castValidDeps\u1d48 eq deps)\ncastValidDeps\u1d48                         eq (retirepool deps) = retirepool         (castValidDeps\u1d48 eq deps)\ncastValidDeps\u1d48                         eq (ccreghot   deps) = ccreghot           (castValidDeps\u1d48 eq deps)\n\ncastValidDeps\u1d4d : \u2200 {pp deps\u2081 deps\u2082 certs} \u2192 deps\u2081 \u2261\u1d50 deps\u2082 \u2192 ValidDeps\u1d4d pp deps\u2081 certs \u2192 ValidDeps\u1d4d pp deps\u2082 certs\ncastValidDeps\u1d4d   eq [] = []\ncastValidDeps\u1d4d   eq (delegate    deps) = delegate   (castValidDeps\u1d4d eq deps)\ncastValidDeps\u1d4d   eq (dereg       deps) = dereg      (castValidDeps\u1d4d eq deps)\ncastValidDeps\u1d4d {pp} {certs = cert \u2237 _}\n                 eq (regdrep     deps) = regdrep    (castValidDeps\u1d4d (cong-updateCertDeposit pp cert eq) deps)\ncastValidDeps\u1d4d {pp} {deps\u2081} {deps\u2082} {certs = cert \u2237 _}\n  eq (deregdrep h deps) = deregdrep (proj\u2081 eq h)    (castValidDeps\u1d4d (cong-updateCertDeposit pp cert {deps\u2081} {deps\u2082} eq) deps)\ncastValidDeps\u1d4d   eq (regpool     deps) = regpool    (castValidDeps\u1d4d eq deps)\ncastValidDeps\u1d4d   eq (retirepool  deps) = retirepool (castValidDeps\u1d4d eq deps)\ncastValidDeps\u1d4d   eq (ccreghot    deps) = ccreghot   (castValidDeps\u1d4d eq deps)\ncastValidDeps\u1d4d   eq (reg         deps) = reg        (castValidDeps\u1d4d eq deps)\n\nvalidDDeps : \u2200 {pp certs deps} \u2192 L.ValidCertDeposits pp deps certs \u2192 ValidDeps\u1d48 pp (certDDeps deps) certs\nvalidDDeps                L.[]             = []\nvalidDDeps               (L.delegate    v) = delegate   (castValidDeps\u1d48 (lem-add-included CredentialDeposit) (validDDeps v))\nvalidDDeps               (L.regpool     v) = regpool    (castValidDeps\u1d48 (lem-add-excluded \u03bb ()) (validDDeps v))\nvalidDDeps               (L.regdrep     v) = regdrep    (castValidDeps\u1d48 (lem-add-excluded \u03bb ()) (validDDeps v))\nvalidDDeps {deps = deps} (L.dereg h h'  v) = dereg      (filter\u1d50-\u2208 deps CredentialDeposit h) h'\n                                                        (castValidDeps\u1d48 (filter\u1d50-restrict deps) (validDDeps v))\nvalidDDeps {deps = deps} (L.deregdrep _ v) = deregdrep  (castValidDeps\u1d48 (lem-del-excluded deps \u03bb ()) (validDDeps v))\nvalidDDeps               (L.ccreghot    v) = ccreghot   (validDDeps v)\nvalidDDeps               (L.retirepool  v) = retirepool (validDDeps v)\nvalidDDeps {deps = deps} (L.reg         v) = reg (castValidDeps\u1d48 (lem-add-included CredentialDeposit) (validDDeps v))\n\nvalidGDeps : \u2200 {pp certs deps} \u2192 L.ValidCertDeposits pp deps certs \u2192 ValidDeps\u1d4d pp (certGDeps deps) certs\nvalidGDeps                L.[]             = []\nvalidGDeps               (L.delegate    v) = delegate   (castValidDeps\u1d4d (lem-add-excluded \u03bb ()) (validGDeps v))\nvalidGDeps               (L.regpool     v) = regpool    (castValidDeps\u1d4d (lem-add-excluded \u03bb ()) (validGDeps v))\nvalidGDeps               (L.regdrep     v) = regdrep    (castValidDeps\u1d4d (lem-add-included DRepDeposit) (validGDeps v))\nvalidGDeps {deps = deps} (L.dereg _ _   v) = dereg      (castValidDeps\u1d4d (lem-del-excluded deps \u03bb ()) (validGDeps v))\nvalidGDeps {deps = deps} (L.deregdrep h v) = deregdrep  (filter\u1d50-\u2208 deps DRepDeposit h)\n                                                        (castValidDeps\u1d4d (filter\u1d50-restrict deps) (validGDeps v))\nvalidGDeps               (L.ccreghot    v) = ccreghot   (validGDeps v)\nvalidGDeps               (L.retirepool  v) = retirepool (validGDeps v)\nvalidGDeps               (L.reg         v) = reg (castValidDeps\u1d4d (lem-add-excluded \u03bb ()) (validGDeps v))\n\nlem-upd-prop-ddeps : \u2200 {txid} {gaDep} props deps\n                   \u2192 certDDeps deps \u2261\u1d50 certDDeps (L.updateProposalDeposits props txid gaDep deps)\nlem-upd-prop-ddeps [] deps = id , id\nlem-upd-prop-ddeps {txid} {gaDep} (_ \u2237 props) deps = begin\n    certDDeps deps \u02e2\n      \u2248\u27e8 lem-upd-prop-ddeps props deps \u27e9\n    certDDeps (L.updateProposalDeposits props txid gaDep deps) \u02e2\n      \u2248\u27e8 lem-add-excluded (\u03bb ()) \u27e8\n    certDDeps (L.updateProposalDeposits props txid gaDep deps \u222a\u207a \u2774 L.GovActionDeposit _ , _ \u2775) \u02e2\n      \u220e\n  where\n    open module R {A} = SetoidReasoning (\u2261\u1d49-Setoid {A = A})\n\nlem-upd-prop-gdeps : \u2200 {txid} {gaDep} props deps\n                   \u2192 certGDeps deps \u2261\u1d50 certGDeps (L.updateProposalDeposits props txid gaDep deps)\nlem-upd-prop-gdeps [] deps = id , id\nlem-upd-prop-gdeps {txid} {gaDep} (_ \u2237 props) deps = begin\n    certGDeps deps \u02e2\n      \u2248\u27e8 lem-upd-prop-gdeps props deps \u27e9\n    certGDeps (L.updateProposalDeposits props txid gaDep deps) \u02e2\n      \u2248\u27e8 lem-add-excluded (\u03bb ()) \u27e8\n    certGDeps (L.updateProposalDeposits props txid gaDep deps \u222a\u207a \u2774 L.GovActionDeposit _ , _ \u2775) \u02e2\n      \u220e\n  where\n    open module R {A} = SetoidReasoning (\u2261\u1d49-Setoid {A = A})\n\nlem-ddeps : \u2200 {pp certs} (deposits : CertDeps* pp certs)\n          \u2192 updateCertDeps* certs deposits .CertDeps*.deps\u1d48 \u2261 updateDDeps pp certs (deposits .CertDeps*.deps\u1d48)\nlem-ddeps {certs = []} _ = refl\nlem-ddeps (delegate*    ddeps gdeps) rewrite lem-ddeps $\\begin{pmatrix} \\,\\htmlId{11333}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{11337}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11300}{\\htmlId{11341}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11306}{\\htmlId{11349}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-ddeps (dereg* v v'  ddeps gdeps) rewrite lem-ddeps $\\begin{pmatrix} \\,\\htmlId{11422}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{11426}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11389}{\\htmlId{11430}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11395}{\\htmlId{11438}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-ddeps (regpool*     ddeps gdeps) rewrite lem-ddeps $\\begin{pmatrix} \\,\\htmlId{11511}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{11515}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11478}{\\htmlId{11519}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11484}{\\htmlId{11527}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-ddeps (retirepool*  ddeps gdeps) rewrite lem-ddeps $\\begin{pmatrix} \\,\\htmlId{11600}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{11604}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11567}{\\htmlId{11608}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11573}{\\htmlId{11616}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-ddeps (regdrep*     ddeps gdeps) rewrite lem-ddeps $\\begin{pmatrix} \\,\\htmlId{11689}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{11693}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11656}{\\htmlId{11697}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11662}{\\htmlId{11705}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-ddeps (deregdrep* v ddeps gdeps) rewrite lem-ddeps $\\begin{pmatrix} \\,\\htmlId{11778}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{11782}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11745}{\\htmlId{11786}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11751}{\\htmlId{11794}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-ddeps (ccreghot*    ddeps gdeps) rewrite lem-ddeps $\\begin{pmatrix} \\,\\htmlId{11867}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{11871}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11834}{\\htmlId{11875}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11840}{\\htmlId{11883}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-ddeps (reg*         ddeps gdeps) rewrite lem-ddeps $\\begin{pmatrix} \\,\\htmlId{11956}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{11960}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11923}{\\htmlId{11964}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#11929}{\\htmlId{11972}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\n\nlem-gdeps : \u2200 {pp certs} (deposits : CertDeps* pp certs)\n          \u2192 updateCertDeps* certs deposits .CertDeps*.deps\u1d4d \u2261 updateGDeps pp certs (deposits .CertDeps*.deps\u1d4d)\nlem-gdeps {certs = []} _ = refl\nlem-gdeps (delegate*    ddeps gdeps) rewrite lem-gdeps $\\begin{pmatrix} \\,\\htmlId{12246}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{12250}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12213}{\\htmlId{12254}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12219}{\\htmlId{12262}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-gdeps (dereg* v v'  ddeps gdeps) rewrite lem-gdeps $\\begin{pmatrix} \\,\\htmlId{12335}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{12339}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12302}{\\htmlId{12343}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12308}{\\htmlId{12351}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-gdeps (regpool*     ddeps gdeps) rewrite lem-gdeps $\\begin{pmatrix} \\,\\htmlId{12424}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{12428}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12391}{\\htmlId{12432}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12397}{\\htmlId{12440}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-gdeps (retirepool*  ddeps gdeps) rewrite lem-gdeps $\\begin{pmatrix} \\,\\htmlId{12513}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{12517}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12480}{\\htmlId{12521}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12486}{\\htmlId{12529}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-gdeps (regdrep*     ddeps gdeps) rewrite lem-gdeps $\\begin{pmatrix} \\,\\htmlId{12602}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{12606}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12569}{\\htmlId{12610}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12575}{\\htmlId{12618}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-gdeps (deregdrep* v ddeps gdeps) rewrite lem-gdeps $\\begin{pmatrix} \\,\\htmlId{12691}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{12695}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12658}{\\htmlId{12699}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12664}{\\htmlId{12707}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-gdeps (ccreghot*    ddeps gdeps) rewrite lem-gdeps $\\begin{pmatrix} \\,\\htmlId{12780}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{12784}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12747}{\\htmlId{12788}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12753}{\\htmlId{12796}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\nlem-gdeps (reg*         ddeps gdeps) rewrite lem-gdeps $\\begin{pmatrix} \\,\\htmlId{12869}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{12873}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12836}{\\htmlId{12877}{\\htmlClass{Bound}{\\text{ddeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#12842}{\\htmlId{12885}{\\htmlClass{Bound}{\\text{gdeps}}}}\\, \\end{pmatrix}$ = refl\n\ncertDeposits : L.LState \u2192 L.Deposits \u00d7 L.Deposits\ncertDeposits s = certDDeps deps , certGDeps deps\n  where deps = s .L.LState.utxoSt .L.UTxOState.deposits\n\n_\u2261\u1d48_ : (x y : L.Deposits \u00d7 L.Deposits) \u2192 Type\n_\u2261\u1d48_ = Pointwise _\u2261\u1d50_ _\u2261\u1d50_\n{-# INJECTIVE_FOR_INFERENCE _\u2261\u1d48_ #-}\n\n\u2261\u1d48-isEquivalence : IsEquivalence _\u2261\u1d48_\n\u2261\u1d48-isEquivalence .IsEquivalence.refl = (id , id) , (id , id)\n\u2261\u1d48-isEquivalence .IsEquivalence.sym (deq , geq) = \u2261\u1d49-isEquivalence .IsEquivalence.sym deq , \u2261\u1d49-isEquivalence .IsEquivalence.sym geq\n\u2261\u1d48-isEquivalence .IsEquivalence.trans (deq\u2081 , geq\u2081) (deq\u2082 , geq\u2082) =\n  \u2261\u1d49-isEquivalence .IsEquivalence.trans deq\u2081 deq\u2082 ,\n  \u2261\u1d49-isEquivalence .IsEquivalence.trans geq\u2081 geq\u2082\n\ncong-updateDDep : \u2200 {pp} cert {deps\u2081 deps\u2082}\n                \u2192 deps\u2081 \u2261\u1d50 deps\u2082\n                \u2192 updateDDep pp cert deps\u2081 \u2261\u1d50 updateDDep pp cert deps\u2082\ncong-updateDDep {pp} cert@(L.delegate c del kh v)\n                                        eq = cong-updateCertDeposit pp cert eq\ncong-updateDDep {pp} cert@(L.dereg c v) {deps\u2081} {deps\u2082}\n                                        eq = cong-updateCertDeposit pp cert {deps\u2081} {deps\u2082} eq\ncong-updateDDep {pp} cert@(L.reg c v)   eq = cong-updateCertDeposit pp cert eq\ncong-updateDDep      (L.regpool _ _)    eq = eq\ncong-updateDDep      (L.regdrep _ _ _)  eq = eq\ncong-updateDDep      (L.deregdrep _ _)  eq = eq\ncong-updateDDep      (L.retirepool _ _) eq = eq\ncong-updateDDep      (L.ccreghot _ _)   eq = eq\n\ncong-updateDDeps : \u2200 {pp} certs {deps\u2081 deps\u2082}\n                 \u2192 deps\u2081 \u2261\u1d50 deps\u2082\n                 \u2192 updateDDeps pp certs deps\u2081 \u2261\u1d50 updateDDeps pp certs deps\u2082\ncong-updateDDeps []             eq = eq\ncong-updateDDeps (cert \u2237 certs) eq = cong-updateDDeps certs (cong-updateDDep cert eq)\n\ncong-updateGDep : \u2200 {pp} cert {deps\u2081 deps\u2082}\n                \u2192 deps\u2081 \u2261\u1d50 deps\u2082\n                \u2192 updateGDep pp cert deps\u2081 \u2261\u1d50 updateGDep pp cert deps\u2082\ncong-updateGDep      (L.delegate _ _ _ _)   eq = eq\ncong-updateGDep      (L.dereg _ _)          eq = eq\ncong-updateGDep      (L.reg _ _)            eq = eq\ncong-updateGDep      (L.regpool _ _)        eq = eq\ncong-updateGDep {pp} cert@(L.regdrep _ _ _) eq = cong-updateCertDeposit pp cert eq\ncong-updateGDep {pp} cert@(L.deregdrep _ _) {deps\u2081} {deps\u2082}\n                                            eq = cong-updateCertDeposit pp cert {deps\u2081} {deps\u2082} eq\ncong-updateGDep      (L.retirepool _ _)     eq = eq\ncong-updateGDep      (L.ccreghot _ _  )     eq = eq\n\ncong-updateGDeps : \u2200 {pp} certs {deps\u2081 deps\u2082}\n                 \u2192 deps\u2081 \u2261\u1d50 deps\u2082\n                 \u2192 updateGDeps pp certs deps\u2081 \u2261\u1d50 updateGDeps pp certs deps\u2082\ncong-updateGDeps []             eq = eq\ncong-updateGDeps (cert \u2237 certs) eq = cong-updateGDeps certs (cong-updateGDep cert eq)\n\nprivate open module S {A} = Setoid (\u2261\u1d49-Setoid {A = A}) using () renaming (sym to \u2248-sym; trans to _\u27e8\u2248\u27e9_)\n\n-- This proof takes quite a long time to check. Way longer if we tried to use nice equational reasoning.\n-- I suspect making filter\u1d50 and _\u222a\u207a_ opaque would speed things up a million times.\nlem-upd-cert-ddeps : \u2200 {pp} deps certs\n                  \u2192 updateDDeps pp certs (certDDeps deps) \u2261\u1d50 certDDeps (L.updateCertDeposits pp certs deps)\nlem-upd-cert-ddeps deps [] = id , id\nlem-upd-cert-ddeps {pp} deps (L.delegate c del kh v \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (lem-add-included CredentialDeposit)) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.CredentialDeposit c , v \u2775\nlem-upd-cert-ddeps {pp} deps (L.dereg c v \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (filter\u1d50-restrict deps)) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u2223 cs \u1d9c) certs\n  where cs = \u2774 L.CredentialDeposit c \u2775\nlem-upd-cert-ddeps {pp} deps (L.reg c v \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (lem-add-included CredentialDeposit)) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.CredentialDeposit c , pp .PParams.keyDeposit \u2775\nlem-upd-cert-ddeps {pp} deps (L.regpool kh p \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (lem-add-excluded-\u222a\u02e1 deps \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u222a\u02e1 dep) certs\n  where dep = \u2774 L.PoolDeposit kh , pp .PParams.poolDeposit \u2775\nlem-upd-cert-ddeps {pp} deps (L.regdrep c v a \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (lem-add-excluded \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.DRepDeposit c , v \u2775\nlem-upd-cert-ddeps {pp} deps (L.deregdrep c v \u2237 certs) =\n  \u2248-sym (cong-updateDDeps certs (lem-del-excluded deps \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-ddeps (deps \u2223 cs \u1d9c) certs\n  where cs = \u2774 L.DRepDeposit c \u2775\nlem-upd-cert-ddeps deps (L.retirepool _ _ \u2237 certs) = lem-upd-cert-ddeps deps certs\nlem-upd-cert-ddeps deps (L.ccreghot _ _ \u2237 certs) = lem-upd-cert-ddeps deps certs\n\nlem-upd-cert-gdeps : \u2200 {pp} deps certs\n                  \u2192 updateGDeps pp certs (certGDeps deps) \u2261\u1d50 certGDeps (L.updateCertDeposits pp certs deps)\nlem-upd-cert-gdeps deps [] = id , id\nlem-upd-cert-gdeps {pp} deps (L.delegate c del kh v \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (lem-add-excluded \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.CredentialDeposit c , v \u2775\nlem-upd-cert-gdeps {pp} deps (L.dereg c v \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (lem-del-excluded deps \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u2223 cs \u1d9c) certs\n  where cs = \u2774 L.CredentialDeposit c \u2775\nlem-upd-cert-gdeps {pp} deps (L.reg c v \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (lem-add-excluded \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.CredentialDeposit c , pp .PParams.keyDeposit \u2775\nlem-upd-cert-gdeps {pp} deps (L.regpool kh p \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (lem-add-excluded-\u222a\u02e1 deps \u03bb ())) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u222a\u02e1 dep) certs\n  where dep = \u2774 L.PoolDeposit kh , pp .PParams.poolDeposit \u2775\nlem-upd-cert-gdeps {pp} deps (L.regdrep c v a \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (lem-add-included DRepDeposit)) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u222a\u207a dep) certs\n  where dep = \u2774 L.DRepDeposit c , v \u2775\nlem-upd-cert-gdeps {pp} deps (L.deregdrep c v \u2237 certs) =\n  \u2248-sym (cong-updateGDeps certs (filter\u1d50-restrict deps)) \u27e8\u2248\u27e9\n  lem-upd-cert-gdeps (deps \u2223 cs \u1d9c) certs\n  where cs = \u2774 L.DRepDeposit c \u2775\nlem-upd-cert-gdeps deps (L.retirepool _ _ \u2237 certs) = lem-upd-cert-gdeps deps certs\nlem-upd-cert-gdeps deps (L.ccreghot _ _ \u2237 certs) = lem-upd-cert-gdeps deps certs\n\nlem-upd-ddeps : \u2200 pparams deps tx (open TxBody (body tx) using (txCerts))\n              \u2192 updateDDeps pparams txCerts (certDDeps deps) \u2261\u1d50 certDDeps (L.updateDeposits pparams (body tx) deps)\nlem-upd-ddeps pparams deps tx = begin\n    updateDDeps pparams txCerts (certDDeps deps) \u02e2\n      \u2248\u27e8 cong-updateDDeps txCerts (lem-upd-prop-ddeps txGovProposals deps) \u27e9\n    updateDDeps pparams txCerts (certDDeps (updateProp deps)) \u02e2\n      \u2248\u27e8 lem-upd-cert-ddeps (updateProp deps) txCerts \u27e9\n    certDDeps (L.updateDeposits pparams (body tx) deps) \u02e2\n      \u220e\n  where\n    open TxBody (body tx)\n    open module R {A} = SetoidReasoning (\u2261\u1d49-Setoid {A = A})\n    updateCert = L.updateCertDeposits pparams txCerts\n    updateProp = L.updateProposalDeposits txGovProposals txId (pparams .PParams.govActionDeposit)\n\nlem-upd-gdeps  :   \u2200 pparams deps tx (open TxBody (body tx) using (txCerts))\n               \u2192   updateGDeps pparams txCerts (certGDeps deps)\n               \u2261\u1d50  certGDeps (L.updateDeposits pparams (body tx) deps)\nlem-upd-gdeps pparams deps tx = begin\n    updateGDeps pparams txCerts (certGDeps deps) \u02e2\n      \u2248\u27e8 cong-updateGDeps txCerts (lem-upd-prop-gdeps txGovProposals deps) \u27e9\n    updateGDeps pparams txCerts (certGDeps (updateProp deps)) \u02e2\n      \u2248\u27e8 lem-upd-cert-gdeps (updateProp deps) txCerts \u27e9\n    certGDeps (L.updateDeposits pparams (body tx) deps) \u02e2\n      \u220e\n  where\n    open TxBody (body tx)\n    open module R {A} = SetoidReasoning (\u2261\u1d49-Setoid {A = A})\n    updateCert = L.updateCertDeposits pparams txCerts\n    updateProp = L.updateProposalDeposits txGovProposals txId (pparams .PParams.govActionDeposit)\n\nlemUpdCert : \u2200 pp ((ddeps , gdeps) : L.Deposits \u00d7 L.Deposits) deps cert\n           \u2192 (ddeps , gdeps) \u2261\u1d48 (certDDeps deps , certGDeps deps)\n           \u2192 (updateDDep pp cert ddeps , updateGDep pp cert gdeps) \u2261\u1d48\n             (certDDeps (C.updateCertDeposit pp cert deps) , certGDeps (C.updateCertDeposit pp cert deps))\nlemUpdCert pp (ddeps , gdeps) deps (L.delegate _ _ _ _) (deq , geq) = \u222a\u207a-cong-r deq\n                                                                      \u27e8\u2248\u27e9 \u2248-sym (lem-add-included CredentialDeposit)\n                                                                    , geq \u27e8\u2248\u27e9 \u2248-sym (lem-add-excluded \u03bb ())\nlemUpdCert pp (ddeps , gdeps) deps (L.dereg _ _)        (deq , geq) = restrict-cong ddeps (certDDeps deps) deq\n                                                                      \u27e8\u2248\u27e9 \u2248-sym (filter\u1d50-restrict deps)\n                                                                    , geq \u27e8\u2248\u27e9 \u2248-sym (lem-del-excluded deps \u03bb ())\nlemUpdCert pp (ddeps , gdeps) deps (L.reg _ _)          (deq , geq) = (\u222a\u207a-cong-r deq\n                                                                      \u27e8\u2248\u27e9 \u2248-sym (lem-add-included CredentialDeposit))\n                                                                    , geq \u27e8\u2248\u27e9 \u2248-sym (lem-add-excluded \u03bb ())\nlemUpdCert pp (ddeps , gdeps) deps (L.regpool x x\u2081)     (deq , geq) = deq \u27e8\u2248\u27e9 \u2248-sym (lem-add-excluded \u03bb ())\n                                                                    , geq \u27e8\u2248\u27e9 \u2248-sym (lem-add-excluded \u03bb ())\nlemUpdCert pp (ddeps , gdeps) deps (L.regdrep _ _ _)    (deq , geq) = deq \u27e8\u2248\u27e9 \u2248-sym (lem-add-excluded \u03bb ())\n                                                                    , \u222a\u207a-cong-r geq\n                                                                      \u27e8\u2248\u27e9 \u2248-sym (lem-add-included DRepDeposit)\nlemUpdCert pp (ddeps , gdeps) deps (L.deregdrep _ _)    (deq , geq) = deq \u27e8\u2248\u27e9 \u2248-sym (lem-del-excluded deps \u03bb ())\n                                                                    , (restrict-cong gdeps (certGDeps deps) geq\n                                                                      \u27e8\u2248\u27e9 \u2248-sym (filter\u1d50-restrict deps))\nlemUpdCert pp (ddeps , gdeps) deps (L.retirepool _ _)   (deq , geq) = deq , geq\nlemUpdCert pp (ddeps , gdeps) deps (L.ccreghot _ _)     (deq , geq) = deq , geq\n</pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Map.html","title":"Map","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Conformance.Equivalence.Map where\n\nopen import Ledger.Prelude hiding (filter\u1d50-singleton-false)\nopen import Axiom.Set.Properties th\n\nimport Algebra as Alg\nimport Algebra.Definitions as AlgDefs\nimport Algebra.Structures as AlgStrucs\n\nopen import Data.List.Relation.Unary.Any using (Any)\nopen import Data.These as These using (These; this; that; these; fold)\nopen import Data.Product using (swap)\nopen import Data.Sum using () renaming (map to map-\u228e)\nimport Relation.Binary.Reasoning.Setoid as SetoidReasoning\nopen import Relation.Binary using (IsEquivalence; _Preserves_\u27f6_)\nopen import Relation.Binary.Bundles\nopen module SetSetoid {A} = Setoid (\u2261\u1d49-Setoid {A}) using () renaming (refl to \u2248-refl; trans to infixr 1 _\u27e8\u2248\u27e9_)\nopen import Data.Product.Properties using (\u00d7-\u2261,\u2261\u2190\u2261; \u00d7-\u2261,\u2261\u2192\u2261)\n\nopen Any\n\nimport Axiom.Set\nimport Axiom.Set.Rel\n{-# DISPLAY Axiom.Set.Theory._\u2208_ _ a b = a \u2208 b #-}\n{-# DISPLAY Axiom.Set.Rel.dom _ a = dom a #-}\n\nmodule _  {A B : Type}\n  (open AlgStrucs {A = B} _\u2261_)\n  \u2983 _ : DecEq A \u2984 \u2983 _ : DecEq B \u2984\n  \u2983 _ : CommutativeMonoid _ _ B \u2984\n  \u2983 csg : IsCommutativeSemigroup _\u25c7_ \u2984\n\n  where\n  private\n    variable\n      k : A\n      v : B\n      m m\u2081 m\u2082 : A \u21c0 B\n\n  \u25c7comm : Alg.Commutative {A = B} _\u2261_ _\u25c7_\n  \u25c7comm = IsCommutativeSemigroup.comm csg\n  -- TODO: fix this (if possible)\n  -- We should probably use the `\u25c7-comm` property of the `\u2983 _ : CommutativeMonoid _ _ B \u2984`\n  -- instance here, but I don't see how to set the instance's `_\u2248_` to be `_\u2261_`, so here\n  -- I instead use the standard library's commutative semigroup.\n\n  open Equivalence\n\n  -- Properties of domains of maps of type m\u2081 \u222a\u207a m\u2082 ---------------------\n\n  -- 1. If `k \u2208 dom m\u2081 \u222a dom m\u2082` (for m\u2081, m\u2082 maps), then `(k , v) \u2208 m\u2081 \u222a\u207a m\u2082` for some `v`.\n  dom\u222a-\u2203\u222a\u207a : {m\u2081 m\u2082 : A \u21c0 B} \u2192 k \u2208 dom m\u2081 \u222a dom m\u2082 \u2192 \u03a3 B (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081 \u222a\u207a m\u2082)\n  dom\u222a-\u2203\u222a\u207a k\u2208 = from dom\u2208 (\u222adom\u2286dom\u222a\u207a k\u2208)\n\n  -- 2. If `(k , v) \u2208 m\u2081 \u222a\u207a m\u2082`, then `k \u2208 dom m\u2081 \u222a dom m\u2082`.\n  \u222a\u207a-dom\u222a : {m\u2081 m\u2082 : A \u21c0 B}{k : A} {v : B} \u2192 (k , v) \u2208 m\u2081 \u222a\u207a m\u2082 \u2192 k \u2208 dom m\u2081 \u222a dom m\u2082\n  \u222a\u207a-dom\u222a {v = v} kv\u2208 = dom\u222a\u207a\u2286\u222adom (to dom\u2208 (v , kv\u2208))\n\n  -- 3. The image of a key `k \u2208 dom m\u2081 \u222a dom m\u2082` under the map `m\u2081 \u222a\u207a m\u2082` is\n  --    `fold id id _\u25c7_ (unionThese m\u2081 m\u2082 k p)`.\n  \u2225_\u222a\u207a_\u2225 : (m\u2081 m\u2082 : A \u21c0 B) \u2192 k \u2208 dom m\u2081 \u222a dom m\u2082 \u2192 B\n  \u2225_\u222a\u207a_\u2225 {k} m\u2081 m\u2082 p = fold id id _\u25c7_ (unionThese m\u2081 m\u2082 k p)\n\n  -- 4. F[ m\u2081 , m\u2082 ] takes a key `k` and a proof of `k \u2208 dom m\u2081 \u222a dom m\u2082` and returns\n  --    the pair `(k , v)` where `v` is the unique image of `k` under `m\u2081 \u222a\u207a m\u2082`.\n  --    i.e., `(k , v) \u2208 m\u2081 \u222a\u207a m\u2082`.\n  F[_,_] : (m\u2081 m\u2082 : A \u21c0 B) \u2192 \u03a3 A (_\u2208 dom m\u2081 \u222a dom m\u2082) \u2192 A \u00d7 B\n  F[ m\u2081 , m\u2082 ] (x , x\u2208) = x , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 x\u2208\n\n  -- 5. A simpler version of `lookup\u1d50`; it doesn't require tactics.\n  lookup\u1d50\u2208 : (m : A \u21c0 B) \u2192 k \u2208 dom m \u2192 B\n  lookup\u1d50\u2208 _ = proj\u2081 \u2218 (from dom\u2208)\n\n  -- 6. Proof that the value you get from `lookup\u1d50\u2208` is in the image of the map.\n  \u2208-lookup\u1d50\u2208 : (m : A \u21c0 B)(k\u2208 : k \u2208 dom m) \u2192 (k , lookup\u1d50\u2208 m k\u2208) \u2208 m\n  \u2208-lookup\u1d50\u2208 m k\u2208 = proj\u2082 (from dom\u2208 k\u2208)\n\n  -- 7. Irrelevance of the proof of `k \u2208 dom m` used in `lookup\u1d50\u2208`.\n  lookup\u1d50\u2208-irrelevance : (m : A \u21c0 B) {k\u2208 k\u2208\u2032 : k \u2208 dom m}\n                       \u2192 lookup\u1d50\u2208 m k\u2208 \u2261 lookup\u1d50\u2208 m k\u2208\u2032\n  lookup\u1d50\u2208-irrelevance m {k\u2208} {k\u2208\u2032} = m .proj\u2082 (\u2208-lookup\u1d50\u2208 m k\u2208) (\u2208-lookup\u1d50\u2208 m k\u2208\u2032)\n\n  -- 8. If `v` is the image of `k` under `m`, then it must be `lookup\u1d50\u2208 m k\u2208m`!\n  \u2208-lookup\u1d50\u2261 : (m : A \u21c0 B) {k\u2208m : k \u2208 dom m} \u2192 (k , v) \u2208 m \u2192 v \u2261 lookup\u1d50\u2208 m k\u2208m\n  \u2208-lookup\u1d50\u2261 m {k\u2208m} kv\u2208 = m .proj\u2082 kv\u2208 (\u2208-lookup\u1d50\u2208 m k\u2208m)\n\n  lookup\u1d50\u2208\u2261 : (m : A \u21c0 B) {k\u2208 : k \u2208 dom m} \u2192 lookup\u1d50\u2208 m k\u2208 \u2261 lookup\u1d50 m k\n  lookup\u1d50\u2208\u2261 {k = k} _ {k\u2208} = refl\n\n  opaque  -- unfolding List-Model List-Model\u1d48 to-sp\n\n    -- 0. The `\u2208-incl-set` lemma is useful for proving some properties of `_\u222a\u207a_`.\n    \u2208-incl-set : {X : \u2119 A} {a : A} (a\u2208X : a \u2208 X) \u2192 \u03a3 (a \u2208 X) \u03bb \u2022 \u2192 (a , \u2022) \u2208 incl-set X\n    \u2208-incl-set {X} {a} a\u2208X =\n      Data.Product.map\u2082 (\u03bb {a\u2208X\u2032} eq \u2192 \u2208-mapPartial {f = incl-set' X} .to (a , a\u2208X\u2032 , eq))\n                        lem\n      where\n        lem : \u03a3 (a \u2208 X) \u03bb a\u2208X\u2032 \u2192 incl-set' X a \u2261 just (a , a\u2208X\u2032)\n        lem with a \u2208? X\n        ... | yes a\u2208X\u2032 = a\u2208X\u2032 , refl\n        ... | no  a\u2209X  = \u22a5-elim (a\u2209X a\u2208X)\n\n    -- Properties of values of \u222a\u207a --------------------------------------------------\n\n    -- 1. If `k \u2208 dom m\u2081 \u222a dom m\u2082` holds, then there is a particular proof `k\u2208\u2032`\n    --    of that fact such that `(k , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2032) \u2208 m\u2081 \u222a\u207a m\u2082`.\n    -- k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a  : {m\u2081 m\u2082 : A \u21c0 B} \u2192 k \u2208 dom m\u2081 \u222a dom m\u2082\n    --             \u2192 \u03a3 (k \u2208 dom m\u2081 \u222a dom m\u2082) \u03bb k\u2208\u2032 \u2192 (k , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2032) \u2208 m\u2081 \u222a\u207a m\u2082\n    -- k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a {k = k} k\u2208 with \u2208-incl-set k\u2208\n    -- ... | k\u2208\u2032 , kk\u2208 = k\u2208\u2032 , to \u2208-map ((k , k\u2208\u2032) , refl , kk\u2208)\n\n    -- Actually, we won't use the general statement above; we only need the following\n    -- version which picks a particular proof of the fact that `k \u2208 dom m\u2081 \u222a dom m\u2082`.\n    -- In fact, for computing the value, the proof is irrelevant (see property 3 below).\n\n    -- 2. We can obtain the particular proof mentioned in 3. using `\u2208-incl-set`.\n    k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a'  : {m\u2081 m\u2082 : A \u21c0 B} (k\u2208 : k \u2208 dom m\u2081 \u222a dom m\u2082)\n                 \u2192 (k , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 (\u2208-incl-set k\u2208 .proj\u2081)) \u2208 m\u2081 \u222a\u207a m\u2082\n    k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' {k = k} {m\u2081} {m\u2082} k\u2208 = goal\n      where\n      k\u2208\u2032 : k \u2208 dom m\u2081 \u222a dom m\u2082\n      k\u2208\u2032 = \u2208-incl-set k\u2208 .proj\u2081  --  &lt;= the particular proof mentioned in 1 above.\n\n      kk\u2208 : (k , \u2208-incl-set k\u2208 .proj\u2081) \u2208 incl-set (dom m\u2081 \u222a dom m\u2082)\n      kk\u2208 = \u2208-incl-set k\u2208 .proj\u2082\n\n      goal : F[ m\u2081 , m\u2082 ] (k , \u2208-incl-set k\u2208 .proj\u2081) \u2208 map\u02e2 F[ m\u2081 , m\u2082 ] (incl-set (dom m\u2081 \u222a dom m\u2082))\n                                                -- this ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ is `(m\u2081 \u222a\u207a m\u2082)\u02e2`\n      goal = to \u2208-map ((k , k\u2208\u2032) , refl , kk\u2208)\n\n    -- 3. The value associated with a key doesn't depend on the proof of key membership.\n    fold-irrelevance : {m\u2081 m\u2082 : A \u21c0 B} {k\u2208\u2081 k\u2208\u2082 : k \u2208 (dom m\u2081 \u222a dom m\u2082)}\n                     \u2192 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2081 \u2261 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2082\n    fold-irrelevance {k = k} {m\u2081 = m\u2081} {m\u2082} {k\u2208\u2081} with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n    ... | yes k\u2208m\u2081 | yes k\u2208m\u2082 = refl\n    ... | yes k\u2208m\u2081 | no k\u2209m\u2082  = refl\n    ... | no k\u2209m\u2081  | yes k\u2208m\u2082 = refl\n    ... | no k\u2209m\u2081  | no k\u2209m\u2082 with from \u2208-\u222a k\u2208\u2081\n    ... | inj\u2081 k\u2208m\u2081 = \u22a5-elim (k\u2209m\u2081 k\u2208m\u2081)\n    ... | inj\u2082 k\u2208m\u2082 = \u22a5-elim (k\u2209m\u2082 k\u2208m\u2082)\n\n    -- 4. If `(k , v) \u2208 m\u2081 \u222a\u207a m\u2082`, then there is a particular proof `k\u2208\u2032` of\n    --    `k \u2208 dom m\u2081 \u222a dom m\u2082` such that `v \u2261 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2032`.\n    \u222a\u207a-unique-val  : {m\u2081 m\u2082 : A \u21c0 B} (k\u2208 : k \u2208 dom m\u2081 \u222a dom m\u2082) \u2192 (k , v) \u2208 m\u2081 \u222a\u207a m\u2082\n                   \u2192 v \u2261 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 (\u2208-incl-set k\u2208 .proj\u2081)\n    \u222a\u207a-unique-val {k = k} {m\u2081 = m\u2081} {m\u2082} k\u2208 kv\u2208 =\n      (m\u2081 \u222a\u207a m\u2082) .proj\u2082 kv\u2208 (to \u2208-map ((k , \u2208-incl-set k\u2208 .proj\u2081) , refl , \u2208-incl-set k\u2208 .proj\u2082))\n\n    -- 5. If `k \u2208 dom m\u2081 \u222a dom m\u2082`, and `k \u2208 dom m\u2081` and `k \u2208 dom m\u2082`, then there's a\n    --    proof `k\u2208\u2032` of `k \u2208 dom m\u2081 \u222a dom m\u2082` such that `\u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2032`.\n    \u2225\u222a\u207a\u2225\u2261lu\u25c7lu  :  {m\u2081 m\u2082 : A \u21c0 B} (k\u2208 : k \u2208 dom m\u2081 \u222a dom m\u2082)\n                    {k\u2208m\u2081 : k \u2208 dom m\u2081} {k\u2208m\u2082 : k \u2208 dom m\u2082}\n                 \u2192  \u03a3 (k \u2208 dom m\u2081 \u222a dom m\u2082) \u03bb k\u2208\u2032 \u2192 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u2032 \u2261 lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\n    \u2225\u222a\u207a\u2225\u2261lu\u25c7lu {k} {m\u2081} {m\u2082} k\u2208 {k\u2208m\u2081} {k\u2208m\u2082} with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n    ... | no k\u2209m\u2081   | _       = \u22a5-elim (k\u2209m\u2081 k\u2208m\u2081)\n    ... | _         | no k\u2209m\u2082 = \u22a5-elim (k\u2209m\u2082 k\u2208m\u2082)\n    ... | yes k\u2208m\u2081\u2032 | yes k\u2208m\u2082\u2032 = k\u2208 , goal\n      where\n      open \u2261-Reasoning\n      goal : lookup\u1d50\u2208 m\u2081 k\u2208m\u2081\u2032 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\u2032 \u2261 lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\n      goal = begin\n        lookup\u1d50\u2208 m\u2081 k\u2208m\u2081\u2032 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\u2032  \u2261\u27e8 cong (_\u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\u2032) (lookup\u1d50\u2208-irrelevance m\u2081) \u27e9\n        lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\u2032   \u2261\u27e8 cong (lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7_ ) (lookup\u1d50\u2208-irrelevance m\u2082) \u27e9\n        lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082    \u220e\n\n    -- 5.' Again, we won't need the general statement (`\u2225\u222a\u207a\u2225\u2261lu\u25c7lu`), but instead the version below\n    --     which picks a particular proof of `k \u2208 dom m\u2081 \u222a dom m\u2082`.\n    \u2225\u222a\u207a\u2225\u2261lu\u25c7lu'  :  {m\u2081 m\u2082 : A \u21c0 B} (kv\u2208 : (k , v) \u2208 m\u2081 \u222a\u207a m\u2082)\n                     {k\u2208m\u2081 : k \u2208 dom m\u2081} {k\u2208m\u2082 : k \u2208 dom m\u2082}\n                  \u2192  \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 (\u2208-incl-set (\u222a\u207a-dom\u222a kv\u2208) .proj\u2081) \u2261 lookup\u1d50\u2208 m\u2081 k\u2208m\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 k\u2208m\u2082\n    \u2225\u222a\u207a\u2225\u2261lu\u25c7lu' kv\u2208 with \u2225\u222a\u207a\u2225\u2261lu\u25c7lu (\u222a\u207a-dom\u222a kv\u2208)\n    ... | k\u2208\u2032 , v\u2261 = trans fold-irrelevance v\u2261\n\n\n    ------------------------------------------------------------------------------------------------\n\n    res\u1d9c-dom\u2209\u207b : \u2200 m {ks}{a : A}{b : B} \u2192 (a , b) \u2208 (m \u2223 ks \u1d9c) \u2192 (a , b) \u2208 m \u00d7 a \u2209 ks\n    res\u1d9c-dom\u2209\u207b m x = ex-\u2286 x , (\u2208-res\u1d9c-dom\u207b $ \u2208-dom x) .proj\u2081\n\n    res\u1d9c-dom\u2209\u207a : \u2200 m {ks}{a : A}{b : B} \u2192 (a , b) \u2208 m \u00d7 a \u2209 ks \u2192 (a , b) \u2208 (m \u2223 ks \u1d9c)\n    res\u1d9c-dom\u2209\u207a m = to \u2208-filter \u2218 swap\n\n    deconstruct-\u222a\u207a  :  {m m\u2081 m\u2082 : A \u21c0 B} {a : A}\n                       {a\u2208\u2081 : a \u2208 dom m \u222a dom m\u2081}\n                       {a\u2208\u2082 : a \u2208 dom m \u222a dom m\u2082}\n                    \u2192  m\u2081 \u2261\u1d50 m\u2082 \u2192 \u2225 m \u222a\u207a m\u2081 \u2225 a\u2208\u2081 \u2261 \u2225 m \u222a\u207a m\u2082 \u2225 a\u2208\u2082\n\n    deconstruct-\u222a\u207a {m} {m\u2081} {m\u2082} {a} {a\u2208\u2081} m\u2081\u2261m\u2082\n      with a \u2208? dom m | a \u2208? dom m\u2081 | a \u2208? dom m\u2082\n    ... | yes a\u2208m | yes a\u2208m\u2081 | yes a\u2208m\u2082 =\n      cong (\u03bb (b : B) \u2192 lookup\u1d50 m a \u25c7 b)\n           (proj\u2082 m\u2082\n             (proj\u2081 m\u2081\u2261m\u2082 (proj\u2082 $ from dom\u2208 a\u2208m\u2081))  -- : (a , lookup\u1d50 m\u2081 a) \u2208 (m\u2082 \u02e2)\n             (proj\u2082 (from dom\u2208 a\u2208m\u2082))                -- : (a , lookup\u1d50 m\u2082 a) \u2208 (m\u2082 \u02e2)\n           )\n    ... | no  a\u2209m | yes a\u2208m\u2081 | yes a\u2208m\u2082 =\n      proj\u2082 m\u2082 (proj\u2081 m\u2081\u2261m\u2082 (proj\u2082 (from dom\u2208 a\u2208m\u2081))) (proj\u2082 (from dom\u2208 a\u2208m\u2082))\n    ... | yes a\u2208m | no  a\u2209m\u2081 | no a\u2209m\u2082 = refl\n    ... | _ | yes a\u2208m\u2081 | no a\u2209m\u2082 = \u22a5-elim (a\u2209m\u2082 (dom\u2286 (proj\u2081 m\u2081\u2261m\u2082) a\u2208m\u2081))\n    ... | _ | no  a\u2209m\u2081 | yes a\u2208m\u2082 = \u22a5-elim (a\u2209m\u2081 (dom\u2286 (proj\u2082 m\u2081\u2261m\u2082) a\u2208m\u2082))\n    ... | no  a\u2209m | no  a\u2209m\u2081 | no a\u2209m\u2082 with from \u2208-\u222a a\u2208\u2081\n    ... | inj\u2081 a\u2208m = \u22a5-elim (a\u2209m a\u2208m)\n    ... | inj\u2082 a\u2208m\u2081 = \u22a5-elim (a\u2209m\u2081 a\u2208m\u2081)\n\n\n    fold-\u25c7-union-comm  :  {m\u2081 m\u2082 : A \u21c0 B} {a : A}\n                          {a\u2208\u2081 : a \u2208 dom m\u2081 \u222a dom m\u2082}\n                          {a\u2208\u2082 : a \u2208 dom m\u2082 \u222a dom m\u2081}\n                       \u2192  \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 (\u2208-incl-set a\u2208\u2081 .proj\u2081)\n                       \u2261  \u2225 m\u2082 \u222a\u207a m\u2081 \u2225 (\u2208-incl-set a\u2208\u2082 .proj\u2081)\n\n    fold-\u25c7-union-comm {m\u2081} {m\u2082} {a} {a\u2208\u2081} with a \u2208? dom m\u2081 | a \u2208? dom m\u2082\n    ... | yes a\u2208m\u2081 | yes a\u2208m\u2082 = \u25c7comm (lookup\u1d50 m\u2081 a) (lookup\u1d50 m\u2082 a)\n    ... | no  a\u2209m\u2081 | yes a\u2208m\u2082 = refl\n    ... | yes a\u2208m\u2081 | no  a\u2209m\u2082 = refl\n    ... | no  a\u2209m\u2081 | no  a\u2209m\u2082 with from \u2208-\u222a a\u2208\u2081\n    ... | inj\u2081 a\u2208m\u2081 = \u22a5-elim (a\u2209m\u2081 a\u2208m\u2081)\n    ... | inj\u2082 a\u2208m\u2082 = \u22a5-elim (a\u2209m\u2082 a\u2208m\u2082)\n\n\n    \u222a\u207a-comm-\u2286 : {m\u2081 m\u2082 : A \u21c0 B} \u2192 m\u2081 \u222a\u207a m\u2082 \u2286 m\u2082 \u222a\u207a m\u2081\n    \u222a\u207a-comm-\u2286 {m\u2081} {m\u2082} {a} {b} ab\u2208 with a \u2208? dom m\u2081 | a \u2208? dom m\u2082\n    ... | yes a\u2208m\u2081 | _ = to \u2208-map $ (a , \u2208-incl-set a\u2208\u02d8 .proj\u2081)\n                                  , \u00d7-\u2261,\u2261\u2192\u2261 (refl , b\u2261) , \u2208-incl-set a\u2208\u2082 .proj\u2082\n      where\n      a\u2208\u2082 : a \u2208 unions (fromList (dom m\u2082 \u2237 dom m\u2081 \u2237 [])) .proj\u2081\n      a\u2208\u2082 = to \u2208-unions (dom m\u2081 , to \u2208-fromList (there (here refl)) , a\u2208m\u2081)\n\n      a\u2208\u02d8 : a \u2208 dom m\u2082 \u222a dom m\u2081\n      a\u2208\u02d8 = to \u2208-\u222a (inj\u2082 a\u2208m\u2081)\n\n      b\u2261 : b \u2261 fold id id _\u25c7_ (unionThese m\u2082 m\u2081 a $ \u2208-incl-set a\u2208\u02d8 .proj\u2081)\n      b\u2261 = trans (\u222a\u207a-unique-val (to \u2208-\u222a $ inj\u2081 a\u2208m\u2081) ab\u2208) fold-\u25c7-union-comm\n\n    ... | no a\u2209m\u2081 | yes a\u2208m\u2082 = to \u2208-map $ (a , \u2208-incl-set a\u2208\u02d8 .proj\u2081)\n                                        , \u00d7-\u2261,\u2261\u2192\u2261 (refl , b\u2261) , \u2208-incl-set a\u2208\u2082 .proj\u2082\n      where\n      a\u2208\u2082 : a \u2208 unions (fromList (dom m\u2082 \u2237 dom m\u2081 \u2237 [])) .proj\u2081\n      a\u2208\u2082 = to \u2208-unions (dom m\u2082 , to \u2208-fromList (here refl) , a\u2208m\u2082)\n\n      a\u2208\u02d8 : a \u2208 dom m\u2082 \u222a dom m\u2081\n      a\u2208\u02d8 = to \u2208-\u222a $ inj\u2081 a\u2208m\u2082\n\n      b\u2261 : b \u2261 fold id id _\u25c7_ (unionThese m\u2082 m\u2081 a (\u2208-incl-set a\u2208\u02d8 .proj\u2081))\n      b\u2261 = trans (\u222a\u207a-unique-val (to \u2208-\u222a (inj\u2082 a\u2208m\u2082)) ab\u2208) fold-\u25c7-union-comm\n\n    ... | no  a\u2209m\u2081 | no a\u2209m\u2082 with from \u2208-\u222a (\u222a\u207a-dom\u222a ab\u2208)\n    ... | inj\u2081 a\u2208m\u2081 = \u22a5-elim (a\u2209m\u2081 a\u2208m\u2081)\n    ... | inj\u2082 a\u2208m\u2082 = \u22a5-elim (a\u2209m\u2082 a\u2208m\u2082)\n\n\n    \u222a\u207a-comm : {m\u2081 m\u2082 : A \u21c0 B} \u2192 m\u2081 \u222a\u207a m\u2082 \u2261\u1d50 m\u2082 \u222a\u207a m\u2081\n    \u222a\u207a-comm = \u222a\u207a-comm-\u2286 , \u222a\u207a-comm-\u2286\n\n    \u222a\u207a-comm-val  :  {m\u2081 m\u2082 : A \u21c0 B}\n                    {k\u2208m\u2081\u2082 : k \u2208 dom m\u2081 \u222a dom m\u2082}\n                    {k\u2208m\u2082\u2081 : k \u2208 dom m\u2082 \u222a dom m\u2081}\n                 \u2192  \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208m\u2081\u2082 \u2261 \u2225 m\u2082 \u222a\u207a m\u2081 \u2225 k\u2208m\u2082\u2081\n    \u222a\u207a-comm-val {k = k} {m\u2081 = m\u2081}{m\u2082}{k\u2208m\u2081\u2082}{k\u2208m\u2082\u2081} = (m\u2081 \u222a\u207a m\u2082) .proj\u2082 kv\u2208\u2081\u2082 (\u222a\u207a-comm-\u2286 kv\u2208\u2082\u2081)\n      where\n      kv\u2208\u2081\u2082 : (k , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208m\u2081\u2082) \u2208 m\u2081 \u222a\u207a m\u2082\n      kv\u2208\u2081\u2082 = subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081 \u222a\u207a m\u2082) fold-irrelevance (k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208m\u2081\u2082)\n\n      kv\u2208\u2082\u2081 : (k , \u2225 m\u2082 \u222a\u207a m\u2081 \u2225 k\u2208m\u2082\u2081) \u2208 m\u2082 \u222a\u207a m\u2081\n      kv\u2208\u2082\u2081 = subst (\u03bb x \u2192 (k , x) \u2208 m\u2082 \u222a\u207a m\u2081) fold-irrelevance (k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208m\u2082\u2081)\n\n\n    \u222a\u207a-cong-\u2286\u02e1 : {m m\u2081 m\u2082 : A \u21c0 B} \u2192 m\u2081 \u2261\u1d50 m\u2082 \u2192 m \u222a\u207a m\u2081 \u2286 m \u222a\u207a m\u2082\n    \u222a\u207a-cong-\u2286\u02e1 {m}{m\u2081}{m\u2082} m\u2081\u2261m\u2082@(m\u2081\u2286m\u2082 , m\u2082\u2286m\u2081) {k} {v} kv\u2208 with from \u2208-map kv\u2208\n    ... | (.k , k\u2208) , refl , s =\n      let k\u2208'' , \u2208inclset = \u2208-incl-set k\u2208'\n          \u2261F : (k , v) \u2261 F[ m , m\u2082 ] (k , k\u2208'')\n          \u2261F = \u00d7-\u2261,\u2261\u2192\u2261 (refl , deconstruct-\u222a\u207a {a\u2208\u2081 = k\u2208} m\u2081\u2261m\u2082)\n      in  to (\u2208-map {f = F[ m , m\u2082 ]}) ((k , k\u2208'') , \u2261F , \u2208inclset)\n      where\n      a\u2208-\u222adom\u2081 : k \u2208 dom m \u222a dom m\u2081\n      a\u2208-\u222adom\u2081 = dom\u222a\u207a\u2286\u222adom (to dom\u2208 (v , kv\u2208))\n\n      dom\u2081\u2286dom\u2082 : dom m\u2081 \u2286 dom m\u2082\n      dom\u2081\u2286dom\u2082 = dom\u2286 m\u2081\u2286m\u2082\n\n      k\u2208' : k \u2208 dom m \u222a dom m\u2082\n      k\u2208' = \u222a-cong-\u2286 id dom\u2081\u2286dom\u2082 a\u2208-\u222adom\u2081\n\n    \u222a\u207a-cong-l : {m : A \u21c0 B} \u2192 (m \u222a\u207a_ ) Preserves _\u2261\u1d50_ \u27f6 _\u2261\u1d50_\n    \u222a\u207a-cong-l m\u2081\u2261m\u2082@(m\u2081\u2286m\u2082 , m\u2082\u2286m\u2081) = (\u222a\u207a-cong-\u2286\u02e1 m\u2081\u2261m\u2082) , \u222a\u207a-cong-\u2286\u02e1 (m\u2082\u2286m\u2081 , m\u2081\u2286m\u2082)\n\n    \u222a\u207a-cong-r : {m : A \u21c0 B} \u2192 ( _\u222a\u207a m) Preserves _\u2261\u1d50_ \u27f6 _\u2261\u1d50_\n    \u222a\u207a-cong-r m\u2081\u2261m\u2082 .proj\u2081 kv\u2208m\u2081m = proj\u2081 \u222a\u207a-comm (\u222a\u207a-cong-\u2286\u02e1 m\u2081\u2261m\u2082 (proj\u2081 \u222a\u207a-comm kv\u2208m\u2081m))\n    \u222a\u207a-cong-r m\u2081\u2261m\u2082@(m\u2081\u2286m\u2082 , m\u2082\u2286m\u2081) .proj\u2082 kv\u2208m\u2082m =\n      proj\u2081 \u222a\u207a-comm (\u222a\u207a-cong-\u2286\u02e1 (m\u2082\u2286m\u2081 , m\u2081\u2286m\u2082) (proj\u2081 \u222a\u207a-comm kv\u2208m\u2082m))\n\n    \u222a\u207a-dom-id : (m : A \u21c0 B) \u2192 dom m \u2261\u1d49 dom m \u222a dom (\u2205{A \u21c0 B})\n    \u222a\u207a-dom-id m = begin\n      dom m \u2248\u02d8\u27e8 \u222a-identity\u02b3 (dom m) \u27e9\n      dom m \u222a \u2205 \u2248\u02d8\u27e8 \u222a-cong \u2261\u1d49.refl dom\u2205 \u27e9\n      dom m \u222a dom (\u2205{A \u21c0 B})\n      \u220e\n      where\n      open SetoidReasoning (\u2261\u1d49-Setoid{A})\n      module \u2261\u1d49 = IsEquivalence (\u2261\u1d49-isEquivalence {A})\n\n    \u222a\u207a-id-dom\u2208 :  (m : A \u21c0 B) \u2192 k \u2208 dom m  \u21d4  k \u2208 dom m \u222a dom (\u2205{A \u21c0 B})\n    \u222a\u207a-id-dom\u2208 m = mk\u21d4 (\u222a\u207a-dom-id m .proj\u2081) (\u222a\u207a-dom-id m .proj\u2082)\n\n    \u222a\u207a-id-lemma  :  (m : A \u21c0 B)\n                    (k\u2208m : k \u2208 dom m)\n                    (k\u2208 : k \u2208 dom m \u222a dom (\u2205{A \u21c0 B}))\n                 \u2192  lookup\u1d50\u2208 m k\u2208m \u2261 \u2225 m \u222a\u207a \u2205{A \u21c0 B} \u2225 k\u2208\n\n    \u222a\u207a-id-lemma {k} m k\u2208domm k\u2208domm\u222a with k \u2208? dom m | k \u2208? dom (\u2205{A \u21c0 B})\n    ... | _ | yes  k\u2208\u2205 = \u22a5-elim (\u22a5-elim (\u2209-dom\u2205 k\u2208\u2205))\n    ... | no  k\u2209m | no  k\u2209\u2205 = case from \u2208-\u222a k\u2208domm\u222a of \u03bb where\n      (inj\u2081 k\u2208m) \u2192 \u22a5-elim (k\u2209m k\u2208m)\n      (inj\u2082 k\u2208\u2205) \u2192 \u22a5-elim (k\u2209\u2205 k\u2208\u2205)\n    ... | yes k\u2208m | no  k\u2209\u2205 with from \u2208-map k\u2208domm\n    ... | (.k , v) , refl , kv\u2208m = m .proj\u2082 kv\u2208m (\u2208-lookup\u1d50\u2208 m k\u2208m)\n                                  -- goal : v \u2261 lookup\u1d50\u2208 m k\u2208m --\n\n    \u222a\u207a-id-r : (m : A \u21c0 B) \u2192 m \u222a\u207a \u2205{A \u21c0 B} \u2261\u1d50 m\n    \u222a\u207a-id-r m .proj\u2081 {(k , v)} kv\u2208m\u2205 with from \u2208-map kv\u2208m\u2205\n    ... | (.k , k\u2208) , refl , snd = subst  (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m)\n                                          (\u222a\u207a-id-lemma m (from (\u222a\u207a-id-dom\u2208 m) k\u2208) k\u2208)\n                                          (\u2208-lookup\u1d50\u2208 m $ from (\u222a\u207a-id-dom\u2208 m) k\u2208)\n\n    \u222a\u207a-id-r m .proj\u2082 {(k , v)} kv\u2208m with to dom\u2208 (v , kv\u2208m)\n    ... | k\u2208m =\n      subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m \u222a\u207a \u2205{A \u21c0 B}) (trans lu\u2261 v\u2261) (k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208)\n      where\n      k\u2208 : k \u2208 dom m \u222a dom (\u2205{A \u21c0 B})\n      k\u2208 = to (\u222a\u207a-id-dom\u2208 m) k\u2208m\n\n      lu\u2261 : \u2225 m \u222a\u207a (\u2205{A \u21c0 B}) \u2225 (\u2208-incl-set k\u2208 .proj\u2081) \u2261 lookup\u1d50\u2208 m (\u2208-incl-set k\u2208m .proj\u2081)\n      lu\u2261 = sym $ \u222a\u207a-id-lemma m (\u2208-incl-set k\u2208m .proj\u2081) (\u2208-incl-set k\u2208 .proj\u2081)\n\n      v\u2261 : lookup\u1d50\u2208 m (\u2208-incl-set k\u2208m .proj\u2081) \u2261 v\n      v\u2261 = sym $ m .proj\u2082 kv\u2208m (\u2208-lookup\u1d50\u2208 m (\u2208-incl-set k\u2208m .proj\u2081))\n\n    restrict-cong : (m\u2081 m\u2082 : A \u21c0 B) {ks : \u2119 A} \u2192 m\u2081 \u2261\u1d50 m\u2082 \u2192 (m\u2081 \u2223 ks \u1d9c) \u2261\u1d50 (m\u2082 \u2223 ks \u1d9c)\n    restrict-cong m\u2081 m\u2082 (m\u2081\u2286m\u2082 , _) .proj\u2081 ab\u2208 with res\u1d9c-dom\u2209\u207b m\u2081 ab\u2208\n    ... | ab\u2208 , a\u2209 = res\u1d9c-dom\u2209\u207a m\u2082 (m\u2081\u2286m\u2082 ab\u2208 , a\u2209)\n    restrict-cong m\u2081 m\u2082 (_ , m\u2082\u2286m\u2081) .proj\u2082 ab\u2208 with res\u1d9c-dom\u2209\u207b m\u2082 ab\u2208\n    ... | ab\u2208 , a\u2209 = res\u1d9c-dom\u2209\u207a m\u2081 (m\u2082\u2286m\u2081 ab\u2208 , a\u2209)\n\n\n  module _ {P : A \u2192 Type} \u2983 _ : P \u2047\u00b9 \u2984 where\n\n    P\u2032 : A \u00d7 B \u2192 Type\n    P\u2032 (k , _) = P k\n\n    P\u2192P\u2032 : P k \u2192 \u2200 b \u2192 P\u2032 (k , b)\n    P\u2192P\u2032 = \u03bb z _ \u2192 z\n\n    \u2208-dom-filter-P : (m : A \u21c0 B) \u2192 k \u2208 dom (filter\u1d50 P\u2032 m) \u2192 P k\n    \u2208-dom-filter-P _ k\u2208Pm = \u2208-filter .from (dom\u2208 .from k\u2208Pm .proj\u2082) .proj\u2081\n\n    \u2208-dom-filter-dom : (m : A \u21c0 B) \u2192 k \u2208 dom (filter\u1d50 P\u2032 m) \u2192 k \u2208 dom m\n    \u2208-dom-filter-dom m k\u2208domf with from dom\u2208 k\u2208domf\n    ... | b , kb\u2208filter = to dom\u2208 (b , proj\u2082 ((from \u2208-filter) kb\u2208filter))\n\n    dom-filter-\u2286 : (m : A \u21c0 B) \u2192 dom (filter\u1d50 P\u2032 m) \u2286 dom m\n    dom-filter-\u2286 m k\u2208Pm = dom\u2208 .to (_ , filter-\u2286 (dom\u2208 .from k\u2208Pm .proj\u2082))\n\n    \u2208-dom-filter\u02e1 : (m : A \u21c0 B) \u2192 k \u2208 dom (filter\u1d50 P\u2032 m) \u2192 P k \u00d7 k \u2208 dom m\n    \u2208-dom-filter\u02e1 m h = \u2208-dom-filter-P m h , \u2208-dom-filter-dom m h\n\n    \u2208-dom-filter\u02b3 : (m : A \u21c0 B) \u2192 P k \u00d7 k \u2208 dom m \u2192 k \u2208 dom (filter\u1d50 P\u2032 m)\n    \u2208-dom-filter\u02b3 m (pk , k\u2208) = dom\u2208 .to ( (from dom\u2208 k\u2208) .proj\u2081\n                                         , to \u2208-filter (pk , (from dom\u2208 k\u2208) .proj\u2082 ) )\n\n    filter\u1d50-\u2208 : (m : A \u21c0 B) {k : A} {v : B} \u2192 P k \u2192 (k , v) \u2208 m \u2192 (k , v) \u2208 filter\u1d50 P\u2032 m\n    filter\u1d50-\u2208 m = curry $ to \u2208-filter\n\n    cong-filter\u1d50 : (m\u2081 m\u2082 : A \u21c0 B) \u2192 m\u2081 \u2261\u1d50 m\u2082 \u2192 filter\u1d50 P\u2032 m\u2081 \u2261\u1d50 filter\u1d50 P\u2032 m\u2082\n    cong-filter\u1d50 m\u2081 m\u2082 eq .proj\u2081 \u2208Pm\u2081 = filter\u1d50-\u2208 m\u2082 (\u2208-dom-filter\u02e1 m\u2081 (\u2208-dom \u2208Pm\u2081) .proj\u2081) (eq .proj\u2081 (\u2208-filter .from \u2208Pm\u2081 .proj\u2082))\n    cong-filter\u1d50 m\u2081 m\u2082 eq .proj\u2082 \u2208Pm\u2082 = filter\u1d50-\u2208 m\u2081 (\u2208-dom-filter\u02e1 m\u2082 (\u2208-dom \u2208Pm\u2082) .proj\u2081) (eq .proj\u2082 (\u2208-filter .from \u2208Pm\u2082 .proj\u2082))\n\n    \u222a\u207a-filter-P\u2032 : (m\u2081 m\u2082 : A \u21c0 B) \u2192 (k , v) \u2208 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082 \u2192 P\u2032 (k , v)\n    \u222a\u207a-filter-P\u2032 {k = k}{v} m\u2081 m\u2082 kv\u2208 with (from \u2208-\u222a (\u222a\u207a-dom\u222a kv\u2208))\n    ... | inj\u2081 k\u2208\u2081 = \u2208-dom-filter\u02e1 m\u2081 k\u2208\u2081 .proj\u2081\n    ... | inj\u2082 k\u2208\u2082 = \u2208-dom-filter\u02e1 m\u2082 k\u2208\u2082 .proj\u2081\n\n    lookup\u2261lookup-filter  : (m : A \u21c0 B) (k\u2208 : k \u2208 dom m) (k\u2208\u2032 : k \u2208 dom (filter\u1d50 P\u2032 m))\n                          \u2192 lookup\u1d50\u2208 m k\u2208 \u2261 lookup\u1d50\u2208 (filter\u1d50 P\u2032 m) k\u2208\u2032\n    lookup\u2261lookup-filter m k\u2208 k\u2208\u2032 =\n      (m .proj\u2082) (\u2208-lookup\u1d50\u2208 m k\u2208) (proj\u2082 (from \u2208-filter (\u2208-lookup\u1d50\u2208 (filter\u1d50 P\u2032 m) k\u2208\u2032)))\n\n    \u2208-\u222a\u207a-l'  : {m\u2081 m\u2082 : A \u21c0 B} {k\u2208m\u2081 : k \u2208 dom m\u2081} {k\u2208m\u2081m\u2082 : k \u2208 dom m\u2081 \u222a dom m\u2082}\n             \u2192 (k , v) \u2208 m\u2081 \u222a\u207a m\u2082 \u2192 k \u2209 dom m\u2082\n             \u2192 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 (\u2208-incl-set k\u2208m\u2081m\u2082 .proj\u2081) \u2261 lookup\u1d50\u2208 m\u2081 k\u2208m\u2081\n    \u2208-\u222a\u207a-l' {k = k} {m\u2081 = m\u2081} {m\u2082} {k\u2208m\u2081} {k\u2208m\u2081m\u2082} kv\u2208m\u2081m\u2082 k\u2209m\u2082 with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n    ... | _ | yes k\u2208\u2082 = \u22a5-elim (k\u2209m\u2082 k\u2208\u2082)\n    ... | no k\u2209\u2081 | _ = \u22a5-elim (k\u2209\u2081 k\u2208m\u2081)\n    ... | yes k\u2208\u2081 | no k\u2209\u2082 with from \u2208-map k\u2208m\u2081\n    ... | (.k , v) , refl , kv\u2208m\u2081 = m\u2081 .proj\u2082 (\u2208-lookup\u1d50\u2208 m\u2081 k\u2208\u2081) kv\u2208m\u2081\n\n    \u2208-\u222a\u207a-l  : {m\u2081 m\u2082 : A \u21c0 B} (k\u2208m\u2081 : k \u2208 dom m\u2081)\n            \u2192 (k , v) \u2208 m\u2081 \u222a\u207a m\u2082 \u2192 k \u2209 dom m\u2082\n            \u2192 v \u2261 lookup\u1d50\u2208 m\u2081 k\u2208m\u2081\n    \u2208-\u222a\u207a-l k\u2208m\u2081 kv\u2208\u2081\u2082 k\u2209m\u2082 = trans (\u222a\u207a-unique-val (\u222a\u207a-dom\u222a kv\u2208\u2081\u2082) kv\u2208\u2081\u2082) (\u2208-\u222a\u207a-l' kv\u2208\u2081\u2082 k\u2209m\u2082)\n\n\n    \u222a\u207a-filter  : (m\u2081 m\u2082 : A \u21c0 B) {a : A} {b : B}\n               \u2192 (a , b) \u2208 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082\n               \u2192 a \u2208 dom m\u2081 \u2192 a \u2209 dom m\u2082 \u2192 (a , b) \u2208 filter\u1d50 P\u2032 m\u2081\n    \u222a\u207a-filter m\u2081 m\u2082 {a} {b} ab\u2208' a\u2208 a\u2209 =\n      subst (\u03bb \u2022 \u2192 (a , \u2022) \u2208 filter\u1d50 P\u2032 m\u2081) (sym $ \u2208-\u222a\u207a-l a\u2208f\u2081 ab\u2208' a\u2209f\u2082)\n                                            (from dom\u2208 a\u2208f\u2081 .proj\u2082)\n      where\n      a\u2208f\u2081 : a \u2208 dom (filter\u1d50 P\u2032 m\u2081)\n      a\u2208f\u2081 = \u2208-dom-filter\u02b3 m\u2081 (\u222a\u207a-filter-P\u2032 m\u2081 m\u2082 ab\u2208' , a\u2208)\n\n      a\u2209f\u2082 : a \u2209 dom (filter\u1d50 P\u2032 m\u2082)\n      a\u2209f\u2082 = a\u2209 \u2218 (\u2208-dom-filter-dom m\u2082)\n\n    \u222a\u207a-filter-lookup\u2261  : \u2200 (m\u2081 m\u2082 : A \u21c0 B) {a : A} {b : B}\n                       \u2192 (a , b) \u2208 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082\n                       \u2192 (a\u2208 : a \u2208 dom m\u2081) \u2192 a \u2209 dom m\u2082\n                       \u2192 b \u2261 lookup\u1d50\u2208 m\u2081 a\u2208\n    \u222a\u207a-filter-lookup\u2261 m\u2081 m\u2082 {a} {b} ab\u2208' a\u2208 a\u2209 =\n      proj\u2082 m\u2081 (from \u2208-filter (\u222a\u207a-filter m\u2081 m\u2082 ab\u2208' a\u2208 a\u2209) .proj\u2082) (from dom\u2208 a\u2208 .proj\u2082)\n\n    \u2208-\u222a\u207a-filter\u02e1  : {m\u2081 m\u2082 : A \u21c0 B} \u2192 (k , v) \u2208 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082\n                  \u2192 (k\u2208\u222adom : k \u2208 dom m\u2081 \u222a dom m\u2082) \u2192 k \u2208 dom (m\u2081 \u222a\u207a m\u2082)\n                  \u2192 These (k \u2208 dom(filter\u1d50 P\u2032 m\u2081)) (k \u2208 dom(filter\u1d50 P\u2032 m\u2082))\n                  \u2192 v \u2261 \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208\u222adom\n\n    \u2208-\u222a\u207a-filter\u02e1 {k = k} {v} {m\u2081}{m\u2082} kv\u2208\u2032 k\u2208\u222adom k\u2208dom\u222a\u207a (this k\u2208m\u2081\u2032) with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n    ... | no \u2209\u2081 | _ = \u22a5-elim $ \u2209\u2081 $ to dom\u2208 ( from dom\u2208 k\u2208m\u2081\u2032 .proj\u2081\n                                            , from \u2208-filter (proj\u2082 $ from dom\u2208 k\u2208m\u2081\u2032) .proj\u2082 )\n    ... | yes \u2208\u2081 | no  \u2209\u2082 = trans (\u222a\u207a-filter-lookup\u2261 m\u2081 m\u2082 kv\u2208\u2032 \u2208\u2081 \u2209\u2082) (lookup\u1d50\u2208\u2261 m\u2081)\n    ... | yes \u2208\u2081 | yes \u2208\u2082 = begin\n      v                                         \u2261\u27e8 \u222a\u207a-unique-val (\u222a\u207a-dom\u222a kv\u2208\u2032) kv\u2208\u2032 \u27e9\n      \u2225 m\u2081\u2032 \u222a\u207a m\u2082\u2032 \u2225 _                          \u2261\u27e8 \u2225\u222a\u207a\u2225\u2261lu\u25c7lu' kv\u2208\u2032 \u27e9\n      lookup\u1d50\u2208 m\u2081\u2032 k\u2208m\u2081\u2032 \u25c7 lookup\u1d50\u2208 m\u2082\u2032 k\u2208m\u2082\u2032   \u2261\u02d8\u27e8 cong (lookup\u1d50\u2208 m\u2081\u2032 k\u2208m\u2081\u2032 \u25c7_)\n                                                         (lookup\u2261lookup-filter m\u2082 \u2208\u2082 k\u2208m\u2082\u2032) \u27e9\n      lookup\u1d50\u2208 m\u2081\u2032 k\u2208m\u2081\u2032 \u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082       \u2261\u02d8\u27e8 cong (_\u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082)\n                                                         (lookup\u2261lookup-filter m\u2081 \u2208\u2081 k\u2208m\u2081\u2032) \u27e9\n      lookup\u1d50\u2208 m\u2081 \u2208\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082           \u220e\n        where\n        open \u2261-Reasoning\n        m\u2081\u2032 m\u2082\u2032 : A \u21c0 B\n        m\u2081\u2032 = filter\u1d50 P\u2032 m\u2081\n        m\u2082\u2032 = filter\u1d50 P\u2032 m\u2082\n\n        k\u2208m\u2082\u2032 : k \u2208 dom (filter\u1d50 P\u2032 m\u2082)\n        k\u2208m\u2082\u2032 = \u2208-dom-filter\u02b3 m\u2082 (proj\u2081 (\u2208-dom-filter\u02e1 m\u2081 k\u2208m\u2081\u2032) , \u2208\u2082)\n\n    \u2208-\u222a\u207a-filter\u02e1 {k = k} {v = v} {m\u2081 = m\u2081} {m\u2082} kv\u2208\u2032 k\u2208\u222adom\u2081\u2082 k\u2208dom\u222a\u2081\u2082 (that k\u2208m\u2082\u2032)\n      = trans v\u2261m\u2082m\u2081 \u222a\u207a-comm-val\n        where\n        v\u2261m\u2082m\u2081 : v \u2261 \u2225 m\u2082 \u222a\u207a m\u2081 \u2225 _\n        v\u2261m\u2082m\u2081 = \u2208-\u222a\u207a-filter\u02e1 (\u222a\u207a-comm-\u2286 kv\u2208\u2032)\n                              (proj\u2081 (\u222a-comm (dom m\u2081) (dom m\u2082)) k\u2208\u222adom\u2081\u2082)\n                              (dom\u2286 \u222a\u207a-comm-\u2286 k\u2208dom\u222a\u2081\u2082) (this k\u2208m\u2082\u2032)\n\n    \u2208-\u222a\u207a-filter\u02e1 {k = k} {v = v} {m\u2081 = m\u2081} {m\u2082} kv\u2208\u2032 k\u2208\u222adom k\u2208dom\u222a\u207a (these k\u2208m\u2081\u2032 k\u2208m\u2082\u2032)\n      with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n    ... | no \u2209\u2081 | _ = \u22a5-elim $ \u2209\u2081 $ to dom\u2208 ( from dom\u2208 k\u2208m\u2081\u2032 .proj\u2081\n                                            , from \u2208-filter (proj\u2082 $ from dom\u2208 k\u2208m\u2081\u2032) .proj\u2082 )\n    ... | yes \u2208\u2081 | no  \u2209\u2082 = trans (\u222a\u207a-filter-lookup\u2261 m\u2081 m\u2082 kv\u2208\u2032 \u2208\u2081 \u2209\u2082) (lookup\u1d50\u2208\u2261 m\u2081)\n    ... | yes \u2208\u2081 | yes \u2208\u2082 = let open \u2261-Reasoning; m\u2081\u2032 = filter\u1d50 P\u2032 m\u2081; m\u2082\u2032 = filter\u1d50 P\u2032 m\u2082 in\n      begin\n      v                                    \u2261\u27e8 \u222a\u207a-unique-val (\u222a\u207a-dom\u222a kv\u2208\u2032) kv\u2208\u2032 \u27e9\n      \u2225 m\u2081\u2032 \u222a\u207a m\u2082\u2032 \u2225 _                     \u2261\u27e8 \u2225\u222a\u207a\u2225\u2261lu\u25c7lu' kv\u2208\u2032 \u27e9\n      lookup\u1d50\u2208 m\u2081\u2032 _ \u25c7 lookup\u1d50\u2208 m\u2082\u2032 k\u2208m\u2082\u2032  \u2261\u02d8\u27e8 cong (lookup\u1d50\u2208 m\u2081\u2032 _ \u25c7_) (lookup\u2261lookup-filter m\u2082 \u2208\u2082 _) \u27e9\n      lookup\u1d50\u2208 m\u2081\u2032 k\u2208m\u2081\u2032 \u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082  \u2261\u02d8\u27e8 cong (_\u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082) (lookup\u2261lookup-filter m\u2081 \u2208\u2081 _) \u27e9\n      lookup\u1d50\u2208 m\u2081 \u2208\u2081 \u25c7 lookup\u1d50\u2208 m\u2082 \u2208\u2082      \u220e\n\n\n    opaque\n      open Equivalence\n\n      --------------------------------------------------------------------------------------------------\n      -- filter\u1d50-\u222a\u207a-distr  -----------------------------------------------------------------------------\n      -- Note: this property only holds because P\u2032 is not looking at the value.\n      -- Counter-example if it does look at the value:\n      -- Suppose `m\u2081\u02e2 = m\u2082\u02e2 = {(0, 1)}`, `P\u2032 (0, 1)`, and `\u00ac P\u2032 (0, 2)`.\n      -- Then `m\u2081 \u222a\u207a m\u2082 \u2261 {(0, 2)}` so (lhs) `filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)` is empty,\n      -- but `(filter\u1d50 P\u2032 m\u2081)\u02e2 \u2261 (filter\u1d50 P\u2032 m\u2082)\u02e2 = {(0, 1)}` so (rhs) `filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082` contains {(0, 2)}.\n\n      filter\u1d50-\u222a\u207a-distr-\u2287 : (m\u2081 m\u2082 : A \u21c0 B) \u2192 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082 \u2286 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)\n      filter\u1d50-\u222a\u207a-distr-\u2287 m\u2081 m\u2082 {k} {v} kv\u2208Pm\u2081Pm\u2082 =\n        case \u00bf P k \u00bf of \u03bb where\n          (yes pk) \u2192 yes-case pk\n          (no \u00acpk) \u2192 \u22a5-elim (\u00acpk ([ \u2208-dom-filter-P m\u2081 , \u2208-dom-filter-P m\u2082 ]\u2032 k\u2208Pm\u2081\u2228k\u2208Pm\u2082))\n        where\n          open \u2261-Reasoning\n          k\u2208Pm\u2081\u2228k\u2208Pm\u2082 : k \u2208 dom (filter\u1d50 P\u2032 m\u2081) \u228e k \u2208 dom (filter\u1d50 P\u2032 m\u2082)\n          k\u2208Pm\u2081\u2228k\u2208Pm\u2082 = \u2208-\u222a .from (dom\u222a\u207a\u2286\u222adom (\u2208-map\u2032 kv\u2208Pm\u2081Pm\u2082))\n\n          k\u2208Pm\u2081\u2295k\u2208Pm\u2082 : These (k \u2208 dom (filter\u1d50 P\u2032 m\u2081)) (k \u2208 dom (filter\u1d50 P\u2032 m\u2082))\n          k\u2208Pm\u2081\u2295k\u2208Pm\u2082 with k \u2208? dom (filter\u1d50 P\u2032 m\u2081) | k \u2208? dom (filter\u1d50 P\u2032 m\u2082) | k\u2208Pm\u2081\u2228k\u2208Pm\u2082\n          ... | yes \u2208\u2081 | yes \u2208\u2082 | _       = these \u2208\u2081 \u2208\u2082\n          ... | yes \u2208\u2081 | no  _  | _       = this \u2208\u2081\n          ... | no  _  | yes \u2208\u2082 | _       = that \u2208\u2082\n          ... | no  \u2209\u2081 | no  _  | inj\u2081 \u2208\u2081 = \u22a5-elim (\u2209\u2081 \u2208\u2081)\n          ... | no  _  | no  \u2209\u2082 | inj\u2082 \u2208\u2082 = \u22a5-elim (\u2209\u2082 \u2208\u2082)\n\n          yes-case : P k \u2192 (k , v) \u2208 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)\n          yes-case pk = \u2208-filter .to (pk , kv\u2208m\u2081m\u2082)\n            where\n              k\u2208m\u2081\u2228k\u2208m\u2082 : k \u2208 dom m\u2081 \u228e k \u2208 dom m\u2082\n              k\u2208m\u2081\u2228k\u2208m\u2082 = map-\u228e (dom-filter-\u2286 m\u2081) (dom-filter-\u2286 m\u2082) k\u2208Pm\u2081\u2228k\u2208Pm\u2082\n\n              k\u2208m\u2081m\u2082 : k \u2208 dom m\u2081 \u222a dom m\u2082\n              k\u2208m\u2081m\u2082 = \u2208-\u222a .to k\u2208m\u2081\u2228k\u2208m\u2082\n\n              k\u2208m\u2081m\u2082\u207a : k \u2208 dom (m\u2081 \u222a\u207a m\u2082)\n              k\u2208m\u2081m\u2082\u207a = \u222adom\u2286dom\u222a\u207a k\u2208m\u2081m\u2082\n\n              [kv\u2032\u2208m\u2081m\u2082] : \u03a3 (k \u2208 dom m\u2081 \u222a dom m\u2082) (\u03bb k\u2208m\u2081m\u2082\u2032 \u2192 (k , \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208m\u2081m\u2082\u2032) \u2208 m\u2081 \u222a\u207a m\u2082)\n              [kv\u2032\u2208m\u2081m\u2082] = _ , \u2208-map\u2032 (\u2208-incl-set k\u2208m\u2081m\u2082 .proj\u2082)\n\n              k\u2208m\u2081m\u2082\u2032 : k \u2208 dom m\u2081 \u222a dom m\u2082\n              k\u2208m\u2081m\u2082\u2032  = [kv\u2032\u2208m\u2081m\u2082] .proj\u2081\n\n              k\u2208m\u2081\u222a\u207am\u2082 : k \u2208 dom (m\u2081 \u222a\u207a m\u2082)\n              k\u2208m\u2081\u222a\u207am\u2082  = \u222adom\u2286dom\u222a\u207a k\u2208m\u2081m\u2082\u2032\n\n              v\u2032 : B\n              v\u2032 = \u2225 m\u2081 \u222a\u207a m\u2082 \u2225 k\u2208m\u2081m\u2082\u2032\n\n              kv\u2032\u2208m\u2081m\u2082 : (k , v\u2032) \u2208 m\u2081 \u222a\u207a m\u2082\n              kv\u2032\u2208m\u2081m\u2082 = [kv\u2032\u2208m\u2081m\u2082] .proj\u2082\n\n              v=v\u2032 : v \u2261 v\u2032\n              v=v\u2032 = \u2208-\u222a\u207a-filter\u02e1 kv\u2208Pm\u2081Pm\u2082 k\u2208m\u2081m\u2082\u2032 k\u2208m\u2081\u222a\u207am\u2082 k\u2208Pm\u2081\u2295k\u2208Pm\u2082\n\n              kv\u2208m\u2081m\u2082 : (k , v) \u2208 m\u2081 \u222a\u207a m\u2082\n              kv\u2208m\u2081m\u2082 = subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081 \u222a\u207a m\u2082) (sym v=v\u2032) kv\u2032\u2208m\u2081m\u2082\n\n      filter\u1d50-\u222a\u207a-distr-\u2286 : (m\u2081 m\u2082 : A \u21c0 B) \u2192 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082) \u2286 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082\n      filter\u1d50-\u222a\u207a-distr-\u2286 m\u2081 m\u2082 {k} {v} kv\u2208Pm\u2081m\u2082 with from \u2208-filter kv\u2208Pm\u2081m\u2082\n      ... | Pkv , kv\u2208 with k \u2208? dom m\u2081 | k \u2208? dom m\u2082\n      ... | yes k\u2208\u2081 | yes k\u2208\u2082 =\n        subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032) ((m\u2081 \u222a\u207a m\u2082) .proj\u2082 kb\u2208 kv\u2208) (\u2203b .proj\u2082)\n          where\n          open \u2261-Reasoning\n          m\u2081\u2032 m\u2082\u2032 : A \u21c0 B; m\u2081\u2032 = filter\u1d50 P\u2032 m\u2081; m\u2082\u2032 = filter\u1d50 P\u2032 m\u2082\n\n          k\u2208\u222adom\u2032 : k \u2208 dom m\u2081\u2032 \u222a dom m\u2082\u2032\n          k\u2208\u222adom\u2032 = to \u2208-\u222a $ inj\u2081 (\u2208-dom-filter\u02b3 m\u2081 (Pkv , k\u2208\u2081))\n\n          \u2203b : \u03a3 B \u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032\n          \u2203b = \u2225 m\u2081\u2032 \u222a\u207a m\u2082\u2032 \u2225 (\u2208-incl-set k\u2208\u222adom\u2032 .proj\u2081) , k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208\u222adom\u2032\n\n          b : B\n          b = \u2203b .proj\u2081\n\n          kb\u2208\u2032 : (k , b) \u2208 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)\n          kb\u2208\u2032 = filter\u1d50-\u222a\u207a-distr-\u2287 m\u2081 m\u2082 (\u2203b .proj\u2082)\n\n          kb\u2208 : (k , b) \u2208 m\u2081 \u222a\u207a m\u2082\n          kb\u2208 = (from \u2208-filter kb\u2208\u2032) .proj\u2082\n\n      ... | no k\u2209\u2081 | yes k\u2208\u2082 =\n        subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032) ((m\u2081 \u222a\u207a m\u2082) .proj\u2082 kb\u2208 kv\u2208) (\u2203b .proj\u2082)\n          where\n          open \u2261-Reasoning\n          m\u2081\u2032 m\u2082\u2032 : A \u21c0 B; m\u2081\u2032 = filter\u1d50 P\u2032 m\u2081; m\u2082\u2032 = filter\u1d50 P\u2032 m\u2082\n\n          k\u2208\u222adom\u2032 : k \u2208 dom m\u2081\u2032 \u222a dom m\u2082\u2032\n          k\u2208\u222adom\u2032 = to \u2208-\u222a $ inj\u2082 (\u2208-dom-filter\u02b3 m\u2082 (Pkv , k\u2208\u2082))\n\n          \u2203b : \u03a3 B \u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032\n          \u2203b = \u2225 m\u2081\u2032 \u222a\u207a m\u2082\u2032 \u2225 (\u2208-incl-set k\u2208\u222adom\u2032 .proj\u2081) , k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208\u222adom\u2032\n\n          b : B\n          b = \u2203b .proj\u2081\n\n          kb\u2208\u2032 : (k , b) \u2208 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)\n          kb\u2208\u2032 = filter\u1d50-\u222a\u207a-distr-\u2287 m\u2081 m\u2082 (\u2203b .proj\u2082)\n\n          kb\u2208 : (k , b) \u2208 m\u2081 \u222a\u207a m\u2082\n          kb\u2208 = (from \u2208-filter kb\u2208\u2032) .proj\u2082\n\n\n      ... | yes k\u2208\u2081 | no k\u2209\u2082 =\n        subst (\u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032) ((m\u2081 \u222a\u207a m\u2082) .proj\u2082 kb\u2208 kv\u2208) (\u2203b .proj\u2082)\n          where\n          open \u2261-Reasoning\n          m\u2081\u2032 m\u2082\u2032 : A \u21c0 B; m\u2081\u2032 = filter\u1d50 P\u2032 m\u2081; m\u2082\u2032 = filter\u1d50 P\u2032 m\u2082\n\n          k\u2208\u222adom\u2032 : k \u2208 dom m\u2081\u2032 \u222a dom m\u2082\u2032\n          k\u2208\u222adom\u2032 = to \u2208-\u222a $ inj\u2081 (\u2208-dom-filter\u02b3 m\u2081 (Pkv , k\u2208\u2081))\n\n          \u2203b : \u03a3 B \u03bb \u2022 \u2192 (k , \u2022) \u2208 m\u2081\u2032 \u222a\u207a m\u2082\u2032\n          \u2203b = \u2225 m\u2081\u2032 \u222a\u207a m\u2082\u2032 \u2225 (\u2208-incl-set k\u2208\u222adom\u2032 .proj\u2081) , k\u00d7\u2225\u222a\u207a\u2225\u2208\u222a\u207a' k\u2208\u222adom\u2032\n\n          b : B\n          b = \u2203b .proj\u2081\n\n          kb\u2208\u2032 : (k , b) \u2208 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082)\n          kb\u2208\u2032 = filter\u1d50-\u222a\u207a-distr-\u2287 m\u2081 m\u2082 (\u2203b .proj\u2082)\n\n          kb\u2208 : (k , b) \u2208 m\u2081 \u222a\u207a m\u2082\n          kb\u2208 = (from \u2208-filter kb\u2208\u2032) .proj\u2082\n\n      ... | no k\u2209\u2081 | no k\u2209\u2082 with from \u2208-\u222a (\u222a\u207a-dom\u222a kv\u2208)\n      ... | inj\u2081 k\u2208\u2081 = \u22a5-elim (k\u2209\u2081 k\u2208\u2081)\n      ... | inj\u2082 k\u2208\u2082 = \u22a5-elim (k\u2209\u2082 k\u2208\u2082)\n\n\n      -- MAIN LEMMA --\n      filter\u1d50-\u222a\u207a-distr : (m\u2081 m\u2082 : A \u21c0 B) \u2192 filter\u1d50 P\u2032 (m\u2081 \u222a\u207a m\u2082) \u2261\u1d50 filter\u1d50 P\u2032 m\u2081 \u222a\u207a filter\u1d50 P\u2032 m\u2082\n      filter\u1d50-\u222a\u207a-distr m\u2081 m\u2082 = filter\u1d50-\u222a\u207a-distr-\u2286 m\u2081 m\u2082 , filter\u1d50-\u222a\u207a-distr-\u2287 m\u2081 m\u2082\n\n\n      filter\u1d50-singleton-true : P k \u2192 filter\u1d50 P\u2032 \u2774 k , v \u2775 \u2261\u1d50 \u2774 k , v \u2775\n      filter\u1d50-singleton-true p .proj\u2081 = proj\u2082 \u2218 (from \u2208-filter)\n      filter\u1d50-singleton-true {k}{v} p .proj\u2082 {a} x = to \u2208-filter (subst P\u2032 (sym (from \u2208-singleton x)) p , x)\n\n      -- TODO: move to agda-sets\n      -- https://github.com/input-output-hk/agda-sets/pull/19\n      filter\u1d50-singleton-false : \u00ac P k \u2192 filter\u1d50 P\u2032 \u2774 k , v \u2775 \u2261\u1d50 \u2205\n      filter\u1d50-singleton-false \u00acp .proj\u2081 x =\n        \u22a5-elim $ \u00acp $ subst P\u2032 (from \u2208-singleton $ proj\u2082 (from \u2208-filter x)) (proj\u2081 $ from \u2208-filter x)\n      filter\u1d50-singleton-false _ .proj\u2082 = \u22a5-elim \u2218 \u2209-\u2205\n\n      filter\u1d50-restrict : \u2200 m {ks} \u2192 filter\u1d50 P\u2032 (m \u2223 ks \u1d9c) \u2261\u1d50 filter\u1d50 P\u2032 m \u2223 ks \u1d9c\n      filter\u1d50-restrict m {ks} .proj\u2081 {a , b} h with from \u2208-filter h\n      ... | Pa , ab\u2208m\u2216ks with res\u1d9c-dom\u2209\u207b m ab\u2208m\u2216ks\n      ... | ab\u2208m , a\u2209ks = res\u1d9c-dom\u2209\u207a (filter\u1d50 P\u2032 m) (to \u2208-filter (Pa , ab\u2208m) , a\u2209ks)\n      filter\u1d50-restrict m {ks} .proj\u2082 {a , b} h with res\u1d9c-dom\u2209\u207b (filter\u1d50 P\u2032 m) h\n      ... | ab\u2208m\u2032 , a\u2209ks = to \u2208-filter (from \u2208-filter ab\u2208m\u2032 .proj\u2081\n                                       , res\u1d9c-dom\u2209\u207a m (from \u2208-filter ab\u2208m\u2032 .proj\u2082 , a\u2209ks))\n\n      \u2208-filter-res- : {x : A \u00d7 B} (m : A \u21c0 B) \u2192 x \u2208 filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775 \u2192 P\u2032 x \u00d7 \u2203[ b ] x \u2261 (k , b)\n      \u2208-filter-res- m x\u2208 = proj\u2081 (from \u2208-filter $ res-\u2286 x\u2208) , res-singleton''{m = filter\u1d50 P\u2032 m} x\u2208\n\n      module \u2261\u1d49 = IsEquivalence (\u2261\u1d49-isEquivalence {\u03a3 A (\u03bb x \u2192 B)})\n      open SetoidReasoning (\u2261\u1d49-Setoid{\u03a3 A (\u03bb x \u2192 B)})\n\n      restrict-singleton-filter\u1d50-false : \u2200 m \u2192 \u00ac P k \u2192 filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775 \u1d9c \u2261\u1d50 filter\u1d50 P\u2032 m\n      restrict-singleton-filter\u1d50-false {k} m \u00acp = \u2261\u1d49.sym $\n        begin\n        filter\u1d50 P\u2032 m \u02e2                                        \u2248\u27e8 \u2261\u1d49.sym (res-ex-\u222a Dec-\u2208-singleton) \u27e9\n        (filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775) \u02e2 \u222a (filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775 \u1d9c)\u02e2  \u2248\u27e8 \u222a-cong \u00acP\u2192res-\u2205 \u2261\u1d49.refl \u27e9\n        \u2205 \u222a (filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775 \u1d9c) \u02e2                        \u2248\u27e8 \u222a-identity\u02e1 _ \u27e9\n        (filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775 \u1d9c) \u02e2                            \u220e\n          where\n          \u00acP\u2192res-\u2205 :  (filter\u1d50 P\u2032 m \u2223 \u2774 k \u2775)\u02e2 \u2261\u1d49 \u2205\n          \u00acP\u2192res-\u2205 .proj\u2081 {a} x with \u2208-filter-res- m x\n          ... | px , b , refl = \u22a5-elim (\u00acp px)\n          \u00acP\u2192res-\u2205 .proj\u2082 = \u22a5-elim \u2218 \u2209-\u2205\n\n\n    opaque\n      lem-add-included : P k \u2192 filter\u1d50 P\u2032 (m \u222a\u207a \u2774 k , v \u2775) \u2261\u1d50 filter\u1d50 P\u2032 m \u222a\u207a \u2774 k , v \u2775\n      lem-add-included p =\n        filter\u1d50-\u222a\u207a-distr _ _ \u27e8\u2248\u27e9 \u222a\u207a-cong-l (filter\u1d50-singleton-true p)\n\n      lem-add-excluded : \u00ac P k \u2192 filter\u1d50 P\u2032 (m \u222a\u207a \u2774 k , v \u2775) \u2261\u1d50 filter\u1d50 P\u2032 m\n      lem-add-excluded p =\n        filter\u1d50-\u222a\u207a-distr _ _ \u27e8\u2248\u27e9 \u222a\u207a-cong-l (filter\u1d50-singleton-false p) \u27e8\u2248\u27e9 \u222a\u207a-id-r _\n\n      -- TODO: move to agda-sets\n      -- https://github.com/input-output-hk/agda-sets/pull/19\n      lem-add-excluded-\u222a\u02e1\n        : (m : A \u21c0 B)\n        \u2192 \u00ac P k\n        \u2192 filter\u1d50 P\u2032 (m \u222a\u02e1 \u2774 k , v \u2775) \u2261\u1d50 filter\u1d50 P\u2032 m\n      lem-add-excluded-\u222a\u02e1 {k = k} {v = v} m \u00acp with k \u2208? dom m\n      ... | yes k\u2208m =\n          filter\u1d50-cong\n            {m = m \u222a\u02e1 \u2774 k , v \u2775}\n            {m' = m}\n            (singleton-\u2208-\u222a\u02e1 {m = m} k\u2208m)\n      ... | no k\u2209m = begin\n          filter\u1d50 P\u2032 (m \u222a\u02e1 \u2774 k , v \u2775) \u02e2\n            \u2248\u27e8 filter-cong $ disjoint-\u222a\u02e1-\u222a (disjoint-sing k\u2209m) \u27e9\n          filter\u02e2 P\u2032 (m \u02e2 \u222a \u2774 k , v \u2775)\n            \u2248\u27e8 filter-hom-\u222a \u27e9\n          filter\u02e2 P\u2032 (m \u02e2) \u222a filter\u02e2 P\u2032 \u2774 k , v \u2775\n            \u2248\u27e8 \u222a-cong \u2261\u1d49.refl (filter\u1d50-singleton-false \u00acp) \u27e9\n          filter\u02e2 P\u2032 (m \u02e2) \u222a \u2205\n            \u2248\u27e8 \u222a-identity\u02b3 (filter\u02e2 P\u2032 (m \u02e2)) \u27e9\n          filter\u02e2 P\u2032 (m \u02e2)\n          \u220e\n        where\n          disjoint-sing : k \u2209 dom m \u2192 disjoint (dom m) (dom (singleton (k , v)))\n          disjoint-sing k\u2209m a\u2208d a\u2208sing\n            rewrite from \u2208-dom-singleton-pair a\u2208sing = k\u2209m a\u2208d\n\n      lem-del-excluded : \u2200 m \u2192 \u00ac P k \u2192 filter\u1d50 P\u2032 (m \u2223 \u2774 k \u2775 \u1d9c) \u2261\u1d50 filter\u1d50 P\u2032 m\n      lem-del-excluded m \u00acp = filter\u1d50-restrict m \u27e8\u2248\u27e9 restrict-singleton-filter\u1d50-false m \u00acp\n</pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.Utxo.html","title":"Utxo","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Data.Unit using (\u22a4)\nopen import Data.Product using (_\u00d7_; _,_)\nopen import Function.Bundles using (_\u21d4_; mk\u21d4; Equivalence)\nopen import Relation.Binary.PropositionalEquality\nopen \u2261-Reasoning\n\nopen import Ledger.Conway.Conformance.Equivalence.Convert\n\nmodule Ledger.Conway.Conformance.Equivalence.Utxo\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Utxo txs abs public\n    open import Ledger.Conway.Specification.Utxow txs abs public\n    open import Ledger.Conway.Specification.Certs govStructure public\n\n  module C where\n    open import Ledger.Conway.Conformance.Utxo txs abs public\n    open import Ledger.Conway.Conformance.Utxow txs abs public\n    open import Ledger.Conway.Conformance.Certs govStructure public\n\nopen Tx\n\nsetDeposits : L.Deposits \u2192 L.UTxOState \u2192 L.UTxOState\nsetDeposits deposits utxoSt = record utxoSt { deposits = deposits }\n\nwithDepositsFrom : L.UTxOState \u2192 L.UTxOState \u2192 L.UTxOState\nwithDepositsFrom utxoSt = setDeposits (L.UTxOState.deposits utxoSt)\n\ninstance\n\n  UTXOSToConf : \u2200 {\u0393 s tx s'} \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s' \u2b46 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 (withDepositsFrom s s')\n  UTXOSToConf .conv\u2071 _ (L.Scripts-Yes (certsValid , eval , txValid)) = C.Scripts-Yes (eval , txValid)\n  UTXOSToConf .conv\u2071 _ (L.Scripts-No h)                              = C.Scripts-No h\n\nmodule _ {\u0393 s tx s'} where\n  open L.UTxOEnv \u0393 renaming (pparams to pp)\n  open L.UTxOState s using (deposits)\n  open Tx tx renaming (body to txb)\n\n  utxoSDeposits : \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s' \u2192 L.Deposits\n  utxoSDeposits (C.Scripts-Yes _) = L.updateDeposits pp txb deposits\n  utxoSDeposits (C.Scripts-No  _) = deposits\n\n  utxoDeposits : \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s' \u2192 L.Deposits\n  utxoDeposits (C.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ h) = utxoSDeposits h\n\n  utxowDeposits : \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s' \u2192 L.Deposits\n  utxowDeposits (C.UTXOW-inductive\u22ef _ _ _ _ _ _ _ _ h) = utxoDeposits h\n\ninstance\n  -- Here we pass in the ValidCertDeposits proof explicitly and\n  -- override the deposits in s' with updateDeposits (in case of\n  -- Scripts-Yes).\n  UTXOSFromConf : \u2200 {\u0393 s tx s'}\n                    (let open L.UTxOEnv \u0393 using () renaming (pparams to pp)\n                         open L.UTxOState s using (deposits)\n                         open Tx tx renaming (body to txb)\n                         open TxBody txb using (txCerts))\n                \u2192 (isValid tx \u2261 false \u228e L.ValidCertDeposits pp deposits txCerts)\n                  \u22a2 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s' \u2b46\u2071 \u03bb _ h \u2192\n                    \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 (setDeposits (utxoSDeposits h) s')\n  UTXOSFromConf .conv\u2071 (inj\u2081 refl)       (C.Scripts-Yes (eval , ()))\n  UTXOSFromConf .conv\u2071 (inj\u2082 validCerts) (C.Scripts-Yes (eval , txValid)) = L.Scripts-Yes (validCerts , eval , txValid)\n  UTXOSFromConf .conv\u2071 _ (C.Scripts-No h) = L.Scripts-No h\n\ninstance\n  -- It's a little weird that UTXO still has a bunch of preconditions\n  -- for consumed and produced (using updateDeposits) when the\n  -- deposits don't change! Why are they even part of the UTxOState?\n  -- In conformance the update happens in GOVCERT (under CERT).\n  UTXOToConf : \u2200 {\u0393 s tx s'} \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s' \u2b46 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXO\u2988 (withDepositsFrom s s')\n  UTXOToConf {s = s} {tx = tx} .conv\u2071 _ (L.UTXO-inductive (a , b , c , d , e , f , g , r , h , i , j , k , l , m , n , o , p , utxo)) =\n    C.UTXO-inductive (a , b , c , d , e , f , g , r , h , i , j , k , l , m , n , o , p , conv utxo)\n\n  UTXOFromConf : \u2200 {\u0393 s tx s'}\n                   (let open L.UTxOEnv \u0393 using () renaming (pparams to pp)\n                        open L.UTxOState s using (deposits)\n                        open Tx tx renaming (body to txb)\n                        open TxBody txb using (txCerts))\n               \u2192 (isValid tx \u2261 false \u228e L.ValidCertDeposits pp deposits txCerts)\n                 \u22a2 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s' \u2b46\u2071 \u03bb _ h \u2192\n                   \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXO\u2988 (setDeposits (utxoDeposits h) s')\n  UTXOFromConf {s = s} {tx = tx} .conv\u2071 validCerts (C.UTXO-inductive (a , b , c , d , e , f , g , r , h , i , j , k , l , m , n , o , p , utxo)) =\n    L.UTXO-inductive (a , b , c , d , e , f , g , r , h , i , j , k , l , m , n , o , p , (validCerts \u22a2conv utxo))\n\n  UTXOWToConf : \u2200 {\u0393 s tx s'} \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s' \u2b46 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 (withDepositsFrom s s')\n  UTXOWToConf .conv\u2071 _ (L.UTXOW-inductive\u22ef a b c d e f g h utxo) =\n    C.UTXOW-inductive\u22ef a b c d e f g h (conv utxo)\n\n  UTXOWFromConf : \u2200 {\u0393 s tx s'}\n                    (let open L.UTxOEnv \u0393 using () renaming (pparams to pp)\n                         open L.UTxOState s using (deposits)\n                         open Tx tx renaming (body to txb)\n                         open TxBody txb using (txCerts))\n                \u2192 (isValid tx \u2261 false \u228e L.ValidCertDeposits pp deposits txCerts)\n                  \u22a2 \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s' \u2b46\u2071 \u03bb _ h \u2192\n                    \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 (setDeposits (utxowDeposits h) s')  -- Conformance doesn't update deposits in UTXOW\n  UTXOWFromConf .conv\u2071 validCerts (C.UTXOW-inductive\u22ef a b c d e f g h utxo) =\n    L.UTXOW-inductive\u22ef a b c d e f g h (validCerts \u22a2conv utxo)\n</pre>"},{"location":"Ledger.Conway.Conformance.Equivalence.html","title":"Equivalence","text":"<pre>{-# OPTIONS --safe #-}\n-- Proof that the rules under Ledger.Conway.Conformance are equivalent\n-- to the rules under Ledger.\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Data.Unit using (\u22a4)\nopen import Data.Product using (_\u00d7_; _,_) renaming (map to \u27e8_,_\u27e9)\nopen import Function.Bundles using (_\u21d4_; mk\u21d4; Equivalence)\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Binary using (IsEquivalence)\n\nopen import Ledger.Conway.Conformance.Equivalence.Convert\n\nmodule Ledger.Conway.Conformance.Equivalence\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nmodule L where\n  open import Ledger.Conway.Specification.Ledger txs abs public\n  open import Ledger.Conway.Specification.Utxo txs abs public\n  open import Ledger.Conway.Specification.Utxow txs abs public\n  open import Ledger.Conway.Specification.Gov txs public\n  open import Ledger.Conway.Specification.Certs govStructure public\n\nmodule C where\n  open import Ledger.Conway.Conformance.Ledger txs abs public\n  open import Ledger.Conway.Conformance.Utxo txs abs public\n  open import Ledger.Conway.Conformance.Utxow txs abs public\n  open import Ledger.Conway.Conformance.Certs govStructure public\n\nopen import Ledger.Conway.Conformance.Equivalence.Certs txs abs\nopen import Ledger.Conway.Conformance.Equivalence.Utxo txs abs\nopen import Ledger.Conway.Conformance.Equivalence.Deposits txs abs\n\nopen Tx\nopen import Axiom.Set.Properties th using (\u2261\u1d49-Setoid)\n\n-- Invalid transactions don't change the deposits\nlemInvalidDepositsL : \u2200 {\u0393 utxoSt utxoSt' tx}\n                    \u2192 isValid tx \u2261 false\n                    \u2192 \u0393 L.\u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt'\n                    \u2192 L.UTxOState.deposits utxoSt \u2261 L.UTxOState.deposits utxoSt'\nlemInvalidDepositsL refl (L.UTXOW\u21d2UTXO\n                          (L.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n                            (L.Scripts-No _))) = refl\n\nlemInvalidDepositsC : \u2200 {\u0393 utxoSt utxoSt' tx}\n                    \u2192 isValid tx \u2261 false\n                    \u2192 (h : \u0393 C.\u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt')\n                    \u2192 utxowDeposits h \u2261 L.UTxOState.deposits utxoSt'\nlemInvalidDepositsC refl (C.UTXOW\u21d2UTXO\n                          (C.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n                            (C.Scripts-No _))) = refl\n\n-- The UTXOW rule doesn't change the deposits in Conformance\nlemDepositsC : \u2200 {\u0393 utxoSt utxoSt' tx}\n             \u2192 (h : \u0393 C.\u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt')\n             \u2192 L.UTxOState.deposits utxoSt \u2261 L.UTxOState.deposits utxoSt'\nlemDepositsC (C.UTXOW\u21d2UTXO\n               (C.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n                 (C.Scripts-Yes _))) = refl\nlemDepositsC (C.UTXOW\u21d2UTXO\n               (C.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n                 (C.Scripts-No _))) = refl\n\nlemUpdateDeposits : \u2200 {\u0393 s tx s'} (open L.UTxOEnv \u0393)\n                  \u2192 isValid tx \u2261 true\n                  \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n                  \u2192 L.updateDeposits pparams (body tx) (L.UTxOState.deposits s) \u2261 L.UTxOState.deposits s'\nlemUpdateDeposits refl\n  (L.UTXOW\u21d2UTXO\n    (L.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ _ _\n      (L.Scripts-Yes _))) = refl\n\ngetValidCertDeposits : \u2200 {\u0393 s tx s'}\n                     \u2192 (let open L.UTxOEnv \u0393 using (pparams)\n                            open L.UTxOState s using (deposits)\n                            open TxBody (tx .Tx.body) using (txCerts))\n                     \u2192 isValid tx \u2261 true\n                     \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n                     \u2192 L.ValidCertDeposits pparams deposits txCerts\ngetValidCertDeposits refl\n  (L.UTXOW\u21d2UTXO\n    (L.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n      (L.Scripts-Yes (v , _)))) = v\n\nmakeCertDeps* : \u2200 {\u0393 s tx s'}\n              \u2192 (let open L.UTxOEnv \u0393 using (pparams)\n                     open L.UTxOState s using (deposits)\n                     open TxBody (tx .Tx.body) using (txCerts))\n              \u2192 isValid tx \u2261 true\n              \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n              \u2192 CertDeps* pparams txCerts\nmakeCertDeps* {s = s} valid r = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#4085}{\\htmlId{4351}{\\htmlClass{Function}{\\text{certDDeps}}}}\\, \\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{4361}{\\htmlClass{Function}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#4231}{\\htmlId{4372}{\\htmlClass{Function}{\\text{certGDeps}}}}\\, \\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{4382}{\\htmlClass{Function}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#7768}{\\htmlId{4393}{\\htmlClass{Function}{\\text{validDDeps}}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.html#4492}{\\htmlId{4404}{\\htmlClass{Function}{\\text{validDeps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Deposits.html#8857}{\\htmlId{4416}{\\htmlClass{Function}{\\text{validGDeps}}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.html#4492}{\\htmlId{4427}{\\htmlClass{Function}{\\text{validDeps}}}}\\, \\end{pmatrix}$\n  where\n    open L.UTxOState s using (deposits)\n    validDeps = getValidCertDeposits valid r\n\nlem-cert-deposits-valid : \u2200 {\u0393 s tx s'} (open L.LEnv \u0393 using (pparams))\n                        \u2192 isValid tx \u2261 true\n                        \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s'\n                        \u2192 updateLedgerDeps pparams tx (certDeposits s) \u2261\u1d48 certDeposits s'\nlem-cert-deposits-valid {\u0393} {s} {tx} {s'} refl (L.LEDGER-V\u22ef refl utxow certs gov) rewrite sym (lemUpdateDeposits refl utxow) =\n  lem-upd-ddeps pparams deps tx ,\n  lem-upd-gdeps pparams deps tx\n  where\n    open L.LEnv \u0393 using (pparams)\n    deps = s .L.LState.utxoSt . L.UTxOState.deposits\n\nlem-cert-deposits-invalid : \u2200 {\u0393 s tx s'} (open L.LEnv \u0393 using (pparams))\n                        \u2192 isValid tx \u2261 false\n                        \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s'\n                        \u2192 certDeposits s \u2261\u1d48 certDeposits s'\nlem-cert-deposits-invalid refl (L.LEDGER-I\u22ef _ utxow) rewrite lemInvalidDepositsL refl utxow =\n  (id , id) , (id , id)\n\ninstance\n  LStateToConf : L.Deposits \u00d7 L.Deposits \u22a2 L.LState \u2b46 C.LState\n  LStateToConf .conv\u2071 deposits ledgerSt =\n    let open L.LState ledgerSt in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ledger.html#1408}{\\htmlId{5585}{\\htmlClass{Field}{\\text{utxoSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1435}{\\htmlId{5594}{\\htmlClass{Field}{\\text{govSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.html#5525}{\\htmlId{5602}{\\htmlClass{Bound}{\\text{deposits}}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#377}{\\htmlId{5611}{\\htmlClass{Function Operator}{\\text{\u22a2conv}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1461}{\\htmlId{5617}{\\htmlClass{Field}{\\text{certState}}}}\\, \\end{pmatrix}$\n\ninstance\n  LEDGERToConf : \u2200 {\u0393 s tx s'}\n               \u2192 \u0393 L.\u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s' \u2b46\n                 \u2203[ certDeposits-s' ]\n                    certDeposits-s' \u2261\u1d48 certDeposits s'\n                  \u00d7 \u0393 C.\u22a2 (certDeposits s \u22a2conv s) \u21c0\u2987 tx ,LEDGER\u2988 (certDeposits-s' \u22a2conv s')\n  LEDGERToConf {\u0393} {s} {tx} {s'} .conv\u2071 _ r@(L.LEDGER-V\u22ef refl utxow certs gov) =\n    updateLedgerDeps pparams tx (certDeposits s)\n    , lem-cert-deposits-valid refl r\n    , subst\u2082 (\u03bb \u2022 \u25c6 \u2192 \u0393 C.\u22a2 getCertDeps* cdeposits \u22a2conv s \u21c0\u2987 tx ,LEDGER\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Equivalence.html#6084}{\\htmlId{6144}{\\htmlClass{Bound}{\\text{\u2022}}}}\\, \\\\ \\,\\htmlId{6148}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.html#6086}{\\htmlId{6152}{\\htmlClass{Bound}{\\text{\u25c6}}}}\\, \\end{pmatrix}$)\n             utxoEq certsEq ledger'\n    where\n      open L.LEnv \u0393\n      open L.LState s\n      open L.LState s' renaming (utxoSt to utxoSt'; certState to certState'; govSt to govSt')\n      open TxBody (body tx) using (txCerts)\n      deposits = L.UTxOState.deposits utxoSt\n      utxow' : _ C.\u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 setDeposits deposits utxoSt'\n      utxow' = conv utxow\n      utxoStC'    = setDeposits (L.updateDeposits pparams (body tx) deposits) utxoSt'\n      cdeposits  = makeCertDeps* refl utxow\n      cdeposits' = updateCertDeps* txCerts cdeposits\n      certStateC' = getCertDeps* cdeposits' \u22a2conv certState'\n      certs' : _ C.\u22a2 (getCertDeps* cdeposits \u22a2conv certState) \u21c0\u2987 txCerts ,CERTS\u2988 certStateC'\n      certs' = cdeposits \u22a2conv certs\n      ledger' : \u0393 C.\u22a2 (getCertDeps* cdeposits \u22a2conv s) \u21c0\u2987 tx ,LEDGER\u2988 C.\u27e6 utxoStC' , govSt' , certStateC' \u27e7\u02e1\n      ledger' = C.LEDGER-V\u22ef refl utxow' certs' gov\n      utxoEq  : utxoStC' \u2261 utxoSt'\n      utxoEq  = cong (\u03bb \u2022 \u2192 $\\begin{pmatrix} \\,\\htmlId{7124}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{7128}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.html#7118}{\\htmlId{7132}{\\htmlClass{Bound}{\\text{\u2022}}}}\\, \\\\ \\,\\htmlId{7136}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$)\n                     (lemUpdateDeposits refl utxow)\n      ddeps = getCertDeps* cdeposits .proj\u2081\n      gdeps = getCertDeps* cdeposits .proj\u2082\n      certsEq : certStateC' \u2261 (updateDDeps pparams txCerts ddeps , updateGDeps pparams txCerts gdeps) \u22a2conv certState'\n      certsEq = cong\u2082 (\u03bb \u2022 \u25c6 \u2192 $\\begin{pmatrix} \\begin{pmatrix} \\,\\htmlId{7435}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{7439}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{7443}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.html#7425}{\\htmlId{7447}{\\htmlClass{Bound}{\\text{\u2022}}}}\\, \\end{pmatrix} \\\\ \\,\\htmlId{7453}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\begin{pmatrix} \\,\\htmlId{7459}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{7463}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.html#7427}{\\htmlId{7467}{\\htmlClass{Bound}{\\text{\u25c6}}}}\\, \\end{pmatrix} \\end{pmatrix}$)\n                     (lem-ddeps cdeposits)\n                     (lem-gdeps cdeposits)\n\n  -- LEDGERToConf {\u0393} {s} {tx} {s'} .conv\u2071 (cdeps , cdeps-eq) r@(L.LEDGER-I\u22ef refl utxow) =\n  LEDGERToConf {\u0393} {s} {tx} {s'} .conv\u2071 _ r@(L.LEDGER-I\u22ef refl utxow) =\n    certDeposits s , lem-cert-deposits-invalid refl r ,\n    subst (\u03bb \u2022 \u2192 \u0393 C.\u22a2 _ \u22a2conv s \u21c0\u2987 tx ,LEDGER\u2988 $\\begin{pmatrix} \\begin{pmatrix} \\,\\htmlId{7831}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{7835}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.html#7792}{\\htmlId{7839}{\\htmlClass{Bound}{\\text{\u2022}}}}\\, \\\\ \\,\\htmlId{7843}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix} \\\\ \\,\\htmlId{7849}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{7853}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$)\n          (lemInvalidDepositsL refl utxow)\n          (C.LEDGER-I\u22ef refl (conv utxow))\n\ninstance\n\n  LStateFromConf : C.LState \u2b46 L.LState\n  LStateFromConf .conv\u2071 _ ls =\n    let open C.LState ls in\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Ledger.html#928}{\\htmlId{8058}{\\htmlClass{Field}{\\text{utxoSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Ledger.html#955}{\\htmlId{8067}{\\htmlClass{Field}{\\text{govSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#559}{\\htmlId{8075}{\\htmlClass{Function}{\\text{conv}}}}\\, \\,\\href{Ledger.Conway.Conformance.Ledger.html#981}{\\htmlId{8080}{\\htmlClass{Field}{\\text{certState}}}}\\, \\end{pmatrix}$\n\ncertDepositsC : C.CertState \u2192 L.Deposits \u00d7 L.Deposits\ncertDepositsC cs = let open C.CertState cs in C.DState.deposits dState , C.GState.deposits gState\n\nWellformedLState : C.LState \u2192 Type\nWellformedLState s = certDepositsC (C.LState.certState s) \u2261\u1d48 certDeposits (conv s)\n\ngetValidCertDepositsCERTS : \u2200 {\u0393 s certs s'} deposits (open L.CertEnv \u0393 using (pp))\n                          \u2192 certDepositsC s \u2261\u1d48 (certDDeps deposits , certGDeps deposits)\n                          \u2192 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s certs s'\n                          \u2192 L.ValidCertDeposits pp deposits certs\ngetValidCertDepositsCERTS deposits wf (run-[] x) = L.[]\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-deleg (C.DELEG-delegate x)) rs)\n  = L.delegate (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-deleg (C.DELEG-dereg (_ , h , h'))) rs)\n  = L.dereg (\u2208-filter .Equivalence.from (wf .proj\u2081 .proj\u2081 h) .proj\u2082) h'\n            (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-deleg (C.DELEG-reg x)) rs)\n  = L.reg (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-pool L.POOL-regpool) rs)\n  = L.regpool (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-pool C.POOL-retirepool) rs)\n  = L.retirepool (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-vdel (C.GOVCERT-regdrep x)) rs)\n  = L.regdrep (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-vdel (C.GOVCERT-deregdrep (_ , h))) rs)\n  = L.deregdrep (\u2208-filter .Equivalence.from (wf .proj\u2082 .proj\u2081 h) .proj\u2082)\n                (getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\ngetValidCertDepositsCERTS {\u0393} {s} {cert \u2237 _} deposits wf (run-\u2237 (C.CERT-vdel (C.GOVCERT-ccreghot x)) rs)\n  = L.ccreghot(getValidCertDepositsCERTS _ (lemUpdCert (L.CertEnv.pp \u0393) (certDepositsC s) deposits cert wf) rs)\n\n\ngetValidCertDepositsC : \u2200 \u0393 s {s'} tx\n                     \u2192 (let open C.LEnv \u0393 using (pparams; slot; enactState)\n                            open TxBody (tx .Tx.body) using (txCerts; txGovVotes; txWithdrawals)\n                            open C.LState s\n                            open C.UTxOState utxoSt using (deposits)\n                            cc = C.allColdCreds govSt enactState\n                       )\n                     \u2192 WellformedLState s\n                     \u2192 isValid tx \u2261 true\n                     \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Core.Specification.Epoch.html#954}{\\htmlId{11152}{\\htmlClass{Function}{\\text{epoch}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1055}{\\htmlId{11158}{\\htmlClass{Function}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1113}{\\htmlId{11165}{\\htmlClass{Function}{\\text{pparams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Transaction.html#5049}{\\htmlId{11175}{\\htmlClass{Function}{\\text{txGovVotes}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Transaction.html#4874}{\\htmlId{11188}{\\htmlClass{Function}{\\text{txWithdrawals}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.html#10982}{\\htmlId{11204}{\\htmlClass{Bound}{\\text{cc}}}}\\, \\end{pmatrix}$ C.\u22a2 certState \u21c0\u2987 txCerts ,CERTS\u2988 s'\n                     \u2192 L.ValidCertDeposits pparams deposits txCerts\ngetValidCertDepositsC \u0393 s tx wf refl (run {s' = s'} (C.CERT-pre _ , cert-post)) =\n  getValidCertDepositsCERTS (C.UTxOState.deposits ((C.LState.utxoSt s))) wf cert-post\n\nlemUtxowDeposits : \u2200 {\u0393 s s' tx}\n                      (let open C.UTxOEnv \u0393 using (pparams))\n                  \u2192 isValid tx \u2261 true\n                  \u2192 (r : \u0393 C.\u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s')\n                  \u2192 utxowDeposits r \u2261 L.updateDeposits pparams (body tx) (C.UTxOState.deposits s')\nlemUtxowDeposits refl (C.UTXOW\u21d2UTXO\n                        (C.UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n                          (C.Scripts-Yes _))) = refl\n\ninstance\n\n  LEDGERFromConf : \u2200 {\u0393 s tx s'} \u2192 WellformedLState s\n                                    \u22a2 \u0393 C.\u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s'\n                                    \u2b46 \u0393 L.\u22a2 conv s \u21c0\u2987 tx ,LEDGER\u2988 conv s'\n  LEDGERFromConf .conv\u2071 _ (C.LEDGER-I\u22ef invalid utxow) with inj\u2081 invalid \u22a2conv utxow\n  ... | utxow' rewrite lemInvalidDepositsC invalid utxow = L.LEDGER-I\u22ef invalid utxow'\n  LEDGERFromConf {\u0393} {s} {tx} {s'} .conv\u2071 wf (C.LEDGER-V\u22ef refl utxow certs gov) =\n    subst (\u03bb \u2022 \u2192 \u0393 L.\u22a2 conv s \u21c0\u2987 tx ,LEDGER\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Equivalence.html#12404}{\\htmlId{12438}{\\htmlClass{Bound}{\\text{\u2022}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.html#12636}{\\htmlId{12442}{\\htmlClass{Function}{\\text{govSt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#559}{\\htmlId{12451}{\\htmlClass{Function}{\\text{conv}}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.html#12657}{\\htmlId{12456}{\\htmlClass{Function}{\\text{certSt'}}}}\\, \\end{pmatrix}$) eqUtxo ledger'\n    where\n      open C.LEnv \u0393\n\n      open C.LState s renaming (certState to certSt)\n      open C.LState s' using () renaming (utxoSt to utxoSt'; govSt to govSt'; certState to certSt')\n\n      open TxBody (body tx)\n      open C.UTxOState utxoSt using (deposits)\n\n      valid-deps : L.ValidCertDeposits pparams deposits txCerts\n      valid-deps = getValidCertDepositsC \u0393 s tx wf refl certs\n\n      utxow' : _ L.\u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 (setDeposits (utxowDeposits utxow) utxoSt')\n      utxow' = inj\u2082 valid-deps \u22a2conv utxow\n\n      eqUtxo : setDeposits (utxowDeposits utxow) utxoSt' \u2261 utxoSt'\n      eqUtxo = cong (\u03bb \u2022 \u2192 $\\begin{pmatrix} \\,\\htmlId{13096}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{13100}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.html#13090}{\\htmlId{13104}{\\htmlClass{Bound}{\\text{\u2022}}}}\\, \\\\ \\,\\htmlId{13108}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$) (lemUtxowDeposits refl utxow)\n\n      ledger' : \u0393 L.\u22a2 conv s \u21c0\u2987 tx ,LEDGER\u2988 L.\u27e6 setDeposits (utxowDeposits utxow) utxoSt'\n                                              , govSt'\n                                              , conv certSt' \u27e7\u02e1\n      ledger' = L.LEDGER-V\u22ef refl utxow' (conv certs) gov\n\nopen IsEquivalence \u2261\u1d48-isEquivalence renaming (refl to \u2261\u1d48-refl; sym to \u2261\u1d48-sym; trans to \u2261\u1d48-trans)\n\nlemCERTS'DepositsC : \u2200 {\u0393 s dcerts s'} (open C.CertEnv \u0393 using (pp))\n                   \u2192 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s dcerts s'\n                   \u2192 certDepositsC s' \u2261 \u27e8 updateDDeps pp dcerts , updateGDeps pp dcerts \u27e9 (certDepositsC s)\nlemCERTS'DepositsC (run-[] C.CERT-post) = refl\nlemCERTS'DepositsC (run-\u2237 (C.CERT-deleg  (C.DELEG-delegate     _)) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-deleg  (C.DELEG-dereg        _)) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-deleg  (C.DELEG-reg          _)) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-pool   L.POOL-regpool          ) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-pool    C.POOL-retirepool     )  rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-vdel   (C.GOVCERT-regdrep    _)) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-vdel   (C.GOVCERT-deregdrep  _)) rs) = lemCERTS'DepositsC rs\nlemCERTS'DepositsC (run-\u2237 (C.CERT-vdel   (C.GOVCERT-ccreghot   _)) rs) = lemCERTS'DepositsC rs\n\nlemCERTSDepositsC : \u2200 {\u0393 s txCerts s'} (open C.CertEnv \u0393 using (pp))\n                  \u2192 \u0393 C.\u22a2 s \u21c0\u2987 txCerts ,CERTS\u2988 s'\n                  \u2192 certDepositsC s' \u2261 \u27e8 updateDDeps pp txCerts , updateGDeps pp txCerts \u27e9 (certDepositsC s)\nlemCERTSDepositsC (run (C.CERT-pre _ , step)) = lemCERTS'DepositsC step\n\nlemWellformed : \u2200 {\u0393 s tx s'} \u2192 WellformedLState s \u2192 \u0393 C.\u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s' \u2192 WellformedLState s'\nlemWellformed {\u0393} {s = ls} {tx} {s' = ls'} wf (C.LEDGER-V\u22ef refl utxo certs gov) = goal\n  where\n    open C.LState ls  renaming (certState to certSt)\n    open C.LState ls' renaming (utxoSt to utxoSt'; certState to certSt')\n    open L.LEnv \u0393 using (pparams)\n    open TxBody (body tx)\n\n    deposits  = L.UTxOState.deposits utxoSt\n    deposits' = L.UTxOState.deposits utxoSt'\n\n    depositsL' = L.updateDeposits pparams (body tx) deposits\n\n    ddeps = certDepositsC certSt .proj\u2081\n    gdeps = certDepositsC certSt .proj\u2082\n\n    ddeps' = certDepositsC certSt' .proj\u2081\n    gdeps' = certDepositsC certSt' .proj\u2082\n\n    lem : deposits' \u2261 depositsL'\n    lem rewrite lemDepositsC utxo = refl\n\n    lem\u2081 : (ddeps' , gdeps') \u2261 (updateDDeps pparams txCerts ddeps , updateGDeps pparams txCerts gdeps)\n    lem\u2081 = lemCERTSDepositsC certs\n\n    lem\u2082 :  (updateDDeps pparams txCerts (certDDeps deposits) , updateGDeps pparams txCerts (certGDeps deposits))\n         \u2261\u1d48 (certDDeps deposits' , certGDeps deposits')\n    lem\u2082 rewrite lem = lem-upd-ddeps pparams deposits tx , lem-upd-gdeps pparams deposits tx\n\n    lem\u2083 :  (updateDDeps pparams txCerts ddeps , updateGDeps pparams txCerts gdeps)\n         \u2261\u1d48 (updateDDeps pparams txCerts (certDDeps deposits) , updateGDeps pparams txCerts (certGDeps deposits))\n    lem\u2083 = \u27e8 cong-updateDDeps txCerts , cong-updateGDeps txCerts \u27e9 wf\n\n    goal : (ddeps' , gdeps') \u2261\u1d48 (certDDeps deposits' , certGDeps deposits')\n    goal with refl \u2190 lem\u2081 = \u2261\u1d48-trans {ddeps' , gdeps'}\n                                     {updateDDeps pparams txCerts (certDDeps deposits) , updateGDeps pparams txCerts (certGDeps deposits)}\n                                     {certDDeps deposits' , certGDeps deposits'}\n                              lem\u2083\n                              lem\u2082\nlemWellformed wf (C.LEDGER-I\u22ef refl utxo) rewrite lemDepositsC utxo = wf\n\nsetCertDeposits : L.Deposits \u00d7 L.Deposits \u2192 C.CertState \u2192 C.CertState\nsetCertDeposits (ddeps , gdeps) cs =\n  let open C.CertState cs in\n  $\\begin{pmatrix} \\,\\htmlId{16965}{\\htmlClass{Keyword}{\\text{record}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#1108}{\\htmlId{16972}{\\htmlClass{Field}{\\text{dState}}}}\\, \\,\\htmlId{16979}{\\htmlClass{Symbol}{\\text{{}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#849}{\\htmlId{16980}{\\htmlClass{Field}{\\text{deposits}}}}\\, \\,\\htmlId{16989}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.html#16912}{\\htmlId{16991}{\\htmlClass{Bound}{\\text{ddeps}}}}\\,\\,\\htmlId{16996}{\\htmlClass{Symbol}{\\text{}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Certs.html#1128}{\\htmlId{17000}{\\htmlClass{Field}{\\text{pState}}}}\\, \\\\ \\,\\htmlId{17009}{\\htmlClass{Keyword}{\\text{record}}}\\, \\,\\href{Ledger.Conway.Conformance.Certs.html#1148}{\\htmlId{17016}{\\htmlClass{Field}{\\text{gState}}}}\\, \\,\\htmlId{17023}{\\htmlClass{Symbol}{\\text{{}}}\\,\\,\\href{Ledger.Conway.Conformance.Certs.html#1019}{\\htmlId{17024}{\\htmlClass{Field}{\\text{deposits}}}}\\, \\,\\htmlId{17033}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Ledger.Conway.Conformance.Equivalence.html#16920}{\\htmlId{17035}{\\htmlClass{Bound}{\\text{gdeps}}}}\\,\\,\\htmlId{17040}{\\htmlClass{Symbol}{\\text{}}}}\\, \\end{pmatrix}$\n\nupdateCDep : PParams \u2192 L.DCert \u2192 L.Deposits \u00d7 L.Deposits \u2192 L.Deposits \u00d7 L.Deposits\nupdateCDep pp cert (ddep , gdep) = updateDDep pp cert ddep , updateGDep pp cert gdep\n\nopaque\n  castCERTS' : \u2200 {\u0393 certs} {s s' : L.CertState} deps\u2081 deps\u2082 deps\u2081'\n             \u2192 deps\u2081 \u2261\u1d48 deps\u2082\n             \u2192 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 (deps\u2081 \u22a2conv s) certs (deps\u2081' \u22a2conv s')\n             \u2192 \u2203[ deps\u2082' ] deps\u2081' \u2261\u1d48 deps\u2082'\n                           \u00d7 RunTraceAndThen C._\u22a2_\u21c0\u2987_,CERT\u2988_ C._\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 (deps\u2082 \u22a2conv s) certs (deps\u2082' \u22a2conv s')\n  castCERTS' deps\u2081 deps\u2082 deps\u2081' eqd (run-[] C.CERT-post) = deps\u2082 , eqd , run-[] C.CERT-post\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-deleg {dCert = cert} (C.DELEG-delegate h))    rs)\n    = let\n        open C.CertEnv \u0393 using (pp)\n        deps\u2082' , eqd' , rs' = castCERTS' (updateCDep pp cert deps\u2081) (updateCDep pp cert deps\u2082) deps\u2081'\n                                         (\u27e8 cong-updateDDep {pp} cert {deps\u2081 .proj\u2081} {deps\u2082 .proj\u2081}\n                                          , cong-updateGDep {pp} cert {deps\u2081 .proj\u2082} {deps\u2082 .proj\u2082} \u27e9 eqd) rs\n        in  deps\u2082' , eqd' , run-\u2237 (C.CERT-deleg (C.DELEG-delegate h)) rs'\n\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-deleg {dCert = cert} (C.DELEG-dereg (a , b , c))) rs) =\n    let open C.CertEnv \u0393 using (pp)\n        deps\u2082' , eqd' , rs' = castCERTS' (updateCDep pp cert deps\u2081) (updateCDep pp cert deps\u2082) deps\u2081'\n                                         (\u27e8 cong-updateDDep {pp} cert {deps\u2081 .proj\u2081} {deps\u2082 .proj\u2081}\n                                          , cong-updateGDep {pp} cert {deps\u2081 .proj\u2082} {deps\u2082 .proj\u2082} \u27e9 eqd) rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-deleg (C.DELEG-dereg (a , eqd .proj\u2081 .proj\u2081 b , c))) rs'\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-deleg {dCert = cert} (C.DELEG-reg h))         rs) =\n    let open C.CertEnv \u0393 using (pp)\n        deps\u2082' , eqd' , rs' = castCERTS' (updateCDep pp cert deps\u2081) (updateCDep pp cert deps\u2082) deps\u2081'\n                                         (\u27e8 cong-updateDDep {pp} cert {deps\u2081 .proj\u2081} {deps\u2082 .proj\u2081}\n                                          , cong-updateGDep {pp} cert {deps\u2081 .proj\u2082} {deps\u2082 .proj\u2082} \u27e9 eqd) rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-deleg (C.DELEG-reg h)) rs'\n\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-pool  {dCert = cert} L.POOL-regpool)          rs) =\n    let deps\u2082' , eqd' , rs' = castCERTS' deps\u2081 deps\u2082 deps\u2081' eqd rs\n    in  deps\u2082' , eqd' , run-\u2237  (C.CERT-pool L.POOL-regpool) rs'\n\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-pool  {dCert = cert} C.POOL-retirepool)       rs) =\n    let deps\u2082' , eqd' , rs' = castCERTS' deps\u2081 deps\u2082 deps\u2081' eqd rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-pool C.POOL-retirepool) rs'\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-vdel  {dCert = cert} (C.GOVCERT-regdrep h))   rs) =\n    let open C.CertEnv \u0393 using (pp)\n        deps\u2082' , eqd' , rs' = castCERTS' (updateCDep pp cert deps\u2081) (updateCDep pp cert deps\u2082) deps\u2081'\n                                         (\u27e8 cong-updateDDep {pp} cert {deps\u2081 .proj\u2081} {deps\u2082 .proj\u2081}\n                                          , cong-updateGDep {pp} cert {deps\u2081 .proj\u2082} {deps\u2082 .proj\u2082} \u27e9 eqd) rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-vdel (C.GOVCERT-regdrep h)) rs'\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-vdel  {dCert = cert} (C.GOVCERT-deregdrep (a , b))) rs) =\n    let open C.CertEnv \u0393 using (pp)\n        deps\u2082' , eqd' , rs' = castCERTS' (updateCDep pp cert deps\u2081) (updateCDep pp cert deps\u2082) deps\u2081'\n                                         (\u27e8 cong-updateDDep {pp} cert {deps\u2081 .proj\u2081} {deps\u2082 .proj\u2081}\n                                          , cong-updateGDep {pp} cert {deps\u2081 .proj\u2082} {deps\u2082 .proj\u2082} \u27e9 eqd) rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-vdel (C.GOVCERT-deregdrep (a , eqd .proj\u2082 .proj\u2081 b))) rs'\n                                                                   -- ^^^^^^^^^^^^^^^^^^^ Actual work\n  castCERTS' {\u0393} deps\u2081 deps\u2082 deps\u2081' eqd (run-\u2237 (C.CERT-vdel  {dCert = cert} (C.GOVCERT-ccreghot h))  rs) =\n    let deps\u2082' , eqd' , rs' = castCERTS' deps\u2081 deps\u2082 deps\u2081' eqd rs\n    in  deps\u2082' , eqd' , run-\u2237 (C.CERT-vdel (C.GOVCERT-ccreghot h)) rs'\n\n  castCERTS : \u2200 {\u0393 certs} {s s' : L.CertState} deps\u2081 deps\u2082 deps\u2081'\n            \u2192 deps\u2081 \u2261\u1d48 deps\u2082\n            \u2192 \u0393 C.\u22a2 deps\u2081 \u22a2conv s \u21c0\u2987 certs ,CERTS\u2988 (deps\u2081' \u22a2conv s')\n            \u2192 \u2203[ deps\u2082' ] deps\u2081' \u2261\u1d48 deps\u2082' \u00d7 \u0393 C.\u22a2 deps\u2082 \u22a2conv s \u21c0\u2987 certs ,CERTS\u2988 (deps\u2082' \u22a2conv s')\n  castCERTS deps\u2081 deps\u2082 deps\u2081' eqd (run (C.CERT-pre h , step)) =\n    let deps\u2082' , eqd' , step' = castCERTS' deps\u2081 deps\u2082 deps\u2081' eqd step\n    in  deps\u2082' , eqd' , run (C.CERT-pre h , step')\n\n_\u22a2_\u21c0\u2987_,GOVn\u2988_ : L.GovEnv \u00d7 \u2115 \u2192 L.GovState \u2192 List (GovVote \u228e GovProposal) \u2192 L.GovState \u2192 Type\n_\u22a2_\u21c0\u2987_,GOVn\u2988_ = _\u22a2_\u21c0\u27e6_\u27e7\u1d62*'_ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = IdSTS} {_\u22a2_\u21c0\u27e6_\u27e7_ = L._\u22a2_\u21c0\u2987_,GOV\u2988_}\n\nopaque\n  castLEDGER : \u2200 {\u0393 tx} {s s' : L.LState} deps\u2081 deps\u2082 deps\u2081'\n            \u2192 deps\u2081 \u2261\u1d48 deps\u2082\n            \u2192 \u0393 C.\u22a2 deps\u2081 \u22a2conv s \u21c0\u2987 tx ,LEDGER\u2988 (deps\u2081' \u22a2conv s')\n            \u2192 \u2203[ deps\u2082' ] deps\u2081' \u2261\u1d48 deps\u2082' \u00d7 \u0393 C.\u22a2 deps\u2082 \u22a2conv s \u21c0\u2987 tx ,LEDGER\u2988 (deps\u2082' \u22a2conv s')\n  castLEDGER {\u0393} {tx} {s} {s'} deps\u2081 deps\u2082 deps\u2081' eqd (C.LEDGER-V\u22ef refl utxo certs gov) =\n    let deps\u2082' , eqd' , certs' = castCERTS deps\u2081 deps\u2082 deps\u2081' eqd certs\n    in  deps\u2082' , eqd' , C.LEDGER-V\u22ef refl utxo certs' gov\n  castLEDGER deps\u2081 deps\u2082 deps\u2081' eqd (C.LEDGER-I\u22ef refl utxo) = _ , eqd , C.LEDGER-I\u22ef refl utxo\n\n---------------------------------------------------------------------------\n-- The main result\n---------------------------------------------------------------------------\n\nopen import Ledger.Conway.Conformance.Equivalence.Bisimilarity\n\n-- An LState s\u02e1 from the Spec and an LState s\u1d9c from Conformance are\n-- bisimular iff\n--  \u2219 the deposits in the CertState of s\u1d9c are equal (as maps) to the\n--    appropriate restrictions of the deposits in the UTxOState of s\u02e1\n--  \u2219 the only difference between s\u02e1 and s\u1d9c are the extra deposits in\n--    the CertState of s\u1d9c.\n_\u223c_ : L.LState \u2192 C.LState \u2192 Type\ns\u02e1 \u223c s\u1d9c = certDeposits s\u02e1 \u2261\u1d48 certDepositsC (C.LState.certState s\u1d9c) \u00d7 s\u02e1 \u2261 conv s\u1d9c\n\n-- This gives us the main result: a bisimulation between the LEDGER\n-- rules in Ledger and in Conformance.\nbisimilarityProof : Bisimilar L._\u22a2_\u21c0\u2987_,LEDGER\u2988_ C._\u22a2_\u21c0\u2987_,LEDGER\u2988_\nbisimilarityProof .Bisimilar._\u2248_ = _\u223c_\nbisimilarityProof .Bisimilar.to {\u0393} {tx} {s\u02e1} {s\u02e1'} {s\u1d9c} (eq , refl) r =\n  let deps  , eqd  , r'  = conv r\n      deps' , eqd' , r'' = castLEDGER (certDeposits (conv s\u1d9c))\n                                      (certDepositsC (C.LState.certState s\u1d9c))\n                                      deps\n                                      eq\n                                      r'\n      eqd'' : certDeposits s\u02e1' \u2261\u1d48 deps'\n      eqd'' = \u2261\u1d48-trans {certDeposits s\u02e1'} {deps} {deps'} (\u2261\u1d48-sym {deps} {certDeposits s\u02e1'} eqd) eqd'\n  in\n  (deps' \u22a2conv s\u02e1') , (eqd'' , refl) , r''\nbisimilarityProof .Bisimilar.from {\u0393} {tx} {s\u02e1} {s\u1d9c} {s\u1d9c'} (eqd , refl) r =\n  conv s\u1d9c' , (wf' , refl) , wf \u22a2conv r\n  where\n    wf  = \u2261\u1d48-sym {certDeposits (conv s\u1d9c)} {certDepositsC (C.LState.certState s\u1d9c)} eqd\n    wf' = \u2261\u1d48-sym {certDepositsC (C.LState.certState s\u1d9c')} {certDeposits (conv s\u1d9c')} (lemWellformed wf r)\n    r' = wf \u22a2conv r\n</pre>"},{"location":"Ledger.Conway.Conformance.Gov.html","title":"Gov","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nmodule Ledger.Conway.Conformance.Gov\n  (txs : _) (open TransactionStructure txs hiding (epoch))\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Axiom.Set.Properties th using (\u2203-sublist-\u21d4)\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Ledger txs abs\n\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Ledger.Conway.Conformance.Equivalence.Certs txs abs\nopen import Ledger.Conway.Conformance.Equivalence.Convert\n\nopen import Ledger.Conway.Specification.Gov txs using (GovState) public\nimport Ledger.Conway.Specification.Gov txs as L\n\nrecord GovEnv : Type where\n  field\n    txid        : TxId\n    epoch       : Epoch\n    pparams     : PParams\n    ppolicy     : Maybe ScriptHash\n    enactState  : EnactState\n    certState   : CertState\n    rewardCreds : \u2119 Credential\n\ninstance\n  unquoteDecl HasCast-GovEnv = derive-HasCast\n    [ (quote GovEnv , HasCast-GovEnv) ]\n\n_\u22a2_\u21c0\u2987_,GOVS\u2988_ : GovEnv \u2192 GovState \u2192 List (GovVote \u228e GovProposal) \u2192 GovState \u2192 Type\n\u0393 \u22a2 govSt \u21c0\u2987 gvps ,GOVS\u2988 govSt'\n  = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Gov.html#952}{\\htmlId{1362}{\\htmlClass{Function}{\\text{txid}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Gov.html#975}{\\htmlId{1369}{\\htmlClass{Function}{\\text{epoch}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Gov.html#999}{\\htmlId{1377}{\\htmlClass{Function}{\\text{pparams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Gov.html#1025}{\\htmlId{1387}{\\htmlClass{Function}{\\text{ppolicy}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Gov.html#1060}{\\htmlId{1397}{\\htmlClass{Function}{\\text{enactState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#559}{\\htmlId{1410}{\\htmlClass{Function}{\\text{conv}}}}\\, \\,\\href{Ledger.Conway.Conformance.Gov.html#1089}{\\htmlId{1415}{\\htmlClass{Function}{\\text{certState}}}}\\, \\\\\n  \\,\\href{Ledger.Conway.Conformance.Gov.html#1117}{\\htmlId{1429}{\\htmlClass{Function}{\\text{rewardCreds}}}}\\, \\end{pmatrix}$ L.\u22a2 rmOrphanDRepVotes (conv certState) govSt  \u21c0\u2987 gvps ,GOVS\u2988 govSt'\n  where open GovEnv \u0393\n</pre>"},{"location":"Ledger.Conway.Conformance.Ledger.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\nimport Ledger.Conway.Conformance.Certs\n\nmodule Ledger.Conway.Conformance.Ledger.Properties\n  (txs : _) (open TransactionStructure txs) (open Ledger.Conway.Conformance.Certs govStructure)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Axiom.Set.Properties th\nopen import Ledger.Conway.Conformance.Chain txs abs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Conformance.Epoch txs abs\nopen import Ledger.Conway.Conformance.Certs.Properties govStructure\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Gov.Properties.Computational txs\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Utxo.Properties txs abs\nopen import Ledger.Conway.Conformance.Utxow txs abs\nopen import Ledger.Conway.Conformance.Utxow.Properties txs abs\n\nopen import Data.Bool.Properties using (\u00ac-not)\nopen import Data.List.Base using (filter)\nopen import stdlib.Data.List.Subpermutations using (\u2208\u02e1-map-filter)\nopen import Data.List.Properties using (++-identity\u02b3; map-++; ++-assoc; length-++)\nopen import Data.List.Membership.Propositional.Properties using (\u2208-filter\u207a; map-\u2208\u2194)\nopen import Data.Product.Properties using (\u00d7-\u2261,\u2261\u2190\u2261)\nopen import Data.Nat.Properties using (+-0-monoid; +-identity\u02b3; +-suc; +-comm)\nopen import Relation.Binary using (IsEquivalence)\nopen import Relation.Unary using (Decidable)\n\nopen import Ledger.Conway.Conformance.Equivalence.Certs txs abs\nopen import Ledger.Conway.Conformance.Equivalence.Convert\n\nimport Function.Related.Propositional as R\n\nimport Relation.Binary.Reasoning.Setoid as SetoidReasoning\n\ninstance _ = +-0-monoid\n\nopen import Interface.ComputationalRelation\n\n-- ** Proof that LEDGER is computational.\n\ninstance\n  _ = Monad-ComputationResult\n\n  Computational-LEDGER : Computational _\u22a2_\u21c0\u2987_,LEDGER\u2988_ String\n  Computational-LEDGER = record {go}\n    where\n    open Computational \u2983...\u2984 renaming (computeProof to comp; completeness to complete)\n    computeUtxow = comp {STS = _\u22a2_\u21c0\u2987_,UTXOW\u2988_}\n    computeCerts = comp {STS = _\u22a2_\u21c0\u2987_,CERTS\u2988_}\n    computeGov   = comp {STS = _\u22a2_\u21c0\u2987_,GOVS\u2988_}\n\n    module go\n      (\u0393 : LEnv)   (let open LEnv \u0393)\n      (s : LState) (let open LState s)\n      (tx : Tx)    (let open Tx tx renaming (body to txb); open TxBody txb)\n      where\n      utxo\u0393 = UTxOEnv \u220b record { LEnv \u0393 }\n      cert\u0393 = CertEnv \u220b $\\begin{pmatrix} \\,\\href{Ledger.Core.Specification.Epoch.html#954}{\\htmlId{2749}{\\htmlClass{Function}{\\text{epoch}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1055}{\\htmlId{2755}{\\htmlClass{Field}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1113}{\\htmlId{2762}{\\htmlClass{Field}{\\text{pparams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Transaction.html#5049}{\\htmlId{2772}{\\htmlClass{Function}{\\text{txGovVotes}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Transaction.html#4874}{\\htmlId{2785}{\\htmlClass{Function}{\\text{txWithdrawals}}}}\\, \\\\ \\,\\htmlId{2801}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$\n      gov\u0393 : CertState \u2192 GovEnv\n      gov\u0393 certState = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Transaction.html#4766}{\\htmlId{2862}{\\htmlClass{Function}{\\text{txId}}}}\\, \\\\ \\,\\href{Ledger.Core.Specification.Epoch.html#954}{\\htmlId{2869}{\\htmlClass{Function}{\\text{epoch}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1055}{\\htmlId{2875}{\\htmlClass{Field}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1113}{\\htmlId{2882}{\\htmlClass{Field}{\\text{pparams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1078}{\\htmlId{2892}{\\htmlClass{Field}{\\text{ppolicy}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1139}{\\htmlId{2902}{\\htmlClass{Field}{\\text{enactState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Equivalence.Convert.html#559}{\\htmlId{2915}{\\htmlClass{Function}{\\text{conv}}}}\\, \\,\\href{Ledger.Conway.Conformance.Ledger.Properties.html#2848}{\\htmlId{2920}{\\htmlClass{Bound}{\\text{certState}}}}\\, \\\\ \\,\\htmlId{2932}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$\n\n      computeProof : ComputationResult String (\u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s')\n      computeProof = case isValid \u225f true of \u03bb where\n        (yes p) \u2192 do\n          (utxoSt' , utxoStep) \u2190 computeUtxow utxo\u0393 utxoSt tx\n          (certSt' , certStep) \u2190 computeCerts cert\u0393 certState txCerts\n          (govSt'  , govStep)  \u2190 computeGov (gov\u0393 certSt') (rmOrphanDRepVotes (conv certSt') govSt) (txgov txb)\n          success (_ , LEDGER-V\u22ef p utxoStep certStep govStep)\n        (no \u00acp) \u2192 do\n          (utxoSt' , utxoStep) \u2190 computeUtxow utxo\u0393 utxoSt tx\n          success (_ , LEDGER-I\u22ef (\u00ac-not \u00acp) utxoStep)\n\n      completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s' \u2192 (proj\u2081 &lt;$&gt; computeProof) \u2261 success s'\n      completeness  ls' (LEDGER-V\u22ef v utxoStep certStep govStep)\n        with isValid \u225f true\n      ... | no \u00acv = contradiction v \u00acv\n      ... | yes refl\n        with computeUtxow utxo\u0393 utxoSt tx | complete _ _ _ _ utxoStep\n      ... | success (utxoSt' , _) | refl\n        with computeCerts cert\u0393 certState txCerts | complete _ _ _ _ certStep\n      ... | success (certSt' , _) | refl\n        with computeGov (gov\u0393 certSt') (rmOrphanDRepVotes (conv certSt') govSt) (txgov txb) | complete {STS = _\u22a2_\u21c0\u2987_,GOVS\u2988_} (gov\u0393 certSt') _ _ _ govStep\n      ... | success (govSt' , _) | refl = refl\n      completeness ls' (LEDGER-I\u22ef i utxoStep)\n        with isValid \u225f true\n      ... | yes refl = case i of \u03bb ()\n      ... | no \u00acv\n        with computeUtxow utxo\u0393 utxoSt tx | complete _ _ _ _ utxoStep\n      ... | success (utxoSt' , _) | refl = refl\n\nComputational-LEDGERS : Computational _\u22a2_\u21c0\u2987_,LEDGERS\u2988_ String\nComputational-LEDGERS = it\n</pre>"},{"location":"Ledger.Conway.Conformance.Ledger.html","title":"Ledger","text":"<pre>\n{-# OPTIONS --safe #-}\n\nimport Data.List as L\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nmodule Ledger.Conway.Conformance.Ledger\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Conformance.Gov txs abs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Utxow txs abs\nopen import Ledger.Conway.Conformance.Certs govStructure\n\nopen import Ledger.Conway.Specification.Ledger txs abs public\n  using (LEnv; HasCast-LEnv; allColdCreds; rmOrphanDRepVotes; txgov)\n\nopen Tx\n\nrecord LState : Type where\n  constructor \u27e6_,_,_\u27e7\u02e1\n  field\n    utxoSt     : UTxOState\n    govSt      : GovState\n    certState  : CertState\n\ninstance\n  unquoteDecl HasCast-LState = derive-HasCast\n    [ (quote LState , HasCast-LState) ]\n\nprivate variable\n  \u0393 : LEnv\n  s s' s'' : LState\n  utxoSt' : UTxOState\n  govSt' : GovState\n  certState' : CertState\n  tx : Tx\n\nopen UTxOState\n\ndata\n\n  _\u22a2_\u21c0\u2987_,LEDGER\u2988_ : LEnv \u2192 LState \u2192 Tx \u2192 LState \u2192 Type\n\n  where\n\n  LEDGER-V :\n    let open LState s; txb = tx .body; open TxBody txb; open LEnv \u0393\n        open CertState certState; open DState dState\n        utxoSt'' = record utxoSt' { deposits = updateDeposits pparams txb (deposits utxoSt') }\n     in\n    \u2219  isValid tx \u2261 true\n    \u2219  record { LEnv \u0393 } \u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt'\n    \u2219  $\\begin{pmatrix} \\,\\href{Ledger.Core.Specification.Epoch.html#954}{\\htmlId{1641}{\\htmlClass{Function}{\\text{epoch}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1055}{\\htmlId{1647}{\\htmlClass{Function}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1113}{\\htmlId{1654}{\\htmlClass{Function}{\\text{pparams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Transaction.html#5049}{\\htmlId{1664}{\\htmlClass{Function}{\\text{txGovVotes}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Transaction.html#4874}{\\htmlId{1677}{\\htmlClass{Function}{\\text{txWithdrawals}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#3671}{\\htmlId{1693}{\\htmlClass{Function}{\\text{allColdCreds}}}}\\, \\,\\href{Ledger.Conway.Conformance.Ledger.html#955}{\\htmlId{1706}{\\htmlClass{Function}{\\text{govSt}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1139}{\\htmlId{1712}{\\htmlClass{Function}{\\text{enactState}}}}\\, \\end{pmatrix}$ \u22a2 certState \u21c0\u2987 txCerts ,CERTS\u2988 certState'\n    \u2219  $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Transaction.html#4766}{\\htmlId{1776}{\\htmlClass{Function}{\\text{txId}}}}\\, \\\\ \\,\\href{Ledger.Core.Specification.Epoch.html#954}{\\htmlId{1783}{\\htmlClass{Function}{\\text{epoch}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1055}{\\htmlId{1789}{\\htmlClass{Function}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1113}{\\htmlId{1796}{\\htmlClass{Function}{\\text{pparams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1078}{\\htmlId{1806}{\\htmlClass{Function}{\\text{ppolicy}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1139}{\\htmlId{1816}{\\htmlClass{Function}{\\text{enactState}}}}\\, \\\\  \\,\\href{Ledger.Conway.Conformance.Ledger.html#1193}{\\htmlId{1830}{\\htmlClass{Generalizable}{\\text{certState'}}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{1843}{\\htmlClass{Function}{\\text{dom}}}}\\,\n    \\,\\href{Ledger.Conway.Conformance.Certs.html#822}{\\htmlId{1851}{\\htmlClass{Function}{\\text{rewards}}}}\\, \\end{pmatrix}$ \u22a2 govSt \u21c0\u2987 txgov txb ,GOVS\u2988 govSt'\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Ledger.html#1456}{\\htmlId{1966}{\\htmlClass{Bound}{\\text{utxoSt''}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Ledger.html#1173}{\\htmlId{1977}{\\htmlClass{Generalizable}{\\text{govSt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Ledger.html#1193}{\\htmlId{1986}{\\htmlClass{Generalizable}{\\text{certState'}}}}\\, \\end{pmatrix}$\n\n\n  LEDGER-I : let open LState s; txb = tx .body; open TxBody txb; open LEnv \u0393 in\n    \u2219  isValid tx \u2261 false\n    \u2219  record { LEnv \u0393 } \u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt'\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Ledger.html#1151}{\\htmlId{2233}{\\htmlClass{Generalizable}{\\text{utxoSt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Ledger.html#955}{\\htmlId{2243}{\\htmlClass{Function}{\\text{govSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Ledger.html#981}{\\htmlId{2251}{\\htmlClass{Function}{\\text{certState}}}}\\, \\end{pmatrix}$\n\npattern LEDGER-V\u22ef w x y z = LEDGER-V (w , x , y , z)\npattern LEDGER-I\u22ef y z     = LEDGER-I (y , z)\n\n_\u22a2_\u21c0\u2987_,LEDGERS\u2988_ : LEnv \u2192 LState \u2192 List Tx \u2192 LState \u2192 Type\n_\u22a2_\u21c0\u2987_,LEDGERS\u2988_ = ReflexiveTransitiveClosure {sts = _\u22a2_\u21c0\u2987_,LEDGER\u2988_}\n</pre>"},{"location":"Ledger.Conway.Conformance.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Properties\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Conformance.Chain txs abs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Epoch txs abs\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Conformance.Certs govStructure\n\nisCredDeposit : DepositPurpose \u2192 Type\nisCredDeposit (CredentialDeposit x) = \u22a4\nisCredDeposit _ = \u22a5\n\ninstance\n  isCredDeposit? : isCredDeposit \u2047\u00b9\n  isCredDeposit? {CredentialDeposit x} = \u2047 (yes tt)\n  isCredDeposit? {PoolDeposit x} = \u2047 (no \u03bb ())\n  isCredDeposit? {DRepDeposit x} = \u2047 (no \u03bb ())\n  isCredDeposit? {GovActionDeposit x} = \u2047 (no \u03bb ())\n\nisGADeposit : DepositPurpose \u2192 Type\nisGADeposit (GovActionDeposit x) = \u22a4\nisGADeposit _ = \u22a5\n\ninstance\n  isGADeposit? : isGADeposit \u2047\u00b9\n  isGADeposit? {CredentialDeposit x} = \u2047 (no \u03bb ())\n  isGADeposit? {PoolDeposit x} = \u2047 (no \u03bb ())\n  isGADeposit? {DRepDeposit x} = \u2047 (no \u03bb ())\n  isGADeposit? {GovActionDeposit x} = \u2047 (yes tt)\n\ngetLState : NewEpochState \u2192 LState\ngetLState = EpochState.ls \u2218 NewEpochState.epochState\n\ngetRewards : NewEpochState \u2192 Credential \u21c0 Coin\ngetRewards = DState.rewards \u2218 CertState.dState \u2218 LState.certState \u2218 getLState\n\nallDReps : NewEpochState \u2192 DReps\nallDReps = GState.dreps \u2218 CertState.gState \u2218 LState.certState \u2218 getLState\n\ngetGovState : NewEpochState \u2192 GovState\ngetGovState = LState.govSt \u2218 getLState\n\ninstance\n  _ : IsSet Block Tx\n  _ = record { toSet = fromList \u2218 Block.ts }\n\n  _ : IsSet TxBody GovProposal\n  _ = record { toSet = fromList \u2218 TxBody.txGovProposals }\n\nvalidBlockIn : ChainState \u2192 Block \u2192 Type\nvalidBlockIn s b = \u2203[ s' ] _ \u22a2 s \u21c0\u2987 b ,CHAIN\u2988 s'\n\nvalidBlock : Block \u2192 Type\nvalidBlock b = \u2203[ s ] validBlockIn s b\n\n-- Transaction validity is complicated. In the truest sense, a\n-- transaction is valid if it is part of a valid block,\n-- i.e. `validTxIn\u2081`. However, a transaction can also be seen as valid\n-- if it could be applied at a certain slot (with no knowledge of an\n-- actual block). This is closer to how the mempool sees transaction\n-- validity and is expressed by `validTxIn\u2082`.\n\n-- Note that these two are not equivalent and in fact there is no\n-- implication between the two in either direction. `2 =&gt; 1` would\n-- require one to come up with a block, which we can't, but `1 =&gt; 2`\n-- is also not true, since the transaction might depend on a previous\n-- transaction in the same block. Maybe this means that `validTxIn\u2082`\n-- should be changed so that it allows for applying a list of\n-- transactions before the final transaction? However, the downside\n-- then becomes that the transaction isn't applied to the given state\n-- but to some intermediate one. Maybe we'll gain some insight on this\n-- matter once we have proven more theorems.\n\nvalidTxIn\u2081 : ChainState \u2192 Tx \u2192 Type\nvalidTxIn\u2081 s tx = \u2203[ b ] tx \u2208 b \u00d7 validBlockIn s b\n\nmodule _ (s : ChainState) (slot : Slot) where\n\n  open ChainState s; open NewEpochState newEpochState\n  open EpochState epochState; open EnactState es\n\n  private\n    ledgerEnv = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Properties.html#3323}{\\htmlId{3475}{\\htmlClass{Bound}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#1739}{\\htmlId{3482}{\\htmlClass{Function}{\\text{constitution}}}}\\, \\,\\htmlId{3495}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Data.Product.Base.html#636}{\\htmlId{3496}{\\htmlClass{Field}{\\text{proj\u2081}}}}\\, \\,\\htmlId{3502}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Data.Product.Base.html#650}{\\htmlId{3503}{\\htmlClass{Field}{\\text{proj\u2082}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#1844}{\\htmlId{3511}{\\htmlClass{Function}{\\text{pparams}}}}\\, \\,\\htmlId{3519}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Data.Product.Base.html#636}{\\htmlId{3520}{\\htmlClass{Field}{\\text{proj\u2081}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Epoch.html#1464}{\\htmlId{3528}{\\htmlClass{Function}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.PParams.html#3084}{\\htmlId{3533}{\\htmlClass{Field}{\\text{Acnt.treasury}}}}\\, \\,\\href{Ledger.Conway.Conformance.Epoch.html#1391}{\\htmlId{3547}{\\htmlClass{Function}{\\text{acnt}}}}\\, \\end{pmatrix}$\n\n  validTxIn\u2082 : Tx \u2192 Type\n  validTxIn\u2082 tx = \u2203[ ls' ] ledgerEnv \u22a2 ls \u21c0\u2987 tx ,LEDGER\u2988 ls'\n\nvalidTx\u2081 : Tx \u2192 Type\nvalidTx\u2081 tx = \u2203[ s ] validTxIn\u2081 s tx\n\nChainInvariant : \u2200 {a} \u2192 (ChainState \u2192 Type a) \u2192 Type a\nChainInvariant P = \u2200 b s s' \u2192 _ \u22a2 s \u21c0\u2987 b ,CHAIN\u2988 s' \u2192 P s \u2192 P s'\n\nmodule _ (s : ChainState) where\n  open ChainState s; open NewEpochState newEpochState; open EpochState epochState\n  open LState ls\n  open EnactState es renaming (pparams to pparams')\n  open CertState certState; open DState dState\n  pparams = \u2223 pparams' \u2223\n  open PParams pparams\n  open Tx; open TxBody\n\n  -- Transaction properties\n\n  module _ {slot} {tx} (let txb = body tx) (valid : validTxIn\u2082 s slot tx)\n    (indexedSum-\u222a\u207a-hom : \u2200 {A V : Type} \u2983 _ : DecEq A \u2984 \u2983 _ : DecEq V \u2984 \u2983 mon : CommutativeMonoid 0\u2113 0\u2113 V \u2984\n      \u2192 (d\u2081 d\u2082 : A \u21c0 V) \u2192 indexedSum\u1d5b' id (d\u2081 \u222a\u207a d\u2082) \u2261 indexedSum\u1d5b' id d\u2081 \u25c7 indexedSum\u1d5b' id d\u2082)\n    (indexedSum-\u2286 : \u2200 {A : Type} \u2983 _ : DecEq A \u2984 (d d' : A \u21c0 \u2115) \u2192 d \u02e2 \u2286 d' \u02e2\n      \u2192 indexedSum\u1d5b' id d \u2264 indexedSum\u1d5b' id d') -- technically we could use an ordered monoid instead of \u2115\n    where\n    open import Ledger.Conway.Conformance.Utxow txs abs\n    open import Ledger.Conway.Conformance.Utxo.Properties txs abs\n\n  --   propose-ChangePP-hasGroup : \u2200 {up prop}\n  --     \u2192 prop \u2208 txb \u2192 prop .GovProposal.action \u2261 ChangePParams up \u2192 updateGroups up \u2262 \u2205\n  --   propose-ChangePP-hasGroup = {!!}\n\n  -- Block properties\n\n  module _ {b} (valid : validBlockIn s b) (let open Block b) where\n    isNewEpochBlock : Type\n    isNewEpochBlock = epoch slot \u2261 suc\u1d49 lastEpoch\n\n    newChainState : ChainState\n    newChainState = proj\u2081 valid\n\n    -- enact-change\u21d2newEpoch : es \u2262 getEnactState newChainState \u2192 isNewEpochBlock\n    -- enact-change\u21d2newEpoch = {!!}\n\n  -- Invariant properties\n\n  action-deposits\u2261actions-prop : Type\n  action-deposits\u2261actions-prop = filter\u02e2 isGADeposit (dom (UTxOState.deposits utxoSt))\n    \u2261 fromList (map (\u03bb where (id , _) \u2192 GovActionDeposit id) govSt)\n\n  dom-rwds\u2261credDeposits : Type\n  dom-rwds\u2261credDeposits = filter\u02e2 isCredDeposit (dom (UTxOState.deposits utxoSt))\n    \u2261 map\u02e2 CredentialDeposit (dom rewards)\n\n  pp-wellFormed : Type\n  pp-wellFormed = paramsWellFormed pparams\n\n-- action-deposits\u2261actions-inv : ChainInvariant action-deposits\u2261actions-prop\n-- action-deposits\u2261actions-inv = {!!}\n\n-- dom-rwds\u2261credDeposits-inv : ChainInvariant dom-rwds\u2261credDeposits\n-- dom-rwds\u2261credDeposits-inv = {!!}\n\n-- pp-wellFormed-inv : ChainInvariant pp-wellFormed\n-- pp-wellFormed-inv = {!!}\n\n-- Epoch boundary properties\n\n-- module _ {\u0393 es e es'} (step : \u0393 \u22a2 es \u21c0\u2987 e ,NEWEPOCH\u2988 es') where\n--   dom-rwds-const : dom (getRewards es) \u2261 dom (getRewards es')\n--   dom-rwds-const = {!!}\n\n--   prop\u2261\u2205\u21d2activeDReps-const : getGovState es \u2261 [] \u2192 activeDReps e es \u2261\u1d49 activeDReps (suc\u1d49 e) es'\n--   prop\u2261\u2205\u21d2activeDReps-const = {!!}\n</pre>"},{"location":"Ledger.Conway.Conformance.Rewards.html","title":"Rewards","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Rewards\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs)\n  where\n\nopen import Ledger.Prelude\n\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Ledger.Conway.Conformance.Ledger txs abs\nopen import Ledger.Conway.Conformance.Utxo txs abs\n\nopen import Ledger.Conway.Specification.Rewards txs abs\n  hiding (_\u22a2_\u21c0\u2987_,SNAP\u2988_) public\n\nprivate variable\n  lstate : LState\n  mark set go : Snapshot\n  feeSS : Coin\n\ndata _\u22a2_\u21c0\u2987_,SNAP\u2988_ : LState \u2192 Snapshots \u2192 \u22a4 \u2192 Snapshots \u2192 Type where\n  SNAP : let open LState lstate\n             open UTxOState utxoSt\n             open CertState certState\n             stake = stakeDistr utxo (record { DState dState }) pState\n    in\n    lstate \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Rewards.html#664}{\\htmlId{970}{\\htmlClass{Generalizable}{\\text{mark}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Rewards.html#669}{\\htmlId{977}{\\htmlClass{Generalizable}{\\text{set}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Rewards.html#673}{\\htmlId{983}{\\htmlClass{Generalizable}{\\text{go}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Rewards.html#689}{\\htmlId{988}{\\htmlClass{Generalizable}{\\text{feeSS}}}}\\, \\end{pmatrix}$ \u21c0\u2987 tt ,SNAP\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Rewards.html#890}{\\htmlId{1011}{\\htmlClass{Bound}{\\text{stake}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Rewards.html#664}{\\htmlId{1019}{\\htmlClass{Generalizable}{\\text{mark}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Rewards.html#669}{\\htmlId{1026}{\\htmlClass{Generalizable}{\\text{set}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3020}{\\htmlId{1032}{\\htmlClass{Function}{\\text{fees}}}}\\, \\end{pmatrix}$\n</pre>"},{"location":"Ledger.Conway.Conformance.Script.html","title":"Script","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Algebra.Morphism\nopen import Data.List.Relation.Unary.All using (All; []; _\u2237_; all?; uncons)\nopen import Data.List.Relation.Unary.Any\nopen import Data.Nat.Properties using (+-0-commutativeMonoid; suc-injective)\n\nopen import stdlib.Data.List.Relation.Unary.MOf\n\n\nopen import Ledger.Prelude hiding (All; Any; all?; any?; _\u2237\u02b3_; uncons; _\u2286_)\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\n\nimport Ledger.Conway.Specification.Script\n\nmodule Ledger.Conway.Conformance.Script\n  (cs : _) (open CryptoStructure cs)\n  (es : _) (open EpochStructure es)\n  where\n\nopen Ledger.Conway.Specification.Script cs es\n\nrecord HSTimelock : Type where\n  field\n    timelock     : Timelock\n    tlScriptHash : ScriptHash\n    tlScriptSize : \u2115\n\ninstance\n  Hashable-HSTimelock : Hashable HSTimelock ScriptHash\n  Hashable-HSTimelock .hash = HSTimelock.tlScriptHash\n\nunquoteDecl DecEq-HSTimelock = derive-DecEq ((quote HSTimelock , DecEq-HSTimelock) \u2237 [])\n\nrecord HSPlutusScript : Type where\n  constructor MkHSPlutusScript\n  field psScriptHash : ScriptHash\n        psScriptSize : \u2115\n\ninstance\n  Hashable-HSPlutusScript : Hashable HSPlutusScript ScriptHash\n  Hashable-HSPlutusScript .hash = HSPlutusScript.psScriptHash\n\nP1ScriptStructure-HTL : P1ScriptStructure\nP1ScriptStructure-HTL = record\n  { P1Script = HSTimelock\n  ; validP1Script = \u03bb x y \u2192 evalTimelock x y \u2218 HSTimelock.timelock }\n\n</pre>"},{"location":"Ledger.Conway.Conformance.Utxo.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract using (AbstractFunctions)\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nmodule Ledger.Conway.Conformance.Utxo.Properties\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Data.Nat.Properties hiding (_\u225f_)\nopen import Data.String.Base renaming (_++_ to _+\u02e2_) using ()\nopen import Interface.ComputationalRelation\nopen import Ledger.Prelude hiding (\u2264-trans; \u2264-antisym; All); open Properties\nopen import Ledger.Conway.Specification.Script.Validation txs abs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Prelude\nopen import stdlib-meta.Tactic.GenError\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Utxo txs abs public\n\nopen Equivalence\n\ninstance\n  _ = TokenAlgebra.Value-CommutativeMonoid tokenAlgebra\n  _ = +-0-monoid\n  _ = Functor-ComputationResult\n\ninstance\n  Computational-UTXOS : Computational _\u22a2_\u21c0\u2987_,UTXOS\u2988_ String\n  Computational-UTXOS = record {go} where\n    module go \u0393 s tx\n      (let H-Yes , \u2047 H-Yes? = Scripts-Yes-premises {\u0393} {s} {tx})\n      (let H-No  , \u2047 H-No?  = Scripts-No-premises {\u0393} {s} {tx}) where\n      open Tx tx renaming (body to txb); open TxBody txb\n      open UTxOEnv \u0393 renaming (pparams to pp)\n      open UTxOState s\n      sLst = collectP2ScriptsWithContext pp tx utxo\n\n      computeProof =\n        case H-Yes? ,\u2032 H-No? of \u03bb where\n          (yes p , no _ ) \u2192 success (_ , (Scripts-Yes p))\n          (no _  , yes p) \u2192 success (_ , (Scripts-No p))\n          (_     , _    ) \u2192 failure \"isValid check failed\"\n\n      completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n      completeness _ (Scripts-Yes p) with H-No? | H-Yes?\n      ... | yes (_ , refl) | _     = case proj\u2082 p of \u03bb ()\n      ... | no _           | yes _ = refl\n      ... | no _           | no \u00acp = case \u00acp p of \u03bb ()\n      completeness _ (Scripts-No p) with H-Yes? | H-No?\n      ... | yes (_ , refl) | _     = case proj\u2082 p of \u03bb ()\n      ... | no _           | yes _ = refl\n      ... | no _           | no \u00acp = case \u00acp p of \u03bb ()\n\ninstance\n  Computational-UTXO : Computational _\u22a2_\u21c0\u2987_,UTXO\u2988_ String\n  Computational-UTXO = record {Go}\n    where\n      module Go \u0393 s tx (let H , \u2047 H? = UTXO-premises {tx}{\u0393}{s}) where\n\n        open Computational Computational-UTXOS\n          renaming (computeProof to computeProof'; completeness to completeness')\n\n        computeProofH : Dec H \u2192 ComputationResult String (\u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s')\n        computeProofH (yes (x , y , z , e , k , l , m , c , v , j , n , o , p , q , r , t , u)) =\n            map\u2082\u2032 (UTXO-inductive\u22ef _ _ _ x y z e k l m c v j n o p q r t u) &lt;$&gt; computeProof' \u0393 s tx\n        computeProofH (no \u00acp) = failure $ genErrors \u00acp\n\n        computeProof : ComputationResult String (\u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s')\n        computeProof = computeProofH H?\n\n        completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n        completeness s' (UTXO-inductive\u22ef _ _ _ x y z e k l m c v j n o p q r t u h) with H?\n        ... | no \u00acp = \u22a5-elim $ \u00acp (x , y , z , e , k , l , m , c , v , j , n , o , p , q , r , t , u )\n        ... | yes _ with computeProof' \u0393 s tx | completeness' _ _ _ _ h\n        ... | success _ | refl = refl\n\nopen Computational \u2983...\u2984\n\nprivate variable\n  tx                         : Tx\n  utxo utxo'                 : UTxO\n  \u0393                          : UTxOEnv\n  utxoState utxoState'       : UTxOState\n  fees fees'                 : Fees\n  donations donations'       : Donations\n  deposits deposits'         : Deposits\n\nUTXO-step : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 ComputationResult String UTxOState\nUTXO-step = compute \u2983 Computational-UTXO \u2984\n\nUTXO-step-computes-UTXO  :  UTXO-step \u0393 utxoState tx \u2261 success utxoState'\n                         \u21d4  \u0393 \u22a2 utxoState \u21c0\u2987 tx ,UTXO\u2988 utxoState'\nUTXO-step-computes-UTXO = \u2261-success\u21d4STS \u2983 Computational-UTXO \u2984\n</pre>"},{"location":"Ledger.Conway.Conformance.Utxo.html","title":"Utxo","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Algebra              using (CommutativeMonoid)\nopen import Data.Nat.Properties  using (+-0-monoid)\nimport Data.Maybe as M\nimport Data.Sum.Relation.Unary.All as Sum\n\nimport Data.Integer as \u2124\nimport Data.Rational as \u211a\n\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Utxo\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Script.Validation txs abs\nopen import Ledger.Conway.Specification.Fees txs using (scriptsCost)\nopen import Ledger.Conway.Conformance.Certs govStructure\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Utxo txs abs public\n\nopen PParams\n\ninstance\n  _ = +-0-monoid\n\nopen L public using (UTxOEnv; UTxOState; \u27e6_,_,_,_\u27e7\u1d58; HasCast-UTxOState; updateDeposits\n                    ; cbalance; balance; depositRefunds; consumed\n                    ; produced; outs; newDeposits; refScriptsSize )\n\nprivate variable\n  \u0393 : UTxOEnv\n  s s' : UTxOState\n  tx : Tx\n\nopen PParams\n\ndata _\u22a2_\u21c0\u2987_,UTXOS\u2988_ : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 UTxOState \u2192 Type where\n  Scripts-Yes :\n    \u2200 {\u0393} {s} {tx}\n    \u2192 let open Tx tx renaming (body to txb); open TxBody txb\n          open UTxOEnv \u0393 renaming (pparams to pp)\n          open UTxOState s\n          p2Scripts = collectP2ScriptsWithContext pp tx utxo\n      in\n        \u2219 evalP2Scripts p2Scripts \u2261 isValid\n        \u2219 isValid \u2261 true\n          \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n          \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988  $\\begin{pmatrix} \\,\\htmlId{1709}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Utxo.html#2998}{\\htmlId{1710}{\\htmlClass{Function}{\\text{utxo}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{1715}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.Transaction.html#4618}{\\htmlId{1717}{\\htmlClass{Function}{\\text{txIns}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{1723}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\\,\\htmlId{1724}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{1726}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\htmlId{1729}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Utxo.html#4772}{\\htmlId{1730}{\\htmlClass{Function}{\\text{L.outs}}}}\\, \\,\\href{Ledger.Conway.Conformance.Utxo.html#1395}{\\htmlId{1737}{\\htmlClass{Field}{\\text{txb}}}}\\,\\,\\htmlId{1740}{\\htmlClass{Symbol}{\\text{)}}}\\,\n                              \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3020}{\\htmlId{1774}{\\htmlClass{Function}{\\text{fees}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{1779}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Transaction.html#4840}{\\htmlId{1781}{\\htmlClass{Function}{\\text{txFee}}}}\\,\n                              \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{1819}{\\htmlClass{Function}{\\text{deposits}}}}\\,\n                              \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3068}{\\htmlId{1860}{\\htmlClass{Function}{\\text{donations}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{1870}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Transaction.html#5010}{\\htmlId{1872}{\\htmlClass{Function}{\\text{txDonation}}}}\\,\n                              \\end{pmatrix}$\n\n  Scripts-No :\n    \u2200 {\u0393} {s} {tx}\n    \u2192 let open Tx tx renaming (body to txb); open TxBody txb\n          open UTxOEnv \u0393 renaming (pparams to pp)\n          open UTxOState s\n          p2Scripts = collectP2ScriptsWithContext pp tx utxo\n      in\n        \u2219 evalP2Scripts p2Scripts \u2261 isValid\n        \u2219 isValid \u2261 false\n          \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n          \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988  $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.html#2998}{\\htmlId{2304}{\\htmlClass{Function}{\\text{utxo}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{2309}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.Transaction.html#4690}{\\htmlId{2311}{\\htmlClass{Function}{\\text{collateralInputs}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{2328}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\n                              \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3020}{\\htmlId{2362}{\\htmlClass{Function}{\\text{fees}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{2367}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Utxo.html#4932}{\\htmlId{2369}{\\htmlClass{Function}{\\text{L.cbalance}}}}\\, \\,\\htmlId{2380}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Utxo.html#2998}{\\htmlId{2381}{\\htmlClass{Function}{\\text{utxo}}}}\\, \\,\\href{Axiom.Set.Map.html#13534}{\\htmlId{2386}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.Transaction.html#4690}{\\htmlId{2388}{\\htmlClass{Function}{\\text{collateralInputs}}}}\\,\\,\\htmlId{2404}{\\htmlClass{Symbol}{\\text{)}}}\\,\n                              \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{2438}{\\htmlClass{Function}{\\text{deposits}}}}\\,\n                              \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3068}{\\htmlId{2479}{\\htmlClass{Function}{\\text{donations}}}}\\,\n                              \\end{pmatrix}$\n\nunquoteDecl Scripts-Yes-premises = genPremises Scripts-Yes-premises (quote Scripts-Yes)\nunquoteDecl Scripts-No-premises  = genPremises Scripts-No-premises  (quote Scripts-No)\n\ndata _\u22a2_\u21c0\u2987_,UTXO\u2988_ : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 UTxOState \u2192 Type where\n\n  UTXO-inductive :\n    let open Tx tx renaming (body to txb); open TxBody txb; open TxWitnesses wits\n        open UTxOEnv \u0393 renaming (pparams to pp)\n        open UTxOState s\n        txOuts\u02b0 = (mapValues txOutHash txOuts)\n        overhead = 160\n    in\n    \u2219 txIns \u2262 \u2205                              \u2219 txIns \u222a refInputs \u2286 dom utxo\n    \u2219 txIns \u2229 refInputs \u2261 \u2205                  \u2219 L.inInterval slot txVldt\n    \u2219 L.minfee pp utxo tx \u2264 txFee            \u2219 (txrdmrs \u02e2 \u2262 \u2205 \u2192 L.collateralCheck pp tx utxo)\n    \u2219 consumed pp s txb \u2261 produced pp s txb  \u2219 coin mint \u2261 0\n    \u2219 txsize \u2264 maxTxSize pp\n    \u2219 L.refScriptsSize utxo tx \u2264 pp .maxRefScriptSizePerTx\n\n    \u2219 \u2200[ (_ , txout) \u2208 \u2223 txOuts\u02b0 \u2223 ]\n        inject ((overhead + L.utxoEntrySize txout) * coinsPerUTxOByte pp) \u2264\u1d57 getValue\u02b0 txout\n    \u2219 \u2200[ (_ , txout) \u2208 \u2223 txOuts\u02b0 \u2223 ]\n        serSize (getValue\u02b0 txout) \u2264 maxValSize pp\n    \u2219 \u2200[ (a , _) \u2208 range txOuts\u02b0 ]\n        Sum.All (const \u22a4) (\u03bb a \u2192 a .BootstrapAddr.attrsSize \u2264 64) a\n    \u2219 \u2200[ (a , _) \u2208 range txOuts\u02b0 ]  netId a         \u2261 NetworkId\n    \u2219 \u2200[ a \u2208 dom txWithdrawals ]    NetworkIdOf a   \u2261 NetworkId\n    \u2219 txNetworkId ~ just NetworkId\n    \u2219 currentTreasury ~ just treasury\n    \u2219 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s'\n\npattern UTXO-inductive\u22ef tx \u0393 s x y z w k l m c v j n o p q r t u h\n      = UTXO-inductive {tx}{\u0393}{s} (x , y , z , w , k , l , m , c , v , j , n , o , p , q , r , t , u , h)\nunquoteDecl UTXO-premises = genPremises UTXO-premises (quote UTXO-inductive)\n</pre>"},{"location":"Ledger.Conway.Conformance.Utxow.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nimport Data.Maybe as M\n\nopen import Ledger.Prelude\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Utxow.Properties\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Conformance.Utxow txs abs\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Conformance.Utxo.Properties txs abs\n\nopen import stdlib-meta.Tactic.GenError using (genErrors)\n\ninstance\n  Computational-UTXOW : Computational _\u22a2_\u21c0\u2987_,UTXOW\u2988_ String\n  Computational-UTXOW = record {Go}\n    where module Go \u0393 s tx (let H , \u2047 H? = UTXOW-inductive-premises {tx}{s}) where\n\n    open Computational Computational-UTXO\n      renaming (computeProof to computeProof'; completeness to completeness')\n\n    computeProof : ComputationResult String (\u2203 (\u0393 \u22a2 s \u21c0\u2987 tx ,UTXOW\u2988_))\n    computeProof =\n      case H? of \u03bb where\n        (yes (p\u2081 , p\u2082 , p\u2083 , p\u2084 , p\u2085 , p\u2086 , p\u2087 , p\u2088)) \u2192\n          map (map\u2082\u2032 (UTXOW-inductive\u22ef p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 p\u2087 p\u2088)) (computeProof' \u0393 s tx)\n        (no \u00acp) \u2192 failure $ genErrors \u00acp\n\n    completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n                        \u2192 map proj\u2081 computeProof \u2261 success s'\n    completeness s' (UTXOW-inductive\u22ef p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 p\u2087 p\u2088 h) with H?\n    ... | no \u00acp = \u22a5-elim $ \u00acp ((p\u2081 , p\u2082 , p\u2083 , p\u2084 , p\u2085 , p\u2086 , p\u2087 , p\u2088))\n    ... | yes _ with computeProof' \u0393 s tx | completeness' _ _ _ _ h\n    ... | success _ | refl = refl\n</pre>"},{"location":"Ledger.Conway.Conformance.Utxow.html","title":"Utxow","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Conformance.Utxow\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\nopen import Ledger.Conway.Conformance.Utxo txs abs\nopen import Ledger.Conway.Specification.Script.Validation txs abs\nopen import Ledger.Conway.Specification.Certs govStructure\n\nprivate\n  module L where\n    open import Ledger.Conway.Specification.Utxow txs abs public\n    open import Ledger.Conway.Specification.Utxo txs abs public\n\ndata\n\n  _\u22a2_\u21c0\u2987_,UTXOW\u2988_ : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 UTxOState \u2192 Type\n\nprivate variable\n  \u0393 : UTxOEnv\n  s s' : UTxOState\n  tx : Tx\n\ndata _\u22a2_\u21c0\u2987_,UTXOW\u2988_ where\n\n  UTXOW-inductive :\n    let open Tx tx renaming (body to txb); open TxBody txb; open TxWitnesses wits\n        open UTxOState s\n        witsKeyHashes       = map\u02e2 hash (dom vkSigs)\n        witsScriptHashes    = map\u02e2 hash scripts\n        refScriptHashes     = map\u02e2 hash (refScripts tx utxo)\n        neededScriptHashes  = mapPartial (isScriptObj  \u2218 proj\u2082) (credsNeeded utxo txb)\n        neededVKeyHashes    = mapPartial (isKeyHashObj \u2218 proj\u2082) (credsNeeded utxo txb)\n        txdatsHashes        = map\u02e2 hash txdats\n        inputsDataHashes    = mapPartial (\u03bb txout \u2192 if txOutToP2Script utxo tx txout\n                                                     then txOutToDataHash txout\n                                                     else nothing) (range (utxo \u2223 txIns))\n        refInputsDataHashes = mapPartial txOutToDataHash (range (utxo \u2223 refInputs))\n        outputsDataHashes   = mapPartial txOutToDataHash (range txOuts)\n        nativeScripts       = mapPartial toP1Script (txscripts tx utxo)\n    in\n    \u2219  \u2200[ (vk , \u03c3) \u2208 vkSigs ] isSigned vk (txidBytes txId) \u03c3\n    \u2219  \u2200[ s \u2208 nativeScripts ] (hash s \u2208 neededScriptHashes \u2192 validP1Script witsKeyHashes txVldt s)\n    \u2219  neededVKeyHashes \u2286 witsKeyHashes\n    \u2219  neededScriptHashes - refScriptHashes \u2261\u1d49 witsScriptHashes\n    \u2219  inputsDataHashes \u2286 txdatsHashes\n    \u2219  txdatsHashes \u2286 inputsDataHashes \u222a outputsDataHashes \u222a refInputsDataHashes\n    \u2219  L.languages tx utxo \u2286 L.allowedLanguages tx utxo\n    \u2219  txADhash \u2261 map hash txAD\n    \u2219  \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s'\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n\npattern UTXOW-inductive\u22ef p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 p\u2087 p\u2088 h\n      = UTXOW-inductive (p\u2081 , p\u2082 , p\u2083 , p\u2084 , p\u2085 , p\u2086 , p\u2087 , p\u2088 , h)\npattern UTXOW\u21d2UTXO x = UTXOW-inductive\u22ef _ _ _ _ _ _ _ _ x\n\nunquoteDecl UTXOW-inductive-premises =\n  genPremises UTXOW-inductive-premises (quote UTXOW-inductive)\n</pre>"},{"location":"Ledger.Conway.Conformance.html","title":"Conformance","text":"<pre>{-# OPTIONS --safe #-}\nmodule Ledger.Conway.Conformance where\n\nimport Ledger.Conway.Conformance.Certs\nimport Ledger.Conway.Conformance.Certs.Properties\nimport Ledger.Conway.Conformance.Chain\nimport Ledger.Conway.Conformance.Chain.Properties\nimport Ledger.Conway.Conformance.Equivalence\nimport Ledger.Conway.Conformance.Epoch\nimport Ledger.Conway.Conformance.Epoch.Properties\nimport Ledger.Conway.Conformance.Gov\nimport Ledger.Conway.Conformance.Ledger\nimport Ledger.Conway.Conformance.Ledger.Properties\nimport Ledger.Conway.Conformance.Properties\nimport Ledger.Conway.Conformance.Utxo\nimport Ledger.Conway.Conformance.Utxo.Properties\nimport Ledger.Conway.Conformance.Utxow\nimport Ledger.Conway.Conformance.Utxow.Properties\nimport Ledger.Conway.Conformance.Script\n</pre>"},{"location":"Ledger.Conway.Foreign.ExternalFunctions.html","title":"ExternalFunctions","text":"<pre>module Ledger.Conway.Foreign.ExternalFunctions where\n\nopen import Ledger.Prelude\nopen import Foreign.HaskellTypes.Deriving\n\nrecord ExternalFunctions : Set where\n  field extIsSigned : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 Bool\n{-# FOREIGN GHC\n  data ExternalFunctions = MkExternalFunctions\n    { extIsSigned :: Integer -&gt; Integer -&gt; Integer -&gt; Bool\n    }\n#-}\n{-# COMPILE GHC ExternalFunctions = data ExternalFunctions (MkExternalFunctions) #-}\n\ndummyExternalFunctions : ExternalFunctions\ndummyExternalFunctions = record { extIsSigned = \u03bb x x\u2081 x\u2082 \u2192 true }\n{-# COMPILE GHC dummyExternalFunctions as dummyExternalFunctions #-}\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Address.html","title":"Address","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Address where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\n\ninstance\n  HsTy-HSVKey = autoHsType HSVKey\n  Conv-HSVKey = autoConvert HSVKey\n\n  HsTy-Credential = autoHsType Credential\n  Conv-Credential = autoConvert Credential\n\n  HsTy-BaseAddr = autoHsType BaseAddr \u22a3 fieldPrefix \"base\"\n  Conv-BaseAddr = autoConvert BaseAddr\n\n  HsTy-BootstrapAddr = autoHsType BootstrapAddr \u22a3 fieldPrefix \"boot\"\n  Conv-BootstrapAddr = autoConvert BootstrapAddr\n\n  HsTy-RwdAddr = autoHsType RwdAddr \u22a3 fieldPrefix \"rwd\"\n  Conv-RwdAddr = autoConvert RwdAddr\n\nunquoteDecl = do\n  hsTypeAlias Addr\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.BaseTypes.html","title":"BaseTypes","text":"<pre>module Ledger.Conway.Foreign.HSLedger.BaseTypes where\n\nopen import Data.Rational\n\nopen import Ledger.Prelude.Numeric.UnitInterval\nopen import Ledger.Prelude.Numeric.PositiveNat\nopen import Ledger.Conway.Foreign.ExternalFunctions\nopen import Ledger.Conway.Foreign.HSLedger.Core public\nimport Ledger.Prelude.Foreign.HSTypes as F\n\ninstance\n  iConvTop    = Convertible-Refl {\u22a4}\n  iConvNat    = Convertible-Refl {\u2115}\n  iConvString = Convertible-Refl {String}\n  iConvBool   = Convertible-Refl {Bool}\n\ninstance\n\n  -- * Unit and empty\n\n  HsTy-\u22a5 = MkHsType \u22a5 F.Empty\n  Conv-\u22a5 = autoConvert \u22a5\n\n  HsTy-\u22a4 = MkHsType \u22a4 \u22a4\n\n  -- * Rational numbers\n\n  HsTy-Rational = MkHsType \u211a F.Rational\n  Conv-Rational : HsConvertible \u211a\n  Conv-Rational = \u03bb where\n    .to (mk\u211a n d _)       \u2192 n F., suc d\n    .from (n F., zero)    \u2192 0\u211a -- TODO is there a safer way to do this?\n    .from (n F., (suc d)) \u2192 n Data.Rational./ suc d\n\n  -- * Maps and Sets\n\n  HsTy-HSSet : \u2200 {A} \u2192 \u2983 HasHsType A \u2984 \u2192 HasHsType (\u2119 A)\n  HsTy-HSSet {A} = MkHsType _ (F.HSSet (HsType A))\n\n  Conv-HSSet : \u2200 {A} \u2983 _ : HasHsType A \u2984\n             \u2192 \u2983 HsConvertible A \u2984\n             \u2192 HsConvertible (\u2119 A)\n  Conv-HSSet = \u03bb where\n    .to \u2192 F.MkHSSet \u2218 to \u2218 setToList\n    .from \u2192 fromList\u02e2 \u2218 from \u2218 F.HSSet.elems\n\n  HsTy-Map : \u2200 {A B} \u2192 \u2983 HasHsType A \u2984 \u2192 \u2983 HasHsType B \u2984 \u2192 HasHsType (A \u21c0 B)\n  HsTy-Map {A} {B} = MkHsType _ (F.HSMap (HsType A) (HsType B))\n\n  Conv-HSMap : \u2200 {A B} \u2983 _ : HasHsType A \u2984 \u2983 _ : HasHsType B \u2984\n    \u2192 \u2983 DecEq A \u2984\n    \u2192 \u2983 HsConvertible A \u2984\n    \u2192 \u2983 HsConvertible B \u2984\n    \u2192 HsConvertible (A \u21c0 B)\n  Conv-HSMap = \u03bb where\n    .to \u2192 F.MkHSMap \u2218 to\n    .from \u2192 from \u2218 F.HSMap.assocList\n\n  -- * ComputationResult\n\n  HsTy-ComputationResult : \u2200 {l} {Err} {A : Type l}\n                           \u2192 \u2983 HasHsType Err \u2984 \u2192 \u2983 HasHsType A \u2984\n                           \u2192 HasHsType (ComputationResult Err A)\n  HsTy-ComputationResult {Err = Err} {A} = MkHsType _ (F.ComputationResult (HsType Err) (HsType A))\n\n  Conv-ComputationResult : ConvertibleType ComputationResult F.ComputationResult\n  Conv-ComputationResult = autoConvertible\n\nopen import Ledger.Conway.Foreign.HSLedger.ExternalStructures dummyExternalFunctions\n  renaming\n    ( HSTransactionStructure to DummyTransactionStructure\n    ; HSAbstractFunctions to DummyAbstractFunctions\n    )\n  public\nopen import Ledger.Conway.Conformance.Certs.Properties govStructure\n\nunquoteDecl = do\n  hsTypeAlias Coin\n  hsTypeAlias ExUnits\n  hsTypeAlias Epoch\n  hsTypeAlias ScriptHash\n\ninstance\n  HsTy-UnitInterval : HasHsType UnitInterval\n  HsTy-UnitInterval .HasHsType.HsType = F.Rational\n    -- I would like to use \u211a here, but F.Rational converts better.\n\n  Conv-UnitInterval : Convertible UnitInterval F.Rational\n  Conv-UnitInterval .to x = to (fromUnitInterval x)\n  Conv-UnitInterval .from x =\n    case toUnitInterval (from x) of \u03bb where\n      (just x) \u2192 x\n      nothing \u2192 error \"Formal Spec: rational outside of unit interval\"\n\ninstance\n  HsTy-PosNat : HasHsType PosNat\n  HsTy-PosNat .HasHsType.HsType = \u2115\n\n  Conv-PosNat : Convertible PosNat \u2115\n  Conv-PosNat .to x = to (fromPosNat x)\n  Conv-PosNat .from x =\n    case toPosNat (from x) of \u03bb where\n      (just x) \u2192 x\n      nothing \u2192 error \"Formal Spec: natural number is zero (not nonZero)\"\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Cert.html","title":"Cert","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Cert where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes hiding (CertEnv; DCert) renaming (\u27e6_,_,_\u27e7\u1d9c\u02e2 to \u27e6_,_,_\u27e7\u1d9c\u02e2'; CertState to CertState')\nopen import Ledger.Conway.Foreign.HSLedger.Certs\n\nopen import Ledger.Conway.Conformance.Certs.Properties govStructure\n  using ( Computational-CERT\n        ; Computational-CERTS\n        )\n\nopen import Ledger.Conway.Conformance.Certs govStructure\n\ninstance\n  HsTy-CertState = autoHsType CertState \u22a3 withConstructor \"MkCertState\"\n  Conv-CertState = autoConvert CertState\n\n  Conv-CertState-CertState' : Convertible CertState CertState'\n  Conv-CertState-CertState' .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#751}{\\htmlId{751}{\\htmlClass{Bound}{\\text{dState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#760}{\\htmlId{760}{\\htmlClass{Bound}{\\text{pState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#769}{\\htmlId{769}{\\htmlClass{Bound}{\\text{gState}}}}\\, \\end{pmatrix}$    = $\\begin{pmatrix} \\,\\href{Foreign.Convertible.html#230}{\\htmlId{787}{\\htmlClass{Field}{\\text{to}}}}\\, \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#751}{\\htmlId{790}{\\htmlClass{Bound}{\\text{dState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#760}{\\htmlId{799}{\\htmlClass{Bound}{\\text{pState}}}}\\, \\\\ \\,\\href{Foreign.Convertible.html#230}{\\htmlId{808}{\\htmlClass{Field}{\\text{to}}}}\\, \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#769}{\\htmlId{811}{\\htmlClass{Bound}{\\text{gState}}}}\\, \\end{pmatrix}$\n  Conv-CertState-CertState' .from $\\begin{pmatrix} \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#859}{\\htmlId{859}{\\htmlClass{Bound}{\\text{dState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#868}{\\htmlId{868}{\\htmlClass{Bound}{\\text{pState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#877}{\\htmlId{877}{\\htmlClass{Bound}{\\text{gState}}}}\\, \\end{pmatrix}$ = $\\begin{pmatrix} \\,\\href{Foreign.Convertible.html#251}{\\htmlId{893}{\\htmlClass{Field}{\\text{from}}}}\\, \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#859}{\\htmlId{898}{\\htmlClass{Bound}{\\text{dState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#868}{\\htmlId{907}{\\htmlClass{Bound}{\\text{pState}}}}\\, \\\\ \\,\\href{Foreign.Convertible.html#251}{\\htmlId{916}{\\htmlClass{Field}{\\text{from}}}}\\, \\,\\href{Ledger.Conway.Foreign.HSLedger.Cert.html#877}{\\htmlId{921}{\\htmlClass{Bound}{\\text{gState}}}}\\, \\end{pmatrix}$\n\ncerts-step : HsType (CertEnv \u2192 CertState \u2192 List DCert \u2192 ComputationResult String CertState)\ncerts-step = to (compute Computational-CERTS)\n\n{-# COMPILE GHC certs-step as certsStep #-}\n\ncert-step : HsType (CertEnv \u2192 CertState \u2192 DCert \u2192 ComputationResult String CertState)\ncert-step = to (compute Computational-CERT)\n\n{-# COMPILE GHC cert-step as certStep #-}\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Certs.html","title":"Certs","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Certs where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes renaming (\u27e6_,_,_\u27e7\u1d48 to \u27e6_,_,_\u27e7\u1d48'; DState to DState'\n                                                              ; \u27e6_,_\u27e7\u1d5b to \u27e6_,_\u27e7\u1d5b'; GState to GState') hiding (CertEnv)\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Core\nopen import Ledger.Conway.Foreign.HSLedger.PParams\n\nopen import Ledger.Conway.Conformance.Certs govStructure using (\u27e6_,_,_,_\u27e7\u1d48; \u27e6_,_,_\u27e7\u1d5b; DState; GState; CertEnv)\n\nopen import Ledger.Conway.Specification.Certs.Properties.Computational govStructure\n  using (Computational-POOL)\nopen import Ledger.Conway.Conformance.Certs.Properties govStructure\n  using ( Computational-DELEG\n        ; Computational-GOVCERT\n        )\n\ninstance\n  HsTy-StakePoolParams = autoHsType StakePoolParams\n  Conv-StakePoolParams = autoConvert StakePoolParams\n\n  HsTy-DepositPurpose = autoHsType DepositPurpose\n  Conv-DepositPurpose = autoConvert DepositPurpose\n\n  HsTy-DelegEnv = autoHsType DelegEnv\n    \u22a3 withConstructor \"MkDelegEnv\"\n    \u2022 fieldPrefix \"de\"\n    \u2022 withName \"DelegEnv\"\n  Conv-DelegEnv = autoConvert DelegEnv\n\n  HsTy-PState = autoHsType PState\n    \u22a3 withConstructor \"MkPState\"\n    \u2022 fieldPrefix \"ps\"\n  Conv-PState = autoConvert PState\n\nrecord CertEnv' : Type where\n  field\n    epoch     : Epoch\n    pp        : PParams\n    votes     : List GovVote'\n    wdrls     : RwdAddr \u21c0 Coin\n    coldCreds : \u2119 Credential\n\ninstance\n  HsTy-CertEnv' = autoHsType CertEnv'\n    \u22a3 withConstructor \"MkCertEnv\"\n    \u2022 withName \"CertEnv\"\n    \u2022 fieldPrefix \"ce\"\n  Conv-CertEnv' = autoConvert CertEnv'\n\n  mkCertEnv' : Convertible CertEnv CertEnv'\n  mkCertEnv' = \u03bb where\n    .to   ce \u2192 let module ce = CertEnv ce in record { epoch = ce.epoch ; pp = ce.pp ; votes = to ce.votes ; wdrls = ce.wdrls ; coldCreds = ce.coldCreds }\n    .from ce \u2192 let module ce = CertEnv' ce in record { epoch = ce.epoch ; pp = ce.pp ; votes = from ce.votes ; wdrls = ce.wdrls ; coldCreds = ce.coldCreds }\n\n  HsTy-CertEnv = MkHsType CertEnv (HsType CertEnv')\n  Conv-CertEnv = mkCertEnv' \u2a3e Conv-CertEnv'\n\ninstance\n  HsTy-DState = autoHsType DState\n    \u22a3 withConstructor \"MkDState\"\n    \u2022 withName \"DState\"\n    \u2022 fieldPrefix \"ds\"\n  Conv-DState = autoConvert DState\n\n  HsTy-DCert = autoHsType DCert\n  Conv-DCert = autoConvert DCert\n\n  HsTy-GState = autoHsType GState\n    \u22a3 withConstructor \"MkGState\"\n    \u2022 fieldPrefix \"gs\"\n  Conv-GState = autoConvert GState\n\n  Conv-DState-DState' : Convertible DState DState'\n  Conv-DState-DState' .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2648}{\\htmlId{2648}{\\htmlClass{Bound}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2661}{\\htmlId{2661}{\\htmlClass{Bound}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2675}{\\htmlId{2675}{\\htmlClass{Bound}{\\text{rewards}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2685}{\\htmlId{2685}{\\htmlClass{Bound}{\\text{deposits}}}}\\, \\end{pmatrix}$ = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2648}{\\htmlId{2701}{\\htmlClass{Bound}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2661}{\\htmlId{2714}{\\htmlClass{Bound}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2661}{\\htmlId{2728}{\\htmlClass{Bound}{\\text{stakeDelegs}}}}\\, \\end{pmatrix}$\n  Conv-DState-DState' .from $\\begin{pmatrix} \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2774}{\\htmlId{2774}{\\htmlClass{Bound}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2787}{\\htmlId{2787}{\\htmlClass{Bound}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2801}{\\htmlId{2801}{\\htmlClass{Bound}{\\text{rewards}}}}\\, \\end{pmatrix}$         = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2774}{\\htmlId{2825}{\\htmlClass{Bound}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2787}{\\htmlId{2838}{\\htmlClass{Bound}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2787}{\\htmlId{2852}{\\htmlClass{Bound}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{2866}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\end{pmatrix}$\n\n  Conv-GState-GState' : Convertible GState GState'\n  Conv-GState-GState' .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2951}{\\htmlId{2951}{\\htmlClass{Bound}{\\text{dreps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2959}{\\htmlId{2959}{\\htmlClass{Bound}{\\text{ccHotKeys}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2971}{\\htmlId{2971}{\\htmlClass{Bound}{\\text{deposits}}}}\\, \\end{pmatrix}$ = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2951}{\\htmlId{2987}{\\htmlClass{Bound}{\\text{dreps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#2959}{\\htmlId{2995}{\\htmlClass{Bound}{\\text{ccHotKeys}}}}\\, \\end{pmatrix}$\n  Conv-GState-GState' .from $\\begin{pmatrix} \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#3039}{\\htmlId{3039}{\\htmlClass{Bound}{\\text{dreps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#3047}{\\htmlId{3047}{\\htmlClass{Bound}{\\text{ccHotKeys}}}}\\, \\end{pmatrix}$         = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#3039}{\\htmlId{3073}{\\htmlClass{Bound}{\\text{dreps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Certs.html#3047}{\\htmlId{3081}{\\htmlClass{Bound}{\\text{ccHotKeys}}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{3093}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\end{pmatrix}$\n\ndeleg-step : HsType (DelegEnv \u2192 DState \u2192 DCert \u2192 ComputationResult String DState)\ndeleg-step = to (compute Computational-DELEG)\n\n{-# COMPILE GHC deleg-step as delegStep #-}\n\npool-step : HsType (PParams \u2192 PState \u2192 DCert \u2192 ComputationResult String PState)\npool-step = to (compute Computational-POOL)\n\n{-# COMPILE GHC pool-step as poolStep #-}\n\ngovcert-step : HsType (CertEnv \u2192 GState \u2192 DCert \u2192 ComputationResult String GState)\ngovcert-step = to (compute Computational-GOVCERT)\n\n{-# COMPILE GHC govcert-step as govCertStep #-}\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Chain.html","title":"Chain","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Chain where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.NewEpoch\nopen import Ledger.Conway.Foreign.HSLedger.Transaction\n\nopen import Ledger.Conway.Conformance.Chain it it\nopen import Ledger.Conway.Conformance.Chain.Properties it it\n\ninstance\n  HsTy-ChainState = autoHsType ChainState\n  Conv-ChainState = autoConvert ChainState\n\n  HsTy-Block = autoHsType Block\n  Conv-Block = autoConvert Block\n\nchain-step : HsType (\u22a4 \u2192 ChainState \u2192 Block \u2192 ComputationResult String ChainState)\nchain-step = to (compute Computational-CHAIN)\n\n{-# COMPILE GHC chain-step as chainStep #-}\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Core.html","title":"Core","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Core where\n\nopen import Ledger.Prelude hiding (\u03b5) renaming (fromList to fromList\u02e2) public\n\nopen Computational public\n\nopen import Algebra.Construct.DirectProduct using (commutativeMonoid)\nopen import Algebra.Morphism    using (module MonoidMorphisms)\nopen import Data.Nat.Properties using (+-0-commutativeMonoid) public\nimport      Data.Integer as \u2124\nimport      Data.Rational as \u211a\n\nopen import Foreign.Convertible           public\nopen import Foreign.Convertible.Deriving  public\nopen import Foreign.HaskellTypes          public\nopen import Foreign.HaskellTypes.Deriving public\n\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\n\nopen import Ledger.Conway.Specification.Transaction renaming (Vote to VoteTag) public\n\nopen import Ledger.Prelude.Foreign.Util public\n\nopen import Tactic.Derive.Show\n\ninstance\n  Hashable-\u22a4 : Hashable \u22a4 \u2115\n  Hashable-\u22a4 = \u03bb where .hash tt \u2192 0\n\nrecord HSVKey : Type where\n  constructor MkHSVKey\n  field hvkVKey       : \u2115\n        hvkStoredHash : \u2115\n\n{-# FOREIGN GHC\n  data HSVKey = MkHSVKey\n    { hvkVKey :: Integer\n    , hvkStoredHash :: Integer\n    }\n#-}\n{-# COMPILE GHC HSVKey = data HSVKey (MkHSVKey) #-}\n\nunquoteDecl DecEq-HSVKey = derive-DecEq ((quote HSVKey , DecEq-HSVKey) \u2237 [])\n\ninstance\n  Hashable-HSVKey : Hashable HSVKey \u2115\n  Hashable-HSVKey = \u03bb where .hash \u2192 HSVKey.hvkStoredHash\n\n  isHashableSet-HSVKey : isHashableSet HSVKey\n  isHashableSet-HSVKey = mkIsHashableSet \u2115\n\n  Hashable-\u2115 : Hashable \u2115 \u2115\n  Hashable-\u2115 = \u03bb where .hash \u2192 id\n\n  isHashableSet-\u2115 : isHashableSet \u2115\n  isHashableSet-\u2115 = mkIsHashableSet \u2115\n\nunquoteDecl Show-HSVKey = derive-Show\n  ((quote HSVKey , Show-HSVKey) \u2237 [])\n\nmodule Implementation where\n  Network          = \u2115\n  SlotsPerEpoch\u1d9c   = 4320 -- TODO pass this externally instead of hardcoding\n  ActiveSlotCoeff  = \u2124.1\u2124 \u211a./ 20  \n  StabilityWindow\u1d9c = 10\n  RandomnessStabilisationWindow\u1d9c = 10\n  MaxLovelaceSupply\u1d9c = 1\n  Quorum           = 1\n  NetworkId        = 0 -- Testnet\n\n  SKey = \u2115\n  VKey = HSVKey\n  Sig  = \u2115\n  Ser  = \u2115\n\n  isKeyPair  = \u03bb sk vk \u2192 sk \u2261 HSVKey.hvkVKey vk\n  sign       = _+_\n  ScriptHash = \u2115\n\n  Data         = \u2115\n  Data\u02b0        = mkHashableSet \u2115\n  toData : \u2200 {A : Type} \u2192 A \u2192 Data\n  toData _ = 0\n\n  ExUnits      = \u2115 \u00d7 \u2115\n  ExUnit-CommutativeMonoid =\n    Conversion.fromBundle (commutativeMonoid +-0-commutativeMonoid +-0-commutativeMonoid)\n  _\u2265\u1d49_ : ExUnits \u2192 ExUnits \u2192 Type\n  _\u2265\u1d49_ = _\u2261_\n\n  instance\n    Show-ExUnits : Show ExUnits\n    Show-ExUnits = Show-\u00d7\n\n  CostModel    = \u22a4\n  Language     = \u22a4\n  LangDepView  = \u22a4\n  Prices       = \u22a4\n\n  TxId            = \u2115\n  Ix              = \u2115\n  AuxiliaryData   = \u2115\n  DocHash         = \u2115\n  tokenAlgebra    = Coin-TokenAlgebra\n    where open import Ledger.Conway.Specification.TokenAlgebra.Coin ScriptHash\n            using (Coin-TokenAlgebra)\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Enact.html","title":"Enact","text":"<pre>open import Data.Rational using (\u211a)\nmodule Ledger.Conway.Foreign.HSLedger.Enact where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.PParams\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Actions\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Enact.Properties.Computational govStructure\n\ninstance\n  HsTy-EnactState = autoHsType EnactState \u22a3 withConstructor \"MkEnactState\"\n                                          \u2022 fieldPrefix \"es\"\n  Conv-EnactState = autoConvert EnactState\n\n  HsTy-EnactEnv = autoHsType EnactEnv \u22a3 withConstructor \"MkEnactEnv\"\n                                      \u2022 fieldPrefix \"ee\"\n  Conv-EnactEnv = autoConvert EnactEnv\n\nenact-step : HsType (EnactEnv \u2192 EnactState \u2192 GovAction \u2192 ComputationResult String EnactState)\nenact-step = to (compute Computational-ENACT)\n\n{-# COMPILE GHC enact-step as enactStep #-}\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Epoch.html","title":"Epoch","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Epoch where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Enact\nopen import Ledger.Conway.Foreign.HSLedger.Ledger\nopen import Ledger.Conway.Foreign.HSLedger.PParams\nopen import Ledger.Conway.Foreign.HSLedger.Ratify\nopen import Ledger.Conway.Foreign.HSLedger.Rewards\n\nopen import Ledger.Conway.Conformance.Equivalence.Convert\nopen import Ledger.Conway.Conformance.Epoch it it\nopen import Ledger.Conway.Conformance.Epoch.Properties it it\n\nmodule EpochSpec where\n  open import Ledger.Conway.Specification.Epoch it it public\n  open import Ledger.Conway.Specification.Epoch.Properties.Computational it it public\n\nimport Data.String as S\n\ninstance\n  Show-EPOCH : \u2200 {eps e eps'} \u2192 Show (_ EpochSpec.\u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps')\n  Show-EPOCH .show (EpochSpec.EPOCH (s , r , pr)) =\n    \"EPOCH\\n\" S.++ \"SNAP\" S.++ \" POOLREAP\"\n\ninstance\n  HsTy-EpochState = autoHsType EpochState \u22a3 withConstructor \"MkEpochState\"\n                                          \u2022 fieldPrefix \"es\"\n  Conv-EpochState = autoConvert EpochState\n\n-- An implementation of EPOCH that connects the conformance state\n-- with the specification rule.\n\nepoch-step\n  : HsType (\u22a4 \u2192 EpochState \u2192 Epoch \u2192 ComputationResult \u22a5 (EpochState \u00d7 String))\nepoch-step _ epochSt e =\n  let r = EpochSpec.Computational-EPOCH .computeProof _ (conv (from epochSt)) e\n  in case r of \u03bb where\n    (success (s , p)) \u2192 to (success (conv s , show p))\n\n{-# COMPILE GHC epoch-step as epochStep #-}\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.ExternalStructures.html","title":"ExternalStructures","text":"<pre>open import Ledger.Conway.Foreign.ExternalFunctions\n\nmodule Ledger.Conway.Foreign.HSLedger.ExternalStructures (externalFunctions : ExternalFunctions) where\n\nimport      Data.Rational as \u211a using (pos) -- import an instance\n\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\nopen import Ledger.Conway.Foreign.HSLedger.Core\n\nHSGlobalConstants = GlobalConstants \u220b record {Implementation}\ninstance\n  HSEpochStructure = EpochStructure  \u220b \u2115EpochStructure HSGlobalConstants\n\n  HSCryptoStructure : CryptoStructure\n  HSCryptoStructure = record\n    { Implementation\n    ; pkk = HSPKKScheme\n    }\n    where\n    open ExternalFunctions externalFunctions\n    HSPKKScheme : PKKScheme\n    HSPKKScheme = record\n      { Implementation\n      ; isSigned         = \u03bb a b m \u2192 extIsSigned (HSVKey.hvkVKey a) b m \u2261 true\n      ; sign             = \u03bb _ _ \u2192 zero\n        -- we can't prove correctness since the function is provided by the Haskell implementation\n      ; isSigned-correct = error \"isSigned-correct evaluated\"\n      ; Dec-isSigned     = \u2047 (_ \u225f _)\n      }\n\n-- No P2 scripts for now\n\nopen import Ledger.Conway.Specification.Script it it\nopen import Ledger.Conway.Specification.Script.Timelock it it public\nopen import Ledger.Conway.Conformance.Script it it public\n\ninstance\n  HSScriptStructure : ScriptStructure\n  HSScriptStructure = record\n    { p1s = P1ScriptStructure-HTL\n    ; hashRespectsUnion = hashRespectsUnion\n    ; ps = HSP2ScriptStructure\n    }\n    where\n      hashRespectsUnion : \u2200 {A B \u210d}\n        \u2192 Hashable A \u210d \u2192 Hashable B \u210d\n        \u2192 Hashable (A \u228e B) \u210d\n      hashRespectsUnion a _ .hash (inj\u2081 x) = hash \u2983 a \u2984 x\n      hashRespectsUnion _ b .hash (inj\u2082 y) = hash \u2983 b \u2984 y\n\n      HSP2ScriptStructure : PlutusStructure\n      HSP2ScriptStructure = record\n        { Implementation\n        ; validPlutusScript = \u03bb _ _ _ _ \u2192 \u22a4\n        ; PlutusScript = HSPlutusScript\n        }\n\nopen import Ledger.Conway.Specification.PParams it it it hiding (Acnt; DrepThresholds; PoolThresholds)\n\nHsGovParams : GovParams\nHsGovParams = record\n  { Implementation\n  ; ppUpd = let open PParamsDiff in \u03bb where\n      .UpdateT      \u2192 PParamsUpdate\n      .updateGroups \u2192 modifiedUpdateGroups\n      .applyUpdate  \u2192 applyPParamsUpdate\n      .ppWF? {u}    \u2192 ppWF u\n  }\n  where\n    open PParamsUpdate\n    -- FIXME Replace `trustMe` with an actual proof\n    ppWF : (u : PParamsUpdate) \u2192\n      ((pp : PParams) \u2192\n      paramsWellFormed pp \u2192\n      paramsWellFormed (applyPParamsUpdate pp u))\n      \u2047\n    ppWF u with paramsUpdateWellFormed? u\n    ... | yes _ = \u2047 (yes trustMe)\n      where\n        postulate\n          trustMe :\n            ((pp : PParams) \u2192\n            paramsWellFormed pp \u2192\n            paramsWellFormed (applyPParamsUpdate pp u))\n    ... | no _  = \u2047 (no trustMe)\n      where\n        postulate\n          trustMe :\n            \u00ac((pp : PParams) \u2192\n            paramsWellFormed pp \u2192\n            paramsWellFormed (applyPParamsUpdate pp u))\n\ninstance\n  HSTransactionStructure : TransactionStructure\n  HSTransactionStructure = record\n    { Implementation\n    ; epochStructure  = HSEpochStructure\n    ; globalConstants = HSGlobalConstants\n    ; cryptoStructure = HSCryptoStructure\n    ; govParams       = HsGovParams\n    ; txidBytes       = id\n    ; scriptStructure = HSScriptStructure\n    ; adHashingScheme = isHashableSet-\u2115\n    }\n\nopen TransactionStructure HSTransactionStructure public\nopen import Ledger.Conway.Specification.Certs govStructure public\n\nopen import Ledger.Conway.Specification.Abstract it\n\ninstance\n  HSAbstractFunctions : AbstractFunctions\n  HSAbstractFunctions = record\n    { Implementation\n    ; txscriptfee = \u03bb tt y \u2192 0\n    ; serSize     = \u03bb v \u2192 0\n    ; indexOfImp  = record\n      { indexOfDCert    = \u03bb _ _ \u2192 nothing\n      ; indexOfRwdAddr  = \u03bb _ _ \u2192 nothing\n      ; indexOfTxIn     = \u03bb _ _ \u2192 nothing\n      ; indexOfPolicyId = \u03bb _ _ \u2192 nothing\n      ; indexOfVote     = \u03bb _ _ \u2192 nothing\n      ; indexOfProposal = \u03bb _ _ \u2192 nothing\n      }\n    ; runPLCScript = \u03bb _ _ _ _ \u2192 false\n    ; scriptSize = \u03bb where \n        (inj\u2081 x) \u2192 HSTimelock.tlScriptSize x\n        (inj\u2082 x) \u2192 HSPlutusScript.psScriptSize x\n    ; valContext = \u03bb _ _ \u2192 zero\n    }\n\nopen import Ledger.Core.Specification.Address Network KeyHash ScriptHash using () public\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Gov.Actions.html","title":"Actions","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Gov.Actions where\n\nopen import Data.Rational using (\u211a)\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.PParams\n\nopen import Ledger.Conway.Specification.Gov.Base\nopen import Ledger.Conway.Specification.Gov.Actions govStructure using (Vote) public\n\nDocHash = GovStructure.DocHash govStructure\n\n-- nondependent version of GovAction\ndata GovAction' : Type where\n  NoConfidence        :                                             GovAction'\n  UpdateCommittee     : (Credential \u21c0 Epoch) \u2192 \u2119 Credential \u2192 \u211a  \u2192  GovAction'\n  NewConstitution     : DocHash \u2192 Maybe ScriptHash               \u2192  GovAction'\n  TriggerHardFork     : ProtVer                                  \u2192  GovAction'\n  ChangePParams       : PParamsUpdate                            \u2192  GovAction'\n  TreasuryWithdrawal  : (RwdAddr \u21c0 Treasury)                     \u2192  GovAction'\n  Info                :                                             GovAction'\n\ninstance\n  mkGovAction' : Convertible GovAction GovAction'\n  mkGovAction' = \u03bb where\n    .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2446}{\\htmlId{1249}{\\htmlClass{InductiveConstructor}{\\text{NoConfidence}}}}\\,        \\\\ \\,\\htmlId{1271}{\\htmlClass{Symbol}{\\text{\\_}}}\\,           \\end{pmatrix}$ \u2192 NoConfidence\n    .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{1312}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\,     \\\\ \\,\\htmlId{1334}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1335}{\\htmlId{1335}{\\htmlClass{Bound}{\\text{m}}}}\\, , \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1339}{\\htmlId{1339}{\\htmlClass{Bound}{\\text{p}}}}\\, , \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1343}{\\htmlId{1343}{\\htmlClass{Bound}{\\text{q}}}}\\,\\,\\htmlId{1344}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$ \u2192 (UpdateCommittee m p q)\n    .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2522}{\\htmlId{1386}{\\htmlClass{InductiveConstructor}{\\text{NewConstitution}}}}\\,     \\\\ \\,\\htmlId{1408}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1409}{\\htmlId{1409}{\\htmlClass{Bound}{\\text{dh}}}}\\, , \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1414}{\\htmlId{1414}{\\htmlClass{Bound}{\\text{s}}}}\\, \\,\\htmlId{1416}{\\htmlClass{Symbol}{\\text{)}}}\\,   \\end{pmatrix}$ \u2192 (NewConstitution dh s)\n    .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{1459}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\,     \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1481}{\\htmlId{1481}{\\htmlClass{Bound}{\\text{p}}}}\\,           \\end{pmatrix}$ \u2192 (TriggerHardFork p)\n    .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{1529}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\,       \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1551}{\\htmlId{1551}{\\htmlClass{Bound}{\\text{pu}}}}\\,          \\end{pmatrix}$ \u2192 (ChangePParams pu)\n    .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{1598}{\\htmlClass{InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1620}{\\htmlId{1620}{\\htmlClass{Bound}{\\text{m}}}}\\,           \\end{pmatrix}$ \u2192 ((TreasuryWithdrawal m))\n    .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2674}{\\htmlId{1673}{\\htmlClass{InductiveConstructor}{\\text{Info}}}}\\,                \\\\ \\,\\htmlId{1695}{\\htmlClass{Symbol}{\\text{\\_}}}\\,           \\end{pmatrix}$ \u2192 Info\n    .from NoConfidence              \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2446}{\\htmlId{1758}{\\htmlClass{InductiveConstructor}{\\text{NoConfidence}}}}\\,        \\\\ \\,\\href{Agda.Builtin.Unit.html#212}{\\htmlId{1780}{\\htmlClass{InductiveConstructor}{\\text{tt}}}}\\,          \\end{pmatrix}$\n    .from (UpdateCommittee m p q)   \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{1836}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\,     \\\\ \\,\\htmlId{1858}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1823}{\\htmlId{1859}{\\htmlClass{Bound}{\\text{m}}}}\\, , \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1825}{\\htmlId{1863}{\\htmlClass{Bound}{\\text{p}}}}\\, , \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1827}{\\htmlId{1867}{\\htmlClass{Bound}{\\text{q}}}}\\,\\,\\htmlId{1868}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$\n    .from (NewConstitution dh s)    \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2522}{\\htmlId{1914}{\\htmlClass{InductiveConstructor}{\\text{NewConstitution}}}}\\,     \\\\ \\,\\htmlId{1936}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1901}{\\htmlId{1937}{\\htmlClass{Bound}{\\text{dh}}}}\\, , \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1904}{\\htmlId{1942}{\\htmlClass{Bound}{\\text{s}}}}\\,\\,\\htmlId{1943}{\\htmlClass{Symbol}{\\text{)}}}\\,    \\end{pmatrix}$\n    .from (TriggerHardFork p)       \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{1992}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\,     \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#1979}{\\htmlId{2014}{\\htmlClass{Bound}{\\text{p}}}}\\,           \\end{pmatrix}$\n    .from (ChangePParams pu)        \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{2070}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\,       \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#2055}{\\htmlId{2092}{\\htmlClass{Bound}{\\text{pu}}}}\\,          \\end{pmatrix}$\n    .from (TreasuryWithdrawal m)    \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{2148}{\\htmlClass{InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Actions.html#2138}{\\htmlId{2170}{\\htmlClass{Bound}{\\text{m}}}}\\,           \\end{pmatrix}$\n    .from Info                      \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2674}{\\htmlId{2226}{\\htmlClass{InductiveConstructor}{\\text{Info}}}}\\,                \\\\ \\,\\href{Agda.Builtin.Unit.html#212}{\\htmlId{2248}{\\htmlClass{InductiveConstructor}{\\text{tt}}}}\\,          \\end{pmatrix}$\n\n  HsTy-GovAction' = autoHsType GovAction' \u22a3 withName \"GovAction\"\n  Conv-GovAction' = autoConvert GovAction'\n\n  HsTy-GovAction = MkHsType GovAction (HsType GovAction')\n  Conv-GovAction = mkGovAction' \u2a3e Conv-GovAction'\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Gov.Core.html","title":"Core","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Gov.Core where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Specification.Gov.Actions govStructure using (Vote)\n\ninstance\n  HsTy-GovRole = autoHsType GovRole\n  Conv-GovRole = autoConvert GovRole\n\n  HsTy-Anchor = autoHsType Anchor\n  Conv-Anchor = autoConvert Anchor\n\n  HsTy-VDeleg = autoHsType VDeleg\n  Conv-VDeleg = autoConvert VDeleg\n\n  HsTy-Vote = autoHsType Vote\n  Conv-Vote = autoConvert Vote\n\n  HsTy-GovVotes = autoHsType GovVotes\n  Conv-GovVotes = autoConvert GovVotes\n\nGovVoter' : Type\nGovVoter' = GovRole \u00d7 Credential\n\ninstance\n  mkGovVoter' : Convertible GovVoter GovVoter'\n  mkGovVoter' .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{829}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\,   \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Core.html#836}{\\htmlId{836}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix}$ = CC   , c\n  mkGovVoter' .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{873}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Core.html#880}{\\htmlId{880}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix}$ = DRep , c\n  mkGovVoter' .to $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{917}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Core.html#924}{\\htmlId{924}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix}$ = SPO  , KeyHashObj c\n  mkGovVoter' .from (CC   , c)   = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{989}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\,   \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Core.html#980}{\\htmlId{996}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix}$\n  mkGovVoter' .from (DRep , c)   = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{1039}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Core.html#1030}{\\htmlId{1046}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix}$\n  mkGovVoter' .from (SPO  , c)   =\n    case c of \u03bb where\n      (KeyHashObj kh) \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{1135}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.Core.html#1127}{\\htmlId{1141}{\\htmlClass{Bound}{\\text{kh}}}}\\, \\end{pmatrix}$\n      (ScriptObj _)   \u2192 error \"mkGovVoter: Converting from SPO with ScriptObj credential\"\n\n  HsTy-GovVoter = MkHsType GovVoter (HsType GovVoter')\n  Conv-GovVoter : Convertible GovVoter (HsType GovVoter')\n  Conv-GovVoter = mkGovVoter' \u2a3e Convertible-Pair\n\nunquoteDecl = do\n  hsTypeAlias GovVoter\n\nrecord GovVote' : Type where\n  field\n    gid         : GovActionID\n    voter       : GovVoter'\n    vote        : Vote\n    anchor      : Maybe Anchor\n\ninstance\n  mkGovVote' : Convertible GovVote GovVote'\n  mkGovVote' = \u03bb where\n    .to v   \u2192 let module v = GovVote v in record { gid = v.gid ; voter = to v.voter  ; vote = v.vote ; anchor = v.anchor }\n    .from v \u2192 let module v = GovVote' v in record { gid = v.gid ; voter = from v.voter ; vote = v.vote ; anchor = v.anchor }\n\n  HsTy-GovVote' = autoHsType GovVote' \u22a3 withConstructor \"MkGovVote\"\n                                      \u2022 withName \"GovVote\"\n  Conv-GovVote' = autoConvert GovVote'\n\n  HsTy-GovVote = MkHsType GovVote (HsType GovVote')\n  Conv-GovVote = mkGovVote' \u2a3e Conv-GovVote'\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Gov.html","title":"Gov","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Gov where\n\nopen import Ledger.Prelude using (Type)\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Enact\nopen import Ledger.Conway.Foreign.HSLedger.PParams\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Core\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Actions\nopen import Ledger.Conway.Foreign.HSLedger.Cert\n\nopen import Ledger.Conway.Conformance.Certs govStructure\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Conformance.Gov it it\nimport Ledger.Conway.Specification.Gov it as L\nopen import Ledger.Conway.Specification.Gov.Properties.Computational it\n\ninstance\n\n  HsTy-GovEnv = autoHsType GovEnv \u22a3 withConstructor \"MkGovEnv\"\n                                  \u2022 fieldPrefix \"ge\"\n  Conv-GovEnv = autoConvert GovEnv\n\n-- NeedsHash depends on a GovAction, so a little bit of manual work is\n-- required to get the types using it into Haskell.\n\n-- First we define to/fromNeedsHash that replaces the \u22a4 cases by a\n-- dummy GovActionID.\n\ntoNeedsHash : \u2200 {action} \u2192 GovActionID \u2192 NeedsHash action\ntoNeedsHash {NoConfidence}        x = x\ntoNeedsHash {UpdateCommittee}     x = x\ntoNeedsHash {NewConstitution}     x = x\ntoNeedsHash {TriggerHardFork}     x = x\ntoNeedsHash {ChangePParams}       x = x\ntoNeedsHash {TreasuryWithdrawal}  x = tt\ntoNeedsHash {Info}                x = tt\n\nfromNeedsHash : \u2200 {action} \u2192 NeedsHash action \u2192 GovActionID\nfromNeedsHash {NoConfidence}        x = x\nfromNeedsHash {UpdateCommittee}     x = x\nfromNeedsHash {NewConstitution}     x = x\nfromNeedsHash {TriggerHardFork}     x = x\nfromNeedsHash {ChangePParams}       x = x\nfromNeedsHash {TreasuryWithdrawal}  x = 0 , 0\nfromNeedsHash {Info}                x = 0 , 0\n\n-- Then we define non-dependent versions of the types that use\n-- NeedsHash.\n\nrecord GovProposal' : Type where\n  field\n    action      : GovAction'\n    prevAction  : GovActionID       -- NeedsHash action\n    policy      : Maybe ScriptHash\n    deposit     : Coin\n    returnAddr  : RwdAddr\n    anchor      : Anchor\n\nrecord GovActionState' : Type where\n  field\n    votes       : GovVotes\n    returnAddr  : RwdAddr\n    expiresIn   : Epoch\n    action      : GovAction'\n    prevAction  : GovActionID       -- NeedsHash action\n\n-- We can convert between the dependent and non-dependent versions\n-- using to/fromNeedsHash.\n\nprivate\n  mkGovProposal' : Convertible GovProposal GovProposal'\n  mkGovProposal' = \u03bb where\n    .to   p \u2192 let module p = GovProposal  p in record { p; action = to p.action  ; prevAction = fromNeedsHash p.prevAction }\n    .from p \u2192 let module p = GovProposal' p in record { p; action = from p.action; prevAction = toNeedsHash   p.prevAction }\n\n  mkGovActionState' : Convertible GovActionState GovActionState'\n  mkGovActionState' = \u03bb where\n    .to   s \u2192 let module s = GovActionState  s in record{ s; action = to s.action  ; prevAction = fromNeedsHash s.prevAction }\n    .from s \u2192 let module s = GovActionState' s in record{ s; action = from s.action; prevAction = toNeedsHash   s.prevAction }\n\n-- Auto-generated conversions for the non-dependent types\n\ninstance\n  HsTy-GovProposal' = autoHsType GovProposal' \u22a3 withName \"GovProposal\"\n                                              \u2022 withConstructor \"MkGovProposal\"\n                                              \u2022 fieldPrefix \"gp\"\n  Conv-GovProposal' = autoConvert GovProposal'\n\n  HsTy-GovActionState' = autoHsType GovActionState' \u22a3 withName \"GovActionState\"\n                                                    \u2022 withConstructor \"MkGovActionState\"\n                                                    \u2022 fieldPrefix \"gas\"\n  Conv-GovActionState' = autoConvert GovActionState'\n\n-- And finally we compose everything into conversions for the dependent types\n\ninstance\n  HsTy-GovProposal = MkHsType GovProposal (HsType GovProposal')\n  Conv-GovProposal = mkGovProposal' \u2a3e Conv-GovProposal'\n\n  HsTy-GovActionState = MkHsType GovActionState (HsType GovActionState')\n  Conv-GovActionState = mkGovActionState' \u2a3e Conv-GovActionState'\n\nunquoteDecl = do\n  hsTypeAlias GovActionID\n  hsTypeAlias GovState\n  hsTypeAlias GovVoter'\n\n-- Computational function\n\ngov-step : HsType (GovEnv \u2192 GovState \u2192 List (GovVote \u228e GovProposal) \u2192 ComputationResult String GovState)\ngov-step \u0393 govSt gvps = to (compute Computational-GOVS $\\begin{pmatrix} \\,\\href{Ledger.Conway.Conformance.Gov.html#952}{\\htmlId{4474}{\\htmlClass{Function}{\\text{txid}}}}\\, \\\\ \\,\\href{Ledger.Conway.Foreign.HSLedger.Gov.html#4622}{\\htmlId{4481}{\\htmlClass{Function}{\\text{e'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Gov.html#999}{\\htmlId{4486}{\\htmlClass{Function}{\\text{pparams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Gov.html#1025}{\\htmlId{4496}{\\htmlClass{Function}{\\text{ppolicy}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Gov.html#1060}{\\htmlId{4506}{\\htmlClass{Function}{\\text{enactState}}}}\\, \\\\ \\,\\href{Foreign.Convertible.html#230}{\\htmlId{4519}{\\htmlClass{Field}{\\text{to}}}}\\, \\,\\href{Ledger.Conway.Conformance.Gov.html#1089}{\\htmlId{4522}{\\htmlClass{Function}{\\text{certState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Conformance.Gov.html#1117}{\\htmlId{4534}{\\htmlClass{Function}{\\text{rewardCreds}}}}\\, \\end{pmatrix}$ (from govSt) (from gvps))\n  where open GovEnv (from \u0393) renaming (epoch to e')\n\n{-# COMPILE GHC gov-step as govStep #-}\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Ledger.html","title":"Ledger","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Ledger where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Certs\nopen import Ledger.Conway.Foreign.HSLedger.Enact\nopen import Ledger.Conway.Foreign.HSLedger.Gov\nopen import Ledger.Conway.Foreign.HSLedger.PParams\nopen import Ledger.Conway.Foreign.HSLedger.Transaction\nopen import Ledger.Conway.Foreign.HSLedger.Utxo\nopen import Ledger.Conway.Foreign.HSLedger.Cert\n\nopen import Ledger.Conway.Conformance.Ledger it it\nopen import Ledger.Conway.Conformance.Ledger.Properties it it\n\ninstance\n  HsTy-LEnv = autoHsType LEnv \u22a3 withConstructor \"MkLEnv\"\n                              \u2022 fieldPrefix \"le\"\n  Conv-LEnv = autoConvert LEnv\n\n  HsTy-LState = autoHsType LState \u22a3 withConstructor \"MkLState\"\n  Conv-LState = autoConvert LState\n\nledger-step : HsType (LEnv \u2192 LState \u2192 Tx \u2192 ComputationResult String LState)\nledger-step = to (compute Computational-LEDGER)\n\n{-# COMPILE GHC ledger-step as ledgerStep #-}\n\nledgers-step : HsType (LEnv \u2192 LState \u2192 List Tx \u2192 ComputationResult String LState)\nledgers-step = to (compute Computational-LEDGERS)\n\n{-# COMPILE GHC ledgers-step as ledgersStep #-}\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.NewEpoch.html","title":"NewEpoch","text":"<pre>module Ledger.Conway.Foreign.HSLedger.NewEpoch where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Epoch\nopen import Ledger.Conway.Foreign.HSLedger.Rewards\n\nopen import Ledger.Conway.Conformance.Equivalence.Convert\nopen import Ledger.Conway.Conformance.Epoch it it\nopen import Ledger.Conway.Conformance.Epoch.Properties it it\n\nimport Data.String as S\n\ninstance\n  Show-NEWEPOCH : \u2200 {eps e eps'} \u2192 Show (_ EpochSpec.\u22a2 eps \u21c0\u2987 e ,NEWEPOCH\u2988 eps')\n  Show-NEWEPOCH .show (EpochSpec.NEWEPOCH-New (_ , e))        = \"NEWEPOCH-New \" S.++ show e\n  Show-NEWEPOCH .show (EpochSpec.NEWEPOCH-Not-New x)          = \"NEWEPOCH-Not-New\"\n  Show-NEWEPOCH .show (EpochSpec.NEWEPOCH-No-Reward-Update x) = \"NEWEPOCH-No-Reward-Update\"\n\ninstance\n  HsTy-NewEpochState = autoHsType NewEpochState \u22a3 withConstructor \"MkNewEpochState\"\n  Conv-NewEpochState = autoConvert NewEpochState\n\n-- An implementation of NEWEPOCH that connects the conformance state\n-- with the specification rule.\n\nnewepoch-step\n  : HsType (\u22a4 \u2192 NewEpochState \u2192 Epoch \u2192 ComputationResult \u22a5 (NewEpochState \u00d7 String))\nnewepoch-step _ neSt e =\n  let r = EpochSpec.Computational-NEWEPOCH .computeProof _ (conv (from neSt)) e\n  in case r of \u03bb where\n    (success (s , p)) \u2192 to (success (conv s , show p))\n\n{-# COMPILE GHC newepoch-step as newEpochStep #-}\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.PParams.html","title":"PParams","text":"<pre>module Ledger.Conway.Foreign.HSLedger.PParams where\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\n\ninstance\n  HsTy-DrepThresholds = autoHsType DrepThresholds\n    \u22a3 withConstructor \"MkDrepThresholds\"\n  Conv-DrepThresholds = autoConvert DrepThresholds\n\n  HsTy-PoolThresholds = autoHsType PoolThresholds\n    \u22a3 withConstructor \"MkPoolThresholds\"\n  Conv-PoolThresholds = autoConvert PoolThresholds\n\n  HsTy-Acnt = autoHsType Acnt \u22a3 withConstructor \"MkAcnt\"\n  Conv-Acnt = autoConvert Acnt\n\n  HsTy-PParams = autoHsType PParams \u22a3 withConstructor \"MkPParams\"\n                                    \u2022 fieldPrefix \"pp\"\n  Conv-PParams = autoConvert PParams\n\n  HsTy-PParamsUpdate = autoHsType PParamsUpdate.PParamsUpdate \u22a3 withConstructor \"MkPParamsUpdate\"\n                                                              \u2022 fieldPrefix \"ppu\"\n  Conv-PParamsUpdate = autoConvert PParamsUpdate.PParamsUpdate\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Ratify.html","title":"Ratify","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Ratify where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Certs\nopen import Ledger.Conway.Foreign.HSLedger.Enact\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Core\nopen import Ledger.Conway.Foreign.HSLedger.Gov\n\nopen import Ledger.Conway.Specification.Enact govStructure\n\nopen import Data.String.Base renaming (_++_ to _+\u02e2_) hiding (show; length)\nimport Data.Rational.Show as Rational\n\nimport Foreign.Haskell.Pair as F\nopen import Ledger.Conway.Specification.Ratify it\nopen import Ledger.Conway.Specification.Ratify.Properties.Computational it\n\ninstance\n  HsTy-StakeDistrs = autoHsType StakeDistrs\n  Conv-StakeDistrs = autoConvert StakeDistrs\n\n  HsTy-RatifyEnv = autoHsType RatifyEnv \u22a3 withConstructor \"MkRatifyEnv\"\n                                        \u2022 fieldPrefix \"re\"\n  Conv-RatifyEnv = autoConvert RatifyEnv\n\n  HsTy-RatifyState = autoHsType RatifyState \u22a3 withConstructor \"MkRatifyState\"\n                                            \u2022 fieldPrefix \"rs\"\n                                            \u2022 RatifyState.es \u21a6 \"rsEnactState\"\n  Conv-RatifyState = autoConvert RatifyState\n\n-- ratify-debug : HsType (RatifyEnv \u2192 RatifyState \u2192 List (GovActionID \u00d7 GovActionState) \u2192 String)\n-- ratify-debug env st sig =\n--   \"Number of govactions: \" +\u02e2 show (length sig) +\u02e2 \"\\n\" +\u02e2\n--   foldr (\u03bb x s \u2192 s +\u02e2 govActionInfo x) \"\" sig\n--   where\n--     open RatifyEnv (from env)\n--     govActionInfo : HsType (GovActionID \u00d7 GovActionState) \u2192 String\n--     govActionInfo (gaId F., gas) =\n--       let\n--         open GovActionState (from gas)\n--         open RatifyState (from st)\n--         open EnactState es\n--         votes'  = actualVotes (from env) (proj\u2081 pparams) (proj\u2081 cc) (action .gaType) votes\n--         showAcceptedStakeRatio role = Rational.show (acceptedStakeRatio role (dom votes') stakeDistrs votes')\n--         showIsAccepted role = case acceptedBy? (from env) es (from gas) role of \u03bb where\n--           (yes _) \u2192 \"\u2713\"\n--           (no  _) \u2192 \"\u00d7\"\n--       in\n--         \"SPO: \\t\"  +\u02e2 showAcceptedStakeRatio SPO  +\u02e2 \"\\t\" +\u02e2 showIsAccepted SPO  +\u02e2 \"\\n\" +\u02e2\n--         \"DRep: \\t\" +\u02e2 showAcceptedStakeRatio DRep +\u02e2 \"\\t\" +\u02e2 showIsAccepted DRep +\u02e2 \"\\n\" +\u02e2\n--         \"CC: \\t\"   +\u02e2 showAcceptedStakeRatio CC   +\u02e2 \"\\t\" +\u02e2 showIsAccepted CC   +\u02e2 \"\\n\"\n\n-- {-# COMPILE GHC ratify-debug as ratifyDebug #-}\n\nratify-step : HsType (RatifyEnv \u2192 RatifyState \u2192 List (GovActionID \u00d7 GovActionState) \u2192 ComputationResult \u22a5 RatifyState)\nratify-step = to (compute Computational-RATIFIES)\n\n{-# COMPILE GHC ratify-step as ratifyStep #-}\n\ninstance\n  Show-RATIFIES : \u2200 {\u0393 s sig s'}\n    \u2192 Show (\u0393 \u22a2 s \u21c0\u2987 sig  ,RATIFIES\u2988 s')\n  Show-RATIFIES {\u0393} {s} {sig} .show r = \"\" -- ratify-debug (to \u0393) (to s) (to sig)\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Rewards.html","title":"Rewards","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Rewards where\n\nimport Data.Integer as \u2124\nimport Data.String as S\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Certs\n\nopen import Ledger.Conway.Conformance.Rewards it it\n\ninstance\n  Show-SNAP : \u2200 {ls ss ss'} \u2192 Show (ls \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss')\n  Show-SNAP {ls} {ss} {ss'} .show SNAP =\n    \"SNAP:\"\n    -- S.++\n    -- \"\\t\" S.++ show-Snapshot (Snapshots.mark ss') S.++ \"\\n\"\n    --   where show-Snapshot : Snapshot \u2192 String\n    --         show-Snapshot ss =\n    --           let open Snapshot ss\n    --           in show (proj\u2081 stake)\n\ninstance\n  HsTy-Snapshot = autoHsType Snapshot \u22a3 withConstructor \"MkSnapshot\"\n  Conv-Snapshot = autoConvert Snapshot\n\n  HsTy-Snapshots = autoHsType Snapshots \u22a3 withConstructor \"MkSnapshots\"\n  Conv-Snapshots = autoConvert Snapshots\n\nrecord HsRewardUpdate : Type where\n  field \u0394t \u0394r \u0394f : \u2124\n        rs : HsType (Credential \u21c0 Coin)\n{-# FOREIGN GHC\n  data HsRewardUpdate = MkRewardUpdate\n    { deltaT  :: Integer\n    , deltaR  :: Integer\n    , deltaF  :: Integer\n    , rs      ::\n        MAlonzo.Code.Ledger.Prelude.Foreign.HSTypes.HSMap\n          MAlonzo.Code.Ledger.Conway.Foreign.HSLedger.Address.Credential\n          Integer\n    }\n    deriving (Eq, Show)\n#-}\n\n{-# COMPILE GHC HsRewardUpdate = data HsRewardUpdate (MkRewardUpdate) #-}\n\ninstance\n  HsTy-RewardUpdate : HasHsType RewardUpdate\n  HsTy-RewardUpdate .HasHsType.HsType = HsRewardUpdate\n\n  -- manual, since we want to throw an error on non-zero update\n  Conv-RewardUpdate : Convertible RewardUpdate HsRewardUpdate\n  Conv-RewardUpdate .to   ru = record { RewardUpdate ru; rs = to (ru .RewardUpdate.rs) }\n  Conv-RewardUpdate .from ru = HsRewardUpdate\u2192RewardUpdate\n    where \n      module _ where\n        module ru = HsRewardUpdate ru\n        open ru\n\n        flowConservation? = \u00bf \u0394t + \u0394r + \u0394f + \u2124.+ (indexedSum\u1d5b' {A = Credential} (\u03bb x \u2192 x) (from rs)) \u2261 \u2124.0\u2124 \u00bf\n        \u0394t-nonnegative?   = \u00bf \u2124.0\u2124 \u2124.\u2264 \u0394t \u00bf\n        \u0394f-nonpositive?   = \u00bf \u0394f \u2124.\u2264 \u2124.0\u2124 \u00bf\n\n        HsRewardUpdate\u2192RewardUpdate : RewardUpdate\n        HsRewardUpdate\u2192RewardUpdate\n          with flowConservation? | \u0394t-nonnegative? | \u0394f-nonpositive?\n        ... | yes p | yes q | yes r = record { ru\n                                             ; rs = from ru.rs\n                                             ; flowConservation = p\n                                             ; \u0394t-nonnegative   = q\n                                             ; \u0394f-nonpositive   = r\n                                             }\n        ... | _ | _ | _ = error \"Formal Spec: cannot make a non-zero reward update\"\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Transaction.html","title":"Transaction","text":"<pre>module Ledger.Conway.Foreign.HSLedger.Transaction where\n\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes\nopen import Ledger.Conway.Foreign.HSLedger.Certs\nopen import Ledger.Conway.Foreign.HSLedger.Gov.Core\nopen import Ledger.Conway.Foreign.HSLedger.Gov\nopen import Ledger.Conway.Foreign.HSLedger.PParams\n\ninstance\n  HsTy-Tag = autoHsType Tag\n  Conv-Tag = autoConvert Tag\n\n  HsTy-Timelock = autoHsType Timelock\n  -- The termination checker doesn't like recursion through lists of recursive structures, or that\n  -- we do all the matching in a rhs pattern lambda. Telling the termination checker to go away does\n  -- work though.\n  {-# TERMINATING #-}\n  Conv-Timelock = autoConvert Timelock\n\n  HsTy-HSTimelock = autoHsType HSTimelock\n  Conv-HSTimelock = autoConvert HSTimelock\n\n  HsTy-HSPlutusScript = autoHsType HSPlutusScript\n  Conv-HSPlutusScript = autoConvert HSPlutusScript\n\n  HsTy-TxWitnessess = autoHsType TxWitnesses \u22a3 withConstructor \"MkTxWitnesses\"\n  Conv-TxWitnessess = autoConvert TxWitnesses\n\n  HsTy-TxBody = autoHsType TxBody \u22a3 withConstructor \"MkTxBody\"\n  Conv-TxBody = autoConvert TxBody\n\n  HsTy-Tx = autoHsType Tx \u22a3 withConstructor \"MkTx\"\n  Conv-Tx = autoConvert Tx\n\nunquoteDecl = do\n  hsTypeAlias TxId\n  hsTypeAlias Ix\n  hsTypeAlias TxIn\n  hsTypeAlias P1Script\n  hsTypeAlias P2Script \u22a3 withName \"P2Script\"\n  hsTypeAlias Script\n  hsTypeAlias Datum\n  hsTypeAlias DataHash \u22a3 withName \"DataHash\"\n  hsTypeAlias Value\n  hsTypeAlias TxOut\n  hsTypeAlias RdmrPtr\n  hsTypeAlias ScriptHash\n  hsTypeAlias AuxiliaryData\n  hsTypeAlias Withdrawals\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.Utxo.html","title":"Utxo","text":"<pre>{-# OPTIONS --no-qualified-instances #-}\n\nmodule Ledger.Conway.Foreign.HSLedger.Utxo where\n\nopen import Ledger.Prelude\n\nopen import Ledger.Conway.Foreign.ExternalFunctions\n\nopen import Data.String.Base renaming (_++_ to _+\u02e2_) hiding (show; length; map; fromList)\n\nopen import Ledger.Conway.Foreign.HSLedger.Core\nopen import Ledger.Conway.Foreign.HSLedger.Address\nopen import Ledger.Conway.Foreign.HSLedger.Certs\nopen import Ledger.Conway.Foreign.HSLedger.PParams\nopen import Ledger.Conway.Foreign.HSLedger.Transaction\n\nopen import Foreign.Haskell.Coerce\n\nopen import Ledger.Conway.Foreign.HSLedger.BaseTypes hiding (TxWitnesses; refScripts; isScriptObj; isKeyHashObj)\nopen import Ledger.Conway.Specification.Script.Validation DummyTransactionStructure DummyAbstractFunctions\nopen import Ledger.Conway.Conformance.Utxo DummyTransactionStructure DummyAbstractFunctions\nopen import Ledger.Conway.Conformance.Utxow DummyTransactionStructure DummyAbstractFunctions\n\ninstance\n  HsTy-UTxOEnv = autoHsType UTxOEnv \u22a3 withConstructor \"MkUTxOEnv\"\n                                    \u2022 fieldPrefix \"ue\"\n  Conv-UTxOEnv = autoConvert UTxOEnv\n\n  HsTy-UTxOState = autoHsType UTxOState \u22a3 withConstructor \"MkUTxOState\"\n  Conv-UTxOState = autoConvert UTxOState\n\nunquoteDecl = do\n  hsTypeAlias UTxO\n  hsTypeAlias Redeemer\n\nmodule _ (ext : ExternalFunctions) where\n  open import Ledger.Conway.Foreign.HSLedger.ExternalStructures ext hiding (Tx; TxBody; inject)\n  open import Ledger.Conway.Conformance.Utxow.Properties HSTransactionStructure HSAbstractFunctions\n  open import Ledger.Conway.Conformance.Utxo.Properties HSTransactionStructure HSAbstractFunctions\n\n  utxo-step : HsType (UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 ComputationResult String UTxOState)\n  utxo-step = to (coerce \u2983 TrustMe \u2984 $ compute Computational-UTXO)\n\n  {-# COMPILE GHC utxo-step as utxoStep #-}\n\n  utxow-step : HsType (UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 ComputationResult String UTxOState)\n  utxow-step = to (coerce \u2983 TrustMe \u2984 $ compute Computational-UTXOW)\n\n  {-# COMPILE GHC utxow-step as utxowStep #-}\n\n  utxo-debug : HsType (UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 String)\n  utxo-debug env st tx =\n    let open Tx (from tx)\n        open TxBody body\n        open UTxOState (from st)\n        open UTxOEnv (from env)\n     in unlines $\n          \"Consumed:\" \u2237\n          (\"\\tInputs:      \\t\" +\u02e2 show (balance (utxo \u2223 txIns))) \u2237\n          (\"\\tMint:        \\t\" +\u02e2 show mint) \u2237\n          (\"\\tRefunds:     \\t\" +\u02e2 show (inject (depositRefunds pparams (from st) body))) \u2237\n          (\"\\tWithdrawals: \\t\" +\u02e2 show (inject (getCoin txWithdrawals))) \u2237\n          (\"\\tTotal:       \\t\" +\u02e2 show (consumed pparams (from st) body)) \u2237\n          \"Produced:\" \u2237\n          (\"\\tOutputs:     \\t\" +\u02e2 show (balance (outs body))) \u2237\n          (\"\\tDonations:   \\t\" +\u02e2 show (inject txDonation)) \u2237\n          (\"\\tDeposits:    \\t\" +\u02e2 show (inject (newDeposits pparams (from st) body))) \u2237\n          (\"\\tFees:        \\t\" +\u02e2 show (inject txFee)) \u2237\n          (\"\\tTotal:       \\t\" +\u02e2 show (produced pparams (from st) body)) \u2237\n          \"\" \u2237\n          \"Reference Scripts Info:\" \u2237\n          (\"\\tTotal size: \\t\" +\u02e2 show (refScriptsSize utxo (from tx))) \u2237\n          []\n\n  {-# COMPILE GHC utxo-debug as utxoDebug #-}\n\n  utxow-debug : HsType (UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 String)\n  utxow-debug env st tx =\n    let open Tx (from tx)\n        open TxBody body\n        open UTxOState (from st)\n        open UTxOEnv (from env)\n        open TxWitnesses (coerce \u2983 TrustMe \u2984 wits)\n        neededScriptHashes = mapPartial (isScriptObj  \u2218 proj\u2082) (credsNeeded utxo body)\n        neededVKeyHashes   = mapPartial (isKeyHashObj \u2218 proj\u2082) (credsNeeded utxo body)\n        refScriptHashes = map\u02e2\n          hash \n          (refScripts (coerce \u2983 TrustMe \u2984 (from tx)) (coerce \u2983 TrustMe \u2984 utxo))\n        witsScriptHashes  = map\u02e2 hash scripts\n     in unlines\n       $ \"neededVKeyHashes utxo txb = \"\n       \u2237 show neededVKeyHashes\n       \u2237 \"\\nwitsKeyHashes = \"\n       \u2237 show (map\u02e2 hash (dom vkSigs))\n       \u2237 \"\\nneededScriptHashes = \"\n       \u2237 show neededScriptHashes\n       \u2237 \"\\nrefScriptHashes = \"\n       \u2237 show refScriptHashes\n       \u2237 \"\\nwitsScriptHashes = \"\n       \u2237 show witsScriptHashes\n       \u2237 []\n\n  {-# COMPILE GHC utxow-debug as utxowDebug #-}\n</pre>"},{"location":"Ledger.Conway.Foreign.HSLedger.html","title":"HSLedger","text":"<pre>module Ledger.Conway.Foreign.HSLedger where\n\nopen import Ledger.Conway.Foreign.HSLedger.Cert public\nopen import Ledger.Conway.Foreign.HSLedger.Chain public\nopen import Ledger.Conway.Foreign.HSLedger.Certs public\nopen import Ledger.Conway.Foreign.HSLedger.Enact public\nopen import Ledger.Conway.Foreign.HSLedger.Epoch public\nopen import Ledger.Conway.Foreign.HSLedger.Gov public\nopen import Ledger.Conway.Foreign.HSLedger.Ledger public\nopen import Ledger.Conway.Foreign.HSLedger.NewEpoch public\nopen import Ledger.Conway.Foreign.HSLedger.Ratify public\nopen import Ledger.Conway.Foreign.HSLedger.Utxo public\n</pre>"},{"location":"Ledger.Conway.Specification.Abstract.html","title":"Abstract","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Abstract (txs : TransactionStructure) where\n\nopen TransactionStructure txs\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Script.ScriptPurpose txs\n\nrecord indexOf : Type where\n  field\n    indexOfDCert    : DCert \u2192 List DCert \u2192 Maybe Ix\n    indexOfRwdAddr  : RwdAddr \u2192 Withdrawals \u2192 Maybe Ix\n    indexOfTxIn     : TxIn \u2192 \u2119 TxIn \u2192 Maybe Ix\n    indexOfPolicyId : ScriptHash \u2192 \u2119 ScriptHash \u2192 Maybe Ix\n    indexOfVote     : GovVoter \u2192 List GovVoter \u2192 Maybe Ix\n    indexOfProposal : GovProposal \u2192 List GovProposal \u2192 Maybe Ix\n\nrecord AbstractFunctions : Type where\n  field txscriptfee  : Prices \u2192 ExUnits \u2192 Coin\n        serSize      : Value \u2192 MemoryEstimate\n        indexOfImp   : indexOf\n        runPLCScript : CostModel \u2192 P2Script \u2192 ExUnits \u2192 List Data \u2192 Bool\n        scriptSize   : Script \u2192 \u2115\n        valContext   : TxInfo \u2192 ScriptPurpose \u2192 Data\n</pre>"},{"location":"Ledger.Conway.Specification.BlockBody.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\nopen import Ledger.Conway.Specification.Abstract using (AbstractFunctions)\n\nmodule Ledger.Conway.Specification.BlockBody.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\nopen import Ledger.Conway.Specification.BlockBody txs abs\nopen import Ledger.Conway.Specification.Ledger.Properties.Computational txs abs\nopen import Ledger.Prelude\n\nopen Computational \u2983...\u2984\n\ninstance\n  Computational-BBODY : Computational _\u22a2_\u21c0\u2987_,BBODY\u2988_ String\n  Computational-BBODY .computeProof \u0393 (ls , _) block = do\n    _ , lsStep \u2190 computeProof _ ls (block .ts)\n    success\n      (_ , BBODY-Block-Body (block .\u2261-bBodySize , block .\u2261-bBodyHash , lsStep))\n    where open Block\n\n  Computational-BBODY .completeness _ s b _\n    (BBODY-Block-Body (_ , _ , lsStep))\n    with recomputeProof lsStep | completeness _ _ _ _ lsStep\n  ... | success _ | refl = refl\n</pre>"},{"location":"Ledger.Conway.Specification.BlockBody.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.BlockBody.Properties where\n\nopen import Ledger.Conway.Specification.BlockBody.Properties.Computational\n</pre>"},{"location":"Ledger.Conway.Specification.BlockBody.html","title":"BlockBody","text":"<pre>{-# OPTIONS --safe #-}\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\u00a0\nmodule Ledger.Conway.Specification.BlockBody\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.Rewards txs abs\n</pre>"},{"location":"Ledger.Conway.Specification.BlockBody.html#blocks","title":"Blocks","text":"<p>The block follows mostly the definition of the Shelley specification. One notable difference is that the size and the hash of the block body are fields of the block, instead of functions.</p> <pre>record BHBody : Type where\n  field\n    bvkcold : VKey\n    bsize   : \u2115\n    slot    : Slot\n    bhash   : KeyHash\n    hBbsize : \u2115\n\nrecord BHeader : Type where\n  field\n    bhbody : BHBody\n    bhsig  : Sig\n\nrecord Block : Type where\n  field\n    bheader     : BHeader\n    ts          : List Tx\n    bBodySize   : \u2115\n    bBodyHash   : KeyHash\n    \u2261-bBodySize : bBodySize \u2261 BHBody.hBbsize (BHeader.bhbody bheader)\n    \u2261-bBodyHash : bBodyHash \u2261 BHBody.bhash (BHeader.bhbody bheader)\n</pre>"},{"location":"Ledger.Conway.Specification.BlockBody.html#block-body-transition","title":"Block Body Transition","text":"<p>The Block Body Transition updates the block body state which comprises the ledger state and the map describing the produced blocks. The environment of the <code>BBODY</code> transition includes the protocol parameters and the accounting state.</p> <p>The helper function <code>incrBlocks</code> counts the number of non-overlay blocks produced by each stake pool.</p> <p>The signal of the <code>BBODY</code> rule is a block from which we extract:</p> <ul> <li>the sequence of transactions, <code>txs</code> = <code>block</code> .<code>ts</code>, of the block;</li> <li>the block header body <code>bhb</code> = <code>block</code> .<code>bheader</code> .<code>bhbody</code>;</li> <li>the hash of the verification key of the issuer of the block, <code>hk</code> = <code>hash</code> (<code>bhb</code> .<code>bvkcold</code>).</li> </ul> <p>The transition is executed if the following preconditions are met:</p> <ul> <li>The size of the block body matches the value given in the block header body.</li> <li>The hash of the block body matches the value given in the block header body.</li> <li>The <code>LEDGERS</code> transition succeeds.</li> </ul> <p>After this, the transition system updates the mapping of the hashed stake pool keys to the incremented value of produced blocks <code>n + 1</code>, provided the current slot is not an overlay slot.</p> <p>The <code>BBODY</code> rule has two predicate failures:</p> <ul> <li>if the size of the block body in the header is not equal to the real size of   the block body, there is a WrongBlockBodySize failure.</li> <li>if the hash of the block body is not also the hash of transactions, there is   an InvalidBodyHash failure.</li> </ul> <pre>BBodyEnv : Type\nBBodyEnv = EnactState \u00d7 Acnt\n\nBBodyState : Type\nBBodyState = LState \u00d7 BlocksMade\n\nincrBlocks : KeyHash \u2192 BlocksMade \u2192 BlocksMade\nincrBlocks hk b = b \u222a\u207a singleton\u1d50 hk 1\n\ndata _\u22a2_\u21c0\u2987_,BBODY\u2988_\n  : BBodyEnv \u2192 BBodyState \u2192 Block \u2192 BBodyState \u2192 Type where\n\n  BBODY-Block-Body : \u2200 {acnt ls ls' b block es} \u2192\n    let\n      open BHeader\n      open BHBody\n      open Block\n      open EnactState\n      txs = block .ts\n      bhb = block .bheader .bhbody\n      hk = hash (bhb .bvkcold)\n      pp = PParamsOf es\n      \u0393  = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.BlockBody.html#3236}{\\htmlId{3333}{\\htmlClass{Bound}{\\text{bhb}}}}\\, \\,\\htmlId{3337}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.BlockBody.html#786}{\\htmlId{3338}{\\htmlClass{Field}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Prelude.html#2381}{\\htmlId{3345}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.BlockBody.html#3118}{\\htmlId{3347}{\\htmlClass{Bound}{\\text{es}}}}\\, \\,\\htmlId{3350}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Enact.html#1739}{\\htmlId{3351}{\\htmlClass{Field}{\\text{constitution}}}}\\, \\,\\href{Ledger.Prelude.html#2381}{\\htmlId{3364}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.BlockBody.html#3302}{\\htmlId{3368}{\\htmlClass{Bound}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.BlockBody.html#3118}{\\htmlId{3373}{\\htmlClass{Bound}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Prelude.Base.html#985}{\\htmlId{3378}{\\htmlClass{Field}{\\text{TreasuryOf}}}}\\, \\,\\href{Ledger.Conway.Specification.BlockBody.html#3098}{\\htmlId{3389}{\\htmlClass{Bound}{\\text{acnt}}}}\\, \\end{pmatrix}$\n\n     in\n    \u2219 block .bBodySize \u2261 bhb .hBbsize\n    \u2219 block .bBodyHash \u2261 bhb .bhash\n    \u2219 \u0393 \u22a2 ls \u21c0\u2987 txs ,LEDGERS\u2988 ls'\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    (es , acnt) \u22a2 ls , b \u21c0\u2987 block ,BBODY\u2988 (ls' , incrBlocks hk b)\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Gov.Base\n\nmodule Ledger.Conway.Specification.Certs.Properties.Computational (gs : _) (open GovStructure gs) where\n\nopen import Data.Maybe.Properties\nopen import Relation.Nullary.Decidable\n\nopen import Tactic.ReduceDec\n\nopen import Algebra using (CommutativeMonoid)\nopen import Ledger.Conway.Specification.Gov.Actions gs hiding (yes; no)\nopen import Ledger.Conway.Specification.Certs gs\n\nopen import Data.Nat.Properties using (+-0-monoid; +-0-commutativeMonoid; +-identity\u02b3; +-identity\u02e1)\nopen import Axiom.Set.Properties th\nopen import Relation.Binary using (IsEquivalence)\nopen Computational \u2983...\u2984\n\nopen import stdlib-meta.Tactic.GenError using (genErrors)\n\nopen CertState\nopen GovVote using (voter)\n\ninstance\n  Computational-DELEG : Computational _\u22a2_\u21c0\u2987_,DELEG\u2988_ String\n  Computational-DELEG .computeProof de st\u1d48 =\n    let open DelegEnv de; open DState st\u1d48 in\n    \u03bb where\n    (delegate c mv mc d) \u2192 case \u00bf (c \u2209 dom rewards \u2192 d \u2261 pparams .PParams.keyDeposit)\n                                \u00d7 (c \u2208 dom rewards \u2192 d \u2261 0)\n                                \u00d7 mv \u2208 map\u02e2 (just \u2218 vDelegCredential) delegatees \u222a\n                                    fromList ( nothing \u2237 just vDelegAbstain \u2237 just vDelegNoConfidence \u2237 [] )\n                                \u00d7 mc \u2208 map\u02e2 just (dom pools) \u222a \u2774 nothing \u2775\n                                \u00bf of \u03bb where\n      (yes p) \u2192 success (-, DELEG-delegate p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    (dereg c d) \u2192 case \u00bf (c , 0) \u2208 rewards \u00bf of \u03bb where\n      (yes p) \u2192 success (-, DELEG-dereg p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    (reg c d) \u2192 case \u00bf c \u2209 dom rewards\n                     \u00d7 (d \u2261 pparams .PParams.keyDeposit \u228e d \u2261 0)\n                     \u00bf of \u03bb where\n      (yes p) \u2192 success (-, DELEG-reg p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n    _ \u2192 failure \"Unexpected certificate in DELEG\"\n  Computational-DELEG .completeness de st\u1d48 (delegate c mv mc d)\n    s' (DELEG-delegate p) rewrite dec-yes (\u00bf (c \u2209 dom (DState.rewards st\u1d48) \u2192 d \u2261 DelegEnv.pparams de .PParams.keyDeposit)\n                                \u00d7 (c \u2208 dom (DState.rewards st\u1d48) \u2192 d \u2261 0)\n                                \u00d7 mv \u2208 map\u02e2 (just \u2218 vDelegCredential) (DelegEnv.delegatees de) \u222a fromList ( nothing \u2237 just vDelegAbstain \u2237 just vDelegNoConfidence \u2237 [] )\n                                \u00d7 mc \u2208 map\u02e2 just (dom (DelegEnv.pools de)) \u222a \u2774 nothing \u2775\n                                           \u00bf) p .proj\u2082 = refl\n  Computational-DELEG .completeness de st\u1d48 (dereg c d) _ (DELEG-dereg p)\n    rewrite dec-yes (\u00bf (c , 0) \u2208 (DState.rewards st\u1d48) \u00bf) p .proj\u2082 = refl\n  Computational-DELEG .completeness de st\u1d48 (reg c d) _ (DELEG-reg p)\n    rewrite dec-yes (\u00bf c \u2209 dom (DState.rewards st\u1d48) \u00d7 (d \u2261 DelegEnv.pparams de .PParams.keyDeposit \u228e d \u2261 0) \u00bf) p .proj\u2082 = refl\n\n  Computational-POOL : Computational _\u22a2_\u21c0\u2987_,POOL\u2988_ String\n  Computational-POOL .computeProof _ st\u1d56 (regpool c _) = success (-, POOL-regpool)\n  Computational-POOL .computeProof _ _ (retirepool c e) = success (-, POOL-retirepool)\n  Computational-POOL .computeProof _ _ _ = failure \"Unexpected certificate in POOL\"\n  Computational-POOL .completeness _ st\u1d56 (regpool c _) _ POOL-regpool = refl\n  Computational-POOL .completeness _ _ (retirepool _ _) _ POOL-retirepool = refl\n\n  Computational-GOVCERT : Computational _\u22a2_\u21c0\u2987_,GOVCERT\u2988_ String\n  Computational-GOVCERT .computeProof ce st\u1d4d (regdrep c d _) =\n    let open CertEnv ce; open PParams pp in\n    case \u00bf (d \u2261 drepDeposit \u00d7 c \u2209 dom (GState.dreps st\u1d4d))\n         \u228e (d \u2261 0 \u00d7 c \u2208 dom (GState.dreps st\u1d4d)) \u00bf of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-regdrep p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof _ st\u1d4d (deregdrep c _) =\n    let open GState st\u1d4d in\n    case c \u2208? dom dreps of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-deregdrep p)\n      (no \u00acp)  \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof ce st\u1d4d (ccreghot c _) =\n    let open CertEnv ce; open GState st\u1d4d in\n    case \u00bf ((c , nothing) \u2209 ccHotKeys \u02e2) \u00d7 c \u2208 coldCreds \u00bf of \u03bb where\n      (yes p) \u2192 success (-, GOVCERT-ccreghot p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-GOVCERT .computeProof _ _ _ = failure \"Unexpected certificate in GOVCERT\"\n  Computational-GOVCERT .completeness ce st\u1d4d\n    (regdrep c d _) _ (GOVCERT-regdrep p)\n    rewrite dec-yes\n      \u00bf (let open CertEnv ce; open PParams pp; open GState st\u1d4d in\n        (d \u2261 drepDeposit \u00d7 c \u2209 dom dreps) \u228e (d \u2261 0 \u00d7 c \u2208 dom dreps))\n      \u00bf p .proj\u2082 = refl\n  Computational-GOVCERT .completeness _ st\u1d4d\n    (deregdrep c _) _ (GOVCERT-deregdrep p)\n    rewrite dec-yes (c \u2208? dom (GState.dreps st\u1d4d)) p .proj\u2082 = refl\n  Computational-GOVCERT .completeness ce st\u1d4d\n    (ccreghot c _) _ (GOVCERT-ccreghot p)\n    rewrite dec-yes (\u00bf (((c , nothing) \u2209 (GState.ccHotKeys st\u1d4d) \u02e2) \u00d7 c \u2208 CertEnv.coldCreds ce) \u00bf) p .proj\u2082 = refl\n\n  Computational-CERT : Computational _\u22a2_\u21c0\u2987_,CERT\u2988_ String\n  Computational-CERT .computeProof ce cs dCert\n    with computeProof $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#4070}{\\htmlId{5124}{\\htmlClass{Field}{\\text{CertEnv.pp}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#5088}{\\htmlId{5135}{\\htmlClass{Bound}{\\text{ce}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{5140}{\\htmlClass{Field}{\\text{PState.pools}}}}\\, \\,\\htmlId{5153}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4754}{\\htmlId{5154}{\\htmlClass{Field}{\\text{pState}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#5091}{\\htmlId{5161}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{5163}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{5167}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{5171}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4566}{\\htmlId{5172}{\\htmlClass{Field}{\\text{GState.dreps}}}}\\, \\,\\htmlId{5185}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4774}{\\htmlId{5186}{\\htmlClass{Field}{\\text{gState}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#5091}{\\htmlId{5193}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{5195}{\\htmlClass{Symbol}{\\text{))}}}\\, \\end{pmatrix}$ (dState cs) dCert\n       | computeProof (CertEnv.pp ce) (pState cs) dCert | computeProof ce (gState cs) dCert\n  ... | success (_ , h) | _               | _               = success (-, CERT-deleg h)\n  ... | failure _       | success (_ , h) | _               = success (-, CERT-pool h)\n  ... | failure _       | failure _       | success (_ , h) = success (-, CERT-vdel h)\n  ... | failure e\u2081      | failure e\u2082      | failure e\u2083      = failure $\n    \"DELEG: \" &lt;&gt; e\u2081 &lt;&gt; \"\\nPOOL: \" &lt;&gt; e\u2082 &lt;&gt; \"\\nVDEL: \" &lt;&gt; e\u2083\n  Computational-CERT .completeness ce cs\n    dCert@(delegate c mv mc d) cs' (CERT-deleg h)\n    with computeProof $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#4070}{\\htmlId{5819}{\\htmlClass{Field}{\\text{CertEnv.pp}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#5739}{\\htmlId{5830}{\\htmlClass{Bound}{\\text{ce}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{5835}{\\htmlClass{Field}{\\text{PState.pools}}}}\\, \\,\\htmlId{5848}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4754}{\\htmlId{5849}{\\htmlClass{Field}{\\text{pState}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#5742}{\\htmlId{5856}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{5858}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{5862}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{5866}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4566}{\\htmlId{5867}{\\htmlClass{Field}{\\text{GState.dreps}}}}\\, \\,\\htmlId{5880}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4774}{\\htmlId{5881}{\\htmlClass{Field}{\\text{gState}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#5742}{\\htmlId{5888}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{5890}{\\htmlClass{Symbol}{\\text{))}}}\\, \\end{pmatrix}$ (dState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(reg c d) cs' (CERT-deleg h)\n    with computeProof $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#4070}{\\htmlId{6074}{\\htmlClass{Field}{\\text{CertEnv.pp}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#6005}{\\htmlId{6085}{\\htmlClass{Bound}{\\text{ce}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{6090}{\\htmlClass{Field}{\\text{PState.pools}}}}\\, \\,\\htmlId{6103}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4754}{\\htmlId{6104}{\\htmlClass{Field}{\\text{pState}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#6008}{\\htmlId{6111}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{6113}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{6117}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{6121}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4566}{\\htmlId{6122}{\\htmlClass{Field}{\\text{GState.dreps}}}}\\, \\,\\htmlId{6135}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4774}{\\htmlId{6136}{\\htmlClass{Field}{\\text{gState}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#6008}{\\htmlId{6143}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{6145}{\\htmlClass{Symbol}{\\text{))}}}\\, \\end{pmatrix}$ (dState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(dereg c _) cs' (CERT-deleg h)\n    with computeProof $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#4070}{\\htmlId{6331}{\\htmlClass{Field}{\\text{CertEnv.pp}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#6260}{\\htmlId{6342}{\\htmlClass{Bound}{\\text{ce}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{6347}{\\htmlClass{Field}{\\text{PState.pools}}}}\\, \\,\\htmlId{6360}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4754}{\\htmlId{6361}{\\htmlClass{Field}{\\text{pState}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#6263}{\\htmlId{6368}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{6370}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{6374}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{6378}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4566}{\\htmlId{6379}{\\htmlClass{Field}{\\text{GState.dreps}}}}\\, \\,\\htmlId{6392}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4774}{\\htmlId{6393}{\\htmlClass{Field}{\\text{gState}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#6263}{\\htmlId{6400}{\\htmlClass{Bound}{\\text{cs}}}}\\,\\,\\htmlId{6402}{\\htmlClass{Symbol}{\\text{))}}}\\, \\end{pmatrix}$ (dState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(regpool c poolParams) cs' (CERT-pool h)\n    with completeness _ _ _ _ h\n  ... | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(retirepool c e) cs' (CERT-pool h)\n    with completeness _ _ _ _ h\n  ... | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(regdrep c d an)\n    cs' (CERT-vdel h)\n    with computeProof ce (gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(deregdrep c _) cs' (CERT-vdel h)\n    with computeProof ce (gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n  Computational-CERT .completeness ce cs\n    dCert@(ccreghot c mkh) cs' (CERT-vdel h)\n    with computeProof ce (gState cs) dCert | completeness _ _ _ _ h\n  ... | success _ | refl = refl\n\n  Computational-PRE-CERT : Computational _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ String\n  Computational-PRE-CERT .computeProof ce cs _ =\n    let open CertEnv ce; open PParams pp\n        open GState (gState cs); open DState (dState cs)\n        refresh = mapPartial (isGovVoterDRep \u2218 voter) (fromList votes)\n        refreshedDReps  = mapValueRestricted (const (CertEnv.epoch ce + drepActivity)) dreps refresh\n    in case \u00bf filter\u02e2 isKeyHash (map\u02e2 RwdAddr.stake (dom wdrls)) \u2286 dom voteDelegs\n              \u00d7 map\u02e2 (map\u2081 RwdAddr.stake) (wdrls \u02e2) \u2286 rewards \u02e2 \u00bf of \u03bb where\n      (yes p) \u2192 success (-, CERT-pre p)\n      (no \u00acp) \u2192 failure (genErrors \u00acp)\n  Computational-PRE-CERT .completeness ce st _ st' (CERT-pre p)\n    rewrite let dState = CertState.dState st; open DState dState in\n      dec-yes \u00bf filter\u02e2 isKeyHash (map\u02e2 RwdAddr.stake (dom (CertEnv.wdrls ce))) \u2286 dom voteDelegs\n                \u00d7 map\u02e2 (map\u2081 RwdAddr.stake) (CertEnv.wdrls ce \u02e2) \u2286 rewards \u02e2 \u00bf\n        p .proj\u2082 = refl\n\n  -- POST-CERT has no premises, so computing always succeeds\n  -- with the unique post-state and proof CERT-post.\n  Computational-POST-CERT : Computational _\u22a2_\u21c0\u2987_,POST-CERT\u2988_ String\n  Computational-POST-CERT .computeProof ce cs tt = success ( cs' , CERT-post)\n    where\n      dreps : DReps\n      dreps = GState.dreps (gState cs)\n      validVoteDelegs : VoteDelegs\n      validVoteDelegs = (VoteDelegsOf cs) \u2223^ ( map\u02e2 vDelegCredential (dom dreps) \u222a fromList (vDelegNoConfidence \u2237 vDelegAbstain \u2237 []) )\n      cs' : CertState\n      cs' = $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#8617}{\\htmlId{8820}{\\htmlClass{Function}{\\text{validVoteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#2193}{\\htmlId{8838}{\\htmlClass{Field}{\\text{StakeDelegsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#8507}{\\htmlId{8852}{\\htmlClass{Bound}{\\text{cs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#2028}{\\htmlId{8857}{\\htmlClass{Field}{\\text{RewardsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#8507}{\\htmlId{8867}{\\htmlClass{Bound}{\\text{cs}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#5098}{\\htmlId{8874}{\\htmlClass{Field}{\\text{PStateOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#8507}{\\htmlId{8883}{\\htmlClass{Bound}{\\text{cs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#5206}{\\htmlId{8888}{\\htmlClass{Field}{\\text{GStateOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.Computational.html#8507}{\\htmlId{8897}{\\htmlClass{Bound}{\\text{cs}}}}\\, \\end{pmatrix}$\n\n  -- Completeness: the relational proof pins s' to exactly `post`,\n  -- and computeProof returns success at that same state; so refl.\n  Computational-POST-CERT .completeness ce cs _ cs' CERT-post = refl\n\nComputational-CERTS : Computational _\u22a2_\u21c0\u2987_,CERTS\u2988_ String\nComputational-CERTS = it\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.Properties.PoV.html","title":"PoV","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Gov.Base\n\nmodule Ledger.Conway.Specification.Certs.Properties.PoV (gs : _) (open GovStructure gs) where\n</pre> <pre>\nopen import Ledger.Conway.Specification.Certs gs\nopen import Ledger.Conway.Specification.Certs.Properties.PoVLemmas gs\nopen import Ledger.Conway.Specification.Gov.Actions gs hiding (yes; no)\nopen import Ledger.Prelude\n\nopen import Axiom.Set.Properties th\n\nopen import Algebra using (CommutativeMonoid)\nopen import Data.Maybe.Properties\nopen import Data.Nat.Properties using (+-0-monoid; +-0-commutativeMonoid; +-identity\u02b3; +-identity\u02e1)\nopen import Relation.Binary using (IsEquivalence)\nopen import Relation.Nullary.Decidable\nopen import Tactic.ReduceDec\n\nopen Computational \u2983...\u2984\n\nopen import stdlib-meta.Tactic.GenError using (genErrors)\n\nopen CertState\n\nprivate variable\n  dCert : DCert\n  l : List DCert\n  A A' B : Type\ninstance\n  _ = +-0-monoid\n\nmodule Certs-PoV  ( indexedSum\u1d5b'-\u222a' :  {A : Type} \u2983 _ : DecEq A \u2984 (m m' : A \u21c0 Coin)\n                              \u2192 disjoint (dom m) (dom m')\n                              \u2192 getCoin (m \u222a\u02e1 m') \u2261 getCoin m + getCoin m' )\n    -- TODO: prove some or all of the following assumptions, used in roof of `CERTBASE-pov`.\n    ( sumConstZero'    :  {A : Type} \u2983 _ : DecEq A \u2984 {X : \u2119 A} \u2192 getCoin (constMap X 0) \u2261 0 )\n    ( res-decomp'      :  {A : Type} \u2983 _ : DecEq A \u2984 (m m' : A \u21c0 Coin)\n                         \u2192 (m \u222a\u02e1 m')\u02e2 \u2261\u1d49 (m \u222a\u02e1 (m' \u2223 dom (m \u02e2) \u1d9c))\u02e2 )\n    ( getCoin-cong'    :  {A : Type} \u2983 _ : DecEq A \u2984 (s : A \u21c0 Coin) (s' : \u2119 (A \u00d7 Coin)) \u2192 s \u02e2 \u2261\u1d49 s'\n                         \u2192 indexedSum' proj\u2082 (s \u02e2) \u2261 indexedSum' proj\u2082 s' )\n    ( \u2261\u1d49-getCoin\u02e2'     :  {A A' : Type} \u2983 _ : DecEq A \u2984 \u2983 _ : DecEq A' \u2984 (s : \u2119 (A \u00d7 Coin)) {f : A \u2192 A'}\n                         \u2192 InjectiveOn (dom s) f \u2192 getCoin (map\u02e2 (map\u2081 f) s) \u2261 getCoin s )\n    where\n    open Certs-Pov-lemmas indexedSum\u1d5b'-\u222a' sumConstZero' res-decomp' getCoin-cong' \u2261\u1d49-getCoin\u02e2'\n</pre> <p> Theorem (The <code>CERTS</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>l</code> be a list of <code>DCerts</code>, and let <code>s\u2081</code>, <code>s\u2099</code> be <code>CertStates</code> such that <code>s\u2081</code> <code>\u21c0\u2987</code> <code>l</code> <code>,CERTS\u2988</code> <code>s\u2099</code>. Then, the value of <code>s\u2081</code> is equal to the value of <code>s\u2099</code> plus the value of the withdrawals in <code>\u0393</code>.</p> <p>Formally.</p> <pre>    CERTS-pov : {\u0393 : CertEnv} {s\u2081 s\u2099  : CertState}\n      \u2192 \u2200[ a \u2208 dom (WithdrawalsOf \u0393) ] NetworkIdOf a \u2261 NetworkId\n      \u2192 \u0393 \u22a2 s\u2081 \u21c0\u2987 l ,CERTS\u2988 s\u2099\n      \u2192 getCoin s\u2081 \u2261 getCoin s\u2099 + getCoin (WithdrawalsOf \u0393)\n</pre> <p>Proof.</p> <pre>    CERTS-pov {\u0393 = \u0393} validNetId (run (pre-cert , certs)) =\n      trans  (PRE-CERT-pov validNetId pre-cert)\n             (cong (_+ getCoin (WithdrawalsOf \u0393)) (sts-pov certs))\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html","title":"PoVLemmas","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Gov.Base\n\nmodule Ledger.Conway.Specification.Certs.Properties.PoVLemmas (gs : _) (open GovStructure gs) where\n\nopen import Ledger.Conway.Specification.Certs gs\nopen import Ledger.Conway.Specification.Gov.Actions gs hiding (yes; no)\nopen import Ledger.Prelude\n\nopen import Axiom.Set.Properties th\n\nopen import Algebra using (CommutativeMonoid)\nopen import Data.Maybe.Properties\nopen import Data.Nat.Properties using (+-0-monoid; +-0-commutativeMonoid; +-identity\u02b3; +-identity\u02e1)\nopen import Relation.Binary using (IsEquivalence)\nopen import Relation.Nullary.Decidable\nopen import Tactic.ReduceDec\n\nopen Computational \u2983...\u2984\n\nopen import stdlib-meta.Tactic.GenError using (genErrors)\n\nopen CertState\n\nprivate variable\n  dCert : DCert\n  l : List DCert\n  A A' B : Type\ninstance\n  _ = +-0-monoid\n\ngetCoin-singleton : \u2983 _ : DecEq A \u2984 {(a , c) : A \u00d7 Coin} \u2192 indexedSum\u1d5b' id \u2774 (a , c) \u2775 \u2261 c\ngetCoin-singleton = indexedSum-singleton' {M = Coin} (finiteness _)\n\n\u222a\u02e1singleton\u2208dom :  \u2983 _ : DecEq A \u2984 (m : A \u21c0 Coin) {(a , c) : A \u00d7 Coin}\n                \u2192 a \u2208 dom m \u2192 getCoin (m \u222a\u02e1 \u2774 (a , c) \u2775\u1d50) \u2261 getCoin m\n\u222a\u02e1singleton\u2208dom m {(a , c)} a\u2208dom = \u2261\u1d49-getCoin (m \u222a\u02e1 \u2774 (a , c) \u2775) m (singleton-\u2208-\u222a\u02e1 {m = m} a\u2208dom)\n\nmodule _  ( indexedSum\u1d5b'-\u222a :  {A : Type} \u2983 _ : DecEq A \u2984 (m m' : A \u21c0 Coin)\n                              \u2192 disjoint (dom m) (dom m')\n                              \u2192 getCoin (m \u222a\u02e1 m') \u2261 getCoin m + getCoin m' )\n  where\n  open \u2261-Reasoning\n  open Equivalence\n\n  \u222a\u02e1singleton\u2209dom :  \u2983 _ : DecEq A \u2984 (m : A \u21c0 Coin) {(a , c) : A \u00d7 Coin}\n                   \u2192 a \u2209 dom m \u2192 getCoin (m \u222a\u02e1 \u2774 (a , c) \u2775\u1d50) \u2261 getCoin m + c\n  \u222a\u02e1singleton\u2209dom m {(a , c)} a\u2209dom = begin\n    getCoin (m \u222a\u02e1 \u2774 a , c \u2775\u1d50)\n      \u2261\u27e8 indexedSum\u1d5b'-\u222a m \u2774 a , c \u2775\u1d50\n         ( \u03bb x y \u2192 a\u2209dom (subst (_\u2208 dom m) (from \u2208-dom-singleton-pair y) x) ) \u27e9\n    getCoin m + getCoin \u2774 a , c \u2775\u1d50\n      \u2261\u27e8 cong (getCoin m +_) getCoin-singleton \u27e9\n    getCoin m + c\n      \u220e\n\n  \u222a\u02e1singleton0\u2261 : \u2983 _ : DecEq A \u2984 \u2192 (m : A \u21c0 Coin) {a : A} \u2192 getCoin (m \u222a\u02e1 \u2774 (a , 0) \u2775\u1d50) \u2261 getCoin m\n  \u222a\u02e1singleton0\u2261 m {a} with a \u2208? dom m\n  ... | yes a\u2208dom = \u222a\u02e1singleton\u2208dom m a\u2208dom\n  ... | no a\u2209dom = trans (\u222a\u02e1singleton\u2209dom m a\u2209dom) (+-identity\u02b3 (getCoin m))\n</pre> <p>Lemma (The <code>CERT</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>s</code>, <code>s'</code> be <code>CertStates</code> such that <code>s</code> <code>\u21c0\u2987</code> <code>dcert</code> <code>,CERT\u2988</code> <code>s'</code> for some <code>dcert</code> : <code>DCert</code>. Then, <code>getCoin</code> <code>s</code> \\(\u2261\\) <code>getCoin</code> <code>s'</code>.</p> <p>Formally.</p> <pre>  CERT-pov : {\u0393 : CertEnv} {s s'  : CertState}\n    \u2192 \u0393 \u22a2 s \u21c0\u2987 dCert ,CERT\u2988 s'\n    \u2192 getCoin s \u2261 getCoin s'\n</pre> <p>Proof.</p> <pre>  CERT-pov (CERT-deleg (DELEG-delegate {rwds = rwds} _)) = sym (\u222a\u02e1singleton0\u2261 rwds)\n  CERT-pov (CERT-deleg (DELEG-reg {rwds = rwds} _)) = sym (\u222a\u02e1singleton0\u2261 rwds)\n  CERT-pov {s = $\\begin{pmatrix} \\,\\htmlId{2975}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#2979}{\\htmlId{2979}{\\htmlClass{Bound}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#2985}{\\htmlId{2985}{\\htmlClass{Bound}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$}{$\\begin{pmatrix} \\,\\htmlId{2996}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3000}{\\htmlId{3000}{\\htmlClass{Bound}{\\text{st\u1d56'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3007}{\\htmlId{3007}{\\htmlClass{Bound}{\\text{st\u1d4d'}}}}\\, \\end{pmatrix}$}\n    (CERT-deleg (DELEG-dereg {c = c} {rwds} {vDelegs = vDelegs}{sDelegs} x)) = begin\n    getCoin $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3072}{\\htmlId{3118}{\\htmlClass{Bound}{\\text{vDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3081}{\\htmlId{3128}{\\htmlClass{Bound}{\\text{sDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3055}{\\htmlId{3138}{\\htmlClass{Bound}{\\text{rwds}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#2979}{\\htmlId{3147}{\\htmlClass{Bound}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#2985}{\\htmlId{3153}{\\htmlClass{Bound}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$\n      \u2261\u02d8\u27e8 \u2261\u1d49-getCoin rwds-\u222a\u02e1-decomp rwds\n          ( \u2261\u1d49.trans rwds-\u222a\u02e1-\u222a (\u2261\u1d49.trans \u222a-sym (res-ex-\u222a Dec-\u2208-singleton)) ) \u27e9\n    getCoin rwds-\u222a\u02e1-decomp\n      \u2261\u27e8 \u2261\u1d49-getCoin rwds-\u222a\u02e1-decomp ((rwds \u2223 \u2774 c \u2775 \u1d9c) \u222a\u02e1 \u2774 (c , 0) \u2775\u1d50) rwds-\u222a\u02e1\u2261sing-\u222a\u02e1  \u27e9\n    getCoin ((rwds \u2223 \u2774 c \u2775 \u1d9c) \u222a\u02e1 \u2774 (c , 0) \u2775\u1d50 )\n      \u2261\u27e8 \u222a\u02e1singleton0\u2261 (rwds \u2223 \u2774 c \u2775 \u1d9c) \u27e9\n    getCoin $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3072}{\\htmlId{3501}{\\htmlClass{Bound}{\\text{vDelegs}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{3509}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{3511}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3051}{\\htmlId{3513}{\\htmlClass{Bound}{\\text{c}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{3515}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{3517}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3081}{\\htmlId{3521}{\\htmlClass{Bound}{\\text{sDelegs}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{3529}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{3531}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3051}{\\htmlId{3533}{\\htmlClass{Bound}{\\text{c}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{3535}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{3537}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3055}{\\htmlId{3541}{\\htmlClass{Bound}{\\text{rwds}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{3546}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{3548}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3051}{\\htmlId{3550}{\\htmlClass{Bound}{\\text{c}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{3552}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{3554}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3000}{\\htmlId{3560}{\\htmlClass{Bound}{\\text{st\u1d56'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.Properties.PoVLemmas.html#3007}{\\htmlId{3567}{\\htmlClass{Bound}{\\text{st\u1d4d'}}}}\\, \\end{pmatrix}$\n      \u220e\n    where\n    module \u2261\u1d49 = IsEquivalence (\u2261\u1d49-isEquivalence {Credential \u00d7 Coin})\n    rwds-\u222a\u02e1-decomp = (rwds \u2223 \u2774 c \u2775 \u1d9c) \u222a\u02e1 (rwds \u2223 \u2774 c \u2775 )\n\n    rwds-\u222a\u02e1-\u222a : rwds-\u222a\u02e1-decomp \u02e2 \u2261\u1d49 (rwds \u2223 \u2774 c \u2775 \u1d9c)\u02e2 \u222a (rwds \u2223 \u2774 c \u2775)\u02e2\n    rwds-\u222a\u02e1-\u222a = disjoint-\u222a\u02e1-\u222a (disjoint-sym res-ex-disjoint)\n\n    disj : disjoint (dom ((rwds \u2223 \u2774 c \u2775\u02e2 \u1d9c) \u02e2)) (dom (\u2774 c , 0 \u2775\u1d50 \u02e2))\n    disj {a} a\u2208res a\u2208dom  = res-comp-dom a\u2208res (dom-single\u2192single a\u2208dom)\n\n    rwds-\u222a\u02e1\u2261sing-\u222a\u02e1 : rwds-\u222a\u02e1-decomp \u02e2 \u2261\u1d49 ((rwds \u2223 \u2774 c \u2775 \u1d9c) \u222a\u02e1 \u2774 (c , 0) \u2775\u1d50 )\u02e2\n    rwds-\u222a\u02e1\u2261sing-\u222a\u02e1 = \u2261\u1d49.trans rwds-\u222a\u02e1-\u222a\n                              ( \u2261\u1d49.trans (\u222a-cong \u2261\u1d49.refl (res-singleton'{m = rwds} x))\n                                         (\u2261\u1d49.sym $ disjoint-\u222a\u02e1-\u222a disj) )\n  CERT-pov (CERT-pool x) = refl\n  CERT-pov (CERT-vdel x) = refl\n\n  injOn : (wdls : Withdrawals)\n          \u2192 \u2200[ a \u2208 dom (wdls \u02e2) ] NetworkIdOf a \u2261 NetworkId\n          \u2192 InjectiveOn (dom (wdls \u02e2)) RwdAddr.stake\n  injOn _ h {record { stake = stakex }} {record { stake = stakey }} x\u2208 y\u2208 refl =\n    cong (\u03bb u \u2192 record { net = u ; stake = stakex }) (trans (h x\u2208) (sym (h y\u2208)))\n\n  module Certs-Pov-lemmas\n    -- TODO: prove some or all of the following assumptions, used in roof of `CERTBASE-pov`.\n    ( sumConstZero    :  {A : Type} \u2983 _ : DecEq A \u2984 {X : \u2119 A} \u2192 getCoin (constMap X 0) \u2261 0 )\n    ( res-decomp      :  {A : Type} \u2983 _ : DecEq A \u2984 (m m' : A \u21c0 Coin)\n                         \u2192 (m \u222a\u02e1 m')\u02e2 \u2261\u1d49 (m \u222a\u02e1 (m' \u2223 dom (m \u02e2) \u1d9c))\u02e2 )\n    ( getCoin-cong    :  {A : Type} \u2983 _ : DecEq A \u2984 (s : A \u21c0 Coin) (s' : \u2119 (A \u00d7 Coin)) \u2192 s \u02e2 \u2261\u1d49 s'\n                         \u2192 indexedSum' proj\u2082 (s \u02e2) \u2261 indexedSum' proj\u2082 s' )\n    ( \u2261\u1d49-getCoin\u02e2     :  {A A' : Type} \u2983 _ : DecEq A \u2984 \u2983 _ : DecEq A' \u2984 (s : \u2119 (A \u00d7 Coin)) {f : A \u2192 A'}\n                         \u2192 InjectiveOn (dom s) f \u2192 getCoin (map\u02e2 (map\u2081 f) s) \u2261 getCoin s )\n    where\n</pre> <p>Lemma (<code>PRE-CERT</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>\u0393</code> : <code>CertEnv</code> be a certificate environment, and let <code>s</code>, <code>s'</code> : <code>CertState</code> be certificate states such that <code>s</code> <code>\u21c0\u2987</code> _ <code>,PRE-CERT\u2988</code> <code>s'</code>. Then, the value of <code>s</code> is equal to the value of <code>s'</code> plus the value of the withdrawals in <code>\u0393</code>.  In other terms,</p> <p><code>getCoin</code> <code>s</code> \\(\u2261\\) <code>getCoin</code> <code>s'</code> + <code>getCoin</code> (<code>\u0393</code> .<code>wdrls</code> ).</p> <p>Formally.</p> <pre>    PRE-CERT-pov : {\u0393 : CertEnv} {s s' : CertState}\n      \u2192 \u2200[ a \u2208 dom (CertEnv.wdrls \u0393) ] NetworkIdOf a \u2261 NetworkId\n      \u2192 \u0393 \u22a2 s \u21c0\u2987 _ ,PRE-CERT\u2988 s'\n      \u2192 getCoin s \u2261 getCoin s' + getCoin (CertEnv.wdrls \u0393)\n</pre> <p>Proof.</p> <pre>\n    PRE-CERT-pov  {\u0393   = \u0393}\n                  {s   = cs}\n                  {s'  = cs'}\n                  validNetId\n                  (CERT-pre {pp}{vs}{e}{dreps}{wdrls} (_ , wdrlsCC\u2286rwds)) =\n      let\n        open DState (dState cs )\n        open DState (dState cs') renaming (rewards to rewards')\n        module \u2261\u1d49       = IsEquivalence (\u2261\u1d49-isEquivalence {Credential \u00d7 Coin})\n        wdrlsCC         = map\u02e2 (map\u2081 RwdAddr.stake) (wdrls \u02e2)\n        zeroMap         = constMap (map\u02e2 RwdAddr.stake (dom wdrls)) 0\n        rwds-\u222a\u02e1-decomp  = (rewards \u2223 dom wdrlsCC \u1d9c) \u222a\u02e1 (rewards \u2223 dom wdrlsCC)\n      in\n        begin\n          getCoin rewards\n            \u2261\u02d8\u27e8 \u2261\u1d49-getCoin rwds-\u222a\u02e1-decomp rewards\n                ( \u2261\u1d49.trans (disjoint-\u222a\u02e1-\u222a (disjoint-sym res-ex-disjoint))\n                           (\u2261\u1d49.trans \u222a-sym (res-ex-\u222a (_\u2208? dom wdrlsCC))) ) \u27e9\n          getCoin rwds-\u222a\u02e1-decomp\n            \u2261\u27e8 indexedSum\u1d5b'-\u222a (rewards \u2223 dom wdrlsCC \u1d9c) (rewards \u2223 dom wdrlsCC)\n                              (disjoint-sym res-ex-disjoint) \u27e9\n          getCoin (rewards \u2223 dom wdrlsCC \u1d9c) + getCoin (rewards \u2223 dom wdrlsCC )\n            \u2261\u27e8 cong (getCoin (rewards \u2223 dom wdrlsCC \u1d9c) +_)\n               ( getCoin-cong (rewards \u2223 dom wdrlsCC) wdrlsCC (res-subset{m = rewards} wdrlsCC\u2286rwds) ) \u27e9\n          getCoin (rewards \u2223 dom wdrlsCC \u1d9c) + getCoin wdrlsCC\n            \u2261\u27e8 cong (getCoin (rewards \u2223 dom wdrlsCC \u1d9c) +_) (\u2261\u1d49-getCoin\u02e2 (wdrls \u02e2) (injOn wdrls validNetId)) \u27e9\n          getCoin (rewards \u2223 dom wdrlsCC \u1d9c) + getCoin wdrls\n            \u2261\u02d8\u27e8 cong (_+ getCoin wdrls)\n                ( begin\n                  getCoin (zeroMap \u222a\u02e1 rewards)\n                    \u2261\u27e8 \u2261\u1d49-getCoin (zeroMap \u222a\u02e1 rewards) (zeroMap \u222a\u02e1 (rewards \u2223 dom zeroMap \u1d9c))\n                                  (res-decomp zeroMap rewards) \u27e9\n                  getCoin (zeroMap \u222a\u02e1 (rewards \u2223 dom zeroMap \u1d9c))\n                    \u2261\u27e8 indexedSum\u1d5b'-\u222a zeroMap (rewards \u2223 dom zeroMap \u1d9c)\n                                      (disjoint-sym res-comp-dom) \u27e9\n                  getCoin zeroMap + getCoin (rewards \u2223 dom zeroMap \u1d9c)\n                    \u2261\u27e8 cong (\u03bb u \u2192 u + getCoin (rewards \u2223 dom zeroMap \u1d9c)) sumConstZero \u27e9\n                  0 + getCoin (rewards \u2223 (dom zeroMap) \u1d9c)\n                    \u2261\u27e8 +-identity\u02e1 (getCoin (rewards \u2223 dom zeroMap \u1d9c)) \u27e9\n                  getCoin (rewards \u2223 dom zeroMap \u1d9c)\n                    \u2261\u27e8 \u2261\u1d49-getCoin (rewards \u2223 dom zeroMap \u1d9c) (rewards \u2223 dom wdrlsCC \u1d9c)\n                       ( res-comp-cong\n                         ( \u2286-Transitive (proj\u2081 constMap-dom) (proj\u2082 dom-map\u02e1\u2261map-dom)\n                         , \u2286-Transitive (proj\u2081 dom-map\u02e1\u2261map-dom) (proj\u2082 constMap-dom) ) ) \u27e9\n                  getCoin (rewards \u2223 dom wdrlsCC \u1d9c)\n                    \u220e ) \u27e9\n          getCoin (zeroMap \u222a\u02e1 rewards) + getCoin wdrls\n            \u220e\n</pre> <p>Lemma (<code>POST-CERT</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>\u0393</code> : <code>CertEnv</code> be a certificate environment, and let <code>s</code>, <code>s'</code> : <code>CertState</code> be certificate states such that <code>s</code> <code>\u21c0\u2987</code> _ <code>,POST-CERT\u2988</code> <code>s'</code>. Then, the value of <code>s</code> is equal to the value of <code>s'</code>. In other terms,</p> <p><code>getCoin</code> <code>s</code> \\(\u2261\\) <code>getCoin</code> <code>s'</code>.</p> <p>Formally.</p> <pre>    POST-CERT-pov : {\u0393 : CertEnv} {s s' : CertState}\n      \u2192 \u0393 \u22a2 s \u21c0\u2987 _ ,POST-CERT\u2988 s'\n      \u2192 getCoin s \u2261 getCoin s'\n</pre> <p>Proof.</p> <pre>    POST-CERT-pov CERT-post = refl\n</pre> <p>Lemma (iteration of <code>CERT</code> rule preserves value).</p> <p>Informally. Let <code>l</code> be a list of <code>DCerts</code>, and let <code>s\u2081</code>, <code>s\u2099</code> be <code>CertStates</code> such that, starting with <code>s\u2081</code> and successively applying the <code>CERT</code> rule to with <code>DCerts</code> from the list <code>l</code>, we obtain <code>s\u2099</code>. Then, the value of <code>s\u2081</code> is equal to the value of <code>s\u2099</code>.</p> <p>Formally.</p> <pre>    sts-pov : {\u0393 : CertEnv} {s\u2081 s\u2099 : CertState} {sigs : List DCert}\n      \u2192 RunTraceAndThen _\u22a2_\u21c0\u2987_,CERT\u2988_ _\u22a2_\u21c0\u2987_,POST-CERT\u2988_ \u0393 s\u2081 sigs s\u2099\n      \u2192 getCoin s\u2081 \u2261 getCoin s\u2099\n</pre> <p>Proof.</p> <pre>    sts-pov (run-[] x) = POST-CERT-pov x\n    sts-pov (run-\u2237 x xs) = trans (CERT-pov x) (sts-pov xs)\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.Properties.VoteDelegsVDeleg.html","title":"VoteDelegsVDeleg","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Gov.Base\n\nmodule Ledger.Conway.Specification.Certs.Properties.VoteDelegsVDeleg (gs : _) (open GovStructure gs) where\n\nopen import Ledger.Conway.Specification.Certs gs\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Gov.Actions gs\n</pre> <p> Claim (<code>voteDelegs</code> by <code>credVoter</code> constructor).</p> <p>Informally.</p> <p>A <code>CertState</code> has a <code>DState</code>, a <code>PState</code>, and a <code>GState</code>.  The <code>DState</code> contains a field <code>voteDelegs</code> which is a mapping from <code>Credential</code> to <code>VDeleg</code>.</p> <p><code>VDeleg</code> is a datatype with three constructors; the one of interest to us here is <code>vDelegCredential{.AgdaInductiveConstructor}, which takes a</code>Credential`{.AgdaDatatype}.</p> <p>Now suppose we have a collection <code>C</code> of credentials\u2014for instance, given <code>d</code> : <code>DState</code>, take <code>C</code> to be the domain of the <code>voteDelegs</code> field of <code>d</code>. We could then obtain a set of <code>VDelegs</code> by applying <code>vDelegCredential{.AgdaInductiveConstructor} to each element of</code>C`{.AgdaBound}.</p> <p>The present property asserts that the set of <code>VDelegs</code> that results from the application of <code>vDelegCredential</code> to the domain of the <code>voteDelegs</code> of <code>d</code> contains the range of the <code>voteDelegs</code> of <code>d</code>.</p> <p>Formally.</p> <pre>voteDelegsVDeleg :  DState \u2192 Type\nvoteDelegsVDeleg d = range (VoteDelegsOf d) \u2286 map\u02e2 vDelegCredential (dom (VoteDelegsOf d))\n</pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Certs.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Certs.Properties where\n\nopen import Ledger.Conway.Specification.Certs.Properties.Computational\nopen import Ledger.Conway.Specification.Certs.Properties.PoV\nopen import Ledger.Conway.Specification.Certs.Properties.PoVLemmas\nopen import Ledger.Conway.Specification.Certs.Properties.VoteDelegsVDeleg\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html","title":"Certificates","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude renaming (filter\u02e2 to filter)\nopen import Ledger.Conway.Specification.Gov.Base\nopen import Ledger.Prelude.Numeric.UnitInterval\n\nmodule Ledger.Conway.Specification.Certs (gs : _) (open GovStructure gs) where\n\nopen import Ledger.Conway.Specification.Gov.Actions gs hiding (yes; no)\nopen RwdAddr\nopen PParams\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#stake-pool-parameter-definitions","title":"Stake Pool Parameter Definitions","text":"<pre>record StakePoolParams : Type where\n  field\n    owners          : \u2119 KeyHash\n    cost            : Coin\n    margin          : UnitInterval\n    pledge          : Coin\n    rewardAccount   : Credential\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#deposit-types","title":"Deposit Types","text":"<pre>data DepositPurpose : Type where\n  CredentialDeposit  : Credential   \u2192 DepositPurpose\n  PoolDeposit        : KeyHash      \u2192 DepositPurpose\n  DRepDeposit        : Credential   \u2192 DepositPurpose\n  GovActionDeposit   : GovActionID  \u2192 DepositPurpose\n\nDeposits : Type\nDeposits = DepositPurpose \u21c0 Coin\n</pre> <pre>record HasDeposits {a} (A : Type a) : Type a where\n  field DepositsOf : A \u2192 Deposits\nopen HasDeposits \u2983...\u2984 public\n\ninstance\n  unquoteDecl DecEq-DepositPurpose = derive-DecEq\n    ((quote DepositPurpose , DecEq-DepositPurpose) \u2237 [])\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#miscellaneous-type-aliases","title":"Miscellaneous Type Aliases","text":"<pre>CCHotKeys : Type\nCCHotKeys = Credential \u21c0 Maybe Credential\n\nPoolEnv : Type\nPoolEnv = PParams\n\nPools : Type\nPools = KeyHash \u21c0 StakePoolParams\n\nRetiring : Type\nRetiring = KeyHash \u21c0 Epoch\n\nRewards : Type\nRewards = Credential \u21c0 Coin\n\nStake : Type\nStake = Credential \u21c0 Coin\n\nStakeDelegs : Type\nStakeDelegs = Credential \u21c0 KeyHash\n</pre> <pre>record HasCCHotKeys {a} (A : Type a) : Type a where\n  field CCHotKeysOf : A \u2192 CCHotKeys\n\nrecord HasPools {a} (A : Type a) : Type a where\n  field PoolsOf : A \u2192 Pools\n\nrecord HasRetiring {a} (A : Type a) : Type a where\n  field RetiringOf : A \u2192 Retiring\n\nrecord HasRewards {a} (A : Type a) : Type a where\n  field RewardsOf : A \u2192 Rewards\n\nrecord HasStake {a} (A : Type a) : Type a where\n  field StakeOf : A -&gt; Stake\n\nrecord HasStakeDelegs {a} (A : Type a) : Type a where\n  field StakeDelegsOf : A -&gt; StakeDelegs\n\nopen HasCCHotKeys \u2983...\u2984 public\nopen HasPools \u2983...\u2984 public\nopen HasRetiring \u2983...\u2984 public\nopen HasRewards \u2983...\u2984 public\nopen HasStake \u2983...\u2984 public\nopen HasStakeDelegs \u2983...\u2984 public\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#delegation-definitions","title":"Delegation Definitions","text":"<pre>data DCert : Type where\n  delegate    : Credential \u2192 Maybe VDeleg \u2192 Maybe KeyHash \u2192 Coin \u2192 DCert\n  dereg       : Credential \u2192 Maybe Coin \u2192 DCert\n  regpool     : KeyHash \u2192 StakePoolParams \u2192 DCert\n  retirepool  : KeyHash \u2192 Epoch \u2192 DCert\n  regdrep     : Credential \u2192 Coin \u2192 Anchor \u2192 DCert\n  deregdrep   : Credential \u2192 Coin \u2192 DCert\n  ccreghot    : Credential \u2192 Maybe Credential \u2192 DCert\n</pre> <pre>  -- The `reg` cert is deprecated in Conway, but it's still present in this era\n  -- for backwards compatibility. This has been added to the spec to make\n  -- conformance testing work properly. We don't talk about this certificate\n  -- in the docs because it has been deprecated and we want to discourage people\n  -- from using it.\n  reg         : Credential \u2192 Coin \u2192 DCert\n</pre> <pre>cwitness : DCert \u2192 Maybe Credential\ncwitness (delegate c _ _ _)  = just c\ncwitness (dereg c _)         = just c\ncwitness (regpool kh _)      = just $ KeyHashObj kh\ncwitness (retirepool kh _)   = just $ KeyHashObj kh\ncwitness (regdrep c _ _)     = just c\ncwitness (deregdrep c _)     = just c\ncwitness (ccreghot c _)      = just c\n</pre> <pre>-- The implementation requires the `reg` cert to be witnessed only if the\n-- deposit is set. There didn't use to be a field for the deposit, but that was\n-- added in the Conway era to make it easier to determine, just by looking at\n-- the transaction, how much deposit was paid for that certificate.\ncwitness (reg _ zero)        = nothing\ncwitness (reg c (suc _))     = just c\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#certification-types","title":"Certification Types","text":"<pre>record CertEnv : Type where\n  field\n    epoch     : Epoch\n    pp        : PParams\n    votes     : List GovVote\n    wdrls     : Withdrawals\n    coldCreds : \u2119 Credential\n\nrecord DState : Type where\n</pre> <pre>  constructor \u27e6_,_,_\u27e7\u1d48\n</pre> <pre>  field\n    voteDelegs   : VoteDelegs\n    stakeDelegs  : StakeDelegs\n    rewards      : Rewards\n\nrecord PState : Type where\n  field\n    pools     : Pools\n    fPools    : Pools\n    retiring  : KeyHash \u21c0 Epoch\n\nrecord GState : Type where\n</pre> <pre>  constructor \u27e6_,_\u27e7\u1d5b\n</pre> <pre>  field\n    dreps      : DReps\n    ccHotKeys  : Credential \u21c0 Maybe Credential\n\nrecord CertState : Type where\n</pre> <pre>  constructor \u27e6_,_,_\u27e7\u1d9c\u02e2\n</pre> <pre>  field\n    dState : DState\n    pState : PState\n    gState : GState\n\nrecord DelegEnv : Type where\n  field\n    pparams       : PParams\n    pools         : Pools\n    delegatees    : \u2119 Credential\n</pre> <pre>record HasDState {a} (A : Type a) : Type a where\n  field DStateOf : A \u2192 DState\nopen HasDState \u2983...\u2984 public\n\nrecord HasPState {a} (A : Type a) : Type a where\n  field PStateOf : A \u2192 PState\nopen HasPState \u2983...\u2984 public\n\nrecord HasGState {a} (A : Type a) : Type a where\n  field GStateOf : A \u2192 GState\nopen HasGState \u2983...\u2984 public\n\nrecord HasCertState {a} (A : Type a) : Type a where\n  field CertStateOf : A \u2192 CertState\nopen HasCertState \u2983...\u2984 public\n\ninstance\n  HasPParams-CertEnv : HasPParams CertEnv\n  HasPParams-CertEnv .PParamsOf = CertEnv.pp\n\n  HasWithdrawals-CertEnv : HasWithdrawals CertEnv\n  HasWithdrawals-CertEnv .WithdrawalsOf = CertEnv.wdrls\n\n  HasVoteDelegs-DState : HasVoteDelegs DState\n  HasVoteDelegs-DState .VoteDelegsOf = DState.voteDelegs\n\n  HasStakeDelegs-DState : HasStakeDelegs DState\n  HasStakeDelegs-DState .StakeDelegsOf = DState.stakeDelegs\n\n  HasRewards-DState : HasRewards DState\n  HasRewards-DState .RewardsOf = DState.rewards\n\n  HasPools-PState : HasPools PState\n  HasPools-PState .PoolsOf = PState.pools\n\n  HasRetiring-PState : HasRetiring PState\n  HasRetiring-PState .RetiringOf = PState.retiring\n\n  HasDReps-GState : HasDReps GState\n  HasDReps-GState .DRepsOf = GState.dreps\n\n  HasCCHotKeys-GState : HasCCHotKeys GState\n  HasCCHotKeys-GState .CCHotKeysOf = GState.ccHotKeys\n\n  HasDState-CertState : HasDState CertState\n  HasDState-CertState .DStateOf = CertState.dState\n\n  HasPState-CertState : HasPState CertState\n  HasPState-CertState .PStateOf = CertState.pState\n\n  HasGState-CertState : HasGState CertState\n  HasGState-CertState .GStateOf = CertState.gState\n\n  HasRewards-CertState : HasRewards CertState\n  HasRewards-CertState .RewardsOf = RewardsOf \u2218 DStateOf\n\n  HasDReps-CertState : HasDReps CertState\n  HasDReps-CertState .DRepsOf = DRepsOf \u2218 GStateOf\n\n  HasCCHotKeys-CertState : HasCCHotKeys CertState\n  HasCCHotKeys-CertState .CCHotKeysOf = CCHotKeysOf \u2218 GStateOf\n\n  HasPools-CertState : HasPools CertState\n  HasPools-CertState .PoolsOf = PoolsOf \u2218 PStateOf\n\n  HasVoteDelegs-CertState : HasVoteDelegs CertState\n  HasVoteDelegs-CertState .VoteDelegsOf = VoteDelegsOf \u2218 DStateOf\n\n  HasStakeDelegs-CertState : HasStakeDelegs CertState\n  HasStakeDelegs-CertState .StakeDelegsOf = StakeDelegsOf \u2218 DStateOf\n</pre> <pre>rewardsBalance : DState \u2192 Coin\nrewardsBalance ds = \u2211[ x \u2190 RewardsOf ds ] x\n</pre> <pre>instance\n  HasCoin-CertState : HasCoin CertState\n  HasCoin-CertState .getCoin = rewardsBalance \u2218 DStateOf\n\n  unquoteDecl HasCast-CertEnv HasCast-DState HasCast-PState HasCast-GState HasCast-CertState HasCast-DelegEnv = derive-HasCast\n    (   (quote CertEnv , HasCast-CertEnv)\n    \u2237   (quote DState , HasCast-DState)\n    \u2237   (quote PState , HasCast-PState)\n    \u2237   (quote GState , HasCast-GState)\n    \u2237   (quote CertState , HasCast-CertState)\n    \u2237 [ (quote DelegEnv , HasCast-DelegEnv) ])\n\nprivate variable\n  rwds rewards           : Rewards\n  dReps                  : DReps\n  sDelegs stakeDelegs    : StakeDelegs\n  ccKeys ccHotKeys       : CCHotKeys\n  vDelegs voteDelegs     : VoteDelegs\n  pools fPools           : Pools\n  retiring               : Retiring\n  wdrls                  : Withdrawals\n\n  an          : Anchor\n  \u0393           : CertEnv\n  d           : Coin\n  md          : Maybe Coin\n  c           : Credential\n  mc          : Maybe Credential\n  delegatees  : \u2119 Credential\n  dCert       : DCert\n  e           : Epoch\n  vs          : List GovVote\n  kh          : KeyHash\n  mkh         : Maybe KeyHash\n  poolParams  : StakePoolParams\n  pp          : PParams\n  mvd         : Maybe VDeleg\n\n  st\u1d48 st\u1d48' : DState\n  st\u1d4d st\u1d4d' : GState\n  st\u1d56 st\u1d56' : PState\n  cc : \u2119 Credential\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#changes-introduced-in-the-conway-era","title":"Changes Introduced in the Conway Era","text":""},{"location":"Ledger.Conway.Specification.Certs.html#delegation","title":"Delegation","text":"<p>Registered credentials can now delegate to a <code>DRep</code> as well as to a stake pool.  This is achieved by giving the <code>delegate</code> certificate two optional fields, corresponding to a <code>DRep</code> and stake pool.</p> <p>Stake can be delegated for voting and block production simultaneously, since these are two separate features. In fact, preventing this could weaken the security of the chain, since security relies on high participation of honest stake holders.</p>"},{"location":"Ledger.Conway.Specification.Certs.html#removal-of-pointer-addresses-genesis-delegations-and-mir-certificates","title":"Removal of Pointer Addresses, Genesis Delegations and MIR Certificates","text":"<p>Support for pointer addresses, genesis delegations and MIR certificates is removed (see CIP-1694 and CKB+23). In <code>DState</code>, this means that the four fields relating to those features are no longer present, and <code>DelegEnv</code> contains none of the fields it used to in the Shelley era (see CVG19, ).</p> <p>Note that pointer addresses are still usable, only their staking functionality has been retired. So all funds locked behind pointer addresses are still accessible, they just don\u2019t count towards the stake distribution anymore. Genesis delegations and MIR certificates have been superceded by the new governance mechanisms, in particular the <code>TreasuryWithdrawal</code> governance action in case of the MIR certificates.</p>"},{"location":"Ledger.Conway.Specification.Certs.html#explicit-deposits","title":"Explicit Deposits","text":"<p>Registration and deregistration of staking credentials are now required to explicitly state the deposit that is being paid or refunded. This deposit is used for checking correctness of transactions with certificates. Including the deposit aligns better with other design decisions such as having explicit transaction fees and helps make this information visible to light clients and hardware wallets.</p> <p>While not shown in the figures, the old certificates without explicit deposits will still be supported for some time for backwards compatibility.</p>"},{"location":"Ledger.Conway.Specification.Certs.html#governance-certificate-rules","title":"Governance Certificate Rules","text":"<p>The rules for transition systems dealing with individual certificates are defined in Sections Auxiliary <code>DELEG</code> Transition System, Auxiliary <code>POOL</code> transition system, and Auxiliary <code>GOVCERT</code> transition system.</p> <p><code>GOVCERT</code> deals with the new certificates relating to <code>DReps</code> and the constitutional committee.</p> <ul> <li> <p><code>GOVCERT-regdrep</code> registers (or    re-registers) a <code>DRep</code>.  In case of registration,    a deposit needs to be paid.  Either way, the activity period of the    <code>DRep</code> is reset.</p> </li> <li> <p><code>GOVCERT-deregdrep</code> deregisters a    <code>DRep</code>.</p> </li> <li> <p><code>GOVCERT-ccreghot</code> registers a \"hot\"    credential for constitutional committee members.<sup>1</sup> We check that the    cold key did not previously resign from the committee. We allow this    delegation for any cold credential that is either part of    <code>EnactState</code> or a proposal. This allows a newly    elected member of the constitutional committee to immediately delegate    their vote to a hot key and use it to vote. Since votes are counted    after previous actions have been enacted, this allows constitutional    committee members to act without a delay of one epoch.</p> </li> </ul>"},{"location":"Ledger.Conway.Specification.Certs.html#auxiliary-deleg-transition-system","title":"Auxiliary DELEG transition system","text":"<pre>data _\u22a2_\u21c0\u2987_,DELEG\u2988_ : DelegEnv \u2192 DState \u2192 DCert \u2192 DState \u2192 Type where\n\n  DELEG-delegate :\n    \u2219 (c \u2209 dom rwds \u2192 d \u2261 pp .keyDeposit)\n    \u2219 (c \u2208 dom rwds \u2192 d \u2261 0)\n    \u2219 mvd \u2208 map\u02e2 (just \u2218 vDelegCredential) delegatees \u222a\n            fromList ( nothing \u2237 just vDelegAbstain \u2237 just vDelegNoConfidence \u2237 [] )\n    \u2219 mkh \u2208 map\u02e2 just (dom pools) \u222a \u2774 nothing \u2775\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{12598}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7971}{\\htmlId{12603}{\\htmlClass{Generalizable}{\\text{pools}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8235}{\\htmlId{12611}{\\htmlClass{Generalizable}{\\text{delegatees}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7933}{\\htmlId{12628}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7857}{\\htmlId{12638}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7789}{\\htmlId{12648}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\end{pmatrix}$ \u21c0\u2987 delegate c mvd mkh d ,DELEG\u2988 $\\begin{pmatrix} \\,\\href{Axiom.Set.Map.html#9260}{\\htmlId{12689}{\\htmlClass{Function}{\\text{insertIfJust}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8175}{\\htmlId{12702}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8447}{\\htmlId{12704}{\\htmlClass{Generalizable}{\\text{mvd}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#7933}{\\htmlId{12708}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\\\ \\,\\href{Axiom.Set.Map.html#9260}{\\htmlId{12718}{\\htmlClass{Function}{\\text{insertIfJust}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8175}{\\htmlId{12731}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8361}{\\htmlId{12733}{\\htmlClass{Generalizable}{\\text{mkh}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#7857}{\\htmlId{12737}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7789}{\\htmlId{12747}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{12752}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{12755}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8175}{\\htmlId{12757}{\\htmlClass{Generalizable}{\\text{c}}}}\\, , \\,\\htmlId{12761}{\\htmlClass{Number}{\\text{0}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{12763}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\end{pmatrix}$\n\n  DELEG-dereg :\n    \u2219 (c , 0) \u2208 rwds\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{12852}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7971}{\\htmlId{12857}{\\htmlClass{Generalizable}{\\text{pools}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8235}{\\htmlId{12865}{\\htmlClass{Generalizable}{\\text{delegatees}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7933}{\\htmlId{12882}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7857}{\\htmlId{12892}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7789}{\\htmlId{12902}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\end{pmatrix}$ \u21c0\u2987 dereg c md ,DELEG\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7933}{\\htmlId{12933}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{12941}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{12943}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8175}{\\htmlId{12945}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{12947}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{12949}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7857}{\\htmlId{12953}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{12961}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{12963}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8175}{\\htmlId{12965}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{12967}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{12969}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7789}{\\htmlId{12973}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{12978}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{12980}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8175}{\\htmlId{12982}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{12984}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{12986}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\end{pmatrix}$\n\n  DELEG-reg :\n    \u2219 c \u2209 dom rwds\n    \u2219 d \u2261 pp .keyDeposit \u228e d \u2261 0\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{13104}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7971}{\\htmlId{13109}{\\htmlClass{Generalizable}{\\text{pools}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8235}{\\htmlId{13117}{\\htmlClass{Generalizable}{\\text{delegatees}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7933}{\\htmlId{13134}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7857}{\\htmlId{13144}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7789}{\\htmlId{13154}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\end{pmatrix}$ \u21c0\u2987 reg c d ,DELEG\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7933}{\\htmlId{13182}{\\htmlClass{Generalizable}{\\text{vDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7857}{\\htmlId{13192}{\\htmlClass{Generalizable}{\\text{sDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7789}{\\htmlId{13202}{\\htmlClass{Generalizable}{\\text{rwds}}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{13207}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{13210}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8175}{\\htmlId{13212}{\\htmlClass{Generalizable}{\\text{c}}}}\\, , \\,\\htmlId{13216}{\\htmlClass{Number}{\\text{0}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{13218}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\end{pmatrix}$\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#auxiliary-pool-transition-system","title":"Auxiliary POOL transition system","text":"Differences with the Shelley Specification <p>We are deviating in style from the Shelley specification here. In the    Shelley specification (Figure 25), the POOL transition system has three rules.    Here we use a single rule to register and to reregister pools, which is the way    in which the Haskell implementation does it as well.</p> <p>Note, in particular, how the regpool rule only sets the pool parameters of    the current epoch only if the pool is not already registered. And conversely,    the future pool parameters are updated only if the pool is already registered.</p> <pre>isPoolRegistered : Pools -&gt; KeyHash -&gt; Maybe StakePoolParams\nisPoolRegistered ps kh = lookup\u1d50? ps kh\n\ndata _\u22a2_\u21c0\u2987_,POOL\u2988_ : PoolEnv \u2192 PState \u2192 DCert \u2192 PState \u2192 Type where\n\n  POOL-regpool :\n    let\n      fPool' =\n        if isPoolRegistered pools kh\n          then \u2774 kh , poolParams \u2775 \u222a\u02e1 fPools\n          else fPools\n     in\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    pp \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7971}{\\htmlId{14265}{\\htmlClass{Generalizable}{\\text{pools}}}}\\,\n         \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7977}{\\htmlId{14282}{\\htmlClass{Generalizable}{\\text{fPools}}}}\\,\n         \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8004}{\\htmlId{14300}{\\htmlClass{Generalizable}{\\text{retiring}}}}\\,\n         \\end{pmatrix}$ \u21c0\u2987 regpool kh poolParams ,POOL\u2988 $\\begin{pmatrix}\n           \\,\\href{Ledger.Conway.Specification.Certs.html#7971}{\\htmlId{14365}{\\htmlClass{Generalizable}{\\text{pools}}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{14371}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{14374}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8337}{\\htmlId{14376}{\\htmlClass{Generalizable}{\\text{kh}}}}\\, , \\,\\href{Ledger.Conway.Specification.Certs.html#8391}{\\htmlId{14381}{\\htmlClass{Generalizable}{\\text{poolParams}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{14392}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\,\n         \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#14096}{\\htmlId{14405}{\\htmlClass{Bound}{\\text{fPool'}}}}\\,\n         \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8004}{\\htmlId{14423}{\\htmlClass{Generalizable}{\\text{retiring}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{14432}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\,  \\,\\href{Class.HasSingleton.html#288}{\\htmlId{14435}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8337}{\\htmlId{14437}{\\htmlClass{Generalizable}{\\text{kh}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{14440}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{14442}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\n         \\end{pmatrix}$\n\n  POOL-retirepool :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    pp \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7971}{\\htmlId{14524}{\\htmlClass{Generalizable}{\\text{pools}}}}\\,\n         \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7977}{\\htmlId{14541}{\\htmlClass{Generalizable}{\\text{fPools}}}}\\,\n         \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8004}{\\htmlId{14559}{\\htmlClass{Generalizable}{\\text{retiring}}}}\\,\n         \\end{pmatrix}$ \u21c0\u2987 retirepool kh e ,POOL\u2988 $\\begin{pmatrix}\n           \\,\\href{Ledger.Conway.Specification.Certs.html#7971}{\\htmlId{14618}{\\htmlClass{Generalizable}{\\text{pools}}}}\\,\n         \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7977}{\\htmlId{14635}{\\htmlClass{Generalizable}{\\text{fPools}}}}\\,\n         \\\\ \\,\\href{Class.HasSingleton.html#288}{\\htmlId{14653}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8337}{\\htmlId{14655}{\\htmlClass{Generalizable}{\\text{kh}}}}\\, , \\,\\href{Ledger.Conway.Specification.Certs.html#8286}{\\htmlId{14660}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{14662}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{14664}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8004}{\\htmlId{14667}{\\htmlClass{Generalizable}{\\text{retiring}}}}\\,\n         \\end{pmatrix}$\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#auxiliary-govcert-transition-system","title":"Auxiliary GOVCERT transition system","text":"<pre>data _\u22a2_\u21c0\u2987_,GOVCERT\u2988_ : CertEnv \u2192 GState \u2192 DCert \u2192 GState \u2192 Type where\n\n  GOVCERT-regdrep :\n    \u2219 (d \u2261 pp .drepDeposit \u00d7 c \u2209 dom dReps) \u228e (d \u2261 0 \u00d7 c \u2208 dom dReps)\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8286}{\\htmlId{14951}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{14955}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8308}{\\htmlId{14960}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8040}{\\htmlId{14965}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8537}{\\htmlId{14973}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7824}{\\htmlId{14982}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7896}{\\htmlId{14990}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\, \\end{pmatrix}$ \u21c0\u2987 regdrep c d an ,GOVCERT\u2988 $\\begin{pmatrix} \\,\\href{Class.HasSingleton.html#288}{\\htmlId{15029}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8175}{\\htmlId{15031}{\\htmlClass{Generalizable}{\\text{c}}}}\\, , \\,\\href{Ledger.Conway.Specification.Certs.html#8286}{\\htmlId{15035}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{15037}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{15039}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\,\\htmlId{15042}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.PParams.html#7468}{\\htmlId{15043}{\\htmlClass{Field}{\\text{drepActivity}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{15056}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{15058}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#7824}{\\htmlId{15061}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7896}{\\htmlId{15069}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\, \\end{pmatrix}$\n\n  GOVCERT-deregdrep :\n    \u2219 c \u2208 dom dReps\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8286}{\\htmlId{15168}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{15172}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8308}{\\htmlId{15177}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8040}{\\htmlId{15182}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8537}{\\htmlId{15190}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7824}{\\htmlId{15199}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7896}{\\htmlId{15207}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\, \\end{pmatrix}$ \u21c0\u2987 deregdrep c d ,GOVCERT\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7824}{\\htmlId{15245}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{15251}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{15253}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8175}{\\htmlId{15255}{\\htmlClass{Generalizable}{\\text{c}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{15257}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{15259}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7896}{\\htmlId{15263}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\, \\end{pmatrix}$\n\n  GOVCERT-ccreghot :\n    \u2219 (c , nothing) \u2209 ccKeys\n    \u2219 c \u2208 cc\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8286}{\\htmlId{15383}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{15387}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8308}{\\htmlId{15392}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8040}{\\htmlId{15397}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8537}{\\htmlId{15405}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7824}{\\htmlId{15414}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7896}{\\htmlId{15422}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\, \\end{pmatrix}$ \u21c0\u2987 ccreghot c mc ,GOVCERT\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7824}{\\htmlId{15460}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Class.HasSingleton.html#288}{\\htmlId{15468}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8175}{\\htmlId{15470}{\\htmlClass{Generalizable}{\\text{c}}}}\\, , \\,\\href{Ledger.Conway.Specification.Certs.html#8202}{\\htmlId{15474}{\\htmlClass{Generalizable}{\\text{mc}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{15477}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{15479}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#7896}{\\htmlId{15482}{\\htmlClass{Generalizable}{\\text{ccKeys}}}}\\, \\end{pmatrix}$\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#sec:the-certs-transition-system","title":"The CERTS Transition System","text":"<p>This section culminates in the definition of the <code>CERTS</code> transition system by bundling previously defined pieces together into a <code>CERT</code> transition rule which <code>CERTS</code> runs on a sequence of signals, keeping track of the certification state as it progresses.</p>"},{"location":"Ledger.Conway.Specification.Certs.html#the-cert-transition-system","title":"The CERT Transition System","text":"<pre>data _\u22a2_\u21c0\u2987_,CERT\u2988_  : CertEnv \u2192 CertState \u2192 DCert \u2192 CertState \u2192 Type where\n\n  CERT-deleg :\n    \u2219 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{16072}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{16077}{\\htmlClass{Field}{\\text{PState.pools}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8517}{\\htmlId{16090}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{16096}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{16100}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4566}{\\htmlId{16101}{\\htmlClass{Field}{\\text{GState.dreps}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#8497}{\\htmlId{16114}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\,\\,\\htmlId{16117}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$ \u22a2 st\u1d48 \u21c0\u2987 dCert ,DELEG\u2988 st\u1d48'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8286}{\\htmlId{16196}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{16200}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8308}{\\htmlId{16205}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8040}{\\htmlId{16210}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8537}{\\htmlId{16218}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8477}{\\htmlId{16227}{\\htmlClass{Generalizable}{\\text{st\u1d48}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8517}{\\htmlId{16233}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8497}{\\htmlId{16239}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$ \u21c0\u2987 dCert ,CERT\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8481}{\\htmlId{16263}{\\htmlClass{Generalizable}{\\text{st\u1d48'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8517}{\\htmlId{16270}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8497}{\\htmlId{16276}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$\n\n  CERT-pool :\n    \u2219 pp \u22a2 st\u1d56 \u21c0\u2987 dCert ,POOL\u2988 st\u1d56'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8286}{\\htmlId{16380}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{16384}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8308}{\\htmlId{16389}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8040}{\\htmlId{16394}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8537}{\\htmlId{16402}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8477}{\\htmlId{16411}{\\htmlClass{Generalizable}{\\text{st\u1d48}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8517}{\\htmlId{16417}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8497}{\\htmlId{16423}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$ \u21c0\u2987 dCert ,CERT\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8477}{\\htmlId{16447}{\\htmlClass{Generalizable}{\\text{st\u1d48}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8521}{\\htmlId{16453}{\\htmlClass{Generalizable}{\\text{st\u1d56'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8497}{\\htmlId{16460}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$\n\n  CERT-vdel :\n    \u2219 \u0393 \u22a2 st\u1d4d \u21c0\u2987 dCert ,GOVCERT\u2988 st\u1d4d'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8477}{\\htmlId{16570}{\\htmlClass{Generalizable}{\\text{st\u1d48}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8517}{\\htmlId{16576}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8497}{\\htmlId{16582}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$ \u21c0\u2987 dCert ,CERT\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8477}{\\htmlId{16606}{\\htmlClass{Generalizable}{\\text{st\u1d48}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8517}{\\htmlId{16612}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8501}{\\htmlId{16618}{\\htmlClass{Generalizable}{\\text{st\u1d4d'}}}}\\, \\end{pmatrix}$\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#the-pre-cert-transition-rule","title":"The PRE-CERT Transition Rule","text":"<p>Here we define the <code>PRE-CERT</code> transition rule.  This rule is applied at the start of the <code>CERTS</code> transition rule and handles the following important housekeeping tasks:</p> <ul> <li> <p>check the correctness of withdrawals and ensure that withdrawals only    happen from credentials that have delegated their voting power;</p> </li> <li> <p>set the activity timer of all <code>DReps</code> that voted    to <code>drepActivity</code> epochs in the future;</p> </li> <li> <p>set the rewards of the credentials that withdrew funds to zero.</p> </li> </ul> <p>Regarding the second item, if there is a new governance proposal to vote on in this transaction, then expiry for all <code>DReps</code> will be increased by the number of dormant epochs.  However, the <code>PRE-CERT</code> transition occurs in <code>LEDGER</code> before the <code>GOV</code> rule, so it cannot validate any governance proposal.  This is not a problem since the entire transaction will fail if the proposal is not accepted in the <code>GOV</code> rule.</p> <pre>open GovVote using (voter)\n</pre> <pre>data _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ : CertEnv \u2192 CertState \u2192 \u22a4 \u2192 CertState \u2192 Type where\n\n  CERT-pre :\n    let refresh         = mapPartial (isGovVoterDRep \u2218 voter) (fromList vs)\n        refreshedDReps  = mapValueRestricted (const (e + pp .drepActivity)) dReps refresh\n        wdrlCreds       = map\u02e2 stake (dom wdrls)\n    in\n    \u2219 filter isKeyHash wdrlCreds \u2286 dom voteDelegs\n    \u2219 map\u02e2 (map\u2081 stake) (wdrls \u02e2) \u2286 rewards \u02e2\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8286}{\\htmlId{18256}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{18260}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8308}{\\htmlId{18265}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8040}{\\htmlId{18270}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8537}{\\htmlId{18278}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7941}{\\htmlId{18289}{\\htmlClass{Generalizable}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7865}{\\htmlId{18302}{\\htmlClass{Generalizable}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7794}{\\htmlId{18316}{\\htmlClass{Generalizable}{\\text{rewards}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8517}{\\htmlId{18328}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7824}{\\htmlId{18336}{\\htmlClass{Generalizable}{\\text{dReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7903}{\\htmlId{18344}{\\htmlClass{Generalizable}{\\text{ccHotKeys}}}}\\, \\end{pmatrix} \\end{pmatrix}$ \u21c0\u2987 _ ,PRE-CERT\u2988 $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7941}{\\htmlId{18378}{\\htmlClass{Generalizable}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7865}{\\htmlId{18391}{\\htmlClass{Generalizable}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Axiom.Set.Map.html#11986}{\\htmlId{18405}{\\htmlClass{Function}{\\text{constMap}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#18065}{\\htmlId{18414}{\\htmlClass{Bound}{\\text{wdrlCreds}}}}\\, \\,\\htmlId{18424}{\\htmlClass{Number}{\\text{0}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{18426}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#7794}{\\htmlId{18429}{\\htmlClass{Generalizable}{\\text{rewards}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8517}{\\htmlId{18441}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#17975}{\\htmlId{18449}{\\htmlClass{Bound}{\\text{refreshedDReps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7903}{\\htmlId{18466}{\\htmlClass{Generalizable}{\\text{ccHotKeys}}}}\\, \\end{pmatrix} \\end{pmatrix}$\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#the-post-cert-transition-rule","title":"The POST-CERT Transition Rule","text":"<p>The <code>POST-CERT</code> transition rule is applied at the end of the <code>CERTS</code> rule and it ensures that only valid registered <code>DReps</code> are included in the final <code>CertState</code>.</p> <pre>data _\u22a2_\u21c0\u2987_,POST-CERT\u2988_ : CertEnv \u2192 CertState \u2192 \u22a4 \u2192 CertState \u2192 Type where\n\n  CERT-post :\n    let activeVDelegs = map\u02e2 vDelegCredential (dom (DRepsOf st\u1d4d))\n                         \u222a fromList (vDelegNoConfidence \u2237 vDelegAbstain \u2237 [])\n    in\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#8286}{\\htmlId{19045}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8423}{\\htmlId{19049}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8308}{\\htmlId{19054}{\\htmlClass{Generalizable}{\\text{vs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8040}{\\htmlId{19059}{\\htmlClass{Generalizable}{\\text{wdrls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8537}{\\htmlId{19067}{\\htmlClass{Generalizable}{\\text{cc}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7941}{\\htmlId{19078}{\\htmlClass{Generalizable}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7865}{\\htmlId{19091}{\\htmlClass{Generalizable}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7794}{\\htmlId{19105}{\\htmlClass{Generalizable}{\\text{rewards}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8517}{\\htmlId{19117}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8497}{\\htmlId{19123}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$ \u21c0\u2987 _ ,POST-CERT\u2988 $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#7941}{\\htmlId{19150}{\\htmlClass{Generalizable}{\\text{voteDelegs}}}}\\, \\,\\href{Axiom.Set.Map.html#17773}{\\htmlId{19161}{\\htmlClass{Function Operator}{\\text{\u2223\\^{}}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#18894}{\\htmlId{19164}{\\htmlClass{Bound}{\\text{activeVDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7865}{\\htmlId{19180}{\\htmlClass{Generalizable}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#7794}{\\htmlId{19194}{\\htmlClass{Generalizable}{\\text{rewards}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8517}{\\htmlId{19206}{\\htmlClass{Generalizable}{\\text{st\u1d56}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#8497}{\\htmlId{19212}{\\htmlClass{Generalizable}{\\text{st\u1d4d}}}}\\, \\end{pmatrix}$\n\n_\u22a2_\u21c0\u2987_,CERTS\u2988_  : CertEnv \u2192 CertState  \u2192 List DCert  \u2192 CertState  \u2192 Type\n_\u22a2_\u21c0\u2987_,CERTS\u2988_ = RunTraceAfterAndThen _\u22a2_\u21c0\u2987_,PRE-CERT\u2988_ _\u22a2_\u21c0\u2987_,CERT\u2988_ _\u22a2_\u21c0\u2987_,POST-CERT\u2988_\n</pre>"},{"location":"Ledger.Conway.Specification.Certs.html#references","title":"References","text":"<p>[CKB+23]  Jared Corduan and Andre Knispel and Matthias Benkort and Kevin Hammond and Charles Hoskinson and Samuel Leathers. A First Step Towards On-Chain Decentralized Governance. 2023.</p> <p>[CVG19]  Jared Corduan and Polina Vinogradova and Matthias G\u00fcdemann. A Formal Specification of the Cardano Ledger. 2019.</p> <ol> <li> <p>By \"hot\" and \"cold\" credentials we mean the following: a cold credential is used to register a hot credential, and then the hot credential is used for voting. The idea is that the access to the cold credential is kept in a secure location, while the hot credential is more conveniently accessed. If the hot credential is compromised, it can be changed using the cold credential.\u00a0\u21a9</p> </li> </ol>"},{"location":"Ledger.Conway.Specification.Chain.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\nopen import Ledger.Conway.Specification.Abstract using (AbstractFunctions)\n\nmodule Ledger.Conway.Specification.Chain.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\nopen import Ledger.Conway.Specification.BlockBody.Properties.Computational txs abs\nopen import Ledger.Conway.Specification.Chain txs abs\nopen import Ledger.Conway.Specification.Enact govStructure using (EnactState)\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.RewardUpdate txs abs\nopen import Ledger.Conway.Specification.RewardUpdate.Properties.Computational txs abs\nopen import Ledger.Prelude\n\nopen Computational \u2983...\u2984\n\nmodule _\n  (nes : NewEpochState)\n  (open EpochState (NewEpochState.epochState nes) using (ls) renaming (es to es'))\n  (open EnactState es' using (pparams))\n  (open PParams \u2223 pparams \u2223 using (maxRefScriptSizePerBlock))\n  (ts : List Tx)\n  where\n  refScriptSize\u2264?Bound : Dec (totalRefScriptsSize ls ts \u2264 maxRefScriptSizePerBlock)\n  refScriptSize\u2264?Bound = totalRefScriptsSize ls ts \u2264? maxRefScriptSizePerBlock\n\ninstance\n  Computational-CHAIN : Computational _\u22a2_\u21c0\u2987_,CHAIN\u2988_ String\n  Computational-CHAIN .computeProof \u0393 s b = do\n    nes , tickStep \u2190 map\u2081 \u22a5-elim $ computeProof {STS = _\u22a2_\u21c0\u2987_,TICK\u2988_} _ _ _\n    (_ , _) , bbStep \u2190 computeProof _ (LStateOf nes , nes .NewEpochState.bcur) b\n    case refScriptSize\u2264?Bound nes (b .Block.ts) of \u03bb where\n      (no \u00acp) \u2192 failure \"totalRefScriptsSize &gt; maxRefScriptSizePerBlock\"\n      (yes p) \u2192 success (_ , CHAIN (p , tickStep , bbStep))\n\n  Computational-CHAIN .completeness _ s b _ (CHAIN {nes = nes} (p , tickStep , bbStep))\n    with recomputeProof tickStep | completeness _ _ _ _ tickStep\n  ... | success _ | refl\n    with recomputeProof bbStep | completeness _ _ _ _ bbStep\n  ... | success _ | refl\n    with refScriptSize\u2264?Bound nes (Block.ts b)\n  ... | yes p = refl\n  ... | no \u00acp = \u22a5-elim (\u00acp p)\n</pre>"},{"location":"Ledger.Conway.Specification.Chain.Properties.CredDepsEqualDomRwds.html","title":"CredDepsEqualDomRwds","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Chain.Properties.CredDepsEqualDomRwds\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs)\n  where\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Chain txs abs\nopen import Ledger.Prelude hiding (map) renaming (map\u02e2 to map; filter\u02e2 to filter)\nopen import Ledger.Conway.Specification.Properties txs abs\n</pre> <p>Claim (Equality of credential depsoits is a <code>CHAIN</code> invariant).</p> <p>Informally.</p> <p>This property concerns two quantities associated with a given <code>ChainState</code> <code>cs</code>,</p> <ul> <li> <p>the credential deposits of the <code>UTxOState</code> of <code>cs</code> and</p> </li> <li> <p>the credential deposits of the rewards in the ledger state of <code>cs</code>.</p> </li> </ul> <p>The predicate <code>credDeposits\u2261dom-rwds</code> <code>cs</code> asserts that these quantities are equal for <code>cs</code>.</p> <p>The property <code>credDeposits\u2261dom-rwds-inv</code> asserts that <code>credDeposits\u2261dom-rwds</code> is a chain invariant. That is, if <code>cs</code> and <code>cs'</code> are two <code>ChainStates</code> such that <code>cs</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,CHAIN\u2988</code> <code>cs'</code>, then <code>credDeposits\u2261dom-rwds</code> <code>cs</code> only if <code>credDeposits\u2261dom-rwds</code> <code>cs'</code>.</p> <p>Formally.</p> <pre>credDeposits\u2261dom-rwds : ChainState \u2192 Type\ncredDeposits\u2261dom-rwds cs =  filter isCredDeposit (dom (DepositsOf cs))\n                            \u2261 map CredentialDeposit (dom (RewardsOf cs))\n\ncredDeposits\u2261dom-rwds-inv : Type\ncredDeposits\u2261dom-rwds-inv = LedgerInvariant _\u22a2_\u21c0\u2987_,CHAIN\u2988_ credDeposits\u2261dom-rwds\n</pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Chain.Properties.EpochStep.html","title":"EpochStep","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Chain.Properties.EpochStep\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs)\n  where\n\nopen import Ledger.Conway.Specification.Chain txs abs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Prelude\nopen Block\n</pre> <p>Claim (New enact state only if new epoch).</p> <p>Informally.</p> <p>Let <code>cs</code> and <code>cs'</code> be <code>ChainStates</code> and <code>b</code> a <code>Block</code>. If <code>cs</code> <code>\u21c0\u2987</code> <code>b</code> <code>,CHAIN\u2988</code> <code>cs'</code> and if the enact states of <code>cs</code> and <code>cs'</code> differ, then the epoch of the slot of <code>b</code> is the successor of the last epoch of <code>cs</code>.</p> <p>Formally.</p> <pre>enact-change\u21d2newEpoch : (b : Block) {cs cs'  : ChainState}\n  \u2192 _ \u22a2 cs \u21c0\u2987 b ,CHAIN\u2988 cs' \u2192 EnactStateOf cs \u2262 EnactStateOf cs'\n  \u2192 Type\n\nenact-change\u21d2newEpoch b {cs} h es\u2262es' =\n  epoch (b .bheader .bhbody .slot) \u2261 suc\u1d49 (LastEpochOf cs)\n  where\n    open Block\n    open BHeader\n    open BHBody\n</pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Chain.Properties.GovDepsMatch.html","title":"GovDepsMatch","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Chain.Properties.GovDepsMatch\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Chain txs abs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Epoch.Properties.GovDepsMatch txs abs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.Ledger.Properties.Base txs abs\nopen import Ledger.Conway.Specification.Ledger.Properties.GovDepsMatch txs abs\nopen import Ledger.Prelude hiding (map) renaming (map\u02e2 to map)\nopen import Ledger.Conway.Specification.RewardUpdate txs abs\n\nmodule _\n  {b   : Block }\n  {nes : NewEpochState}\n  {cs  : ChainState}\n  where\n  open Block b; open ChainState cs\n  open NewEpochState\n  open EPOCH-Body (EpochStateOf cs) renaming (epsLState to csLState)\n  open EnactState ens using (pparams)\n  pp = pparams .proj\u2081\n  open PParams pp using (maxRefScriptSizePerBlock)\n</pre> <p> Theorem (<code>govDepsMatch</code> is invariant of <code>CHAIN</code> rule).</p> <p>Informally.</p> <p>Fix a <code>Block</code> <code>b</code>, a <code>ChainState</code> <code>cs</code>, and a <code>NewEpochState</code> <code>nes</code>. Let <code>csLState</code> be the ledger state of <code>cs</code>. Recall, a <code>ChainState</code> has just one field, <code>newEpochState</code> : <code>NewEpochState</code>. Consider the chain state <code>cs'</code> defined as follows:</p> <pre>  cs' : ChainState\n  cs' .newEpochState =\n    record nes {epochState  = record (EpochStateOf cs) {ls = LStateOf nes}}\n</pre> <p>That is <code>cs'</code> is essentially <code>nes</code>, but the <code>EpochState</code> field is set to the <code>epochState</code> of <code>cs</code> with the exception of the <code>LState</code> field, which is set to that of <code>nes</code>. Let <code>utxoSt</code> and <code>utxoSt'</code> be the respective <code>UTxOStates</code> of the ledger states of <code>cs</code> and <code>cs'</code>, respectively, and let <code>govSt</code> and <code>govSt'</code> be their respective <code>GovStates</code>. Assume the following conditions hold:</p> <ul> <li> <p>Let <code>removed'</code> : <code>\u2119</code>(<code>GovActionID</code> \u00d7 <code>GovActionState</code>) be the union of</p> <ul> <li> <p>the governance actions in the <code>removed</code> field of the ratify state of <code>eps</code>, and</p> </li> <li> <p>the orphaned governance actions in the <code>GovState</code> of <code>eps</code>.</p> </li> </ul> <p>Let \\(\\mathcal{G}\\) be the set \\(\\{\\)<code>GovActionDeposit</code> <code>id</code> : <code>id</code> \u2208 <code>proj\u2081</code> <code>removed'</code>\\(\\}\\).</p> <p>\\(\\mathcal{G}\\) is a subset of the set of deposits of the chain state <code>cs</code>; that is,</p> <p><code>map</code> (<code>GovActionDeposit</code> \\(\u2218\\) <code>proj\u2081</code>) <code>removed'</code> \u2286 <code>dom</code> (<code>DepositsOf</code> <code>cs</code>).</p> </li> <li> <p>The total reference script size of <code>csLState</code> is not    greater than the maximum allowed size per block (as specified in <code>PParams</code>).</p> </li> <li> <p><code>cs</code> <code>\u21c0\u2987</code> <code>b</code> <code>,CHAIN\u2988</code> <code>cs'</code>.</p> </li> </ul> <p>Under these conditions, if the governance action deposits of <code>utxoSt</code> equal those of <code>govSt</code>, then the same holds for <code>utxoSt'</code> and <code>govSt'</code>. In other terms,</p> <p><code>govDepsMatch</code> <code>csLState</code> implies <code>govDepsMatch</code> <code>nesState</code>.</p> <p>Formally.</p> <pre>  CHAIN-govDepsMatch :\n    map (GovActionDeposit \u2218 proj\u2081) removed' \u2286 dom (DepositsOf cs)\n    \u2192  totalRefScriptsSize csLState ts \u2264 maxRefScriptSizePerBlock\n    \u2192  _ \u22a2 cs \u21c0\u2987 b ,CHAIN\u2988 cs'\n    \u2192  govDepsMatch csLState \u2192 govDepsMatch (LStateOf nes)\n</pre> <p>Proof.</p> <pre>  CHAIN-govDepsMatch rrm rss\n      ( CHAIN ( x\n              , TICK ((NEWEPOCH-New (_ , eps\u2081\u2192eps\u2082)) , _)\n              , BBODY-Block-Body (_ , _ , ledgers)\n              )\n      ) =\n    RTC-preserves-inv LEDGER-govDepsMatch ledgers\n     \u2218 EPOCH-PROPS.EPOCH-govDepsMatch rrm eps\u2081\u2192eps\u2082\n\n  CHAIN-govDepsMatch rrm rss\n      ( CHAIN ( x\n              , TICK (NEWEPOCH-Not-New _ , _)\n              , BBODY-Block-Body (_ , _ , ledgers)\n              )\n      ) =\n    RTC-preserves-inv LEDGER-govDepsMatch ledgers\n\n  CHAIN-govDepsMatch rrm rss\n      ( CHAIN ( x\n              , TICK (NEWEPOCH-No-Reward-Update (_ , eps\u2081\u2192eps\u2082) , _)\n              , BBODY-Block-Body (_ , _ , ledgers)\n              )\n      ) =\n    RTC-preserves-inv LEDGER-govDepsMatch ledgers\n     \u2218 EPOCH-PROPS.EPOCH-govDepsMatch rrm eps\u2081\u2192eps\u2082\n</pre>"},{"location":"Ledger.Conway.Specification.Chain.Properties.PParamsWellFormed.html","title":"PParamsWellFormed","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Chain.Properties.PParamsWellFormed\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs)\n  where\n\nopen import Ledger.Conway.Specification.Chain txs abs\nopen import Ledger.Prelude\n</pre> <p>Claim (Well-formedness of <code>PParams</code> is a <code>CHAIN</code> invariant).</p> <p>Informally.</p> <p>We say the <code>PParams</code> of a chain state are well-formed if each of the following parameters is non-zero: <code>maxBlockSize</code>, <code>maxTxSize</code>, <code>maxHeaderSize</code>, <code>maxValSize</code>, <code>refScriptCostStride</code>, <code>coinsPerUTxOByte</code>, <code>poolDeposit</code>, <code>collateralPercentage</code>, <code>ccMaxTermLength</code>, <code>govActionLifetime</code>, <code>govActionDeposit</code>, <code>drepDeposit</code>.</p> <p>We claim that <code>pp-wellFormed</code> is a chain invariant. That is, if <code>cs</code> and <code>cs'</code> are chain states such that <code>cs</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,CHAIN\u2988</code> <code>cs'</code>, and if the <code>PParams</code> of <code>cs</code> are well-formed, then so are the <code>PParams</code> of <code>cs'</code> .</p> <p>Formally.</p> <pre>pp-wellFormed : ChainState \u2192 Type\npp-wellFormed = paramsWellFormed \u2218 PParamsOf\n\npp-wellFormed-invariant : Type\npp-wellFormed-invariant = LedgerInvariant _\u22a2_\u21c0\u2987_,CHAIN\u2988_ pp-wellFormed\n</pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Chain.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Chain.Properties where\n\nopen import Ledger.Conway.Specification.Chain.Properties.Computational\nopen import Ledger.Conway.Specification.Chain.Properties.CredDepsEqualDomRwds\nopen import Ledger.Conway.Specification.Chain.Properties.EpochStep\nopen import Ledger.Conway.Specification.Chain.Properties.GovDepsMatch\nopen import Ledger.Conway.Specification.Chain.Properties.PParamsWellFormed\n</pre>"},{"location":"Ledger.Conway.Specification.Chain.html","title":"Blockchain Layer","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Chain\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.BlockBody txs abs public\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Prelude; open Equivalence\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Specification.RewardUpdate txs abs\nopen import Ledger.Conway.Specification.Utxo txs abs\n\nopen import Algebra\nopen import Data.Nat.Properties using (+-0-monoid)\n</pre>"},{"location":"Ledger.Conway.Specification.Chain.html#sec:definition-of-chainstate","title":"Definition of ChainState","text":"<pre>record ChainState : Type where\n  field\n    newEpochState  : NewEpochState\n</pre> <pre>instance\n  HasNewEpochState-ChainState : HasNewEpochState ChainState\n  HasNewEpochState-ChainState .NewEpochStateOf = ChainState.newEpochState\n\n  HasLastEpoch-ChainState : HasLastEpoch ChainState\n  HasLastEpoch-ChainState .LastEpochOf = LastEpochOf \u2218 NewEpochStateOf\n\n  HasEpochState-ChainState : HasEpochState ChainState\n  HasEpochState-ChainState .EpochStateOf = EpochStateOf \u2218 NewEpochStateOf\n\n  HasEnactState-ChainState : HasEnactState ChainState\n  HasEnactState-ChainState .EnactStateOf = EnactStateOf \u2218 EpochStateOf\n\n  HasLState-ChainState : HasLState ChainState\n  HasLState-ChainState .LStateOf = LStateOf \u2218 EpochStateOf\n\n  HasUTxOState-ChainState : HasUTxOState ChainState\n  HasUTxOState-ChainState .UTxOStateOf = UTxOStateOf \u2218 LStateOf\n\n  HasCertState-ChainState : HasCertState ChainState\n  HasCertState-ChainState .CertStateOf = CertStateOf \u2218 LStateOf\n\n  HasDeposits-ChainState : HasDeposits ChainState\n  HasDeposits-ChainState .DepositsOf = DepositsOf \u2218 UTxOStateOf\n\n  HasRewards-ChainState : HasRewards ChainState\n  HasRewards-ChainState .RewardsOf = RewardsOf \u2218 CertStateOf\n\n  HasPParams-ChainState : HasPParams ChainState\n  HasPParams-ChainState .PParamsOf = PParamsOf \u2218 EnactStateOf\n\ntotalRefScriptsSize : LState \u2192 List Tx \u2192 \u2115\ntotalRefScriptsSize lst txs = sum $ map (refScriptsSize utxo) txs\n  where open UTxOState (LState.utxoSt lst)\n\nprivate variable\n  ls' : LState\n</pre>"},{"location":"Ledger.Conway.Specification.Chain.html#sec:the-chain-transition-system","title":"The CHAIN Transition System","text":"<pre>data _\u22a2_\u21c0\u2987_,CHAIN\u2988_ : \u22a4 \u2192 ChainState \u2192 Block \u2192 ChainState \u2192 Type where\n\n  CHAIN : \u2200 {bcur'} {b : Block} {nes : NewEpochState} {cs : ChainState}\n</pre> <pre>    \u2192 let open ChainState cs; open Block b; open BHeader bheader\n          open BHBody bhbody; open NewEpochState nes\n          open EpochState epochState; open EnactState es renaming (pparams to pp)\n          open PParams \u2223 pp \u2223 using (maxRefScriptSizePerBlock) in\n</pre> <pre>    let  cs'  = record cs {  newEpochState\n                             = record nes {  bcur = bcur';\n                                             epochState\n                                             = record epochState {ls = ls'} } }\n    in\n    \u2219 totalRefScriptsSize ls ts \u2264 maxRefScriptSizePerBlock\n    \u2219 tt \u22a2 newEpochState \u21c0\u2987 slot ,TICK\u2988 nes\n    \u2219 (es , acnt) \u22a2 (ls , bcur) \u21c0\u2987 b ,BBODY\u2988 (ls' , bcur')\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 cs \u21c0\u2987 b ,CHAIN\u2988 cs'\n</pre>"},{"location":"Ledger.Conway.Specification.Enact.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Gov.Base\n\nmodule Ledger.Conway.Specification.Enact.Properties.Computational (gs : _) (open GovStructure gs) where\n\nopen import Ledger.Prelude\n\nopen import Ledger.Conway.Specification.Gov.Actions gs hiding (yes; no)\nopen import Ledger.Conway.Specification.Enact gs\n\nopen EnactState\n\nopen Computational \u2983...\u2984\n\nmodule _ {\u0393 : EnactEnv} {eSt : EnactState} {ga : GovAction} where\n\n  -- TODO: Make this follow from computationalness or viceversa\n  ENACT-deterministic : \u2200 {eSt' eSt''}\n                      \u2192 \u0393 \u22a2 eSt \u21c0\u2987 ga ,ENACT\u2988 eSt'\n                      \u2192 \u0393 \u22a2 eSt \u21c0\u2987 ga ,ENACT\u2988 eSt''\n                      \u2192 eSt' \u2261 eSt''\n  ENACT-deterministic Enact-NoConf Enact-NoConf = refl\n  ENACT-deterministic (Enact-UpdComm _) (Enact-UpdComm _) = refl\n  ENACT-deterministic Enact-NewConst Enact-NewConst = refl\n  ENACT-deterministic Enact-HF Enact-HF = refl\n  ENACT-deterministic Enact-PParams Enact-PParams = refl\n  ENACT-deterministic (Enact-Wdrl _) (Enact-Wdrl _) = refl\n  ENACT-deterministic Enact-Info Enact-Info = refl\n\ninstance\n  Computational-ENACT : Computational _\u22a2_\u21c0\u2987_,ENACT\u2988_ String\n  Computational-ENACT .computeProof \u0393\u1d49 s =\n    let open EnactEnv \u0393\u1d49 renaming (treasury to t; epoch to e) in\n    \u03bb where\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2446}{\\htmlId{1396}{\\htmlClass{InductiveConstructor}{\\text{NoConfidence}}}}\\,        \\\\ \\,\\htmlId{1418}{\\htmlClass{Symbol}{\\text{\\_}}}\\,               \\end{pmatrix}$ \u2192 success (_ , Enact-NoConf)\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{1473}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\,     \\\\ \\,\\htmlId{1495}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Enact.Properties.Computational.html#1496}{\\htmlId{1496}{\\htmlClass{Bound}{\\text{new}}}}\\, , \\,\\href{Ledger.Conway.Specification.Enact.Properties.Computational.html#1502}{\\htmlId{1502}{\\htmlClass{Bound}{\\text{rem}}}}\\, , \\,\\href{Ledger.Conway.Specification.Enact.Properties.Computational.html#1508}{\\htmlId{1508}{\\htmlClass{Bound}{\\text{q}}}}\\,\\,\\htmlId{1509}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$ \u2192\n      case \u00bf \u2200[ term \u2208 range new ]\n               term \u2264 CCMaxTermLengthOf s +\u1d49' e \u00bf of \u03bb where\n      (yes p) \u2192 success (-, Enact-UpdComm\n        (subst (\u03bb x \u2192 \u2200[ term \u2208 range new ] term \u2264 x) (sym +\u1d49\u2261+\u1d49') p))\n      (no \u00acp) \u2192 failure \"ENACT failed at \u2200[ term \u2208 range new ] term \u2264 (CCMaxTermLengthOf s +\u1d49 e)\"\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2522}{\\htmlId{1830}{\\htmlClass{InductiveConstructor}{\\text{NewConstitution}}}}\\,     \\\\ \\,\\htmlId{1852}{\\htmlClass{Symbol}{\\text{\\_}}}\\,               \\end{pmatrix}$ \u2192 success (-, Enact-NewConst)\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{1908}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\,     \\\\ \\,\\htmlId{1930}{\\htmlClass{Symbol}{\\text{\\_}}}\\,               \\end{pmatrix}$ \u2192 success (-, Enact-HF)\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{1980}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\,       \\\\ \\,\\htmlId{2002}{\\htmlClass{Symbol}{\\text{\\_}}}\\,               \\end{pmatrix}$ \u2192 success (-, Enact-PParams)\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2674}{\\htmlId{2057}{\\htmlClass{InductiveConstructor}{\\text{Info}}}}\\,                \\\\ \\,\\htmlId{2079}{\\htmlClass{Symbol}{\\text{\\_}}}\\,               \\end{pmatrix}$ \u2192 success (-, Enact-Info)\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{2131}{\\htmlClass{InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Enact.Properties.Computational.html#2153}{\\htmlId{2153}{\\htmlClass{Bound}{\\text{wdrl}}}}\\,            \\end{pmatrix}$ \u2192\n      case \u00bf \u2211[ x \u2190 s .withdrawals \u222a\u207a wdrl ] x \u2264 t \u00bf of \u03bb where\n        (yes p)  \u2192 success (-, Enact-Wdrl p)\n        (no _)   \u2192 failure \"ENACT failed at \u2211[ x \u2190 (s .withdrawals \u222a\u207a wdrl) \u1da0\u1d50 ] x \u2264 t\"\n  Computational-ENACT .completeness \u0393\u1d49 s action _ p\n    with action | p\n  ... | $\\begin{pmatrix} \\,\\htmlId{2454}{\\htmlClass{DottedPattern Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2446}{\\htmlId{2455}{\\htmlClass{DottedPattern InductiveConstructor}{\\text{NoConfidence}}}}\\,        \\\\ \\,\\htmlId{2477}{\\htmlClass{Symbol}{\\text{\\_}}}\\,               \\end{pmatrix}$ | Enact-NoConf   = refl\n  ... | $\\begin{pmatrix} \\,\\htmlId{2531}{\\htmlClass{DottedPattern Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{2532}{\\htmlClass{DottedPattern InductiveConstructor}{\\text{UpdateCommittee}}}}\\,     \\\\ \\,\\htmlId{2554}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Enact.Properties.Computational.html#2555}{\\htmlId{2555}{\\htmlClass{Bound}{\\text{new}}}}\\, , \\,\\href{Ledger.Conway.Specification.Enact.Properties.Computational.html#2561}{\\htmlId{2561}{\\htmlClass{Bound}{\\text{rem}}}}\\, , \\,\\href{Ledger.Conway.Specification.Enact.Properties.Computational.html#2567}{\\htmlId{2567}{\\htmlClass{Bound}{\\text{q}}}}\\,\\,\\htmlId{2568}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$ | Enact-UpdComm p\n    rewrite dec-yes\n      (\u00bf \u2200[ term \u2208 range new ] term\n           \u2264 CCMaxTermLengthOf s +\u1d49' EnactEnv.epoch \u0393\u1d49 \u00bf)\n      (subst (\u03bb x \u2192 \u2200[ term \u2208 range new ] term \u2264 x) +\u1d49\u2261+\u1d49' p) .proj\u2082\n      = refl\n  ... | $\\begin{pmatrix} \\,\\htmlId{2798}{\\htmlClass{DottedPattern Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2522}{\\htmlId{2799}{\\htmlClass{DottedPattern InductiveConstructor}{\\text{NewConstitution}}}}\\,     \\\\ \\,\\htmlId{2821}{\\htmlClass{Symbol}{\\text{\\_}}}\\,               \\end{pmatrix}$ | Enact-NewConst = refl\n  ... | $\\begin{pmatrix} \\,\\htmlId{2875}{\\htmlClass{DottedPattern Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{2876}{\\htmlClass{DottedPattern InductiveConstructor}{\\text{TriggerHardFork}}}}\\,     \\\\ \\,\\htmlId{2898}{\\htmlClass{Symbol}{\\text{\\_}}}\\,               \\end{pmatrix}$ | Enact-HF       = refl\n  ... | $\\begin{pmatrix} \\,\\htmlId{2952}{\\htmlClass{DottedPattern Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{2953}{\\htmlClass{DottedPattern InductiveConstructor}{\\text{ChangePParams}}}}\\,       \\\\ \\,\\htmlId{2975}{\\htmlClass{Symbol}{\\text{\\_}}}\\,               \\end{pmatrix}$ | Enact-PParams  = refl\n  ... | $\\begin{pmatrix} \\,\\htmlId{3029}{\\htmlClass{DottedPattern Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2674}{\\htmlId{3030}{\\htmlClass{DottedPattern InductiveConstructor}{\\text{Info}}}}\\,                \\\\ \\,\\htmlId{3052}{\\htmlClass{Symbol}{\\text{\\_}}}\\,               \\end{pmatrix}$ | Enact-Info     = refl\n  ... | $\\begin{pmatrix} \\,\\htmlId{3106}{\\htmlClass{DottedPattern Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{3107}{\\htmlClass{DottedPattern InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Enact.Properties.Computational.html#3129}{\\htmlId{3129}{\\htmlClass{Bound}{\\text{wdrl}}}}\\,            \\end{pmatrix}$ | Enact-Wdrl p\n    rewrite dec-yes (\u00bf \u2211[ x \u2190 s .withdrawals \u222a\u207a wdrl ] x \u2264 EnactEnv.treasury \u0393\u1d49 \u00bf) p .proj\u2082\n    = refl\n</pre>"},{"location":"Ledger.Conway.Specification.Enact.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Enact.Properties where\n\nopen import Ledger.Conway.Specification.Enact.Properties.Computational\n</pre>"},{"location":"Ledger.Conway.Specification.Enact.html","title":"Enactment","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Data.Nat.Properties using (+-0-monoid)\nopen import Data.Rational using (\u211a)\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Gov.Base\n\nmodule Ledger.Conway.Specification.Enact (gs : _) (open GovStructure gs) where\n\nopen import Ledger.Conway.Specification.Gov.Actions gs\n</pre>"},{"location":"Ledger.Conway.Specification.Enact.html#sec:auxiliary-types-and-functions","title":"Auxiliary Types and Functions","text":"<p>This section contains some definitions required to define the <code>ENACT</code> transition system.  <code>EnactEnv</code> is the environment and <code>EnactState</code> the state of <code>ENACT</code>, which enacts a governance action.  All governance actions except <code>TreasuryWithdrawal</code> and <code>Info</code> modify <code>EnactState</code> permanently, which of course can have further consequences. <code>TreasuryWithdrawal</code> accumulates withdrawal temporarily in the <code>withdrawals</code> field of <code>EnactState</code>, but this information is applied and reset in <code>EPOCH</code> (see EPOCH Transition System). Also, enacting these governance actions is the only way of modifying <code>EnactState</code>.</p> <p>Note that all other fields of <code>EnactState</code> also contain a <code>GovActionID</code> since they are <code>HashProtected</code>.</p> <pre>record EnactEnv : Type where\n  field\n    gid       : GovActionID\n    treasury  : Treasury\n    epoch     : Epoch\n\nrecord EnactState : Type where\n  field\n    cc            : HashProtected (Maybe ((Credential \u21c0 Epoch) \u00d7 \u211a))\n    constitution  : HashProtected (DocHash \u00d7 Maybe ScriptHash)\n    pv            : HashProtected ProtVer\n    pparams       : HashProtected PParams\n    withdrawals   : Withdrawals\n</pre> <pre>record HasEnactState {a} (A : Type a) : Type a where\n  field EnactStateOf : A \u2192 EnactState\nopen HasEnactState \u2983...\u2984 public\n\ninstance\n  HasPParams-EnactState : HasPParams EnactState\n  HasPParams-EnactState .PParamsOf = proj\u2081 \u2218 EnactState.pparams\n\n  HasccMaxTermLength-EnactState : HasCCMaxTermLength EnactState\n  HasccMaxTermLength-EnactState .CCMaxTermLengthOf = PParams.ccMaxTermLength \u2218 PParamsOf\n\n  HasWithdrawals-EnactState : HasWithdrawals EnactState\n  HasWithdrawals-EnactState .WithdrawalsOf = EnactState.withdrawals\n\n  unquoteDecl HasCast-EnactEnv = derive-HasCast\n    [ (quote EnactEnv , HasCast-EnactEnv) ]\n\nopen EnactState\n</pre> <pre>ccCreds : HashProtected (Maybe ((Credential \u21c0 Epoch) \u00d7 \u211a)) \u2192 \u2119 Credential\nccCreds (just x   , _)  = dom (x .proj\u2081)\nccCreds (nothing  , _)  = \u2205\n\ngetHash : \u2200 {a} \u2192 NeedsHash a \u2192 Maybe GovActionID\ngetHash {NoConfidence}        h = just h\ngetHash {UpdateCommittee}     h = just h\ngetHash {NewConstitution}     h = just h\ngetHash {TriggerHardFork}     h = just h\ngetHash {ChangePParams}       h = just h\ngetHash {TreasuryWithdrawal}  _ = nothing\ngetHash {Info}                _ = nothing\n\ngetHashES : EnactState \u2192 GovActionType \u2192 Maybe GovActionID\ngetHashES es NoConfidence          = just (es .cc .proj\u2082)\ngetHashES es (UpdateCommittee)     = just (es .cc .proj\u2082)\ngetHashES es (NewConstitution)     = just (es .constitution .proj\u2082)\ngetHashES es (TriggerHardFork)     = just (es .pv .proj\u2082)\ngetHashES es (ChangePParams)       = just (es .pparams .proj\u2082)\ngetHashES es (TreasuryWithdrawal)  = nothing\ngetHashES es Info                  = nothing\n</pre> <p>Type of the ENACT transition system</p> <pre>data _\u22a2_\u21c0\u2987_,ENACT\u2988_ : EnactEnv \u2192 EnactState \u2192 GovAction \u2192 EnactState \u2192 Type\n</pre> <pre>private variable\n  s : EnactState\n  up : PParamsUpdate\n  new : Credential \u21c0 Epoch\n  rem : \u2119 Credential\n  q : \u211a\n  dh : DocHash\n  sh : Maybe ScriptHash\n  v : ProtVer\n  wdrl : Withdrawals\n  t : Treasury\n  gid : GovActionID\n  e : Epoch\n\ninstance\n  _ = +-0-monoid\n</pre>"},{"location":"Ledger.Conway.Specification.Enact.html#sec:the-enact-transition-system","title":"The ENACT Transition System","text":"<p>This section defines the rules of the <code>ENACT</code> transition system. Usually no preconditions are checked and the state is simply updated (including the <code>GovActionID</code> for the hash protection scheme, if required).  The exceptions are <code>UpdateCommittee</code> and <code>TreasuryWithdrawal</code>:</p> <ul> <li> <p><code>UpdateCommittee</code> requires that maximum   terms are respected, and</p> </li> <li> <p><code>TreasuryWithdrawal</code> requires that the   treasury is able to cover the sum of all withdrawals (old and new).</p> </li> </ul> <pre>open PParams using (ccMaxTermLength)\nopen EnactState using (cc)\ndata _\u22a2_\u21c0\u2987_,ENACT\u2988_ where\n</pre> <pre>  Enact-NoConf :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Enact.html#3869}{\\htmlId{4818}{\\htmlClass{Generalizable}{\\text{gid}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3854}{\\htmlId{4824}{\\htmlClass{Generalizable}{\\text{t}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3889}{\\htmlId{4828}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\end{pmatrix}$ \u22a2 s \u21c0\u2987 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2446}{\\htmlId{4841}{\\htmlClass{InductiveConstructor}{\\text{NoConfidence}}}}\\, \\\\ \\,\\htmlId{4856}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$ ,ENACT\u2988 record s { cc = nothing , gid }\n\n  Enact-UpdComm : let old      = maybe proj\u2081 \u2205 (s .cc .proj\u2081)\n                      maxTerm  = CCMaxTermLengthOf s +\u1d49 e\n                  in\n    \u2200[ term \u2208 range new ] term \u2264 maxTerm\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Enact.html#3869}{\\htmlId{5135}{\\htmlClass{Generalizable}{\\text{gid}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3854}{\\htmlId{5141}{\\htmlClass{Generalizable}{\\text{t}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3889}{\\htmlId{5145}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\end{pmatrix}$ \u22a2 s \u21c0\u2987 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{5158}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\, \\\\ \\,\\htmlId{5176}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Enact.html#3724}{\\htmlId{5177}{\\htmlClass{Generalizable}{\\text{new}}}}\\, , \\,\\href{Ledger.Conway.Specification.Enact.html#3751}{\\htmlId{5183}{\\htmlClass{Generalizable}{\\text{rem}}}}\\, , \\,\\href{Ledger.Conway.Specification.Enact.html#3772}{\\htmlId{5189}{\\htmlClass{Generalizable}{\\text{q}}}}\\,\\,\\htmlId{5190}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$ ,ENACT\u2988\n      record s { cc = just ((new \u222a\u02e1 old) \u2223 rem \u1d9c , q) , gid }\n\n  Enact-NewConst :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Enact.html#3869}{\\htmlId{5336}{\\htmlClass{Generalizable}{\\text{gid}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3854}{\\htmlId{5342}{\\htmlClass{Generalizable}{\\text{t}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3889}{\\htmlId{5346}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\end{pmatrix}$ \u22a2 s \u21c0\u2987 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2522}{\\htmlId{5359}{\\htmlClass{InductiveConstructor}{\\text{NewConstitution}}}}\\, \\\\ \\,\\htmlId{5377}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Enact.html#3780}{\\htmlId{5378}{\\htmlClass{Generalizable}{\\text{dh}}}}\\, , \\,\\href{Ledger.Conway.Specification.Enact.html#3795}{\\htmlId{5383}{\\htmlClass{Generalizable}{\\text{sh}}}}\\,\\,\\htmlId{5385}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$ ,ENACT\u2988 record s { constitution = (dh , sh) , gid }\n\n  Enact-HF :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Enact.html#3869}{\\htmlId{5507}{\\htmlClass{Generalizable}{\\text{gid}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3854}{\\htmlId{5513}{\\htmlClass{Generalizable}{\\text{t}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3889}{\\htmlId{5517}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\end{pmatrix}$ \u22a2 s \u21c0\u2987 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{5530}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3819}{\\htmlId{5548}{\\htmlClass{Generalizable}{\\text{v}}}}\\, \\end{pmatrix}$ ,ENACT\u2988 record s { pv = v , gid }\n\n  Enact-PParams :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Enact.html#3869}{\\htmlId{5657}{\\htmlClass{Generalizable}{\\text{gid}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3854}{\\htmlId{5663}{\\htmlClass{Generalizable}{\\text{t}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3889}{\\htmlId{5667}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\end{pmatrix}$ \u22a2 s \u21c0\u2987 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{5680}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3703}{\\htmlId{5696}{\\htmlClass{Generalizable}{\\text{up}}}}\\, \\end{pmatrix}$ ,ENACT\u2988\n      record s { pparams = applyUpdate (PParamsOf s) up , gid }\n\n  Enact-Wdrl : let newWdrls = s .withdrawals \u222a\u207a wdrl in\n    \u2211[ x \u2190 newWdrls ] x \u2264 t\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Enact.html#3869}{\\htmlId{5910}{\\htmlClass{Generalizable}{\\text{gid}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3854}{\\htmlId{5916}{\\htmlClass{Generalizable}{\\text{t}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3889}{\\htmlId{5920}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\end{pmatrix}$ \u22a2 s \u21c0\u2987 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{5933}{\\htmlClass{InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3833}{\\htmlId{5954}{\\htmlClass{Generalizable}{\\text{wdrl}}}}\\, \\end{pmatrix}$ ,ENACT\u2988 record s { withdrawals = newWdrls }\n\n  Enact-Info :\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Enact.html#3869}{\\htmlId{6073}{\\htmlClass{Generalizable}{\\text{gid}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3854}{\\htmlId{6079}{\\htmlClass{Generalizable}{\\text{t}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#3889}{\\htmlId{6083}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\end{pmatrix}$ \u22a2 s \u21c0\u2987 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2674}{\\htmlId{6096}{\\htmlClass{InductiveConstructor}{\\text{Info}}}}\\, \\\\ \\,\\htmlId{6103}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$ ,ENACT\u2988 s\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Epoch.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Agda.Builtin.FromNat\nimport Relation.Binary.PropositionalEquality as PE\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.PoolReap txs abs\nopen import Ledger.Conway.Specification.PoolReap.Properties.Computational txs abs\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Specification.Ratify.Properties.Computational txs\nopen import Ledger.Conway.Specification.Rewards txs abs\nopen import Ledger.Conway.Specification.Rewards.Properties.Computational txs abs\n\nopen Computational \u2983...\u2984\n\nmodule _ {eps : EpochState} {e : Epoch} where\n\n  EPOCH-total : \u2203[ eps' ] _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n  EPOCH-total =\n    -, EPOCH\n         ( SNAP-total      .proj\u2082\n         , POOLREAP-total  .proj\u2082\n         , RATIFIES-total' .proj\u2082)\n\n  EPOCH-deterministic : \u2200 eps' eps''\n                      \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n                      \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps''\n                      \u2192 eps' \u2261 eps''\n  EPOCH-deterministic\n      eps'\n      eps''\n      (EPOCH\n        {dState' = dState'\u2081}\n        {acnt' = acnt'\u2081}\n        {ss' = ss'\u2081}\n        {utxoSt'' = utxoSt''\u2081}\n        {pState'' = pState'\u2081}\n        (p\u2081 , p\u2082 , p\u2083)\n      )\n      (EPOCH\n        {dState' = dState'\u2082}\n        {acnt' = acnt'\u2082}\n        {ss' = ss'\u2082}\n        {utxoSt'' = utxoSt''\u2082}\n        {pState'' = pState'\u2082}\n        (p\u2081' , p\u2082' , p\u2083')\n      ) = eps'\u2261eps''\n       where\n         ls : LState\n         ls = LStateOf eps\n\n         es : EnactState\n         es = EnactStateOf (RatifyStateOf eps)\n\n         govUpd : Governance-Update\n         govUpd = GovernanceUpdate.updates ls (RatifyStateOf eps)\n\n         govSt' = Governance-Update.govSt' govUpd\n\n         ss'\u2081\u2261ss'\u2082 : ss'\u2081 \u2261 ss'\u2082\n         ss'\u2081\u2261ss'\u2082 = SNAP-deterministic p\u2081 p\u2081'\n\n         module pPRUpd =  Pre-POOLREAP-Update (Pre-POOLREAPUpdate.updates ls es govUpd)\n\n         pPRUpd\u2081 = Post-POOLREAPUpdate.updates es ls dState'\u2081 acnt'\u2081 govUpd\n         module pPRUpd\u2081 = Post-POOLREAP-Update pPRUpd\u2081\n\n         pPRUpd\u2082 = Post-POOLREAPUpdate.updates es ls dState'\u2082 acnt'\u2082 govUpd\n         module pPRUpd\u2082 = Post-POOLREAP-Update pPRUpd\u2082\n\n         prs'\u2261prs'' : $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#1760}{\\htmlId{2775}{\\htmlClass{Bound}{\\text{utxoSt''\u2081}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#1711}{\\htmlId{2787}{\\htmlClass{Bound}{\\text{acnt'\u2081}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#1684}{\\htmlId{2796}{\\htmlClass{Bound}{\\text{dState'\u2081}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#1791}{\\htmlId{2807}{\\htmlClass{Bound}{\\text{pState'\u2081}}}}\\, \\end{pmatrix}$ \u2261\n                      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#1940}{\\htmlId{2845}{\\htmlClass{Bound}{\\text{utxoSt''\u2082}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#1891}{\\htmlId{2857}{\\htmlClass{Bound}{\\text{acnt'\u2082}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#1864}{\\htmlId{2866}{\\htmlClass{Bound}{\\text{dState'\u2082}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#1971}{\\htmlId{2877}{\\htmlClass{Bound}{\\text{pState'\u2082}}}}\\, \\end{pmatrix}$\n         prs'\u2261prs'' = POOLREAP-deterministic-\u2261 refl refl p\u2082 p\u2082'\n\n         pPRUpd\u2081\u2261pPRUpd\u2082 : pPRUpd\u2081 \u2261 pPRUpd\u2082\n         pPRUpd\u2081\u2261pPRUpd\u2082 rewrite (cong PoolReapState.dState prs'\u2261prs'') | (cong PoolReapState.acnt prs'\u2261prs'') = refl\n\n         stakeDistrs\u2081\u2261stakeDistrs\u2082 : mkStakeDistrs (Snapshots.mark ss'\u2081) e pPRUpd.utxoSt' govSt' (GStateOf ls) (DStateOf ls)\n                                     \u2261 mkStakeDistrs (Snapshots.mark ss'\u2082) e pPRUpd.utxoSt' govSt' (GStateOf ls) (DStateOf ls)\n         stakeDistrs\u2081\u2261stakeDistrs\u2082 = cong (\u03bb ss' \u2192 mkStakeDistrs (Snapshots.mark ss') e pPRUpd.utxoSt' govSt' (GStateOf ls) (DStateOf ls)) ss'\u2081\u2261ss'\u2082\n\n         \u0393\u2261\u0393' = cong\u2082 (\u03bb sd acnt \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#3544}{\\htmlId{3556}{\\htmlClass{Bound}{\\text{sd}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#1229}{\\htmlId{3561}{\\htmlClass{Bound}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#14319}{\\htmlId{3565}{\\htmlClass{Field}{\\text{DRepsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#2050}{\\htmlId{3573}{\\htmlClass{Function}{\\text{ls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#1778}{\\htmlId{3578}{\\htmlClass{Field}{\\text{CCHotKeysOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#2050}{\\htmlId{3590}{\\htmlClass{Function}{\\text{ls}}}}\\, \\\\ \\,\\href{Ledger.Prelude.Base.html#985}{\\htmlId{3595}{\\htmlClass{Field}{\\text{TreasuryOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#3547}{\\htmlId{3606}{\\htmlClass{Bound}{\\text{acnt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#1863}{\\htmlId{3613}{\\htmlClass{Field}{\\text{PoolsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#2050}{\\htmlId{3621}{\\htmlClass{Function}{\\text{ls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#7079}{\\htmlId{3626}{\\htmlClass{Field}{\\text{VoteDelegsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#2050}{\\htmlId{3639}{\\htmlClass{Function}{\\text{ls}}}}\\, \\end{pmatrix}$)\n                      stakeDistrs\u2081\u2261stakeDistrs\u2082 (cong Post-POOLREAP-Update.acnt'' pPRUpd\u2081\u2261pPRUpd\u2082)\n\n         fut'\u2261fut'' : RatifyStateOf eps' \u2261 RatifyStateOf eps''\n         fut'\u2261fut'' = RATIFIES-deterministic-\u2261 \u0393\u2261\u0393' refl refl p\u2083 p\u2083'\n\n         eps'\u2261eps'' : eps' \u2261 eps''\n         eps'\u2261eps''\n           rewrite ss'\u2081\u2261ss'\u2082\n             | cong PoolReapState.utxoSt prs'\u2261prs''\n             | cong PoolReapState.pState prs'\u2261prs''\n             | cong Post-POOLREAP-Update.acnt'' pPRUpd\u2081\u2261pPRUpd\u2082\n             | cong Post-POOLREAP-Update.dState'' pPRUpd\u2081\u2261pPRUpd\u2082\n             | fut'\u2261fut'' = refl\n\n  EPOCH-complete : \u2200 eps' \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps' \u2192 proj\u2081 EPOCH-total \u2261 eps'\n  EPOCH-complete eps' p = EPOCH-deterministic (proj\u2081 EPOCH-total) eps' (proj\u2082 EPOCH-total) p\n\n  abstract\n    EPOCH-total' : \u2203[ eps' ] _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n    EPOCH-total' = EPOCH-total\n\n    EPOCH-complete' : \u2200 eps' \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps' \u2192 proj\u2081 EPOCH-total' \u2261 eps'\n    EPOCH-complete' = EPOCH-complete\n\ninstance\n  Computational-EPOCH : Computational _\u22a2_\u21c0\u2987_,EPOCH\u2988_ \u22a5\n  Computational-EPOCH .computeProof \u0393 s sig = success EPOCH-total'\n  Computational-EPOCH .completeness \u0393 s sig s' h = cong success (EPOCH-complete' s' h)\n\nmodule _ {e : Epoch} where\n\n  NEWEPOCH-total : \u2200 nes'' \u2192 \u2203[ nes' ] _ \u22a2 nes'' \u21c0\u2987 e ,NEWEPOCH\u2988 nes'\n  NEWEPOCH-total nes with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | inspect NewEpochState.ru nes\n  ... | yes p | just ru | PE.[ refl ] =  $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#4855}{\\htmlId{5102}{\\htmlClass{Bound}{\\text{e}}}}\\, \\\\ \\,\\htmlId{5106}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{5110}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#4420}{\\htmlId{5114}{\\htmlClass{Function}{\\text{EPOCH-total'}}}}\\, \\,\\htmlId{5127}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Data.Product.Base.html#636}{\\htmlId{5128}{\\htmlClass{Field}{\\text{proj\u2081}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#194}{\\htmlId{5136}{\\htmlClass{InductiveConstructor}{\\text{nothing}}}}\\, \\\\ \\,\\htmlId{5146}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$\n                                      , NEWEPOCH-New (p , EPOCH-total' .proj\u2082)\n  ... | yes p | nothing | PE.[ refl ] = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#4855}{\\htmlId{5271}{\\htmlClass{Bound}{\\text{e}}}}\\, \\\\ \\,\\htmlId{5275}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{5279}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\href{Data.Product.Base.html#636}{\\htmlId{5283}{\\htmlClass{Field}{\\text{proj\u2081}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.Properties.Computational.html#4420}{\\htmlId{5289}{\\htmlClass{Function}{\\text{EPOCH-total'}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#194}{\\htmlId{5304}{\\htmlClass{InductiveConstructor}{\\text{nothing}}}}\\, \\\\ \\,\\htmlId{5314}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$\n                                      , NEWEPOCH-No-Reward-Update (p , EPOCH-total' .proj\u2082)\n  ... | no \u00acp | _ | _ = -, NEWEPOCH-Not-New \u00acp\n\n  NEWEPOCH-complete : \u2200 nes nes' \u2192 _ \u22a2 nes \u21c0\u2987 e ,NEWEPOCH\u2988 nes' \u2192 proj\u2081 (NEWEPOCH-total nes) \u2261 nes'\n  -- NEWEPOCH-complete nes nes' h with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | h\n  NEWEPOCH-complete nes nes' h with e \u225f NewEpochState.lastEpoch nes + 1 | NewEpochState.ru nes | inspect NewEpochState.ru nes | h\n  ... | yes p | just ru | PE.[ refl ] | NEWEPOCH-New (x , x\u2081) rewrite EPOCH-complete' _ x\u2081 = refl\n  ... | yes p | ru | PE.[ refl ] | NEWEPOCH-Not-New x = \u22a5-elim $ x p\n  ... | yes p | nothing | PE.[ refl ] | NEWEPOCH-No-Reward-Update (x , x\u2081) rewrite EPOCH-complete' _ x\u2081 = refl\n  ... | no \u00acp | ru | PE.[ refl ] | NEWEPOCH-New (x , x\u2081)  = \u22a5-elim $ \u00acp x\n  ... | no \u00acp | ru | PE.[ refl ] | NEWEPOCH-Not-New x = refl\n  ... | no \u00acp | nothing | PE.[ refl ] | NEWEPOCH-No-Reward-Update (x , x\u2081) = \u22a5-elim $ \u00acp x\n\ninstance\n  Computational-NEWEPOCH : Computational _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_ \u22a5\n  Computational-NEWEPOCH .computeProof \u0393 s sig = success (NEWEPOCH-total _)\n  Computational-NEWEPOCH .completeness \u0393 s sig s' h = cong success (NEWEPOCH-complete _ s' h)\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.Properties.ConstRwds.html","title":"ConstRwds","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Epoch.Properties.ConstRwds\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Prelude\n</pre> <p>Claim (The <code>NEWEPOCH</code> rule leaves rewards unchanged).</p> <p>Informally.</p> <p>Rewards are left unchanged by the <code>NEWEPOCH</code> rule.  That is, if <code>es</code> and <code>es'</code> are two <code>NewEpochStates</code> such that <code>es</code> <code>\u21c0\u2987</code> <code>e</code> <code>,NEWEPOCH\u2988</code> <code>es'</code>, then the rewards of <code>es</code> and <code>es'</code> are equal.</p> <p>Formally.</p> <pre>dom-rwds-const : {e : Epoch} (es es' : NewEpochState)\n  \u2192 _ \u22a2 es \u21c0\u2987 e ,NEWEPOCH\u2988 es' \u2192 Type\n\ndom-rwds-const es es' step = dom (RewardsOf es) \u2261 dom (RewardsOf es')\n</pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Epoch.Properties.ExpiredDReps.html","title":"ExpiredDReps","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Epoch.Properties.ExpiredDReps\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Core.Specification.Epoch\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Prelude hiding (cong)\nimport Ledger.Prelude as P\nimport Relation.Binary.Core as B\nopen import Relation.Binary.Definitions\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Enact.Properties.Computational govStructure\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.Rewards txs abs\nopen import Ledger.Conway.Specification.PoolReap txs abs\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Gov.Actions govStructure using (Vote)\nopen import Relation.Binary.PropositionalEquality hiding (cong)\n\nopen import Axiom.Set.Properties th hiding (filter-map)\nopen import abstract-set-theory.Axiom.Set.Properties th\n</pre> <p>The <code>EPOCH</code> transition system behaves parametrically w.r.t. the set of expired <code>DReps</code> that are part of the <code>EpochState</code>.</p> <p>The following family of equivalence relations indexed by <code>Epoch</code> formalize the concept of two maps of <code>DReps</code> being the same on non-expired <code>DReps</code>:</p> <pre>DReps-[_]_\u2248_ : Epoch \u2192 B.Rel DReps 0\u2113\nDReps-[_]_\u2248_ e dreps\u2081 dreps\u2082\n  = filter\u1d50 (activeInEpoch e) dreps\u2081 \u2261\u1d50 filter\u1d50 (activeInEpoch e) dreps\u2082\n</pre> <p>This family of relations is monotonic w.r.t. increment on <code>Epoch</code> and respects <code>suc\u1d49</code>:</p> <pre>DReps-\u2248-mono : \u2200 (e : Epoch) {dreps\u2081 dreps\u2082 : DReps} \u2192 DReps-[ e ] dreps\u2081 \u2248 dreps\u2082 \u2192 DReps-[ suc\u1d49 e ] dreps\u2081 \u2248 dreps\u2082\nDReps-\u2248-mono e {dreps\u2081} {dreps\u2082} dreps\u2081\u2248dreps\u2082 =\n    begin\n      filter\u1d50 (activeInEpoch (suc\u1d49 e)) dreps\u2081 \u02e2\n        \u2248\u27e8 filter-\u21d2 P\u21d2Q \u27e8\n      filter\u1d50 (activeInEpoch (suc\u1d49 e)) (filter\u1d50 (activeInEpoch e) dreps\u2081) \u02e2\n        \u2248\u27e8 filter-cong dreps\u2081\u2248dreps\u2082 \u27e9\n      filter\u1d50 (activeInEpoch (suc\u1d49 e)) (filter\u1d50 (activeInEpoch e) dreps\u2082) \u02e2\n        \u2248\u27e8 filter-\u21d2 P\u21d2Q \u27e9\n      filter\u1d50 (activeInEpoch (suc\u1d49 e)) dreps\u2082 \u02e2\n    \u220e\n    where\n      open import Relation.Binary.Reasoning.Setoid \u2261\u1d49-Setoid\n      import Relation.Unary as U\n      module esp = HasPreorder (EpochStructure.preoEpoch epochStructure)\n      P\u21d2Q : U.Universal ((\u03bb ((_ , e') : Credential \u00d7 Epoch)  \u2192 suc\u1d49 e \u2264 e') U.\u21d2 (\u03bb (_ , e') \u2192 e \u2264 e'))\n      P\u21d2Q _ p = esp.\u2264-trans (proj\u2081 (esp.&lt;\u21d2\u2264\u2227\u2249 e&lt;suc\u1d49)) p\n\nDReps-\u2248-suc\u1d49 : \u2200 (e : Epoch) {dreps\u2081 dreps\u2082 : DReps} \u2192 DReps-[ e ] dreps\u2081 \u2248 dreps\u2082 \u2192 DReps-[ suc\u1d49 e ] mapValues suc\u1d49 dreps\u2081 \u2248 mapValues suc\u1d49 dreps\u2082\nDReps-\u2248-suc\u1d49 e {dreps\u2081} {dreps\u2082} dreps\u2081\u2248dreps\u2082 =\n    begin\n      filter\u1d50 (activeInEpoch (suc\u1d49 e)) (mapValues suc\u1d49 dreps\u2081) \u02e2\n        \u2248\u27e8 filter-map P\u21d2Q \u27e9\n      filter\u1d50 (activeInEpoch (suc\u1d49 e)) (mapValues suc\u1d49 (filter\u1d50 (activeInEpoch e) dreps\u2081)) \u02e2\n        \u2248\u27e8 filter-cong (map-\u2261\u1d49 dreps\u2081\u2248dreps\u2082) \u27e9\n      filter\u1d50 (activeInEpoch (suc\u1d49 e)) (mapValues suc\u1d49 (filter\u1d50 (activeInEpoch e) dreps\u2082)) \u02e2\n        \u2248\u27e8 filter-map P\u21d2Q \u27e8\n      filter\u1d50 (activeInEpoch (suc\u1d49 e)) (mapValues suc\u1d49 dreps\u2082) \u02e2\n    \u220e\n    where\n      open import Relation.Binary.Reasoning.Setoid \u2261\u1d49-Setoid\n      import Relation.Unary as U\n      P\u21d2Q : U.Universal ((\u03bb ((_ , e') : Credential \u00d7 Epoch)  \u2192 suc\u1d49 e \u2264 suc\u1d49 e') U.\u21d2 (\u03bb (_ , e') \u2192 e \u2264 e'))\n      P\u21d2Q _ p = \u2264-pred\u1d49 p\n</pre> <pre>DReps-\u2248-sym : (e : Epoch) {dreps\u2081 dreps\u2082 : DReps} \u2192 DReps-[ e ] dreps\u2081 \u2248 dreps\u2082 \u2192 DReps-[ e ] dreps\u2082 \u2248 dreps\u2081\nDReps-\u2248-sym _ = \u2261\u1d49-isEquivalence.sym\n  where\n    open import Relation.Binary.Structures _\u2261\u1d49_\n    module \u2261\u1d49-isEquivalence = IsEquivalence \u2261\u1d49-isEquivalence\n\nopen Equivalence\n</pre> <p>The family of relations is lifted to <code>EpochState</code>:</p> <pre>record StakeDistrs-_\u2248_ (sd sd' : StakeDistrs) : Type where\n  module sd  = StakeDistrs sd\n  module sd' = StakeDistrs sd'\n  field\n    stakeDistrVDeleg : sd.stakeDistrVDeleg \u2261\u1d50 sd'.stakeDistrVDeleg\n    stakeDistrPools  : sd.stakeDistrPools \u2261 sd'.stakeDistrPools\n\nrecord RatifyEnv-_\u2248_ (\u0393 \u0393' : RatifyEnv) : Type where\n  module \u0393  = RatifyEnv \u0393\n  module \u0393' = RatifyEnv \u0393'\n\n  field\n    stakeDistrs   : StakeDistrs- \u0393.stakeDistrs \u2248 \u0393'.stakeDistrs\n    currentEpoch  : \u0393.currentEpoch \u2261 \u0393'.currentEpoch\n    dreps         : DReps-[ \u0393.currentEpoch ] (DRepsOf \u0393) \u2248 (DRepsOf \u0393')\n    ccHotKeys     : \u0393.ccHotKeys \u2261 \u0393'.ccHotKeys\n    treasury      : \u0393.treasury \u2261 \u0393'.treasury\n    pools         : \u0393.pools \u2261 \u0393'.pools\n    delegatees    : \u0393.delegatees \u2261 \u0393'.delegatees\n\nrecord GState-[_]_\u2248_ (e : Epoch) (gSt gSt' : GState) : Type where\n  module gSt  = GState gSt\n  module gSt' = GState gSt'\n  field\n    dreps      : DReps-[ e ] gSt.dreps \u2248 gSt'.dreps\n    ccHotKeys  : gSt.ccHotKeys \u2261 gSt'.ccHotKeys\n\nrecord CertState-[_]_\u2248_ (e : Epoch) (cSt cSt' : CertState) : Type where\n  module cSt  = CertState cSt\n  module cSt' = CertState cSt'\n  field\n    dState : cSt.dState \u2261 cSt'.dState\n    pState : cSt.pState \u2261 cSt'.pState\n    gState : GState-[ e ] cSt.gState \u2248 cSt'.gState\n\nrecord LState-[_]_\u2248_ (e : Epoch) (lSt lSt' : LState) : Type where\n  module lSt  = LState lSt\n  module lSt' = LState lSt'\n  field\n    utxoSt     : lSt.utxoSt \u2261 lSt'.utxoSt\n    govSt      : lSt.govSt \u2261 lSt'.govSt\n    certState  : CertState-[ e ] lSt.certState \u2248 lSt'.certState\n\nrecord EpochState-[_]_\u2248_ (e : Epoch) (epSt epSt' : EpochState) : Type where\n  module epSt  = EpochState epSt\n  module epSt' = EpochState epSt'\n\n  field\n    acnt       : epSt.acnt \u2261 epSt'.acnt\n    ss         : epSt.ss \u2261 epSt'.ss\n    ls         : LState-[ e ] epSt.ls \u2248 epSt'.ls\n    es         : epSt.es \u2261 epSt'.es\n    fut        : epSt.fut \u2261 epSt'.fut\n</pre> <pre>StakeDistrs-\u2248-sym : Symmetric StakeDistrs-_\u2248_\nStakeDistrs-\u2248-sym sd\u2248sd' = record { stakeDistrVDeleg = \u2261\u1d49-isEquivalence.sym sd\u2248sd'.stakeDistrVDeleg ; stakeDistrPools = \u2261-sym sd\u2248sd'.stakeDistrPools }\n  where\n    module sd\u2248sd' = StakeDistrs-_\u2248_ sd\u2248sd'\n    open import Relation.Binary.Structures _\u2261\u1d49_\n    module \u2261\u1d49-isEquivalence = IsEquivalence \u2261\u1d49-isEquivalence\n    open import Relation.Binary.PropositionalEquality renaming (sym to \u2261-sym)\n\nRatifyEnv-\u2248-sym : Symmetric RatifyEnv-_\u2248_\nRatifyEnv-\u2248-sym {\u0393} {\u0393'} \u0393\u2248\u0393' = record {R}\n  where\n    module R where\n      module \u0393\u2248\u0393' = RatifyEnv-_\u2248_ \u0393\u2248\u0393'\n      module \u0393 = RatifyEnv \u0393\n      module \u0393' = RatifyEnv \u0393'\n      open import Relation.Binary.PropositionalEquality renaming (sym to \u2261-sym)\n\n      stakeDistrs = StakeDistrs-\u2248-sym \u0393\u2248\u0393'.stakeDistrs\n      currentEpoch = \u2261-sym \u0393\u2248\u0393'.currentEpoch\n\n      dreps : DReps-[ \u0393'.currentEpoch ] \u0393'.dreps \u2248 \u0393.dreps\n      dreps rewrite currentEpoch = DReps-\u2248-sym \u0393.currentEpoch {dreps\u2081 = \u0393.dreps} {dreps\u2082 = \u0393'.dreps} \u0393\u2248\u0393'.dreps\n\n      ccHotKeys = \u2261-sym \u0393\u2248\u0393'.ccHotKeys\n      treasury = \u2261-sym \u0393\u2248\u0393'.treasury\n      pools = \u2261-sym \u0393\u2248\u0393'.pools\n      delegatees = \u2261-sym \u0393\u2248\u0393'.delegatees\n\nmodule AcceptedByDRep-\u2248 {\u0393 \u0393' : RatifyEnv} (\u0393\u2248\u0393' : RatifyEnv- \u0393 \u2248 \u0393') (eSt : EnactState) (gaSt : GovActionState) where\n  module \u0393 = RatifyEnv \u0393\n  module \u0393' = RatifyEnv \u0393'\n  module \u0393\u2248\u0393' = RatifyEnv-_\u2248_ \u0393\u2248\u0393'\n  module abdr  = AcceptedByDRep \u0393  eSt gaSt\n  module abdr' = AcceptedByDRep \u0393' eSt gaSt\n\n  castVotes : abdr.castVotes \u2261 abdr'.castVotes\n  castVotes = refl\n\n  activeDReps-\u2261\u1d49 : abdr.activeDReps \u2261\u1d49 abdr'.activeDReps\n  activeDReps-\u2261\u1d49 with \u0393\u2248\u0393'.currentEpoch\n  ... | refl = dom-cong $\n    begin\n      filter\u1d50 (activeInEpoch \u0393.currentEpoch) \u0393.dreps \u02e2\n        \u2248\u02d8\u27e8 filter\u1d50-idem {m = \u0393.dreps} \u27e9\n      filter\u1d50 (activeInEpoch _) (filter\u1d50 (activeInEpoch _) \u0393.dreps) \u02e2\n        \u2248\u27e8 filter-cong \u0393\u2248\u0393'.dreps \u27e9\n      filter\u1d50 (activeInEpoch _) (filter\u1d50 (activeInEpoch _) \u0393'.dreps) \u02e2\n        \u2248\u27e8 filter\u1d50-idem {m = \u0393'.dreps} \u27e9\n      filter\u1d50 (activeInEpoch \u0393'.currentEpoch) \u0393'.dreps \u02e2\n    \u220e\n    where open import Relation.Binary.Reasoning.Setoid \u2261\u1d49-Setoid\n\n  predeterminedDRepVotes : abdr.predeterminedDRepVotes \u2261 abdr'.predeterminedDRepVotes\n  predeterminedDRepVotes = refl\n\n  defaultDRepCredentialVotes : abdr.defaultDRepCredentialVotes \u2261\u1d50 abdr'.defaultDRepCredentialVotes\n  defaultDRepCredentialVotes = map-\u2261\u1d49 (map-\u2261\u1d49 activeDReps-\u2261\u1d49)\n\n  actualVotes : abdr.actualVotes \u2261\u1d50 abdr'.actualVotes\n  actualVotes = \u222a\u02e1-cong {m = abdr.castVotes} {m' = abdr.defaultDRepCredentialVotes \u222a\u02e1 abdr.predeterminedDRepVotes}\n                       {m'' = abdr'.castVotes} {m''' = abdr'.defaultDRepCredentialVotes \u222a\u02e1 abdr'.predeterminedDRepVotes}\n                       (\u2261\u1d49-isEquivalence.reflexive (P.cong proj\u2081 castVotes))\n                       (\u222a\u02e1-cong {m = abdr.defaultDRepCredentialVotes} {m' = abdr.predeterminedDRepVotes }\n                               {m'' = abdr'.defaultDRepCredentialVotes} {m''' = abdr'.predeterminedDRepVotes }\n                               defaultDRepCredentialVotes (\u2261\u1d49-isEquivalence.reflexive (P.cong proj\u2081 predeterminedDRepVotes)))\n    where\n      open import Relation.Binary.Structures _\u2261\u1d49_\n      module \u2261\u1d49-isEquivalence = IsEquivalence \u2261\u1d49-isEquivalence\n\n  t : abdr.t \u2261 abdr'.t\n  t = refl\n\n  acceptedStake : abdr.acceptedStake \u2261 abdr'.acceptedStake\n  acceptedStake =\n    indexedSum\u1d5b'-cong \u2983 it \u2984 \u2983 it \u2984 \u2983 CommMonoid-\u2115-+ \u2984 {f = id}\n      {x = StakeDistrs.stakeDistrVDeleg \u0393.stakeDistrs \u2223 abdr.actualVotes \u207b\u00b9 _}\n      {y = StakeDistrs.stakeDistrVDeleg \u0393'.stakeDistrs \u2223 abdr'.actualVotes \u207b\u00b9 _}\n      (res\u1d50-cong {m = StakeDistrs.stakeDistrVDeleg \u0393.stakeDistrs}\n                 {m' = StakeDistrs.stakeDistrVDeleg \u0393'.stakeDistrs}\n        (StakeDistrs-_\u2248_.stakeDistrVDeleg \u0393\u2248\u0393'.stakeDistrs)\n        (\u207b\u00b9-cong {m = abdr.actualVotes} {m' = abdr'.actualVotes} actualVotes))\n\n  totalStake : abdr.totalStake \u2261 abdr'.totalStake\n  totalStake = indexedSum\u1d5b'-cong \u2983 it \u2984 \u2983 it \u2984 \u2983 CommMonoid-\u2115-+ \u2984 {f = id}\n                 {x = StakeDistrs.stakeDistrVDeleg \u0393.stakeDistrs \u2223 dom (abdr.actualVotes \u2223^ (\u2774 Vote.yes \u2775 \u222a \u2774 Vote.no \u2775))}\n                 {y = StakeDistrs.stakeDistrVDeleg \u0393'.stakeDistrs \u2223 dom (abdr'.actualVotes \u2223^ (\u2774 Vote.yes \u2775 \u222a \u2774 Vote.no \u2775))}\n                 (res\u1d50-cong {m = StakeDistrs.stakeDistrVDeleg \u0393.stakeDistrs}\n                            {m' = StakeDistrs.stakeDistrVDeleg \u0393'.stakeDistrs}\n                            (StakeDistrs-_\u2248_.stakeDistrVDeleg \u0393\u2248\u0393'.stakeDistrs)\n                            (dom-cong (cores\u1d50-cong {m = abdr.actualVotes} {m' = abdr'.actualVotes} actualVotes \u2261\u1d49-isEquivalence.refl)))\n    where\n    open import Relation.Binary.Structures _\u2261\u1d49_\n    module \u2261\u1d49-isEquivalence = IsEquivalence \u2261\u1d49-isEquivalence\n\n  accepted-\u2192 : abdr.accepted \u2192 abdr'.accepted\n  accepted-\u2192 x =\n    subst (\u03bb totalStake \u2192 (abdr'.acceptedStake /\u2080 totalStake) \u2265 abdr'.t ) totalStake\n      (subst (\u03bb acceptedStake \u2192 (acceptedStake /\u2080 abdr.totalStake) \u2265 abdr'.t ) acceptedStake\n        (subst (\u03bb t \u2192 (abdr.acceptedStake /\u2080 abdr.totalStake) \u2265 t ) t x))\n\nmodule AcceptedBySPO-\u2248 {\u0393 \u0393' : RatifyEnv} (\u0393\u2248\u0393' : RatifyEnv- \u0393 \u2248 \u0393') (eSt : EnactState) (gaSt : GovActionState) where\n  module \u0393 = RatifyEnv \u0393\n  module \u0393' = RatifyEnv \u0393'\n  module \u0393\u2248\u0393' = RatifyEnv-_\u2248_ \u0393\u2248\u0393'\n\n  accepted-\u2192 : acceptedBySPO \u0393 eSt gaSt \u2192 acceptedBySPO \u0393' eSt gaSt\n  accepted-\u2192 x rewrite StakeDistrs-_\u2248_.stakeDistrPools \u0393\u2248\u0393'.stakeDistrs | \u0393\u2248\u0393'.pools | \u0393\u2248\u0393'.delegatees = x\n\nmodule AcceptedByCC-\u2248 {\u0393 \u0393' : RatifyEnv} (\u0393\u2248\u0393' : RatifyEnv- \u0393 \u2248 \u0393') (eSt : EnactState) (gaSt : GovActionState) where\n  module \u0393 = RatifyEnv \u0393\n  module \u0393' = RatifyEnv \u0393'\n  module \u0393\u2248\u0393' = RatifyEnv-_\u2248_ \u0393\u2248\u0393'\n\n  accepted-\u2192 : acceptedByCC \u0393 eSt gaSt \u2192 acceptedByCC \u0393' eSt gaSt\n  accepted-\u2192 x rewrite \u0393\u2248\u0393'.currentEpoch | \u0393\u2248\u0393'.ccHotKeys = x\n\nmodule AcceptedConds-\u2248 {\u0393 \u0393' : RatifyEnv} (\u0393\u2248\u0393' : RatifyEnv- \u0393 \u2248 \u0393') (rSt : RatifyState) (ga : GovActionID \u00d7 GovActionState) where\n  module \u0393 = RatifyEnv \u0393\n  module \u0393' = RatifyEnv \u0393'\n  module \u0393\u2248\u0393' = RatifyEnv-_\u2248_ \u0393\u2248\u0393'\n\n  opaque\n    unfolding accepted\n\n    acceptConds-\u2192 : acceptConds \u0393 rSt ga \u2192 acceptConds \u0393' rSt ga\n    acceptConds-\u2192 ((abcc , abdrep , abspo) , y , z)\n      with \u0393\u2248\u0393'.currentEpoch | \u0393\u2248\u0393'.ccHotKeys | \u0393\u2248\u0393'.treasury | \u0393\u2248\u0393'.pools | \u0393\u2248\u0393'.delegatees | StakeDistrs-_\u2248_.stakeDistrPools \u0393\u2248\u0393'.stakeDistrs\n    ... | refl | refl | refl | refl | refl | refl\n      = ( AcceptedByCC-\u2248.accepted-\u2192 \u0393\u2248\u0393' (RatifyState.es rSt) (ga .proj\u2082) abcc\n        , AcceptedByDRep-\u2248.accepted-\u2192 \u0393\u2248\u0393' (RatifyState.es rSt) (ga .proj\u2082) abdrep\n        , AcceptedBySPO-\u2248.accepted-\u2192 \u0393\u2248\u0393' (RatifyState.es rSt) (ga .proj\u2082) abspo\n        )\n        , y\n        , z\n\nmodule RATIFY {\u0393 \u0393' : RatifyEnv} (\u0393\u2248\u0393' : RatifyEnv- \u0393 \u2248 \u0393') {a a' : _} {rSt rSt' : RatifyState} where\n  module \u0393  = RatifyEnv \u0393\n  module \u0393' = RatifyEnv \u0393'\n  module rSt  = RatifyState rSt\n  module rSt' = RatifyState rSt'\n\n  module \u0393\u2248\u0393' = RatifyEnv-_\u2248_ \u0393\u2248\u0393'\n\n  cong : \u2200 (rSt\u2261rSt' : rSt \u2261 rSt') {rSt'' rSt'''}\n       \u2192 \u0393  \u22a2 rSt  \u21c0\u2987 a ,RATIFY\u2988 rSt''\n       \u2192 \u0393' \u22a2 rSt' \u21c0\u2987 a ,RATIFY\u2988 rSt'''\n       \u2192 rSt'' \u2261 rSt'''\n  cong rSt\u2261rSt' (RATIFY-Accept {es = es}((ac , de , ex) , en)) (RATIFY-Accept {es = es'} ((ac' , ex') , en'))\n    with  \u0393\u2248\u0393'.treasury |  \u0393\u2248\u0393'.currentEpoch | rSt\u2261rSt'\n  ... | refl | refl | refl with ENACT-deterministic en en'\n  ... | refl = refl\n  cong refl (RATIFY-Accept (ac , _)) (RATIFY-Reject (\u00acac , _))\n    = \u22a5-elim (\u00acac (AcceptedConds-\u2248.acceptConds-\u2192 \u0393\u2248\u0393' rSt a ac))\n  cong refl (RATIFY-Accept (ac , _)) (RATIFY-Continue (\u00acac , _))\n    = \u22a5-elim (\u00acac (AcceptedConds-\u2248.acceptConds-\u2192 \u0393\u2248\u0393' rSt a ac))\n  cong refl (RATIFY-Reject (\u00acac , _)) (RATIFY-Accept (ac , _))\n    = \u22a5-elim (\u00acac (AcceptedConds-\u2248.acceptConds-\u2192 (RatifyEnv-\u2248-sym \u0393\u2248\u0393') rSt' a ac))\n  cong refl (RATIFY-Reject (\u00acac , _)) (RATIFY-Reject (\u00acac' , _))\n    = refl\n  cong refl (RATIFY-Reject (_ , ex)) (RATIFY-Continue (_ , \u00acex))\n    rewrite \u0393\u2248\u0393'.currentEpoch = \u22a5-elim (\u00acex ex)\n  cong refl (RATIFY-Continue (\u00acac , _)) (RATIFY-Accept (ac , _))\n    = \u22a5-elim (\u00acac (AcceptedConds-\u2248.acceptConds-\u2192 (RatifyEnv-\u2248-sym \u0393\u2248\u0393') rSt' a ac))\n  cong refl (RATIFY-Continue (_ , \u00acex)) (RATIFY-Reject (_ , ex))\n    rewrite \u0393\u2248\u0393'.currentEpoch = \u22a5-elim (\u00acex ex)\n  cong refl (RATIFY-Continue (\u00acac , \u00acex)) (RATIFY-Continue (\u00acac' , \u00acex')) = refl\n\nmodule RATIFIES {\u0393 \u0393' : RatifyEnv} (\u0393\u2248\u0393' : RatifyEnv- \u0393 \u2248 \u0393') where\n  cong\n    : \u2200 {rSt rSt' : RatifyState} (rSt\u2261rSt' : rSt \u2261 rSt') {govSt govSt' : GovState} (govSt\u2261govSt' : govSt \u2261 govSt') {rSt'' rSt''' : RatifyState}\n       \u2192 \u0393  \u22a2 rSt  \u21c0\u2987 govSt  ,RATIFIES\u2988 rSt''\n       \u2192 \u0393' \u22a2 rSt' \u21c0\u2987 govSt' ,RATIFIES\u2988 rSt'''\n       \u2192 rSt'' \u2261 rSt'''\n  cong refl refl (BS-base Id-nop) (BS-base Id-nop) = refl\n  cong refl refl (BS-ind {sig = a} p ps) (BS-ind {sig = a'} q qs)\n    with RATIFY.cong \u0393\u2248\u0393' {a = a} {a' = a'} refl p q\n  ... | refl = cong refl refl ps  qs\n\n\nmodule SNAP {lSt lSt' : LState} {ss ss' : Snapshots}\n            (e : Epoch)\n            (lSt\u2248lSt' : LState-[ e ] lSt \u2248 lSt')\n            where\n  module lSt\u2248lSt' = LState-[_]_\u2248_ lSt\u2248lSt'\n\n  cong : \u2200 (ss\u2261ss' : ss \u2261 ss')\n          {ss'' ss''' : Snapshots}\n          \u2192 lSt  \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss''\n          \u2192 lSt' \u22a2 ss' \u21c0\u2987 tt ,SNAP\u2988 ss'''\n          \u2192 ss'' \u2261 ss'''\n  cong refl SNAP SNAP rewrite lSt\u2248lSt'.utxoSt | CertState-[_]_\u2248_.pState lSt\u2248lSt'.certState | CertState-[_]_\u2248_.dState lSt\u2248lSt'.certState = refl\n\n\nmodule Governance-update\n  {lSt lSt' : LState} {rSt rSt' : RatifyState}\n  (e : Epoch) (lSt\u2248lSt' : LState-[ e ] lSt \u2248 lSt') (rSt\u2261rSt' : rSt \u2261 rSt')\n  where\n\n  module lSt\u2248lSt' = LState-[_]_\u2248_ lSt\u2248lSt'\n\n  module govUpd\u2081 = GovernanceUpdate lSt rSt\n  module govUpd\u2082 = GovernanceUpdate lSt' rSt'\n\n  tmpGovSt : govUpd\u2081.tmpGovSt \u2261 govUpd\u2082.tmpGovSt\n  tmpGovSt rewrite rSt\u2261rSt' | lSt\u2248lSt'.govSt = refl\n\n  orphans : govUpd\u2081.orphans \u2261 govUpd\u2082.orphans\n  orphans rewrite tmpGovSt | rSt\u2261rSt' = refl\n\n  removed' : govUpd\u2081.removed' \u2261 govUpd\u2082.removed'\n  removed' rewrite rSt\u2261rSt' | lSt\u2248lSt'.govSt = refl\n\n  removedGovActions : govUpd\u2081.removedGovActions \u2261 govUpd\u2082.removedGovActions\n  removedGovActions rewrite removed' | lSt\u2248lSt'.utxoSt = refl\n\n  govSt' : govUpd\u2081.govSt' \u2261 govUpd\u2082.govSt'\n  govSt' rewrite removed' | lSt\u2248lSt'.govSt = refl\n\n  updates : govUpd\u2081.updates \u2261 govUpd\u2082.updates\n  updates rewrite govSt' | removedGovActions = refl\n\nrecord Pre-POOLREAP-Update-[_]_\u2248_ (e : Epoch) (pPRUpd\u2081 pPRUpd\u2082 : Pre-POOLREAP-Update) : Type where\n  module pPRUpd\u2081 = Pre-POOLREAP-Update pPRUpd\u2081\n  module pPRUpd\u2082 = Pre-POOLREAP-Update pPRUpd\u2082\n\n  field\n    pState' : pPRUpd\u2081.pState' \u2261 pPRUpd\u2082.pState'\n    gState' : GState-[ suc\u1d49 e ] pPRUpd\u2081.gState' \u2248 pPRUpd\u2082.gState'\n    utxoSt' : pPRUpd\u2081.utxoSt' \u2261 pPRUpd\u2082.utxoSt'\n\nmodule Pre-POOLREAP-update\n  {lSt lSt' : LState} {eSt eSt' : EnactState} {govUpd govUpd' : Governance-Update}\n  (e : Epoch) (eSt\u2261eSt' : eSt \u2261 eSt') (lSt\u2248lSt' : LState-[ e ] lSt \u2248 lSt') (govUpd\u2261govUpd' : govUpd \u2261 govUpd')\n  where\n\n  module lSt\u2248lSt' = LState-[_]_\u2248_ lSt\u2248lSt'\n  module pPRUpd\u2081  = Pre-POOLREAPUpdate lSt eSt govUpd\n  module pPRUpd\u2082  = Pre-POOLREAPUpdate lSt' eSt' govUpd'\n\n  gState' : GState-[ suc\u1d49 e ] pPRUpd\u2081.gState' \u2248 pPRUpd\u2082.gState'\n  gState' = record {R}\n    where\n      module R where\n        open import Relation.Binary.PropositionalEquality renaming (trans to \u2261-trans; sym to \u2261-sym)\n\n        true\u2262false : \u00ac true \u2261 false\n        true\u2262false ()\n\n        dreps : DReps-[ suc\u1d49 e ] GState.dreps pPRUpd\u2081.gState' \u2248 GState.dreps pPRUpd\u2082.gState'\n        dreps with P.cong Governance-Update.govSt' govUpd\u2261govUpd'\n        ... | refl with null (Governance-Update.govSt' govUpd')\n        ... | false = DReps-\u2248-mono e {dreps\u2081 = DRepsOf lSt} {dreps\u2082 = DRepsOf lSt'} (GState-[_]_\u2248_.dreps (CertState-[_]_\u2248_.gState lSt\u2248lSt'.certState))\n        ... | true  = DReps-\u2248-suc\u1d49 e {dreps\u2081 = DRepsOf lSt} {dreps\u2082 = DRepsOf lSt'} (GState-[_]_\u2248_.dreps (CertState-[_]_\u2248_.gState lSt\u2248lSt'.certState))\n\n        ccHotKeys : GState.ccHotKeys pPRUpd\u2081.gState' \u2261  GState.ccHotKeys pPRUpd\u2082.gState'\n        ccHotKeys rewrite GState-[_]_\u2248_.ccHotKeys (CertState-[_]_\u2248_.gState lSt\u2248lSt'.certState) | eSt\u2261eSt' = refl\n\n  utxoSt' : pPRUpd\u2081.utxoSt' \u2261 pPRUpd\u2082.utxoSt'\n  utxoSt' rewrite govUpd\u2261govUpd' | lSt\u2248lSt'.utxoSt = refl\n\n  pState' : pPRUpd\u2081.pState' \u2261 pPRUpd\u2082.pState'\n  pState' rewrite CertState-[_]_\u2248_.pState lSt\u2248lSt'.certState = refl\n\n  updates : Pre-POOLREAP-Update-[ e ] pPRUpd\u2081.updates \u2248 pPRUpd\u2082.updates\n  updates = record { pState' = pState' ; gState' = gState' ; utxoSt' = utxoSt' }\n\nrecord Post-POOLREAP-Update-[_]_\u2248_ (e : Epoch) (pPRUpd\u2081 pPRUpd\u2082 : Post-POOLREAP-Update) : Type where\n  module pPRUpd\u2081 = Post-POOLREAP-Update pPRUpd\u2081\n  module pPRUpd\u2082 = Post-POOLREAP-Update pPRUpd\u2082\n\n  field\n    dState'' : pPRUpd\u2081.dState'' \u2261 pPRUpd\u2082.dState''\n    acnt''   : pPRUpd\u2081.acnt'' \u2261 pPRUpd\u2082.acnt''\n\nmodule Post-POOLREAP-update\n  {eSt eSt' : EnactState} {lSt lSt' : LState} {dSt dSt' : DState} {acnt acnt' : Acnt} {govUpd govUpd' : Governance-Update}\n  (e : Epoch)\n  (eSt\u2261eSt' : eSt \u2261 eSt') (lSt\u2248lSt' : LState-[ e ] lSt \u2248 lSt') (dSt\u2261dSt' : dSt \u2261 dSt') (acnt\u2261acnt' : acnt \u2261 acnt') (govUpd\u2261govUpd' : govUpd \u2261 govUpd')\n  where\n\n  module pPRUpd\u2081 = Post-POOLREAPUpdate eSt lSt dSt acnt govUpd\n  module pPRUpd\u2082 = Post-POOLREAPUpdate eSt' lSt' dSt' acnt' govUpd'\n\n  opaque\n    unfolding Post-POOLREAPUpdate.payout\n\n    govActionReturns : pPRUpd\u2081.govActionReturns \u2261 pPRUpd\u2082.govActionReturns\n    govActionReturns rewrite govUpd\u2261govUpd' = refl\n\n    payout : pPRUpd\u2081.payout \u2261 pPRUpd\u2082.payout\n    payout rewrite eSt\u2261eSt' | govActionReturns = refl\n\n  opaque\n    unfolding Post-POOLREAPUpdate.refunds\n\n    refunds : pPRUpd\u2081.refunds \u2261 pPRUpd\u2082.refunds\n    refunds rewrite payout | dSt\u2261dSt' = refl\n\n  dState'' : pPRUpd\u2081.dState'' \u2261 pPRUpd\u2082.dState''\n  dState'' rewrite refunds | dSt\u2261dSt' = refl\n\n  unclaimed : pPRUpd\u2081.unclaimed \u2261 pPRUpd\u2082.unclaimed\n  unclaimed rewrite payout | refunds = refl\n\n  totWithdrawals : pPRUpd\u2081.totWithdrawals \u2261 pPRUpd\u2082.totWithdrawals\n  totWithdrawals rewrite eSt\u2261eSt' = refl\n\n  acnt'' : pPRUpd\u2081.acnt'' \u2261 pPRUpd\u2082.acnt''\n  acnt'' rewrite unclaimed | totWithdrawals | acnt\u2261acnt' | LState-[_]_\u2248_.utxoSt lSt\u2248lSt' = refl\n\n  updates : Post-POOLREAP-Update-[ e ] pPRUpd\u2081.updates \u2248 pPRUpd\u2082.updates\n  updates = record { dState'' = dState'' ; acnt'' = acnt'' }\n\nrecord PoolReapState-_\u2248_ (prSt prSt' : PoolReapState) : Type where\n  module prSt  = PoolReapState prSt\n  module prSt' = PoolReapState prSt'\n  field\n    utxoSt     : prSt.utxoSt \u2261 prSt'.utxoSt\n    acnt       : prSt.acnt \u2261 prSt'.acnt\n    dState     : prSt.dState \u2261 prSt'.dState\n    pState     : prSt.pState \u2261 prSt'.pState\n\nmodule POOLREAP\n  {prSt prSt' : PoolReapState}\n  (e : Epoch)\n  (prSt\u2248prSt' : PoolReapState- prSt \u2248 prSt') where\n\n  module prSt\u2248prSt' = PoolReapState-_\u2248_ prSt\u2248prSt'\n\n  cong : \u2200 {prSt'' prSt''' : PoolReapState}\n       \u2192 tt \u22a2 prSt \u21c0\u2987 e ,POOLREAP\u2988 prSt''\n       \u2192 tt \u22a2 prSt' \u21c0\u2987 e ,POOLREAP\u2988 prSt'''\n       \u2192 PoolReapState- prSt'' \u2248 prSt'''\n  cong POOLREAP POOLREAP with prSt\u2248prSt'.utxoSt | prSt\u2248prSt'.acnt | prSt\u2248prSt'.dState  | prSt\u2248prSt'.pState\n  ... | refl | refl | refl | refl  = record { utxoSt = refl ; acnt = refl ; dState = refl ; pState = refl }\n\nmodule VDelegDelegatedStake-\u2248\n  (currentEpoch : Epoch)\n  (utxoSt : UTxOState)\n  (govSt : GovState)\n  {gState gState' : GState} (gState\u2248gState' : GState-[ currentEpoch ] gState \u2248 gState')\n  (dState : DState)\n  where\n\n  module gState = GState gState\n  module gState' = GState gState'\n  module gState\u2248gState' = GState-[_]_\u2248_ gState\u2248gState'\n  module vds  = VDelegDelegatedStake currentEpoch utxoSt govSt gState  dState\n  module vds' = VDelegDelegatedStake currentEpoch utxoSt govSt gState' dState\n\n  activeDReps-\u2261\u1d49 : vds.activeDReps \u2261\u1d49 vds'.activeDReps\n  activeDReps-\u2261\u1d49 = dom-cong $\n    begin\n      filter\u1d50 (activeInEpoch currentEpoch) gState.dreps \u02e2\n        \u2248\u27e8 filter\u1d50-idem {m = gState.dreps} \u27e8\n      filter\u1d50 (activeInEpoch currentEpoch) (filter\u1d50 (activeInEpoch currentEpoch) gState.dreps) \u02e2\n        \u2248\u27e8 filter-cong gState\u2248gState'.dreps \u27e9\n      filter\u1d50 (activeInEpoch currentEpoch) (filter\u1d50 (activeInEpoch currentEpoch) gState'.dreps) \u02e2\n        \u2248\u27e8 filter\u1d50-idem {m = gState'.dreps} \u27e9\n      filter\u1d50 (activeInEpoch currentEpoch) gState'.dreps \u02e2\n    \u220e\n    where open import Relation.Binary.Reasoning.Setoid \u2261\u1d49-Setoid\n\n  activeVDelegs : vds.activeVDelegs \u2261\u1d49 vds'.activeVDelegs\n  activeVDelegs = \u222a-cong (map-\u2261\u1d49 activeDReps-\u2261\u1d49) \u2261\u1d49-isEquivalence.refl\n    where\n      open import Relation.Binary.Structures _\u2261\u1d49_\n      module \u2261\u1d49-isEquivalence = IsEquivalence \u2261\u1d49-isEquivalence\n\n  calculate : vds.calculate \u2261\u1d50 vds'.calculate\n  calculate = mapFromFun-cong _ activeVDelegs\n\nopaque\n  unfolding calculateVDelegDelegatedStake\n\n  calculateVDelegDelegatedStake-\u2248\n    : (e : Epoch) \u2192 (utxoSt : UTxOState) \u2192 (govSt : GovState)\n    \u2192 {gState gState' : GState} (gState\u2248gState' : GState-[ e ] gState \u2248 gState')\n    \u2192 (dState : DState)\n    \u2192 calculateVDelegDelegatedStake e utxoSt govSt gState dState \u2261\u1d50 calculateVDelegDelegatedStake e utxoSt govSt gState' dState\n  calculateVDelegDelegatedStake-\u2248 e utxoSt govSt gState\u2248gState' dState = VDelegDelegatedStake-\u2248.calculate  e utxoSt govSt gState\u2248gState' dState\n\nmodule mkStakeDistrs {s s' : Snapshot} {utxoSt utxoSt' : UTxOState} {govSt govSt' : GovState} {gState gState' : GState} {dState dState' : DState}\n                     where\n\n  cong\n   : \u2200 (s\u2261s' : s \u2261 s') (e : Epoch) (utxoSt\u2261utxoSt' : utxoSt \u2261 utxoSt') (govSt\u2261govSt' : govSt \u2261 govSt') (gState\u2248gState' : GState-[ e ] gState \u2248 gState') (dState\u2261dState' : dState \u2261 dState')\n   \u2192 StakeDistrs- (mkStakeDistrs s e utxoSt govSt gState dState) \u2248 (mkStakeDistrs s' e utxoSt' govSt' gState' dState')\n  cong refl e refl refl gState\u2248gState' refl = record { R }\n    where\n      module R where\n        stakeDistrVDeleg = calculateVDelegDelegatedStake-\u2248 e utxoSt govSt gState\u2248gState' dState\n        stakeDistrPools = refl\n</pre> <p>The main property states that <code>EPOCH</code> \"preserves\" the above relation on <code>EpochState</code>:</p> <pre>module EPOCH {epSt epSt' : EpochState} (e : Epoch) (epSt\u2248epSt' : EpochState-[ e ] epSt \u2248 epSt') where\n  module epSt\u2248epSt' = EpochState-[_]_\u2248_ epSt\u2248epSt'\n\n  cong : \u2200 (epSt'' epSt''' : EpochState)\n       \u2192 tt \u22a2 epSt  \u21c0\u2987 e ,EPOCH\u2988 epSt''\n       \u2192 tt \u22a2 epSt' \u21c0\u2987 e ,EPOCH\u2988 epSt'''\n       \u2192 EpochState-[ suc\u1d49 e ] epSt'' \u2248 epSt'''\n  cong eps'' eps''' (EPOCH (snap\u2081 , poolreap\u2081 , ratify\u2081)) (EPOCH (snap\u2082 , poolreap\u2082 , ratify\u2082))\n</pre> <p>(Proof ommited from rendering)</p> <pre>    = record {R}\n    where\n      module R where\n        module lSt\u2248lSt' = LState-[_]_\u2248_ epSt\u2248epSt'.ls\n        module cSt\u2248cSt' = CertState-[_]_\u2248_ lSt\u2248lSt'.certState\n        module gSt\u2248gSt' = GState-[_]_\u2248_ cSt\u2248cSt'.gState\n\n        govUpd\u2081 = GovernanceUpdate.updates (LStateOf epSt) (RatifyStateOf epSt)\n        govUpd\u2082 = GovernanceUpdate.updates (LStateOf epSt') (RatifyStateOf epSt')\n\n        govUpd\u2081\u2261govUpd\u2082 : govUpd\u2081 \u2261 govUpd\u2082\n        govUpd\u2081\u2261govUpd\u2082 = Governance-update.updates e epSt\u2248epSt'.ls epSt\u2248epSt'.fut\n\n        prPRUpd\u2081\u2248prPRUpd\u2082 = Pre-POOLREAP-update.updates e (P.cong EnactStateOf epSt\u2248epSt'.fut) epSt\u2248epSt'.ls govUpd\u2081\u2261govUpd\u2082\n        module prPRUpd\u2081\u2248prPRUpd\u2082 = Pre-POOLREAP-Update-[_]_\u2248_ prPRUpd\u2081\u2248prPRUpd\u2082\n\n        module PoolReapState-\u2248 where\n          utxoSt = prPRUpd\u2081\u2248prPRUpd\u2082.utxoSt'\n          acnt   = epSt\u2248epSt'.acnt\n          dState = cSt\u2248cSt'.dState\n          pState = prPRUpd\u2081\u2248prPRUpd\u2082.pState'\n\n        module prSt\u2248prSt' =  PoolReapState-_\u2248_ (POOLREAP.cong e (record {PoolReapState-\u2248}) poolreap\u2081 poolreap\u2082)\n        module poPRUpd\u2081\u2248poPRUpd\u2082 = Post-POOLREAP-Update-[_]_\u2248_ (Post-POOLREAP-update.updates e ((P.cong EnactStateOf epSt\u2248epSt'.fut))\n                                                                epSt\u2248epSt'.ls prSt\u2248prSt'.dState prSt\u2248prSt'.acnt govUpd\u2081\u2261govUpd\u2082)\n        ss''\u2261ss''' = SNAP.cong e epSt\u2248epSt'.ls epSt\u2248epSt'.ss snap\u2081 snap\u2082\n\n        module \u0393\u2248\u0393' where\n          stakeDistrs   = mkStakeDistrs.cong (P.cong Snapshots.mark ss''\u2261ss''') e prPRUpd\u2081\u2248prPRUpd\u2082.utxoSt' (P.cong Governance-Update.govSt' govUpd\u2081\u2261govUpd\u2082)\n                                             cSt\u2248cSt'.gState cSt\u2248cSt'.dState\n          currentEpoch  = refl\n          dreps         = gSt\u2248gSt'.dreps\n          ccHotKeys     = gSt\u2248gSt'.ccHotKeys\n          treasury      = P.cong Acnt.treasury poPRUpd\u2081\u2248poPRUpd\u2082.acnt''\n          pools         = P.cong PState.pools (cSt\u2248cSt'.pState)\n          delegatees    = P.cong DState.voteDelegs (cSt\u2248cSt'.dState)\n\n        fut\u2261fut' = RATIFIES.cong\n          (record {\u0393\u2248\u0393'})\n          (P.cong\n            (\u03bb x \u2192 RatifyState.constructor\n                     (record (EnactStateOf x) {withdrawals = \u2205})\n                     \u2205\n                     false\n            )\n            epSt\u2248epSt'.fut\n          )\n          (P.cong Governance-Update.govSt' govUpd\u2081\u2261govUpd\u2082)\n          ratify\u2081\n          ratify\u2082\n\n        module CS where\n          dState = poPRUpd\u2081\u2248poPRUpd\u2082.dState''\n          pState = prSt\u2248prSt'.pState\n          gState = prPRUpd\u2081\u2248prPRUpd\u2082.gState'\n\n        module LS where\n          utxoSt = prSt\u2248prSt'.utxoSt\n          govSt = P.cong Governance-Update.govSt' govUpd\u2081\u2261govUpd\u2082\n          certState = record {CS}\n\n        acnt = poPRUpd\u2081\u2248poPRUpd\u2082.acnt''\n        ss   = ss''\u2261ss'''\n        ls   = record {LS}\n\n        es : record (EnactStateOf (RatifyStateOf epSt)) { withdrawals = \u2205 } \u2261 record (EnactStateOf (RatifyStateOf epSt')) { withdrawals = \u2205 }\n        es rewrite (P.cong EnactStateOf epSt\u2248epSt'.fut) = refl\n\n        fut  = fut\u2261fut'\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.Properties.GovDepsMatch.html","title":"GovDepsMatch","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Epoch.Properties.GovDepsMatch\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Prelude using (map\u02e2)\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.Ledger.Properties.Base txs abs\nopen import Ledger.Conway.Specification.PoolReap txs abs\nopen import Ledger.Prelude renaming (map to map'; map\u02e2 to map)\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Specification.Utxo txs abs\n\nopen import Axiom.Set.Properties th\n\nopen import Data.List.Base using (filter)\nopen import Data.List.Membership.Propositional.Properties using (\u2208-filter\u207a; map-\u2208\u2194)\nopen import stdlib.Data.List.Subpermutations using (\u2208\u02e1-map-filter)\nopen import Data.Product.Function.NonDependent.Propositional using (_\u00d7-cong_)\nopen import Data.Product.Properties using (\u00d7-\u2261,\u2261\u2190\u2261)\nopen import Data.Product.Properties.Ext using (\u00d7-\u21d4-swap)\n\nopen import Relation.Unary using (Decidable)\n\nopen Equivalence\n\nimport Function.Related.Propositional as R\nimport Relation.Binary.Reasoning.Setoid as SetoidReasoning\n\nmodule EPOCH-Body (eps : EpochState) where\n  open EpochState eps hiding (es) renaming (ls to epsLState; fut to epsRState) public\n  open RatifyState renaming (es to ensRState) public\n  open LState epsLState public\n  open PState public\n  open GovActionState public\n\n  ens      = record (epsRState .ensRState) { withdrawals = \u2205 }\n  tmpGovSt = filter (\u03bb x \u2192 \u00bf proj\u2081 x \u2209 map proj\u2081 (epsRState .removed) \u00bf) govSt\n  orphans  = fromList $ getOrphans (epsRState .ensRState) tmpGovSt\n  removed' : \u2119 (GovActionID \u00d7 GovActionState)\n  removed' = (epsRState .removed) \u222a orphans\n  removedGovActions = flip concatMap\u02e2 removed' \u03bb (gaid , gaSt) \u2192\n    map (returnAddr gaSt ,_) ((DepositsOf utxoSt \u2223 \u2774 GovActionDeposit gaid \u2775) \u02e2)\n\nmodule EPOCH-PROPS {eps : EpochState} where\n  open EPOCH-Body eps\n</pre> <p> Lemma (<code>govDepsMatch</code> is invariant of <code>EPOCH</code> rule).</p> <p>Informally.</p> <p>Let <code>eps</code>, <code>eps'</code> : <code>EpochState</code> be two epoch states and let <code>e</code> : <code>Epoch</code> be an epoch. Recall, <code>LStateOf</code> <code>eps</code> gives the ledger state of <code>eps</code>. If <code>eps</code> <code>\u21c0\u2987</code> <code>e</code> <code>,EPOCH\u2988</code> <code>eps'</code>, then (under a certain special condition) <code>govDepsMatch</code> (<code>LStateOf</code> <code>eps</code>) implies <code>govDepsMatch</code> (<code>LStateOf</code> <code>eps'</code>).</p> <p>The special condition under which the property holds is the same as the one in Chain.Properties.GovDepsMatch: let <code>removed'</code> be the union of the governance actions in the <code>removed</code> field of the ratify state of <code>eps</code> and the orphaned governance actions in the <code>GovState</code> of <code>eps</code>.</p> <p>For the formal statement of the lemma,</p> <ul> <li> <p>let \\(\ud835\udca2\\) be the set \\(\\{\\)<code>GovActionDeposit</code> <code>id</code> : <code>id</code> \\(\u2208\\) <code>proj\u2081</code> <code>removed'</code>\\(\\}\\), and</p> </li> <li> <p>assume \\(\ud835\udca2\\) is a subset of the set of deposits of (the governance state of) <code>eps</code>.</p> </li> </ul> <p>Formally.</p> <pre>  EPOCH-govDepsMatch :  {eps' : EpochState} {e : Epoch}\n    \u2192 map (GovActionDeposit \u2218 proj\u2081) removed' \u2286 dom (DepositsOf eps)\n    \u2192 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n    \u2192 govDepsMatch (LStateOf eps) \u2192 govDepsMatch (LStateOf eps')\n</pre> <p>Proof.</p> <pre>  EPOCH-govDepsMatch {eps'} {e} ratify-removed = mainProof\n    where\n\n    -- the combinator used in the EPOCH rule\n    \u0394\u03a0 : \u2119 DepositPurpose\n    \u0394\u03a0 = map (proj\u2081 \u2218 proj\u2082) removedGovActions\n\n    -- a simpler combinator that suffices here;\n    \u0394\u03a0' : \u2119 DepositPurpose\n    \u0394\u03a0' = map (GovActionDeposit \u2218 proj\u2081) removed'\n    -- Below we prove \u0394\u03a0 and \u0394\u03a0' are essentially equivalent.\n\n    P : GovActionID \u00d7 GovActionState \u2192 Type\n    P = \u03bb u \u2192 proj\u2081 u \u2209 map proj\u2081 removed'\n\n    P? : Decidable P\n    P? = \u03bb u \u2192 \u00bf P u \u00bf\n\n    utxoDeps : Deposits\n    utxoDeps = UTxOState.deposits (LState.utxoSt epsLState)\n\n    -- utxo deposits restricted to new form of set used in EPOCH rule\n    utxoDeps' : Deposits\n    utxoDeps' = utxoDeps \u2223 \u0394\u03a0' \u1d9c\n\n    \u0394\u03a0'\u2261\u0394\u03a0 : \u0394\u03a0' \u2261\u1d49 \u0394\u03a0\n    \u0394\u03a0'\u2261\u0394\u03a0 = \u0394\u03a0'\u2286\u0394\u03a0 , \u0394\u03a0\u2286\u0394\u03a0'\n      where\n      \u0394\u03a0'\u2286\u0394\u03a0 : \u0394\u03a0' \u2286 \u0394\u03a0\n      \u0394\u03a0'\u2286\u0394\u03a0 {a} x with from \u2208-map x\n      ... | (gaid , gast) , refl , gaidgast\u2208rem with from \u2208-map (ratify-removed x)\n      ... | (dp , c) , refl , dpc\u2208utxoDeps = let gadc = (GovActionDeposit gaid , c) in\n        to \u2208-map ((returnAddr {txs} gast , gadc)\n                 , refl\n                 , to \u2208-concatMap\u02e2 ((gaid , gast)\n                                   , gaidgast\u2208rem\n                                   , to \u2208-map (gadc , refl , res-singleton\u207a {m = utxoDeps} dpc\u2208utxoDeps)))\n      \u0394\u03a0\u2286\u0394\u03a0' : \u0394\u03a0 \u2286 \u0394\u03a0'\n      \u0394\u03a0\u2286\u0394\u03a0' {a} x with from \u2208-map x\n      ... | (rwa , dp , c) , refl , rwa-dp-c\u2208 with (from \u2208-concatMap\u02e2 rwa-dp-c\u2208)\n      ... | (gaid , gast) , gaid-gast-\u2208-removed , rwa-dp-c-\u2208-map with (from \u2208-map rwa-dp-c-\u2208-map)\n      ... | (_ , _) , refl , q\u2208 =\n        to \u2208-map ((gaid , gast)\n                 , proj\u2081 (\u00d7-\u2261,\u2261\u2190\u2261 (proj\u2082 (res-singleton'' {m = utxoDeps} q\u2208)))\n                 , gaid-gast-\u2208-removed)\n\n    map-filter-decomp : \u2200 a \u2192 (a \u2209 \u0394\u03a0' \u00d7 a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) govSt)\n                               \u21d4 (a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081)(filter P? govSt))\n    map-filter-decomp a = mk\u21d4 i (\u03bb h \u2192 ii h , iii h)\n      where\n      i : ((a \u2209 \u0394\u03a0') \u00d7 (a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) govSt))\n          \u2192 a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt)\n      i (a\u2209\u0394\u03a0' , a\u2208) with Inverse.from (map-\u2208\u2194 (GovActionDeposit \u2218 proj\u2081)) a\u2208\n      ... | b , b\u2208 , refl = Inverse.to (map-\u2208\u2194 (GovActionDeposit \u2218 proj\u2081))\n                                       (b , \u2208-filter\u207a P? b\u2208 (a\u2209\u0394\u03a0' \u2218 \u2208-map\u207a-\u2218) , refl)\n\n      ii : a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt) \u2192 a \u2209 \u0394\u03a0'\n      ii a\u2208 a\u2208\u0394\u03a0' with from (\u2208\u02e1-map-filter {l = govSt} {P? = P?}) a\u2208\n      ... | _ , _ , refl , Pb with \u2208-map\u207b' a\u2208\u0394\u03a0'\n      ... | q , refl , q\u2208rem = Pb (to \u2208-map (q , refl , q\u2208rem))\n\n      iii : a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt)\n            \u2192 a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) govSt\n      iii a\u2208 with from (\u2208\u02e1-map-filter {l = govSt} {P? = P?}) a\u2208\n      ... | b , b\u2208 , refl , Pb = Inverse.to (map-\u2208\u2194 (GovActionDeposit \u2218 proj\u2081)) (b , (b\u2208 , refl))\n\n\n    main-invariance-lemma :\n        filter\u02e2 isGADeposit (dom utxoDeps) \u2261\u1d49' fromList (map' (GovActionDeposit \u2218 proj\u2081) govSt)\n        ---------------------------------------------------------------------------------------------------\n      \u2192 filter\u02e2 isGADeposit (dom utxoDeps') \u2261\u1d49' fromList (map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt))\n\n    main-invariance-lemma HYP a = let open R.EquationalReasoning in\n      a \u2208 filter\u02e2 isGADeposit (dom utxoDeps')                          \u223c\u27e8 R.SK-sym \u2208-filter \u27e9\n      (isGADeposit a \u00d7 a \u2208 dom utxoDeps')                              \u223c\u27e8 R.K-refl \u00d7-cong \u2208-res\u1d9c-dom \u27e9\n      (isGADeposit a \u00d7 a \u2209 \u0394\u03a0' \u00d7 \u2203[ q ] (a , q) \u2208 utxoDeps)             \u223c\u27e8 \u00d7-\u21d4-swap \u27e9\n      (a \u2209 \u0394\u03a0' \u00d7 isGADeposit a \u00d7 \u2203[ q ] (a , q) \u2208 utxoDeps)             \u223c\u27e8 R.K-refl \u00d7-cong (R.K-refl \u00d7-cong dom\u2208)\u27e9\n      (a \u2209 \u0394\u03a0' \u00d7 isGADeposit a \u00d7 a \u2208 dom utxoDeps)                      \u223c\u27e8 R.K-refl \u00d7-cong \u2208-filter \u27e9\n      (a \u2209 \u0394\u03a0' \u00d7 a \u2208 filter\u02e2 isGADeposit (dom utxoDeps))                \u223c\u27e8 R.K-refl \u00d7-cong (HYP a) \u27e9\n      (a \u2209 \u0394\u03a0' \u00d7 a \u2208 fromList (map' (GovActionDeposit \u2218 proj\u2081) govSt))  \u223c\u27e8 R.K-refl \u00d7-cong (R.SK-sym \u2208-fromList)\u27e9\n      (a \u2209 \u0394\u03a0' \u00d7 a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) govSt)            \u223c\u27e8 map-filter-decomp a \u27e9\n      a \u2208\u02e1 map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt)           \u223c\u27e8 \u2208-fromList \u27e9\n      a \u2208 fromList (map' (GovActionDeposit \u2218 proj\u2081) (filter P? govSt)) \u220e\n\n    ls\u2081 = record (LStateOf eps')\n           { utxoSt = Pre-POOLREAPUpdate.utxoSt' (LStateOf eps) (EnactStateOf eps) (GovernanceUpdate.updates ((LStateOf eps)) ((RatifyStateOf eps))) }\n\n    open LState\n    open CertState\n\n    retiredDeposits : \u2119 DepositPurpose\n    retiredDeposits = map\u02e2 PoolDeposit ((PStateOf eps) .retiring \u207b\u00b9 e)\n\n    d\u2261PoolDepositA\n      : (d : DepositPurpose)\n      \u2192 d \u2208 dom (DepositsOf ls\u2081 \u2223 retiredDeposits)\n      \u2192 \u2203[ kh ] d \u2261 PoolDeposit kh\n    d\u2261PoolDepositA d d\u2208res =\n      Product.map\u2082 proj\u2081 $\n        \u2208-map\u207b' $       -- (\u2203[ a ] d \u2261 PoolDeposit a \u00d7 a \u2208 _)\n         res-dom d\u2208res  -- d \u2208 retiredDeposits\n      where import Data.Product.Base as Product using (map\u2082)\n\n    noGADepositIsRetired\n      : (d : DepositPurpose)\n      \u2192 d \u2208 dom (DepositsOf ls\u2081 \u2223 retiredDeposits)\n      \u2192 \u00ac isGADeposit d\n    noGADepositIsRetired d d\u2208res dIsGA\n     rewrite (proj\u2082 $ d\u2261PoolDepositA d d\u2208res)\n     with dIsGA\n    ... | ()\n\n    dropRetiredDeposits :\n      filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c)) \u2261\u1d49\n        filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081))\n    dropRetiredDeposits = begin\n      filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c))\n\n        \u2248\u27e8 \u222a-identity\u02e1 _ \u27e8\n\n      \u2205\u02e2 \u222a filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c))\n\n        \u2248\u27e8 \u222a-cong\n             (filter-\u2205 noGADepositIsRetired)\n             (IsEquivalence.refl \u2261\u1d49-isEquivalence)\n         \u27e8\n\n      filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081 \u2223 retiredDeposits))\n      \u222a\n      filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c))\n\n        \u2248\u27e8 filter-hom-\u222a \u27e8\n\n      filter\u02e2 isGADeposit\n        (dom (DepositsOf ls\u2081 \u2223 retiredDeposits)\n         \u222a\n         dom (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c)\n        )\n\n        \u2248\u27e8 filter-cong dom\u222a \u27e8\n\n      filter\u02e2 isGADeposit\n        (dom\n          ((DepositsOf ls\u2081 \u2223 retiredDeposits) \u02e2\n            \u222a\n           (DepositsOf ls\u2081 \u2223 retiredDeposits \u1d9c) \u02e2\n          )\n        )\n\n        \u2248\u27e8 IsEquivalence.refl \u2261\u1d49-isEquivalence \u27e9\n\n      filter\u02e2 isGADeposit\n        (Rel.dom\n          (((DepositsOf ls\u2081 \u02e2) \u2223\u02b3 retiredDeposits)\n            \u222a\n           ((DepositsOf ls\u2081 \u02e2) \u2223\u02b3 retiredDeposits \u1d9c)\n          )\n        )\n\n        \u2248\u27e8 filter-cong $ dom-cong (res-ex-\u222a dec\u00b9) \u27e9\n\n      filter\u02e2 isGADeposit (dom (DepositsOf ls\u2081))\n      \u220e\n\n      where\n        open SetoidReasoning (\u2261\u1d49-Setoid {A = DepositPurpose})\n        open import Relation.Binary using (IsEquivalence)\n        import Axiom.Set.Rel th as Rel\n\n    mainProof\n     : _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n     \u2192 govDepsMatch (LStateOf eps) \u2192 govDepsMatch (LStateOf eps')\n    -- Pattern matching POOLREAP used to be done in EPOCH-govDepsMatch directly.\n    -- However, that made typechecking much slower.\n    mainProof (EPOCH (x , POOLREAP , _)) = poolReapMatch \u2218 ratifiesSnapMatch\n      where\n        ratifiesSnapMatch : govDepsMatch (LStateOf eps) \u2192 govDepsMatch ls\u2081\n        ratifiesSnapMatch =\n          \u2261\u1d49.trans (filter-cong $ dom-cong (res-comp-cong $ \u2261\u1d49.sym \u0394\u03a0'\u2261\u0394\u03a0))\n          \u2218 from \u2261\u1d49\u21d4\u2261\u1d49' \u2218 main-invariance-lemma \u2218 to \u2261\u1d49\u21d4\u2261\u1d49'\n\n        poolReapMatch : govDepsMatch ls\u2081 \u2192 govDepsMatch (LStateOf eps')\n        poolReapMatch = \u2261\u1d49.trans dropRetiredDeposits\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.Properties.NoPropSameDReps.html","title":"NoPropSameDReps","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Epoch.Properties.NoPropSameDReps\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Properties txs abs\n</pre> <p>Claim (DReps unchanged if no gov proposals).</p> <p>Informally.</p> <p>If <code>es</code> is a <code>NewEpochState</code>, and if the <code>GovState</code> of <code>es</code> contains no governance proposals, then the set of <code>activeDReps</code> of <code>es</code> in <code>Epoch</code> <code>e</code> is equal to the set of <code>activeDReps</code> of <code>es</code> in the next epoch.</p> <p>Formally.</p> <pre>prop\u2261\u2205\u21d2activeDReps-const : Epoch \u2192 NewEpochState \u2192 Type\nprop\u2261\u2205\u21d2activeDReps-const e es =\n  GovStateOf es \u2261 [] \u2192 dom (activeDRepsOf es e) \u2261\u1d49 dom (activeDRepsOf es (suc\u1d49 e))\n</pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Epoch.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Epoch.Properties where\n\nopen import Ledger.Conway.Specification.Epoch.Properties.Computational\nopen import Ledger.Conway.Specification.Epoch.Properties.ConstRwds\nopen import Ledger.Conway.Specification.Epoch.Properties.ExpiredDReps\nopen import Ledger.Conway.Specification.Epoch.Properties.GovDepsMatch\nopen import Ledger.Conway.Specification.Epoch.Properties.NoPropSameDReps\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.html","title":"Epoch Boundary","text":"<p>This module introduces the epoch boundary transition system and the related reward calculation.</p> <pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Epoch\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Agda.Builtin.FromNat\n\nimport      Data.Integer as \u2124\nopen import Data.Integer                    using () renaming (+_ to pos)\nopen import Data.Integer.Properties         using (module \u2264-Reasoning; +-mono-\u2264; neg-mono-\u2264; +-identity\u02e1)\n                                            renaming (nonNegative\u207b\u00b9 to nonNegative\u207b\u00b9\u2124)\nopen import Data.Integer.Tactic.RingSolver  using (solve-\u2200)\nopen import Data.Maybe                      using (fromMaybe)\nopen import Data.Nat.GeneralisedArithmetic  using (iterate)\nopen import Data.Rational                   using (\u211a; floor; _*_; _\u00f7_; _/_; _\u2293_; _\u225f_; \u2262-nonZero)\nopen import Data.Rational.Literals          using (number; from\u2124)\nopen import Data.Rational.Properties        using (nonNegative\u207b\u00b9; pos\u21d2nonNeg; \u2293-glb)\n\nopen import stdlib.Data.Rational.Properties using (0\u2264\u21d20\u2264floor; \u00f7-0\u2264\u21d20\u2264; from\u2115-0\u2264; *-0\u2264\u21d20\u2264; from\u2124-0\u2264)\n\nopen import Ledger.Prelude hiding (iterate; _/_; _*_; _\u2293_; _\u225f_; \u2262-nonZero)\nopen import Ledger.Prelude.Numeric.UnitInterval using (fromUnitInterval; UnitInterval-*-0\u2264)\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.PoolReap txs abs\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Specification.Rewards txs abs\nopen import Ledger.Conway.Specification.Utxo txs abs\n\nopen Filter using (filter)\nopen Number number renaming (fromNat to from\u2115)\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#epoch-state","title":"Epoch State","text":"<p>The <code>EpochState</code> type encapsulates the components needed to represent an epoch state.</p> <pre>record EpochState : Type where\n</pre> <pre>  constructor \u27e6_,_,_,_,_\u27e7\u1d49'\n</pre> <pre>  field\n    acnt       : Acnt\n    ss         : Snapshots\n    ls         : LState\n    es         : EnactState\n    fut        : RatifyState\n</pre> <p>Note that the <code>Acnt</code> type has two fields\u2014<code>treasury</code> and <code>reserves</code>.  Thus the <code>acnt</code> field in <code>EpochState</code> can keep track of the total assets that remain in treasury and reserves.</p> <pre>record HasEpochState {a} (A : Type a) : Type a where\n  field EpochStateOf : A \u2192 EpochState\nopen HasEpochState \u2983...\u2984 public\n\ninstance\n  HasSnapshots-EpochState : HasSnapshots EpochState\n  HasSnapshots-EpochState .SnapshotsOf = EpochState.ss\n\n  HasLState-EpochState : HasLState EpochState\n  HasLState-EpochState .LStateOf = EpochState.ls\n\n  HasEnactState-EpochState : HasEnactState EpochState\n  HasEnactState-EpochState .EnactStateOf = EpochState.es\n\n  HasDeposits-EpochState : HasDeposits EpochState\n  HasDeposits-EpochState .DepositsOf = DepositsOf \u2218 LStateOf\n\n  HasDReps-EpochState : HasDReps EpochState\n  HasDReps-EpochState .DRepsOf = DRepsOf \u2218 CertStateOf \u2218 LStateOf\n\n  HasTreasury-EpochState : HasTreasury EpochState\n  HasTreasury-EpochState .TreasuryOf = Acnt.treasury \u2218 EpochState.acnt\n\n  HasReserves-EpochState : HasReserves EpochState\n  HasReserves-EpochState .ReservesOf = Acnt.reserves \u2218 EpochState.acnt\n\n  HasPParams-EpochState : HasPParams EpochState\n  HasPParams-EpochState .PParamsOf = PParamsOf \u2218 EnactStateOf\n\n  HasRatifyState-EpochState : HasRatifyState EpochState\n  HasRatifyState-EpochState .RatifyStateOf = EpochState.fut\n\n  HasPState-EpochState : HasPState EpochState\n  HasPState-EpochState .PStateOf = PStateOf \u2218 CertStateOf \u2218 LStateOf\n</pre> <pre>PoolDelegatedStake : Type\nPoolDelegatedStake = KeyHash \u21c0 Coin\n\nrecord NewEpochState : Type where\n  field\n    lastEpoch   : Epoch\n    bprev       : BlocksMade\n    bcur        : BlocksMade\n    epochState  : EpochState\n    ru          : Maybe RewardUpdate\n    pd          : PoolDelegatedStake\n</pre> Differences with the Shelley Specification <p>The formal specification utilizes the type <code>PoolDelegatedStake</code> in lieu of the derived type <code>PoolDistr</code> (Figure 5, Shelley specification CVG19). The latter can be computed from the former by divinding the associated <code>Coin</code> to each <code>KeyHash</code> by the total stake in the map.</p> <p>In addition, the formal specification omits the VRF key hashes in the codomain of <code>PoolDelegatedStake</code> as they are not implemented at the moment.</p> <pre>record HasNewEpochState {a} (A : Type a) : Type a where\n  field NewEpochStateOf : A \u2192 NewEpochState\nopen HasNewEpochState \u2983...\u2984 public\nrecord HasLastEpoch     {a} (A : Type a) : Type a where field LastEpochOf     : A \u2192 Epoch\nopen HasLastEpoch     \u2983...\u2984 public\n\ninstance\n  HasLastEpoch-NewEpochState : HasLastEpoch NewEpochState\n  HasLastEpoch-NewEpochState .LastEpochOf = NewEpochState.lastEpoch\n\n  HasEpochState-NewEpochState : HasEpochState NewEpochState\n  HasEpochState-NewEpochState .EpochStateOf = NewEpochState.epochState\n\n  HasEnactState-NewEpochState : HasEnactState NewEpochState\n  HasEnactState-NewEpochState .EnactStateOf = EnactStateOf \u2218 EpochStateOf\n\n  Hastreasury-NewEpochState : HasTreasury NewEpochState\n  Hastreasury-NewEpochState .TreasuryOf = TreasuryOf \u2218 EpochStateOf\n\n  HasLState-NewEpochState : HasLState NewEpochState\n  HasLState-NewEpochState .LStateOf = LStateOf \u2218 EpochStateOf\n\n  HasGovState-NewEpochState : HasGovState NewEpochState\n  HasGovState-NewEpochState .GovStateOf = GovStateOf \u2218 LStateOf\n\n  HasCertState-NewEpochState : HasCertState NewEpochState\n  HasCertState-NewEpochState .CertStateOf = CertStateOf \u2218 LStateOf\n\n  HasDReps-NewEpochState : HasDReps NewEpochState\n  HasDReps-NewEpochState .DRepsOf = DRepsOf \u2218 CertStateOf\n\n  HasRewards-NewEpochState : HasRewards NewEpochState\n  HasRewards-NewEpochState .RewardsOf = RewardsOf \u2218 CertStateOf\n\n  HasPParams-NewEpochState : HasPParams NewEpochState\n  HasPParams-NewEpochState .PParamsOf = PParamsOf \u2218 EpochStateOf\n\n  unquoteDecl HasCast-EpochState HasCast-NewEpochState = derive-HasCast\n    ( (quote EpochState     , HasCast-EpochState)\n    \u2237 [ (quote NewEpochState  , HasCast-NewEpochState)])\n\ntoRwdAddr : Credential \u2192 RwdAddr\ntoRwdAddr x = record { net = NetworkId ; stake = x }\n\ngetStakeCred : TxOut \u2192 Maybe Credential\ngetStakeCred (a , _ , _ , _) = stakeCred a\n\nopen GovActionState using (returnAddr)\n\nopaque\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#reward-updates","title":"Reward Updates","text":""},{"location":"Ledger.Conway.Specification.Epoch.html#sec:computing-reward-updates","title":"Computing Reward Updates","text":"<p>This section defines the function <code>createRUpd</code> which creates a <code>RewardUpdate</code>, i.e. the net flow of Ada due to paying out rewards after an epoch:</p> <pre>  createRUpd : \u2115 \u2192 BlocksMade \u2192 EpochState \u2192 Coin \u2192 RewardUpdate\n  createRUpd slotsPerEpoch b es total =\n    record  { \u0394t = \u0394t\u2081\n            ; \u0394r = 0 - \u0394r\u2081 + \u0394r\u2082\n            ; \u0394f = 0 - pos feeSS\n            ; rs = rs\n</pre> <pre>            ; flowConservation = flowConservation\n            ; \u0394t-nonnegative = \u0394t-nonneg\n            ; \u0394f-nonpositive = \u0394f-nonpos\n</pre> <pre>            }\n    where\n      prevPp : PParams\n      prevPp = PParamsOf es\n\n      reserves : Reserves\n      reserves = ReservesOf es\n\n      pstakego : Snapshot\n      pstakego = (SnapshotsOf es) .Snapshots.go\n\n      feeSS : Fees\n      feeSS = FeesOf (SnapshotsOf es)\n\n      stake : Stake\n      stake = StakeOf pstakego\n\n      delegs : StakeDelegs\n      delegs = StakeDelegsOf pstakego\n\n      poolParams : Pools\n      poolParams = PoolsOf pstakego\n\n      blocksMade : \u2115\n      blocksMade = \u2211[ m \u2190 b ] m\n\n      \u03c1 \u03b7 \u03c4 : \u211a\n      \u03c1 = fromUnitInterval (prevPp .PParams.monetaryExpansion)\n      \u03b7 = from\u2115 blocksMade \u00f7\u2080 (from\u2115 slotsPerEpoch * ActiveSlotCoeff)\n      \u03c4 = fromUnitInterval (prevPp .PParams.treasuryCut)\n\n      \u0394r\u2081 rewardPot \u0394t\u2081 R : \u2124\n      \u0394r\u2081 = floor (1 \u2293 \u03b7 * \u03c1 * from\u2115 reserves)\n      rewardPot = pos feeSS + \u0394r\u2081\n      \u0394t\u2081 = floor (from\u2124 rewardPot * \u03c4)\n      R = rewardPot - \u0394t\u2081\n\n      circulation : Coin\n      circulation = total - reserves\n\n      rs : Rewards\n      rs = reward prevPp b (posPart R) poolParams stake delegs circulation\n\n      \u0394r\u2082 : \u2124\n      \u0394r\u2082 = R - pos (\u2211[ c \u2190 rs ] c)\n</pre> <pre>      -- Proofs\n      -- Note: Overloading of + and - seems to interfere with the ring solver.\n      lemmaFlow : \u2200 (t\u2081 r\u2081 f z : \u2124)\n        \u2192 (t\u2081 \u2124.+ (0 \u2124.- r\u2081 \u2124.+ ((f \u2124.+ r\u2081 \u2124.- t\u2081) \u2124.- z)) \u2124.+ (0 \u2124.- f) \u2124.+ z) \u2261 0\n      lemmaFlow = solve-\u2200\n      flowConservation :\n        let t\u2081 = \u0394t\u2081\n            r\u2081 = \u0394r\u2081\n            f  = pos feeSS\n            z  = pos (\u2211[ c \u2190 rs ] c)\n         in\n            (t\u2081 \u2124.+ (0 \u2124.- r\u2081 \u2124.+ ((f \u2124.+ r\u2081 \u2124.- t\u2081) \u2124.- z)) \u2124.+ (0 \u2124.- f) \u2124.+ z) \u2261 0\n      flowConservation = lemmaFlow \u0394t\u2081 \u0394r\u2081 (pos feeSS) (pos (\u2211[ c \u2190 rs ] c))\n\n      \u00f7\u2080-0\u2264\u21d20\u2264 : \u2200 (x y : \u211a) \u2192 0 \u2264 x \u2192 0 \u2264 y \u2192 0 \u2264 (x \u00f7\u2080 y)\n      \u00f7\u2080-0\u2264\u21d20\u2264 x y 0\u2264x 0\u2264y with y \u225f 0\n      ... | (yes y\u22610) = nonNegative\u207b\u00b9 0\n      ... | (no y\u22620)  = \u00f7-0\u2264\u21d20\u2264 x y {{\u2262-nonZero y\u22620}} 0\u2264x 0\u2264y\n\n      \u03b7-nonneg : 0 \u2264 \u03b7\n      \u03b7-nonneg = \u00f7\u2080-0\u2264\u21d20\u2264 _ _ (from\u2115-0\u2264 blocksMade)\n        (*-0\u2264\u21d20\u2264 _ _\n          (from\u2115-0\u2264 slotsPerEpoch)\n          (nonNegative\u207b\u00b9 ActiveSlotCoeff {{pos\u21d2nonNeg ActiveSlotCoeff}}))\n\n      min1\u03b7-nonneg : 0 \u2264 1 \u2293 \u03b7\n      min1\u03b7-nonneg = \u2293-glb (nonNegative\u207b\u00b9 1) \u03b7-nonneg\n\n      \u0394r\u2081-nonneg : 0 \u2264 \u0394r\u2081\n      \u0394r\u2081-nonneg = 0\u2264\u21d20\u2264floor _\n        (*-0\u2264\u21d20\u2264 (1 \u2293 \u03b7 * \u03c1) (from\u2115 reserves)\n          (UnitInterval-*-0\u2264 (1 \u2293 \u03b7) (prevPp .PParams.monetaryExpansion) min1\u03b7-nonneg)\n          (from\u2115-0\u2264 reserves))\n\n      rewardPot-nonneg : 0 \u2264 rewardPot\n      rewardPot-nonneg = +-mono-\u2264 (nonNegative\u207b\u00b9\u2124 (pos feeSS)) \u0394r\u2081-nonneg\n\n      \u0394t-nonneg : 0 \u2264 \u0394t\u2081\n      \u0394t-nonneg = 0\u2264\u21d20\u2264floor _\n        (UnitInterval-*-0\u2264 (from\u2124 rewardPot) (prevPp .PParams.treasuryCut)\n          (from\u2124-0\u2264 rewardPot rewardPot-nonneg))\n\n      \u0394f-nonpos : (0 - pos feeSS) \u2264 0\n      \u0394f-nonpos = begin\n          0 - pos feeSS \u2261\u27e8 +-identity\u02e1 _ \u27e9\n          \u2124.- pos feeSS \u2264\u27e8 neg-mono-\u2264 (\u2124.+\u2264+ z\u2264n) \u27e9\n          0             \u220e\n        where open \u2264-Reasoning\n</pre> <p>Relevant quantities are:</p> <ul> <li> <p><code>prevPp</code>: Previous protocol parameters, which   correspond to the parameters during the epoch for which we are   creating rewards.</p> </li> <li> <p><code>ActiveSlotCoeff</code>: Global constant, equal to the   probability that a party holding all the stake will be selected to be   a leader for given slot. Equals \\(1/20\\) during the Shelley era on the   Cardano Mainnet.</p> </li> <li> <p><code>\u0394r\u2081</code>: Ada taken out of the reserves for paying   rewards, as determined by the <code>monetaryExpansion</code> protocol   parameter.</p> </li> <li> <p><code>rewardPot</code>: Total amount of coin available for rewards   this epoch, as described in Team18.</p> </li> <li> <p><code>feeSS</code>: The fee pot which, together with the reserves,   funds the <code>rewardPot</code>. We use the fee pot that   accumulated during the epoch for which we now compute block production   rewards. Note that fees are not explicitly removed from any account:   the fees come from transactions paying them and are accounted for   whenever transactions are processed.</p> </li> <li> <p><code>\u0394t\u2081</code>: The proportion of the reward pot that will move   to the treasury, as determined by the <code>treasuryCut</code>   protocol parameter. The remaining pot is called the   <code>R</code>, just as in Team18.</p> </li> <li> <p><code>pstakego</code>: Stake distribution used for calculating the   rewards. This is the oldest stake distribution snapshot, labeled   <code>go</code>.</p> </li> <li> <p><code>rs</code>: The rewards, as calculated by the function   <code>reward</code>.</p> </li> <li> <p><code>\u0394r\u2082</code>: The difference between the maximal amount of   rewards that could have been paid out if pools had been optimal, and   the actual rewards paid out. This difference is returned to the   reserves.</p> </li> <li> <p><code>\u00f7\u2080</code>: Division operator that returns zero when the   denominator is zero.</p> </li> </ul>"},{"location":"Ledger.Conway.Specification.Epoch.html#sec:applying-reward-updates","title":"Applying Reward Updates","text":"<p>This section defines the function <code>applyRUpd</code>, which applies a <code>RewardUpdate</code> to the <code>EpochState</code>.</p> <pre>applyRUpd : RewardUpdate \u2192 EpochState \u2192 EpochState\napplyRUpd rewardUpdate $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#12537}{\\htmlId{12537}{\\htmlClass{Bound}{\\text{treasury}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12548}{\\htmlId{12548}{\\htmlClass{Bound}{\\text{reserves}}}}\\, \\end{pmatrix}\n                       \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12585}{\\htmlId{12585}{\\htmlClass{Bound}{\\text{ss}}}}\\,\n                       \\\\ \\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#12617}{\\htmlId{12617}{\\htmlClass{Bound}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12624}{\\htmlId{12624}{\\htmlClass{Bound}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12631}{\\htmlId{12631}{\\htmlClass{Bound}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12642}{\\htmlId{12642}{\\htmlClass{Bound}{\\text{donations}}}}\\, \\end{pmatrix}\n                         \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12682}{\\htmlId{12682}{\\htmlClass{Bound}{\\text{govSt}}}}\\,\n                         \\\\ \\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#12719}{\\htmlId{12719}{\\htmlClass{Bound}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12732}{\\htmlId{12732}{\\htmlClass{Bound}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12746}{\\htmlId{12746}{\\htmlClass{Bound}{\\text{rewards}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12759}{\\htmlId{12759}{\\htmlClass{Bound}{\\text{pState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12768}{\\htmlId{12768}{\\htmlClass{Bound}{\\text{gState}}}}\\, \\end{pmatrix} \\end{pmatrix}\n                       \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12807}{\\htmlId{12807}{\\htmlClass{Bound}{\\text{es}}}}\\,\n                       \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12835}{\\htmlId{12835}{\\htmlClass{Bound}{\\text{fut}}}}\\,\n                       \\end{pmatrix}$ = $\\begin{pmatrix} \\begin{pmatrix} \\,\\href{Prelude.html#3352}{\\htmlId{12872}{\\htmlClass{Function}{\\text{posPart}}}}\\, \\,\\htmlId{12880}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Epoch.html#656}{\\htmlId{12881}{\\htmlClass{InductiveConstructor}{\\text{pos}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#12537}{\\htmlId{12885}{\\htmlClass{Bound}{\\text{treasury}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{12894}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Rewards.html#18002}{\\htmlId{12896}{\\htmlClass{Function}{\\text{\u0394t}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{12899}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#656}{\\htmlId{12901}{\\htmlClass{InductiveConstructor}{\\text{pos}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#13456}{\\htmlId{12905}{\\htmlClass{Function}{\\text{unregRU'}}}}\\,\\,\\htmlId{12913}{\\htmlClass{Symbol}{\\text{)}}}\\,\n                               \\\\ \\,\\href{Prelude.html#3352}{\\htmlId{12948}{\\htmlClass{Function}{\\text{posPart}}}}\\, \\,\\htmlId{12956}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Epoch.html#656}{\\htmlId{12957}{\\htmlClass{InductiveConstructor}{\\text{pos}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#12548}{\\htmlId{12961}{\\htmlClass{Bound}{\\text{reserves}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{12970}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Rewards.html#18005}{\\htmlId{12972}{\\htmlClass{Function}{\\text{\u0394r}}}}\\,\\,\\htmlId{12974}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}\n                             \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12585}{\\htmlId{13009}{\\htmlClass{Bound}{\\text{ss}}}}\\,\n                             \\\\ \\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#12617}{\\htmlId{13047}{\\htmlClass{Bound}{\\text{utxo}}}}\\, \\\\ \\,\\href{Prelude.html#3352}{\\htmlId{13054}{\\htmlClass{Function}{\\text{posPart}}}}\\, \\,\\htmlId{13062}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Epoch.html#656}{\\htmlId{13063}{\\htmlClass{InductiveConstructor}{\\text{pos}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#12624}{\\htmlId{13067}{\\htmlClass{Bound}{\\text{fees}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{13072}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Rewards.html#18008}{\\htmlId{13074}{\\htmlClass{Function}{\\text{\u0394f}}}}\\,\\,\\htmlId{13076}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12631}{\\htmlId{13080}{\\htmlClass{Bound}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12642}{\\htmlId{13091}{\\htmlClass{Bound}{\\text{donations}}}}\\, \\end{pmatrix}\n                               \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12682}{\\htmlId{13136}{\\htmlClass{Bound}{\\text{govSt}}}}\\,\n                               \\\\ \\begin{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#12719}{\\htmlId{13179}{\\htmlClass{Bound}{\\text{voteDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12732}{\\htmlId{13192}{\\htmlClass{Bound}{\\text{stakeDelegs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12746}{\\htmlId{13206}{\\htmlClass{Bound}{\\text{rewards}}}}\\, \\,\\href{Axiom.Set.Map.Dec.html#2149}{\\htmlId{13214}{\\htmlClass{Function Operator}{\\text{\u222a\u207a}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#13388}{\\htmlId{13217}{\\htmlClass{Function}{\\text{regRU}}}}\\, \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12759}{\\htmlId{13227}{\\htmlClass{Bound}{\\text{pState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12768}{\\htmlId{13236}{\\htmlClass{Bound}{\\text{gState}}}}\\, \\end{pmatrix} \\end{pmatrix}\n                             \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12807}{\\htmlId{13278}{\\htmlClass{Bound}{\\text{es}}}}\\,\n                             \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#12835}{\\htmlId{13312}{\\htmlClass{Bound}{\\text{fut}}}}\\, \\end{pmatrix}$\n  where\n    open RewardUpdate rewardUpdate using (\u0394t; \u0394r; \u0394f; rs)\n    regRU     = rs \u2223 dom rewards\n    unregRU   = rs \u2223 dom rewards \u1d9c\n    unregRU'  = \u2211[ x \u2190 unregRU ] x\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#sec:stake-distributions","title":"Stake Distributions","text":"<p>This section defines the functions <code>calculatePoolDelegatedState</code>, <code>calculateVDelegDelegatedStake</code>, and <code>mkStakeDistrs</code>, which calculates stake distributions for voting purposes.</p> <pre>open RwdAddr using (stake)\nopaque\n</pre> <pre>  calculatePoolDelegatedStake\n    : Snapshot\n    \u2192 PoolDelegatedStake\n  calculatePoolDelegatedStake ss =\n      -- Shelley spec: the output map must contain keys appearing in both\n      -- sd and the pool parameters.\n      sd \u2223 dom (PoolsOf ss)\n    where\n      -- stake credentials delegating to each pool\n      stakeCredentialsPerPool : Rel KeyHash Credential\n      stakeCredentialsPerPool = (StakeDelegsOf ss \u02e2) \u207b\u00b9\u02b3\n\n      -- delegated stake per pool\n      sd : KeyHash \u21c0 Coin\n      sd = aggregate\u208a ((stakeCredentialsPerPool \u2218\u02b3 (StakeOf ss \u02e2)) \u1da0\u02e2)\n</pre> <p>The function <code>calculatePoolDelegatedState</code> calculates the delegated stake to <code>SPOs</code>.  This function is used both in the <code>EPOCH</code> rule (via <code>calculatePoolDelegatedStateForVoting</code>, see below) and in the <code>NEWEPOCH</code> rule.</p> <pre>  stakeFromGADeposits\n    : GovState\n    \u2192 UTxOState\n    \u2192 Stake\n  stakeFromGADeposits govSt utxoSt = aggregateBy\n     (map\u02e2 (\u03bb (gaid , addr) \u2192 (gaid , addr) , stake addr) govSt')\n     (mapFromPartialFun (\u03bb (gaid , _) \u2192 lookup\u1d50? deposits (GovActionDeposit gaid)) govSt')\n     where\n       open UTxOState utxoSt\n\n       govSt' : \u2119 (GovActionID \u00d7 RwdAddr)\n       govSt' = map\u02e2 (map\u2082 returnAddr) (fromList govSt)\n</pre> <p>The function <code>stakeFromGADeposits</code> computes the stake pertaining to governance action deposits. It returns a map which, for each governance action, maps its <code>returnAddr</code> (as a staking credential) to the deposit.</p> <pre>module VDelegDelegatedStake\n  (currentEpoch : Epoch)\n  (utxoSt       : UTxOState)\n  (govSt        : GovState)\n  (gState       : GState)\n  (dState       : DState)\n  where\n\n  activeDReps : \u2119 Credential\n  activeDReps = dom (activeDRepsOf gState currentEpoch)\n\n  activeVDelegs : \u2119 VDeleg\n  activeVDelegs = map\u02e2 vDelegCredential activeDReps \u222a \u2774 vDelegNoConfidence \u2775 \u222a \u2774 vDelegAbstain \u2775\n\n  -- compute the stake for a credential\n  stakePerCredential : Credential \u2192 Coin\n  stakePerCredential c = cbalance ((UTxOOf utxoSt) \u2223^' \u03bb txout \u2192 getStakeCred txout \u2261 just c)\n                         + fromMaybe 0 (lookup\u1d50? (stakeFromGADeposits govSt utxoSt) c)\n                         + fromMaybe 0 (lookup\u1d50? (RewardsOf dState) c)\n\n  calculate : VDeleg \u21c0 Coin\n  calculate = mapFromFun (\u03bb vd \u2192 \u2211\u02e2[ c \u2190 (VoteDelegsOf dState) \u207b\u00b9 vd ] (stakePerCredential c))\n                         activeVDelegs\n</pre> <pre>opaque\n</pre> <pre>  calculateVDelegDelegatedStake\n    : Epoch\n    \u2192 UTxOState\n    \u2192 GovState\n    \u2192 GState\n    \u2192 DState\n    \u2192 VDeleg \u21c0 Coin\n  calculateVDelegDelegatedStake = VDelegDelegatedStake.calculate\n</pre> <pre>opaque\n</pre> <pre>  calculatePoolDelegatedStakeForVoting\n    : Snapshot\n    \u2192 UTxOState\n    \u2192 GovState\n    \u2192 KeyHash \u21c0 Coin\n  calculatePoolDelegatedStakeForVoting ss utxoSt govSt\n    = calculatePoolDelegatedStake ss \u222a\u207a (stakeFromDeposits \u2223 dom (PoolsOf ss))\n    where\n      stakeFromDeposits : KeyHash \u21c0 Coin\n      stakeFromDeposits = aggregate\u208a (((StakeDelegsOf ss \u02e2) \u207b\u00b9\u02b3\n                                      \u2218\u02b3 (stakeFromGADeposits govSt utxoSt \u02e2)) \u1da0\u02e2)\n</pre> <p>The function <code>calculatePoolDelegatedStakeForVoting</code> computes the delegated stake to <code>SPOs</code> that will be used for counting votes. It complements the result of <code>calculatePoolDelegatedStake</code> with the deposits made to governance actions.</p> Erratum <p>CIP-1694 specifies that deposits of governance actions should count towards the stake for voting purposes:</p> <p>The deposit amount will be added to the deposit pot, similar to stake key deposits. It will also be counted towards the stake of the reward address it will be paid back to, to not reduce the submitter's voting power to vote on their own (and competing) actions.</p> <p>While originally intended for <code>DReps</code> only, the Haskell implementation and the formal specification count deposits on governance actions towards the stake of <code>SPOs</code> as well.</p> <pre>mkStakeDistrs\n  : Snapshot\n  \u2192 Epoch\n  \u2192 UTxOState\n  \u2192 GovState\n  \u2192 GState\n  \u2192 DState\n  \u2192 StakeDistrs\nmkStakeDistrs ss currentEpoch utxoSt govSt gState dState =\n  $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#16268}{\\htmlId{18113}{\\htmlClass{Function}{\\text{calculateVDelegDelegatedStake}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18067}{\\htmlId{18143}{\\htmlClass{Bound}{\\text{currentEpoch}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18080}{\\htmlId{18156}{\\htmlClass{Bound}{\\text{utxoSt}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18087}{\\htmlId{18163}{\\htmlClass{Bound}{\\text{govSt}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18093}{\\htmlId{18169}{\\htmlClass{Bound}{\\text{gState}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18100}{\\htmlId{18176}{\\htmlClass{Bound}{\\text{dState}}}}\\,\n  \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#16494}{\\htmlId{18187}{\\htmlClass{Function}{\\text{calculatePoolDelegatedStakeForVoting}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18064}{\\htmlId{18224}{\\htmlClass{Bound}{\\text{ss}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18080}{\\htmlId{18227}{\\htmlClass{Bound}{\\text{utxoSt}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18087}{\\htmlId{18234}{\\htmlClass{Bound}{\\text{govSt}}}}\\, \\end{pmatrix}$\n</pre> <pre>private variable\n  e lastEpoch : Epoch\n  fut fut' : RatifyState\n  poolReapState : PoolReapState\n  eps eps' eps'' : EpochState\n  ls : LState\n  es\u2080 : EnactState\n  mark set go : Snapshot\n  feeSS : Fees\n  lstate : LState\n  pState'' : PState\n  dState' : DState\n  acnt acnt' : Acnt\n  utxoSt'' : UTxOState\n  ss ss' : Snapshots\n  ru : RewardUpdate\n  mru : Maybe RewardUpdate\n  pd : PoolDelegatedStake\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#sec:the-epoch-transition-system","title":"The EPOCH Transition System","text":"<p>The <code>EPOCH</code> transition system updates several parts of the <code>EpochState</code>. We encapsulate these updates using Agda's module system. This modularization reduces typechecking times and helps strucuturing proofs about properties of the <code>EPOCH</code> transition system.</p>"},{"location":"Ledger.Conway.Specification.Epoch.html#update-modules-and-functions","title":"Update Modules and Functions","text":"<p>We organize the <code>EPOCH</code> rule around three modules.</p> <ul> <li> <p><code>GovernanceUpdate</code> is used to compute the set of governance   actions to be removed and update the governance state accordingly;</p> </li> <li> <p><code>Pre-POOLREAPUpdate</code> is used to update the <code>PState</code>, <code>GState</code>   and <code>utxoSt</code> which are the inputs to the <code>POOLREAP</code> transition   system;</p> </li> <li> <p><code>Post-POOLREAPUpdate</code> is used to update <code>Acnt</code> and <code>DState</code> from   the output of <code>POOLREAP</code> part of which is in the environment of   the <code>RATIFY</code> transition system and part of which belongs to the   returned <code>EpochState</code>.</p> </li> </ul>"},{"location":"Ledger.Conway.Specification.Epoch.html#helper-functions","title":"Helper Functions","text":"<pre>getOrphans : EnactState \u2192 GovState \u2192 GovState\ngetOrphans es govSt = proj\u2081 $ iterate step ([] , govSt) (length govSt)\n  where\n    step : GovState \u00d7 GovState \u2192 GovState \u00d7 GovState\n    step (orps , govSt) =\n      let\n        isOrphan? a prev = \u00ac? (hasParent? es govSt a prev)\n        (orps' , govSt') = partition\n          (\u03bb (_ , record {action = a ; prevAction = prev}) \u2192 isOrphan? (a .gaType) prev)\n          govSt\n      in\n        (orps ++ orps' , govSt')\n\nrecord Governance-Update : Type where\n  constructor GovernanceUpdate\n  field\n    removedGovActions : \u2119 (RwdAddr \u00d7 DepositPurpose \u00d7 Coin)\n    govSt'            : GovState\n\nmodule GovernanceUpdate (ls : LState)\n                        (fut : RatifyState)\n                        where\n</pre> <pre>  open LState ls\n  open RatifyState fut\n</pre> <pre>  tmpGovSt : GovState\n  tmpGovSt = filter (\u03bb x \u2192 proj\u2081 x \u2209 map\u02e2 proj\u2081 removed) govSt\n\n  orphans : \u2119 (GovActionID \u00d7 GovActionState)\n  orphans  = fromList (getOrphans es tmpGovSt)\n\n  removed' : \u2119 (GovActionID \u00d7 GovActionState)\n  removed' = removed \u222a orphans\n\n  removedGovActions : \u2119 (RwdAddr \u00d7 DepositPurpose \u00d7 Coin)\n  removedGovActions =\n    flip concatMap\u02e2 removed' \u03bb (gaid , gaSt) \u2192\n      map\u02e2\n        (returnAddr gaSt ,_)\n        ((DepositsOf utxoSt \u2223 \u2774 GovActionDeposit gaid \u2775) \u02e2)\n\n  govSt' : GovState\n  govSt' = filter (\u03bb x \u2192 proj\u2081 x \u2209 map\u02e2 proj\u2081 removed') govSt\n\n  updates : Governance-Update\n  updates = GovernanceUpdate removedGovActions govSt'\n\nrecord Pre-POOLREAP-Update : Type where\n  inductive\n  constructor Pre-POOLREAPUpdate\n  field\n    pState' : PState\n    gState' : GState\n    utxoSt' : UTxOState\n\nmodule Pre-POOLREAPUpdate (ls : LState)\n                          (es : EnactState)\n                          (govUpdate : Governance-Update)\n                          where\n</pre> <pre>  open LState ls\n  open CertState certState using (pState; gState)\n  open PState pState\n  open Governance-Update govUpdate\n</pre> <pre>  utxoSt' : UTxOState\n  utxoSt' = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Transaction.html#4490}{\\htmlId{21786}{\\htmlClass{Field}{\\text{UTxOOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1408}{\\htmlId{21793}{\\htmlClass{Function}{\\text{utxoSt}}}}\\, \\\\ \\,\\href{Ledger.Prelude.Base.html#765}{\\htmlId{21802}{\\htmlClass{Field}{\\text{FeesOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1408}{\\htmlId{21809}{\\htmlClass{Function}{\\text{utxoSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#1154}{\\htmlId{21818}{\\htmlClass{Field}{\\text{DepositsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1408}{\\htmlId{21829}{\\htmlClass{Function}{\\text{utxoSt}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{21836}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{abstract-set-theory.FiniteSetTheory.html#519}{\\htmlId{21838}{\\htmlClass{Function}{\\text{map\u02e2}}}}\\, \\,\\htmlId{21843}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Data.Product.Base.html#636}{\\htmlId{21844}{\\htmlClass{Field}{\\text{proj\u2081}}}}\\, \\,\\href{Function.Base.html#1134}{\\htmlId{21850}{\\htmlClass{Function Operator}{\\text{\u2218}}}}\\, \\,\\href{Data.Product.Base.html#650}{\\htmlId{21852}{\\htmlClass{Field}{\\text{proj\u2082}}}}\\,\\,\\htmlId{21857}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#20332}{\\htmlId{21859}{\\htmlClass{Field}{\\text{removedGovActions}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{21877}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\\\ \\,\\htmlId{21881}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$\n\n  pState' : PState\n  pState' = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Certs.html#4420}{\\htmlId{21919}{\\htmlClass{Function}{\\text{fPools}}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{21926}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{21929}{\\htmlClass{Function}{\\text{pools}}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{21937}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4442}{\\htmlId{21941}{\\htmlClass{Function}{\\text{retiring}}}}\\, \\end{pmatrix}$\n\n  gState' : GState\n  gState' =\n    $\\begin{pmatrix} \\,\\htmlId{21990}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Class.ToBool.html#342}{\\htmlId{21991}{\\htmlClass{Function Operator}{\\text{if}}}}\\, \\,\\href{Data.List.Base.html#4681}{\\htmlId{21994}{\\htmlClass{Function}{\\text{null}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#20392}{\\htmlId{21999}{\\htmlClass{Field}{\\text{govSt'}}}}\\, \\,\\href{Class.ToBool.html#342}{\\htmlId{22006}{\\htmlClass{Function Operator}{\\text{then}}}}\\, \\,\\href{Axiom.Set.Map.html#7106}{\\htmlId{22011}{\\htmlClass{Function}{\\text{mapValues}}}}\\, \\,\\href{Ledger.Core.Specification.Epoch.html#1150}{\\htmlId{22021}{\\htmlClass{Function}{\\text{suc\u1d49}}}}\\, \\,\\htmlId{22026}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Actions.html#14319}{\\htmlId{22027}{\\htmlClass{Field}{\\text{DRepsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#4774}{\\htmlId{22035}{\\htmlClass{Function}{\\text{gState}}}}\\,\\,\\htmlId{22041}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Class.ToBool.html#342}{\\htmlId{22043}{\\htmlClass{Function Operator}{\\text{else}}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#14319}{\\htmlId{22048}{\\htmlClass{Field}{\\text{DRepsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#4774}{\\htmlId{22056}{\\htmlClass{Function}{\\text{gState}}}}\\,\\,\\htmlId{22062}{\\htmlClass{Symbol}{\\text{)}}}\\,\n    \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#1778}{\\htmlId{22070}{\\htmlClass{Field}{\\text{CCHotKeysOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#4774}{\\htmlId{22082}{\\htmlClass{Function}{\\text{gState}}}}\\, \\,\\href{Axiom.Set.Map.html#13534}{\\htmlId{22089}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.Enact.html#2583}{\\htmlId{22091}{\\htmlClass{Function}{\\text{ccCreds}}}}\\, \\,\\htmlId{22099}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Enact.html#1670}{\\htmlId{22100}{\\htmlClass{Field}{\\text{EnactState.cc}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#21487}{\\htmlId{22114}{\\htmlClass{Bound}{\\text{es}}}}\\,\\,\\htmlId{22116}{\\htmlClass{Symbol}{\\text{)}}}\\,\n    \\end{pmatrix}$\n\n  updates : Pre-POOLREAP-Update\n  updates = Pre-POOLREAPUpdate pState' gState' utxoSt'\n\nrecord Post-POOLREAP-Update : Type where\n  inductive\n  constructor Post-POOLREAPUpdate\n  field\n    dState''       : DState\n    acnt''         : Acnt\n\nmodule Post-POOLREAPUpdate (es : EnactState)\n                           (ls : LState)\n                           (dState' : DState)\n                           (acnt' : Acnt)\n                           (govUpd : Governance-Update)\n                           where\n</pre> <pre>  open LState\n  open Governance-Update govUpd\n</pre> <pre>  opaque\n    govActionReturns : RwdAddr \u21c0 Coin\n    govActionReturns =\n      aggregate\u208a (map\u02e2 (\u03bb (a , _ , d) \u2192 a , d) removedGovActions \u1da0\u02e2)\n\n    payout : RwdAddr \u21c0 Coin\n    payout = govActionReturns \u222a\u207a WithdrawalsOf es\n\n  opaque\n    refunds : Credential \u21c0 Coin\n    refunds = pullbackMap payout toRwdAddr (dom (RewardsOf dState'))\n\n  dState'' : DState\n  dState'' = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#7079}{\\htmlId{23070}{\\htmlClass{Field}{\\text{VoteDelegsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#22477}{\\htmlId{23083}{\\htmlClass{Bound}{\\text{dState'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#2193}{\\htmlId{23093}{\\htmlClass{Field}{\\text{StakeDelegsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#22477}{\\htmlId{23107}{\\htmlClass{Bound}{\\text{dState'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#2028}{\\htmlId{23117}{\\htmlClass{Field}{\\text{RewardsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#22477}{\\htmlId{23127}{\\htmlClass{Bound}{\\text{dState'}}}}\\, \\,\\href{Axiom.Set.Map.Dec.html#2149}{\\htmlId{23135}{\\htmlClass{Function Operator}{\\text{\u222a\u207a}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#22937}{\\htmlId{23138}{\\htmlClass{Function}{\\text{refunds}}}}\\, \\end{pmatrix}$\n\n  unclaimed : Coin\n  unclaimed = getCoin payout - getCoin refunds\n\n  totWithdrawals : Coin\n  totWithdrawals = \u2211[ x \u2190 WithdrawalsOf es ] x\n\n  acnt'' : Acnt\n  acnt'' = $\\begin{pmatrix} \\,\\href{Ledger.Prelude.Base.html#985}{\\htmlId{23317}{\\htmlClass{Field}{\\text{TreasuryOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#22523}{\\htmlId{23328}{\\htmlClass{Bound}{\\text{acnt'}}}}\\, \\,\\href{Data.Nat.Base.html#4462}{\\htmlId{23334}{\\htmlClass{Primitive Operator}{\\text{\u2238}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#23218}{\\htmlId{23336}{\\htmlClass{Function}{\\text{totWithdrawals}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{23351}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Prelude.Base.html#650}{\\htmlId{23353}{\\htmlClass{Field}{\\text{DonationsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#22436}{\\htmlId{23365}{\\htmlClass{Bound}{\\text{ls}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{23368}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#23151}{\\htmlId{23370}{\\htmlClass{Function}{\\text{unclaimed}}}}\\, \\\\ \\,\\href{Ledger.Prelude.Base.html#869}{\\htmlId{23382}{\\htmlClass{Field}{\\text{ReservesOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#22523}{\\htmlId{23393}{\\htmlClass{Bound}{\\text{acnt'}}}}\\, \\end{pmatrix}$\n\n  updates : Post-POOLREAP-Update\n  updates = Post-POOLREAPUpdate dState'' acnt''\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#transition-rule","title":"Transition Rule","text":"<p>This section defines the <code>EPOCH</code> transition rule.</p> <p>In Conway, the <code>EPOCH</code> rule invokes <code>RATIFIES</code>, and carries out the following tasks:</p> <ul> <li> <p>payout all the enacted treasury withdrawals;</p> </li> <li> <p>remove expired and enacted governance actions, and refund deposits;</p> </li> <li> <p>if <code>govSt\u2019</code> is empty, increment the activity counter for    <code>DReps</code>;</p> </li> <li> <p>remove all hot keys from the constitutional committee delegation map    that do not belong to currently elected members;</p> </li> <li> <p>Apply the resulting enact state from the previous epoch boundary    <code>fut</code> and store the resulting enact state    <code>fut\u2019</code>.</p> </li> </ul> <pre>data _\u22a2_\u21c0\u2987_,EPOCH\u2988_ : \u22a4 \u2192 EpochState \u2192 Epoch \u2192 EpochState \u2192 Type where\n</pre> <pre>  EPOCH :\n    let\n      es = EnactStateOf fut\n\n      govUpd : Governance-Update\n      govUpd = GovernanceUpdate.updates ls fut\n\n      Pre-POOLREAPUpdate pState' gState' utxoSt' = Pre-POOLREAPUpdate.updates ls es govUpd\n      Post-POOLREAPUpdate dState'' acnt'' = Post-POOLREAPUpdate.updates es ls dState' acnt' govUpd\n\n      es' : EnactState\n      es' = record es { withdrawals = \u2205 }\n\n      govSt' : GovState\n      govSt' = Governance-Update.govSt' govUpd\n\n      stakeDistrs : StakeDistrs\n      stakeDistrs = mkStakeDistrs (Snapshots.mark ss') e utxoSt'\n                                  govSt' (GStateOf ls) (DStateOf ls)\n\n      \u0393 : RatifyEnv\n      \u0393 = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#24752}{\\htmlId{24945}{\\htmlClass{Bound}{\\text{stakeDistrs}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18279}{\\htmlId{24959}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#14319}{\\htmlId{24963}{\\htmlClass{Field}{\\text{DRepsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18388}{\\htmlId{24971}{\\htmlClass{Generalizable}{\\text{ls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#1778}{\\htmlId{24976}{\\htmlClass{Field}{\\text{CCHotKeysOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18388}{\\htmlId{24988}{\\htmlClass{Generalizable}{\\text{ls}}}}\\, \\\\ \\,\\href{Ledger.Prelude.Base.html#985}{\\htmlId{24993}{\\htmlClass{Field}{\\text{TreasuryOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#24543}{\\htmlId{25004}{\\htmlClass{Bound}{\\text{acnt''}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#1863}{\\htmlId{25013}{\\htmlClass{Field}{\\text{PoolsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18388}{\\htmlId{25021}{\\htmlClass{Generalizable}{\\text{ls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#7079}{\\htmlId{25026}{\\htmlClass{Field}{\\text{VoteDelegsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18388}{\\htmlId{25039}{\\htmlClass{Generalizable}{\\text{ls}}}}\\, \\end{pmatrix}$\n\n    in\n        ls \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n      \u2219 _  \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#24458}{\\htmlId{25100}{\\htmlClass{Bound}{\\text{utxoSt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18518}{\\htmlId{25110}{\\htmlClass{Generalizable}{\\text{acnt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#4990}{\\htmlId{25117}{\\htmlClass{Field}{\\text{DStateOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18388}{\\htmlId{25126}{\\htmlClass{Generalizable}{\\text{ls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#24442}{\\htmlId{25131}{\\htmlClass{Bound}{\\text{pState'}}}}\\, \\end{pmatrix}$ \u21c0\u2987 e ,POOLREAP\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#18538}{\\htmlId{25159}{\\htmlClass{Generalizable}{\\text{utxoSt''}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18523}{\\htmlId{25170}{\\htmlClass{Generalizable}{\\text{acnt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18499}{\\htmlId{25178}{\\htmlClass{Generalizable}{\\text{dState'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18479}{\\htmlId{25188}{\\htmlClass{Generalizable}{\\text{pState''}}}}\\, \\end{pmatrix}$\n      \u2219 \u0393  \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#24614}{\\htmlId{25214}{\\htmlClass{Bound}{\\text{es'}}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{25220}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\href{Agda.Builtin.Bool.html#192}{\\htmlId{25224}{\\htmlClass{InductiveConstructor}{\\text{false}}}}\\, \\end{pmatrix}$ \u21c0\u2987 govSt' ,RATIFIES\u2988 fut'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#18518}{\\htmlId{25323}{\\htmlClass{Generalizable}{\\text{acnt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18561}{\\htmlId{25330}{\\htmlClass{Generalizable}{\\text{ss}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18388}{\\htmlId{25335}{\\htmlClass{Generalizable}{\\text{ls}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18402}{\\htmlId{25340}{\\htmlClass{Generalizable}{\\text{es\u2080}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18301}{\\htmlId{25346}{\\htmlClass{Generalizable}{\\text{fut}}}}\\, \\end{pmatrix}$ \u21c0\u2987 e ,EPOCH\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#24543}{\\htmlId{25367}{\\htmlClass{Bound}{\\text{acnt''}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18564}{\\htmlId{25376}{\\htmlClass{Generalizable}{\\text{ss'}}}}\\, \\\\ \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#18538}{\\htmlId{25384}{\\htmlClass{Generalizable}{\\text{utxoSt''}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#24680}{\\htmlId{25395}{\\htmlClass{Bound}{\\text{govSt'}}}}\\, \\\\ \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#24534}{\\htmlId{25406}{\\htmlClass{Bound}{\\text{dState''}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18479}{\\htmlId{25417}{\\htmlClass{Generalizable}{\\text{pState''}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#24450}{\\htmlId{25428}{\\htmlClass{Bound}{\\text{gState'}}}}\\, \\end{pmatrix} \\end{pmatrix} \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#24614}{\\htmlId{25444}{\\htmlClass{Bound}{\\text{es'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18305}{\\htmlId{25450}{\\htmlClass{Generalizable}{\\text{fut'}}}}\\, \\end{pmatrix}$\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#sec:the-newepoch-transition-system","title":"The NEWEPOCH Transition System","text":"<p>Finally, we define the <code>NEWEPOCH</code> transition system, which computes the new state as of the start of a new epoch.</p> <pre>data _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_ : \u22a4 \u2192 NewEpochState \u2192 Epoch \u2192 NewEpochState \u2192 Type where\n\n  NEWEPOCH-New : \u2200 {bprev bcur : BlocksMade} \u2192\n    let\n      eps' = applyRUpd ru eps\n      ss   = EpochState.ss eps''\n      pd'  = calculatePoolDelegatedStake (Snapshots.set ss)\n    in\n      \u2219 e \u2261 lastEpoch + 1\n      \u2219 _ \u22a2 eps' \u21c0\u2987 e ,EPOCH\u2988 eps''\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#18281}{\\htmlId{26100}{\\htmlClass{Generalizable}{\\text{lastEpoch}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#25808}{\\htmlId{26112}{\\htmlClass{Bound}{\\text{bprev}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#25814}{\\htmlId{26120}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18358}{\\htmlId{26127}{\\htmlClass{Generalizable}{\\text{eps}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#173}{\\htmlId{26133}{\\htmlClass{InductiveConstructor}{\\text{just}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#18582}{\\htmlId{26138}{\\htmlClass{Generalizable}{\\text{ru}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18629}{\\htmlId{26143}{\\htmlClass{Generalizable}{\\text{pd}}}}\\, \\end{pmatrix}$ \u21c0\u2987 e ,NEWEPOCH\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#18279}{\\htmlId{26166}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#25814}{\\htmlId{26170}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Axiom.Set.Map.html#2671}{\\htmlId{26177}{\\htmlClass{Function}{\\text{\u2205\u1d50}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18367}{\\htmlId{26183}{\\htmlClass{Generalizable}{\\text{eps''}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#194}{\\htmlId{26191}{\\htmlClass{InductiveConstructor}{\\text{nothing}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#25912}{\\htmlId{26201}{\\htmlClass{Bound}{\\text{pd'}}}}\\, \\end{pmatrix}$\n\n  NEWEPOCH-Not-New : \u2200 {bprev bcur : BlocksMade} \u2192\n    \u2219 e \u2262 lastEpoch + 1\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#18281}{\\htmlId{26348}{\\htmlClass{Generalizable}{\\text{lastEpoch}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#26232}{\\htmlId{26360}{\\htmlClass{Bound}{\\text{bprev}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#26238}{\\htmlId{26368}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18358}{\\htmlId{26375}{\\htmlClass{Generalizable}{\\text{eps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18602}{\\htmlId{26381}{\\htmlClass{Generalizable}{\\text{mru}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18629}{\\htmlId{26387}{\\htmlClass{Generalizable}{\\text{pd}}}}\\, \\end{pmatrix}$ \u21c0\u2987 e ,NEWEPOCH\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#18281}{\\htmlId{26410}{\\htmlClass{Generalizable}{\\text{lastEpoch}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#26232}{\\htmlId{26422}{\\htmlClass{Bound}{\\text{bprev}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#26238}{\\htmlId{26430}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18358}{\\htmlId{26437}{\\htmlClass{Generalizable}{\\text{eps}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18602}{\\htmlId{26443}{\\htmlClass{Generalizable}{\\text{mru}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18629}{\\htmlId{26449}{\\htmlClass{Generalizable}{\\text{pd}}}}\\, \\end{pmatrix}$\n\n  NEWEPOCH-No-Reward-Update : \u2200 {bprev bcur : BlocksMade} \u2192\n    let\n      ss  = EpochState.ss eps'\n      pd' = calculatePoolDelegatedStake (Snapshots.set ss)\n    in\n      \u2219 e \u2261 lastEpoch + 1\n      \u2219 _ \u22a2 eps \u21c0\u2987 e ,EPOCH\u2988 eps'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      _ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#18281}{\\htmlId{26745}{\\htmlClass{Generalizable}{\\text{lastEpoch}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#26488}{\\htmlId{26757}{\\htmlClass{Bound}{\\text{bprev}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#26494}{\\htmlId{26765}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18358}{\\htmlId{26772}{\\htmlClass{Generalizable}{\\text{eps}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#194}{\\htmlId{26778}{\\htmlClass{InductiveConstructor}{\\text{nothing}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18629}{\\htmlId{26788}{\\htmlClass{Generalizable}{\\text{pd}}}}\\, \\end{pmatrix}$ \u21c0\u2987 e ,NEWEPOCH\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Epoch.html#18279}{\\htmlId{26811}{\\htmlClass{Generalizable}{\\text{e}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#26494}{\\htmlId{26815}{\\htmlClass{Bound}{\\text{bcur}}}}\\, \\\\ \\,\\href{Axiom.Set.Map.html#2671}{\\htmlId{26822}{\\htmlClass{Function}{\\text{\u2205\u1d50}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#18362}{\\htmlId{26827}{\\htmlClass{Generalizable}{\\text{eps'}}}}\\, \\\\ \\,\\href{Agda.Builtin.Maybe.html#194}{\\htmlId{26834}{\\htmlClass{InductiveConstructor}{\\text{nothing}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#26560}{\\htmlId{26844}{\\htmlClass{Bound}{\\text{pd'}}}}\\, \\end{pmatrix}$\n</pre>"},{"location":"Ledger.Conway.Specification.Epoch.html#references","title":"References","text":"<p>[CVG19]  Jared Corduan and Polina Vinogradova and Matthias G\u00fcdemann. A Formal Specification of the Cardano Ledger. 2019.</p> <p>[Team18]  IOHK Formal Methods Team. Design Specification for Delegation and Incentives in Cardano, IOHK Deliverable SL-D1. 2018.</p>"},{"location":"Ledger.Conway.Specification.Fees.html","title":"Fee Calculation","text":"<p>This section defines the function used to compute the fees associated with reference scripts.</p> <pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (_%_; _*_; \u2264-trans; \u2223_\u2223)\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Fees\n  (txs : _) (open TransactionStructure txs)\n  where\n\nopen import Data.Rational using (0\u211a; \u211a; mk\u211a+; _*_; floor)\nopen import Data.Rational.Literals using (number)\nopen import Ledger.Prelude.Numeric\nopen import Data.Nat.Induction using (&lt;\u2032-wellFounded)\nopen import Data.Nat.Properties using (&lt;\u21d2&lt;\u2032; \u2270\u21d2&gt;; \u2238-mono\u02b3-\u2264; +-mono\u02b3-\u2264; n\u22641+n; m+[n\u2238m]\u2261n; \u2264-reflexive; \u2264-trans)\nopen import Data.Integer using (\u2223_\u2223)\nopen import Induction.WellFounded using (Acc; acc)\nopen import Agda.Builtin.FromNat using (Number)\n\nopen Number number renaming (fromNat to from\u2115)\n</pre>"},{"location":"Ledger.Conway.Specification.Fees.html#sec:calculation-of-fees","title":"Calculation of Fees for Reference Scripts","text":"<p>The function defined in this section calculates the fee for reference scripts in a transaction.  It takes as input the total size of the reference scripts in bytes\u2014calculated by <code>refScriptsSize</code> (see Functions used in UTxO rules)\u2014and uses a function (<code>scriptsCostAux</code>) that is piece-wise linear in the size, where the linear constant multiple grows with each <code>refScriptCostStride</code> bytes. In addition, <code>scriptsCost</code> depends on the following constants, which are bundled with the protocol parameters (see the Protocol Parameter Definitions section).</p> <ul> <li> <p><code>refScriptCostMultiplier</code>: a rational number, the    growth factor or step multiplier that determines how much the price    per byte increases after each increment;</p> </li> <li> <p><code>refScriptCostStride</code>: an integer, the size in bytes at    which the price per byte grows linearly;</p> </li> <li> <p><code>minFeeRefScriptCoinsPerByte</code>: a rational number, the    base fee or initial price per byte.</p> </li> </ul> <p>For background on this method of fee calculation, see Kuleshevich24.</p> <pre>scriptsCost : (pp : PParams) \u2192 \u2115 \u2192 Coin\nscriptsCost pp scriptSize\n  = scriptsCostAux 0\u211a minFeeRefScriptCoinsPerByte scriptSize (&lt;\u2032-wellFounded scriptSize)\n    where\n    minFeeRefScriptCoinsPerByte refScriptCostMultiplier : \u211a\n    minFeeRefScriptCoinsPerByte = PParams.minFeeRefScriptCoinsPerByte pp\n    refScriptCostMultiplier = PParams.refScriptCostMultiplier pp\n\n    refScriptCostStride : \u2115\u207a\n    refScriptCostStride = PParams.refScriptCostStride pp\n\n    scriptsCostAux : \u211a        -- accumulator\n                   \u2192 \u211a        -- current tier price\n                   \u2192 (n : \u2115)  -- remaining script size\n                   \u2192 Acc _&lt;\u2032_ n\n                   \u2192 Coin\n    scriptsCostAux acl curTierPrice n (acc rs) = case  n \u2264? from\u2115\u207a refScriptCostStride of \u03bb where\n      (yes _)  \u2192 \u2223 floor (acl + (from\u2115 n * curTierPrice)) \u2223\n      (no  p)  \u2192 scriptsCostAux\n                   (acl + (from\u2115 (from\u2115\u207a refScriptCostStride) * curTierPrice))\n                   (refScriptCostMultiplier * curTierPrice)\n                   (n - from\u2115\u207a refScriptCostStride)\n                   (rs $ &lt;\u21d2&lt;\u2032 (suc\u2238\u2264 (\u2264-trans (s&lt;s z\u2264n) (\u2270\u21d2&gt; p)) (\u2115\u207a-&gt;0 refScriptCostStride)))\n        where\n        suc\u2238\u2264 : \u2200 {n m : \u2115} \u2192 n &gt; 0 \u2192 m &gt; 0 \u2192 n \u2238 m &lt; n\n        suc\u2238\u2264 {n} {.suc m} p (s\u2264s q) = \u2264-trans (+-mono\u02b3-\u2264 1 (\u2238-mono\u02b3-\u2264 n (s&lt;s q)))\n                                               (\u2264-reflexive (m+[n\u2238m]\u2261n p))\n</pre>"},{"location":"Ledger.Conway.Specification.Fees.html#references","title":"References","text":"<p>[Kuleshevich24]  Alexey Kuleshevich. Changes to the fee calculation due to Reference Scripts. 2024.</p>"},{"location":"Ledger.Conway.Specification.Gov.Actions.html","title":"Governance Actions","text":"<p>This section defines several concepts and types used to represent governance actions.</p> <pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Gov.Base\n\nmodule Ledger.Conway.Specification.Gov.Actions (gs : _) (open GovStructure gs) where\n\nopen import Data.Nat.Properties using (+-0-monoid)\nopen import Data.Rational using (\u211a; 0\u211a; 1\u211a)\n\nopen import Tactic.Derive.Show\n\nopen import Ledger.Prelude as P hiding (yes; no)\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.Actions.html#roles","title":"Roles","text":"<p>There are three distinct roles with specific functions in the governance framework:</p> <ol> <li> <p>constitutional committee (henceforth called <code>CC</code>);</p> </li> <li> <p>delegate representatives (henceforth called <code>DReps</code>);</p> </li> <li> <p>stake pool operators (henceforth called <code>SPOs</code>).</p> </li> </ol> <pre>data GovRole : Type where\n  CC DRep SPO : GovRole\n</pre> <pre>instance\n  unquoteDecl Show-GovRole = derive-Show [ (quote GovRole , Show-GovRole) ]\n</pre> <p>Actors belonging to each governance role are identified by a type of credential:</p> <pre>GovRoleCredential : GovRole \u2192 Type\nGovRoleCredential CC   = Credential\nGovRoleCredential DRep = Credential\nGovRoleCredential SPO  = KeyHash\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.Actions.html#sec:actions","title":"Actions","text":"<p>A governance action is one of the seven types described in the table below:</p> Action Description <code>NoConfidence</code> a motion to create a state of no-confidence in the current constitutional committee <code>UpdateCommittee</code> changes to the members of the constitutional committee and/or to its signature threshold and/or terms <code>NewConstitution</code> a modification to the off-chain Constitution and the proposal policy script <code>TriggerHardFork</code> triggers a non-backwards compatible upgrade of the network; requires a prior software upgrade <code>ChangePParams</code> a change to one or more updatable protocol parameters, excluding changes to major protocol versions (\u201chard forks\u201d) <code>TreasuryWithdrawal</code> movements from the treasury <code>Info</code> an action that has no effect on-chain, other than an on-chain record <pre>data GovActionType : Type where\n  NoConfidence        : GovActionType\n  UpdateCommittee     : GovActionType\n  NewConstitution     : GovActionType\n  TriggerHardFork     : GovActionType\n  ChangePParams       : GovActionType\n  TreasuryWithdrawal  : GovActionType\n  Info                : GovActionType\n</pre> <pre>record HasGovActionType (A : Type) : Type where\n  field GovActionTypeOf : A \u2192 GovActionType\nopen HasGovActionType \u2983...\u2984 public\n</pre> <p>Governance actions carry the following information:</p> <ul> <li> <p><code>UpdateCommittee</code>: a map of credentials and terms to   add and a set of credentials to remove from the committee;</p> </li> <li> <p><code>NewConstitution</code>: a hash of the new constitution   document and an optional proposal policy;</p> </li> <li> <p><code>TriggerHardFork</code>: the protocol version of the epoch to   hard fork into;</p> </li> <li> <p><code>ChangePParams</code>: the updates to the parameters;</p> </li> <li> <p><code>TreasuryWithdrawal</code>: a map of withdrawals.</p> </li> </ul> <pre>GovActionData : GovActionType \u2192 Type\nGovActionData NoConfidence        = \u22a4\nGovActionData UpdateCommittee     = (Credential \u21c0 Epoch) \u00d7 \u2119 Credential \u00d7 \u211a\nGovActionData NewConstitution     = DocHash \u00d7 Maybe ScriptHash\nGovActionData TriggerHardFork     = ProtVer\nGovActionData ChangePParams       = PParamsUpdate\nGovActionData TreasuryWithdrawal  = Withdrawals\nGovActionData Info                = \u22a4\n</pre> <p>A governance action consist of a type of governance action together with the necessary data:</p> <pre>record GovAction : Type where\n</pre> <pre>  constructor \u27e6_,_\u27e7\u1d4d\u1d43\n</pre> <pre>  field\n    gaType : GovActionType\n    gaData : GovActionData gaType\n</pre> <pre>open GovAction public\n\nrecord HasGovAction (A : Type) : Type where\n  field GovActionOf : A \u2192 GovAction\nopen HasGovAction \u2983...\u2984 public\n\ninstance\n  HasGovActionType-GovAction : HasGovActionType GovAction\n  HasGovActionType-GovAction .GovActionTypeOf = GovAction.gaType\n\n  HasCast-GovAction-Sigma : HasCast GovAction (\u03a3 GovActionType GovActionData)\n  HasCast-GovAction-Sigma .cast x = x .gaType , x .gaData\n</pre> <p>Governance actions are uniquely identified by a <code>GovActionID</code>. This type consists of the <code>TxId</code> of the transaction that proposes the governance action together with an index that identifies the proposal within the transaction.</p> <pre>GovActionID : Type\nGovActionID  = TxId \u00d7 \u2115\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.Actions.html#votes","title":"Votes","text":"<p>The <code>Vote</code> type represents the three different voting options: <code>yes</code>, <code>no</code>, and <code>abstain</code>.</p> <pre>data Vote : Type where\n  yes no abstain  : Vote\n</pre> <p>For a <code>Vote</code> to be cast, it must be packaged together with further information, such as who votes <code>GovVoter</code> and for which governance action.  This information is combined in the <code>GovVote</code> record. An optional <code>Anchor</code> can be provided to give context about why a vote was cast in a certain manner.</p> <pre>record GovVoter : Type where\n</pre> <pre>  constructor \u27e6_,_\u27e7\u1d4d\u1d5b\n</pre> <pre>  field\n    gvRole       : GovRole\n    gvCredential : GovRoleCredential gvRole\n</pre> <pre>record Anchor : Type where\n  field\n    url   : String\n    hash  : DocHash\n</pre> <p><code>DocHash</code></p> <p>The type <code>DocHash</code> is abstract but in the implementation it is instantiated with a 32-bit hash type (like, e.g., <code>ScriptHash</code>). We keep it separate because it is used for a different purpose.</p> <pre>record GovVote : Type where\n  field\n    gid         : GovActionID\n    voter       : GovVoter\n    vote        : Vote\n    anchor      : Maybe Anchor\n</pre> <p>Finally, we define the <code>GovVotes</code> type, an inhabitant of which is comprised of three maps that collect the votes cast by members of each of the three governance roles.</p> <pre>record GovVotes : Type where\n  field\n    gvCC   : Credential \u21c0 Vote\n    gvDRep : Credential \u21c0 Vote\n    gvSPO  : KeyHash \u21c0 Vote\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.Actions.html#vote-delegation","title":"Vote Delegation","text":"<p>The type <code>VDeleg</code> represents the different ways in which voting stake can be delegated:</p> <ol> <li>to the credential of a <code>DRep</code> (<code>vDelegCredential</code>);</li> <li>to an abstention (<code>vDelegAbstain</code>);</li> <li>to a vote of no confidence (<code>vDelegNoConfidence</code>).</li> </ol> <pre>data VDeleg : Type where\n  vDelegCredential   : Credential \u2192 VDeleg\n  vDelegAbstain      : VDeleg\n  vDelegNoConfidence : VDeleg\n\nVoteDelegs : Type\nVoteDelegs   = Credential \u21c0 VDeleg\n</pre> <pre>record HasVoteDelegs {a} (A : Type a) : Type a where\n  field VoteDelegsOf : A \u2192 VoteDelegs\nopen HasVoteDelegs \u2983...\u2984 public\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.Actions.html#sec:hash-protection","title":"Hash Protection","text":"<p>For some governance actions, in addition to obtaining the necessary votes, enactment requires that the following condition is also satisfied:</p> <p>the state obtained by enacting the proposal is in fact the state that was intended when the proposal was submitted.</p> <p>This is achieved by requiring actions to unambiguously link to the state they are modifying via a pointer to the previous modification. A proposal can only be enacted if it contains the hash of the previously enacted proposal modifying the same piece of state. <code>NoConfidence</code> and <code>UpdateCommittee</code> modify the same state, while every other type of governance action has its own state that isn\u2019t shared with any other action. This means that the enactibility of a proposal can change when other proposals are enacted.</p> <p>However, not all types of governance actions require this strict protection. For <code>TreasuryWithdrawal</code> and <code>Info</code>, enacting them does not change the state in non-commutative ways, so they can always be enacted.</p> <p>The types we use to represent this hash protection scheme are as follows.</p> <pre>NeedsHash : GovActionType \u2192 Type\nNeedsHash NoConfidence        = GovActionID\nNeedsHash UpdateCommittee     = GovActionID\nNeedsHash NewConstitution     = GovActionID\nNeedsHash TriggerHardFork     = GovActionID\nNeedsHash ChangePParams       = GovActionID\nNeedsHash TreasuryWithdrawal  = \u22a4\nNeedsHash Info                = \u22a4\n\nHashProtected : Type \u2192 Type\nHashProtected A = A \u00d7 GovActionID\n</pre> <pre>instance\n  HasCast-HashProtected : \u2200 {A : Type} \u2192 HasCast (HashProtected A) A\n  HasCast-HashProtected .cast = proj\u2081\n\n  HasCast-HashProtected-MaybeScriptHash : HasCast (HashProtected (DocHash \u00d7 Maybe ScriptHash)) (Maybe ScriptHash)\n  HasCast-HashProtected-MaybeScriptHash .cast = proj\u2082 \u2218 proj\u2081\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.Actions.html#sec:governance-proposal-types","title":"Governance Proposal Types","text":"<p>To propose a governance action, a <code>GovProposal</code> needs to be submitted.  Beside the proposed action, it contains five other fields which we now describe.</p> <ul> <li> <p><code>prevAction</code>: a pointer to the previous action if required    (see Hash Protection);</p> </li> <li> <p><code>policy</code>: a pointer to the proposal policy if one is required;</p> </li> <li> <p><code>deposit</code>: a deposit, which will be returned to <code>returnAddr</code>;</p> </li> <li> <p><code>returnAddr</code>: a reward address to which the deposit will be    returned when the proposal is removed from the state;</p> </li> <li> <p><code>anchor</code>: a placeholder which may be used to provide further    information about the proposal.</p> </li> </ul> <p>While the deposit is held, it is added to the deposit pot, similar to stake key deposits.  It is also counted towards the voting stake (but not the block production stake) of the reward address to which it will be returned, so as not to reduce the submitter\u2019s voting power when voting on their own (and competing) actions.  For a proposal to be valid, the deposit must be set to the current value of <code>govActionDeposit</code>.  The deposit will be returned when the action is removed from the state in any way.</p> <pre>Policy : Type\nPolicy = Maybe ScriptHash\n\nrecord GovProposal : Type where\n  field\n    action      : GovAction\n    prevAction  : NeedsHash (gaType action)\n    policy      : Policy\n    deposit     : Coin\n    returnAddr  : RwdAddr\n    anchor      : Anchor\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.Actions.html#sec:governance-action-state","title":"Governance Action State","text":"<p>The <code>GovActionState</code> type represents the state of an individual governance action.  It contains the individual votes, its lifetime, and information necessary to enact the action and to repay the deposit.</p> <pre>record GovActionState : Type where\n  field\n    votes       : GovVotes\n    returnAddr  : RwdAddr\n    expiresIn   : Epoch\n    action      : GovAction\n    prevAction  : NeedsHash (gaType action)\n</pre> <pre>record HasGovVoter {a} (A : Type a) : Type a where\n  field GovVoterOf : A \u2192 GovVoter\nopen HasGovVoter \u2983...\u2984 public\n\nrecord HasVote {a} (A : Type a) : Type a where\n  field VoteOf : A \u2192 Vote\nopen HasVote \u2983...\u2984 public\n\nrecord HasPolicy {a} (A : Type a) : Type a where\n  field PolicyOf : A \u2192 Policy\nopen HasPolicy \u2983...\u2984 public\n\ninstance\n  HasGovVoter-GovVote : HasGovVoter GovVote\n  HasGovVoter-GovVote .GovVoterOf = GovVote.voter\n\n  HasVote-GovVote : HasVote GovVote\n  HasVote-GovVote .VoteOf = GovVote.vote\n\n  HasPolicy-GovProposal : HasPolicy GovProposal\n  HasPolicy-GovProposal .PolicyOf = GovProposal.policy\n\n  HasGovAction-GovProposal : HasGovAction GovProposal\n  HasGovAction-GovProposal .GovActionOf = GovProposal.action\n\n  HasGovAction-GovActionState : HasGovAction GovActionState\n  HasGovAction-GovActionState .GovActionOf = GovActionState.action\n\n  HasGovActionType-GovProposal : HasGovActionType GovProposal\n  HasGovActionType-GovProposal .GovActionTypeOf = GovActionTypeOf \u2218 GovActionOf\n\n  HasGovActionType-GovActionState : HasGovActionType GovActionState\n  HasGovActionType-GovActionState .GovActionTypeOf = GovActionTypeOf \u2218 GovActionOf\n\ninstance\n  unquoteDecl DecEq-GovActionType = derive-DecEq ((quote GovActionType , DecEq-GovActionType) \u2237 [])\n  unquoteDecl DecEq-GovRole       = derive-DecEq ((quote GovRole , DecEq-GovRole) \u2237 [])\n  unquoteDecl DecEq-Vote          = derive-DecEq ((quote Vote    , DecEq-Vote)    \u2237 [])\n  unquoteDecl DecEq-VDeleg        = derive-DecEq ((quote VDeleg  , DecEq-VDeleg)  \u2237 [])\n\n  DecEq-GovVoter : DecEq GovVoter\n  DecEq-GovVoter ._\u225f_ $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{12708}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\,   \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12715}{\\htmlId{12715}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix}$ $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{12723}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\,   \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12730}{\\htmlId{12730}{\\htmlClass{Bound}{\\text{c'}}}}\\, \\end{pmatrix}$\n    with c \u225f c'\n  ... | P.yes p = P.yes (cong $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{12785}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12767}{\\htmlId{12794}{\\htmlClass{Bound}{\\text{p}}}}\\,\\,\\htmlId{12795}{\\htmlClass{Symbol}{\\text{)}}}\\,\n  \\,\\htmlId{12799}{\\htmlClass{Symbol}{\\text{...}}}\\, \\,\\htmlId{12803}{\\htmlClass{Symbol}{\\text{|}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{12805}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12810}{\\htmlId{12810}{\\htmlClass{Bound}{\\text{\u00acp}}}}\\, \\,\\htmlId{12813}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{12815}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\htmlId{12820}{\\htmlClass{Symbol}{\\text{(\u03bb}}}\\, \\,\\htmlId{12823}{\\htmlClass{Symbol}{\\text{{}}}\\, \\,\\href{Agda.Builtin.Equality.html#207}{\\htmlId{12825}{\\htmlClass{InductiveConstructor}{\\text{refl}}}}\\, \\,\\htmlId{12830}{\\htmlClass{Symbol}{\\text{\u2192}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12810}{\\htmlId{12832}{\\htmlClass{Bound}{\\text{\u00acp}}}}\\, \\,\\href{Agda.Builtin.Equality.html#207}{\\htmlId{12835}{\\htmlClass{InductiveConstructor}{\\text{refl}}}}\\,\\,\\htmlId{12839}{\\htmlClass{Symbol}{\\text{})}}}\\,\n  \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12652}{\\htmlId{12844}{\\htmlClass{Function}{\\text{DecEq-GovVoter}}}}\\, \\,\\htmlId{12859}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Class.DecEq.Core.html#168}{\\htmlId{12860}{\\htmlClass{Field Operator}{\\text{\\_\u225f\\_}}}}\\, \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{12866}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\,   \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12873}{\\htmlId{12873}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{12881}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12888}{\\htmlId{12888}{\\htmlClass{Bound}{\\text{c'}}}}\\, \\end{pmatrix} \\,\\htmlId{12895}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{12897}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\htmlId{12902}{\\htmlClass{Symbol}{\\text{\u03bb}}}\\, \\,\\htmlId{12904}{\\htmlClass{Symbol}{\\text{()}}}\\,\n  \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12652}{\\htmlId{12909}{\\htmlClass{Function}{\\text{DecEq-GovVoter}}}}\\, \\,\\htmlId{12924}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Class.DecEq.Core.html#168}{\\htmlId{12925}{\\htmlClass{Field Operator}{\\text{\\_\u225f\\_}}}}\\, \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{12931}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\,   , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12938}{\\htmlId{12938}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{12946}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\,  , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12953}{\\htmlId{12953}{\\htmlClass{Bound}{\\text{c'}}}}\\, \\end{pmatrix} \\,\\htmlId{12960}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{12962}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\htmlId{12967}{\\htmlClass{Symbol}{\\text{\u03bb}}}\\, \\,\\htmlId{12969}{\\htmlClass{Symbol}{\\text{()}}}\\,\n  \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12652}{\\htmlId{12974}{\\htmlClass{Function}{\\text{DecEq-GovVoter}}}}\\, \\,\\htmlId{12989}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Class.DecEq.Core.html#168}{\\htmlId{12990}{\\htmlClass{Field Operator}{\\text{\\_\u225f\\_}}}}\\, \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{12996}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13003}{\\htmlId{13003}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{13011}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\,   , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13018}{\\htmlId{13018}{\\htmlClass{Bound}{\\text{c'}}}}\\, \\end{pmatrix} \\,\\htmlId{13025}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{13027}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\htmlId{13032}{\\htmlClass{Symbol}{\\text{\u03bb}}}\\, \\,\\htmlId{13034}{\\htmlClass{Symbol}{\\text{()}}}\\,\n  \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12652}{\\htmlId{13039}{\\htmlClass{Function}{\\text{DecEq-GovVoter}}}}\\, \\,\\htmlId{13054}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Class.DecEq.Core.html#168}{\\htmlId{13055}{\\htmlClass{Field Operator}{\\text{\\_\u225f\\_}}}}\\, \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{13061}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13068}{\\htmlId{13068}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{13076}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13083}{\\htmlId{13083}{\\htmlClass{Bound}{\\text{c'}}}}\\, \\end{pmatrix}\n    \\,\\htmlId{13094}{\\htmlClass{Keyword}{\\text{with}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13068}{\\htmlId{13099}{\\htmlClass{Bound}{\\text{c}}}}\\, \\,\\href{Class.DecEq.Core.html#168}{\\htmlId{13101}{\\htmlClass{Field Operator}{\\text{\u225f}}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13083}{\\htmlId{13103}{\\htmlClass{Bound}{\\text{c'}}}}\\,\n  \\,\\htmlId{13108}{\\htmlClass{Symbol}{\\text{...}}}\\, \\,\\htmlId{13112}{\\htmlClass{Symbol}{\\text{|}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2099}{\\htmlId{13114}{\\htmlClass{InductiveConstructor}{\\text{P.yes}}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13120}{\\htmlId{13120}{\\htmlClass{Bound}{\\text{p}}}}\\, \\,\\htmlId{13122}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2099}{\\htmlId{13124}{\\htmlClass{InductiveConstructor}{\\text{P.yes}}}}\\, \\,\\htmlId{13130}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Relation.Binary.PropositionalEquality.Core.html#1481}{\\htmlId{13131}{\\htmlClass{Function}{\\text{cong}}}}\\, \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{13138}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13120}{\\htmlId{13149}{\\htmlClass{Bound}{\\text{p}}}}\\,\\,\\htmlId{13150}{\\htmlClass{Symbol}{\\text{)}}}\\,\n  \\,\\htmlId{13154}{\\htmlClass{Symbol}{\\text{...}}}\\, \\,\\htmlId{13158}{\\htmlClass{Symbol}{\\text{|}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{13160}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13165}{\\htmlId{13165}{\\htmlClass{Bound}{\\text{\u00acp}}}}\\, \\,\\htmlId{13168}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{13170}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\htmlId{13175}{\\htmlClass{Symbol}{\\text{(\u03bb}}}\\, \\,\\htmlId{13178}{\\htmlClass{Symbol}{\\text{{}}}\\, \\,\\href{Agda.Builtin.Equality.html#207}{\\htmlId{13180}{\\htmlClass{InductiveConstructor}{\\text{refl}}}}\\, \\,\\htmlId{13185}{\\htmlClass{Symbol}{\\text{\u2192}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13165}{\\htmlId{13187}{\\htmlClass{Bound}{\\text{\u00acp}}}}\\, \\,\\href{Agda.Builtin.Equality.html#207}{\\htmlId{13190}{\\htmlClass{InductiveConstructor}{\\text{refl}}}}\\,\\,\\htmlId{13194}{\\htmlClass{Symbol}{\\text{})}}}\\,\n  \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12652}{\\htmlId{13199}{\\htmlClass{Function}{\\text{DecEq-GovVoter}}}}\\, \\,\\htmlId{13214}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Class.DecEq.Core.html#168}{\\htmlId{13215}{\\htmlClass{Field Operator}{\\text{\\_\u225f\\_}}}}\\, \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{13221}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13228}{\\htmlId{13228}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{13236}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\,  , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13243}{\\htmlId{13243}{\\htmlClass{Bound}{\\text{c'}}}}\\, \\end{pmatrix} \\,\\htmlId{13250}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{13252}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\htmlId{13257}{\\htmlClass{Symbol}{\\text{\u03bb}}}\\, \\,\\htmlId{13259}{\\htmlClass{Symbol}{\\text{()}}}\\,\n  \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12652}{\\htmlId{13264}{\\htmlClass{Function}{\\text{DecEq-GovVoter}}}}\\, \\,\\htmlId{13279}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Class.DecEq.Core.html#168}{\\htmlId{13280}{\\htmlClass{Field Operator}{\\text{\\_\u225f\\_}}}}\\, \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{13286}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\,  , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13293}{\\htmlId{13293}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{13301}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\,   , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13308}{\\htmlId{13308}{\\htmlClass{Bound}{\\text{c'}}}}\\, \\end{pmatrix} \\,\\htmlId{13315}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{13317}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\htmlId{13322}{\\htmlClass{Symbol}{\\text{\u03bb}}}\\, \\,\\htmlId{13324}{\\htmlClass{Symbol}{\\text{()}}}\\,\n  \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12652}{\\htmlId{13329}{\\htmlClass{Function}{\\text{DecEq-GovVoter}}}}\\, \\,\\htmlId{13344}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Class.DecEq.Core.html#168}{\\htmlId{13345}{\\htmlClass{Field Operator}{\\text{\\_\u225f\\_}}}}\\, \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{13351}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\,  , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13358}{\\htmlId{13358}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{13366}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13373}{\\htmlId{13373}{\\htmlClass{Bound}{\\text{c'}}}}\\, \\end{pmatrix} \\,\\htmlId{13380}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{13382}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\htmlId{13387}{\\htmlClass{Symbol}{\\text{\u03bb}}}\\, \\,\\htmlId{13389}{\\htmlClass{Symbol}{\\text{()}}}\\,\n  \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#12652}{\\htmlId{13394}{\\htmlClass{Function}{\\text{DecEq-GovVoter}}}}\\, \\,\\htmlId{13409}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Class.DecEq.Core.html#168}{\\htmlId{13410}{\\htmlClass{Field Operator}{\\text{\\_\u225f\\_}}}}\\, \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{13416}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\,  , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13423}{\\htmlId{13423}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix} \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{13431}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\,  , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13438}{\\htmlId{13438}{\\htmlClass{Bound}{\\text{c'}}}}\\, \\end{pmatrix}\n    \\,\\htmlId{13449}{\\htmlClass{Keyword}{\\text{with}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13423}{\\htmlId{13454}{\\htmlClass{Bound}{\\text{c}}}}\\, \\,\\href{Class.DecEq.Core.html#168}{\\htmlId{13456}{\\htmlClass{Field Operator}{\\text{\u225f}}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13438}{\\htmlId{13458}{\\htmlClass{Bound}{\\text{c'}}}}\\,\n  \\,\\htmlId{13463}{\\htmlClass{Symbol}{\\text{...}}}\\, \\,\\htmlId{13467}{\\htmlClass{Symbol}{\\text{|}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2099}{\\htmlId{13469}{\\htmlClass{InductiveConstructor}{\\text{P.yes}}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13475}{\\htmlId{13475}{\\htmlClass{Bound}{\\text{p}}}}\\, \\,\\htmlId{13477}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2099}{\\htmlId{13479}{\\htmlClass{InductiveConstructor}{\\text{P.yes}}}}\\, \\,\\htmlId{13485}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Relation.Binary.PropositionalEquality.Core.html#1481}{\\htmlId{13486}{\\htmlClass{Function}{\\text{cong}}}}\\, \\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{13493}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13475}{\\htmlId{13503}{\\htmlClass{Bound}{\\text{p}}}}\\,\\,\\htmlId{13504}{\\htmlClass{Symbol}{\\text{)}}}\\,\n  \\,\\htmlId{13508}{\\htmlClass{Symbol}{\\text{...}}}\\, \\,\\htmlId{13512}{\\htmlClass{Symbol}{\\text{|}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{13514}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13519}{\\htmlId{13519}{\\htmlClass{Bound}{\\text{\u00acp}}}}\\, \\,\\htmlId{13522}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Relation.Nullary.Decidable.Core.html#2136}{\\htmlId{13524}{\\htmlClass{InductiveConstructor}{\\text{P.no}}}}\\, \\,\\htmlId{13529}{\\htmlClass{Symbol}{\\text{(\u03bb}}}\\, \\,\\htmlId{13532}{\\htmlClass{Symbol}{\\text{{}}}\\, \\,\\href{Agda.Builtin.Equality.html#207}{\\htmlId{13534}{\\htmlClass{InductiveConstructor}{\\text{refl}}}}\\, \\,\\htmlId{13539}{\\htmlClass{Symbol}{\\text{\u2192}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13519}{\\htmlId{13541}{\\htmlClass{Bound}{\\text{\u00acp}}}}\\, \\,\\href{Agda.Builtin.Equality.html#207}{\\htmlId{13544}{\\htmlClass{InductiveConstructor}{\\text{refl}}}}\\,\\,\\htmlId{13548}{\\htmlClass{Symbol}{\\text{})}}}\\,\n\n  \\,\\htmlId{13554}{\\htmlClass{Keyword}{\\text{unquoteDecl}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13566}{\\htmlId{13566}{\\htmlClass{Function}{\\text{HasCast-GovVote}}}}\\, \\,\\htmlId{13582}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{stdlib-classes.Class.HasCast.Derive.html#2690}{\\htmlId{13584}{\\htmlClass{Function}{\\text{derive-HasCast}}}}\\, \\,\\href{Data.List.Base.html#4907}{\\htmlId{13599}{\\htmlClass{Function Operator}{\\text{[}}}}\\, \\,\\htmlId{13601}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\htmlId{13602}{\\htmlClass{Keyword}{\\text{quote}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#5990}{\\htmlId{13608}{\\htmlClass{Record}{\\text{GovVote}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13566}{\\htmlId{13618}{\\htmlClass{Function}{\\text{HasCast-GovVote}}}}\\,\\,\\htmlId{13633}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Data.List.Base.html#4907}{\\htmlId{13635}{\\htmlClass{Function Operator}{\\text{]}}}}\\,\n\n  \\,\\htmlId{13640}{\\htmlClass{Keyword}{\\text{unquoteDecl}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13652}{\\htmlId{13652}{\\htmlClass{Function}{\\text{Show-VDeleg}}}}\\, \\,\\htmlId{13664}{\\htmlClass{Symbol}{\\text{=}}}\\, \\,\\href{Tactic.Derive.Show.html#2038}{\\htmlId{13666}{\\htmlClass{Function}{\\text{derive-Show}}}}\\, \\,\\href{Data.List.Base.html#4907}{\\htmlId{13678}{\\htmlClass{Function Operator}{\\text{[}}}}\\, \\,\\htmlId{13680}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\htmlId{13681}{\\htmlClass{Keyword}{\\text{quote}}}\\, \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#6824}{\\htmlId{13687}{\\htmlClass{Datatype}{\\text{VDeleg}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13652}{\\htmlId{13696}{\\htmlClass{Function}{\\text{Show-VDeleg}}}}\\,\\,\\htmlId{13707}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Data.List.Base.html#4907}{\\htmlId{13709}{\\htmlClass{Function Operator}{\\text{]}}}}\\,"},{"location":"Ledger.Conway.Specification.Gov.Actions.html#sec:governance-helper-functions","title":"Governance Helper Functions","text":"<pre>isGovVoterDRep : GovVoter \u2192 Maybe Credential\nisGovVoterDRep $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{13857}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13864}{\\htmlId{13864}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix}$ = just c\nisGovVoterDRep _ = nothing\n\nisGovVoterCredential : GovVoter \u2192 Maybe Credential\nisGovVoterCredential $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{13981}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\,   \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#13988}{\\htmlId{13988}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix}$ = just c\nisGovVoterCredential $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{14026}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#14033}{\\htmlId{14033}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix}$ = just c\nisGovVoterCredential _ = nothing\n\nproposedCC : GovAction \u2192 \u2119 Credential\nproposedCC $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{14133}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\, \\\\ \\,\\htmlId{14151}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Actions.html#14152}{\\htmlId{14152}{\\htmlClass{Bound}{\\text{x}}}}\\, , \\,\\htmlId{14156}{\\htmlClass{Symbol}{\\text{\\_}}}\\, , \\,\\htmlId{14160}{\\htmlClass{Symbol}{\\text{\\_)}}}\\, \\end{pmatrix}$ = dom x\nproposedCC _ = \u2205\n</pre>\n<pre>DReps : Type\nDReps = Credential \u21c0 Epoch\n</pre>\n<pre>record HasDReps {a} (A : Type a) : Type a where\n  field DRepsOf : A \u2192 DReps\nopen HasDReps \u2983...\u2984 public\n</pre>\n\n<p>The following function takes a type <code>A</code> with an associated set of\n<code>DReps</code>, and an epoch <code>e</code>, and returns the\n<code>DReps</code> of <code>A</code> that expire in epoch <code>e</code> or\nlater.</p>\n<pre>activeInEpoch : Epoch \u2192 Credential \u00d7 Epoch \u2192 Type\nactiveInEpoch e (_ , expEpoch) = e \u2264 expEpoch\n\nactiveDRepsOf : {A : Type} \u2983 _ : HasDReps A \u2984 \u2192 A \u2192 Epoch \u2192 DReps\nactiveDRepsOf a e = filter\u1d50 (activeInEpoch e) (DRepsOf a)\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.Base.html","title":"Base","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Gov.Base where\n\nopen import Prelude using (Type)\nopen import Class.DecEq\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\nopen import Ledger.Conway.Specification.Script.Base\nimport Ledger.Conway.Specification.PParams\n\nrecord GovStructure : Type\u2081 where\n  field TxId DocHash : Type\n        \u2983 DecEq-TxId \u2984 : DecEq TxId\n\n  field cryptoStructure : _\n  open CryptoStructure cryptoStructure public\n\n  field epochStructure : _\n  open EpochStructure epochStructure public\n\n  field scriptStructure : ScriptStructure cryptoStructure epochStructure\n  open ScriptStructure scriptStructure public\n\n  open Ledger.Conway.Specification.PParams cryptoStructure epochStructure scriptStructure public\n\n  field govParams : GovParams\n  open GovParams govParams public\n\n  field globalConstants : _\n  open GlobalConstants globalConstants public\n\n  open import Ledger.Core.Specification.Address Network KeyHash ScriptHash public\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.Properties.ChangePPGroup.html","title":"ChangePPGroup","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Gov.Properties.ChangePPGroup\n  (txs : _) (open TransactionStructure txs)\n  where\n\nopen import Ledger.Prelude\n\ninstance\n  _ : IsSet TxBody GovProposal\n  _ = record { toSet = fromList \u2218 TxBody.txGovProposals }\n</pre> <p>Claim (PParam updates have non-empty groups).</p> <p>Informally.</p> <p>Let <code>p</code> : <code>GovProposal</code> be a governance proposal and suppose the <code>GovActionType</code> of <code>p</code> <code>.action</code> is <code>ChangePParams</code>. If the data field of <code>p</code>\u2014that is <code>pu</code> = <code>p</code> <code>.action</code> <code>.gaData</code>\u2014is denoted by <code>pu</code> (for \"parameter update\"), then the set <code>updateGroups</code> <code>pu</code> is nonempty.</p> <p>Formally.</p> <pre>ChangePPHasGroup : {tx : Tx} {p : GovProposal} (pu : PParamsUpdate)\n  \u2192 p \u2208 Tx.body tx \u2192 p .GovProposal.action \u2261 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{1057}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Properties.ChangePPGroup.html#990}{\\htmlId{1073}{\\htmlClass{Bound}{\\text{pu}}}}\\, \\end{pmatrix}$\n  \u2192 Type\nChangePPHasGroup pu _ _ = updateGroups pu \u2262 \u2205\n</pre> <p>Proof. (coming soon)</p>"},{"location":"Ledger.Conway.Specification.Gov.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Gov.Base\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nmodule Ledger.Conway.Specification.Gov.Properties.Computational\n  (txs : _) (open TransactionStructure txs using (govStructure))\n  (open GovStructure govStructure hiding (epoch)) where\n\nopen import Ledger.Prelude hiding (Any; any?)\n\nopen import Axiom.Set.Properties\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Gov.Actions govStructure hiding (yes; no)\nopen import Ledger.Conway.Specification.Ratify txs\n\nimport Data.List.Membership.Propositional as P\nopen import Data.List.Membership.Propositional.Properties\nopen import Data.List.Relation.Unary.All using (all?; All)\nopen import Data.List.Relation.Unary.Any hiding (map)\nopen import Data.List.Relation.Unary.Unique.Propositional\nopen import Data.Maybe.Properties\nopen import Relation.Binary using (IsEquivalence)\n\nopen import Tactic.Defaults\nopen import stdlib-meta.Tactic.GenError\n\nopen Equivalence\nopen GovActionState\nopen Inverse\n\nlookupActionId : (pparams : PParams) (role : GovRole) (aid : GovActionID) (epoch : Epoch) (s : GovState) \u2192\n                 Dec (Any (\u03bb (aid' , ast) \u2192 aid \u2261 aid' \u00d7 canVote pparams (action ast) role \u00d7 \u00ac (expired epoch ast)) s)\nlookupActionId pparams role aid epoch =\n  let instance _ = \u03bb {e ga} \u2192 \u2047 (expired? e ga)\n   in any? \u03bb _ \u2192 \u00bf _ \u00bf\n\nprivate\n  isUpdateCommittee : (a : GovAction) \u2192 Dec (\u2203[ new ] \u2203[ rem ] \u2203[ q ] a \u2261 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{1689}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\, \\\\ \\,\\htmlId{1707}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Properties.Computational.html#1661}{\\htmlId{1708}{\\htmlClass{Bound}{\\text{new}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Properties.Computational.html#1670}{\\htmlId{1714}{\\htmlClass{Bound}{\\text{rem}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Properties.Computational.html#1679}{\\htmlId{1720}{\\htmlClass{Bound}{\\text{q}}}}\\,\\,\\htmlId{1721}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$)\n  isUpdateCommittee $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2446}{\\htmlId{1750}{\\htmlClass{InductiveConstructor}{\\text{NoConfidence}}}}\\,       \\\\ \\,\\htmlId{1771}{\\htmlClass{Symbol}{\\text{\\_}}}\\,                \\end{pmatrix}$ = no \u03bb()\n  isUpdateCommittee $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{1823}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\,    \\\\ \\,\\htmlId{1844}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Properties.Computational.html#1845}{\\htmlId{1845}{\\htmlClass{Bound}{\\text{new}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Properties.Computational.html#1851}{\\htmlId{1851}{\\htmlClass{Bound}{\\text{rem}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.Properties.Computational.html#1857}{\\htmlId{1857}{\\htmlClass{Bound}{\\text{q}}}}\\,\\,\\htmlId{1858}{\\htmlClass{Symbol}{\\text{)}}}\\,  \\end{pmatrix}$ = yes (new , rem , q , refl)\n  isUpdateCommittee $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2522}{\\htmlId{1916}{\\htmlClass{InductiveConstructor}{\\text{NewConstitution}}}}\\,    \\\\ \\,\\htmlId{1937}{\\htmlClass{Symbol}{\\text{\\_}}}\\,                \\end{pmatrix}$ = no \u03bb()\n  isUpdateCommittee $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{1989}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\,    \\\\ \\,\\htmlId{2010}{\\htmlClass{Symbol}{\\text{\\_}}}\\,                \\end{pmatrix}$ = no \u03bb()\n  isUpdateCommittee $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{2062}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\,      \\\\ \\,\\htmlId{2083}{\\htmlClass{Symbol}{\\text{\\_}}}\\,                \\end{pmatrix}$ = no \u03bb()\n  isUpdateCommittee $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{2135}{\\htmlClass{InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\, \\\\ \\,\\htmlId{2156}{\\htmlClass{Symbol}{\\text{\\_}}}\\,                \\end{pmatrix}$ = no \u03bb()\n  isUpdateCommittee $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2674}{\\htmlId{2208}{\\htmlClass{InductiveConstructor}{\\text{Info}}}}\\,               \\\\ \\,\\htmlId{2229}{\\htmlClass{Symbol}{\\text{\\_}}}\\,                \\end{pmatrix}$ = no \u03bb()\n\n  hasPrev : \u2200 x v \u2192 Dec (\u2203[ v' ] x .action \u2261 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{2307}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Properties.Computational.html#2288}{\\htmlId{2325}{\\htmlClass{Bound}{\\text{v'}}}}\\, \\end{pmatrix}$ \u00d7 pvCanFollow v' v)\n  hasPrev record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2446}{\\htmlId{2382}{\\htmlClass{InductiveConstructor}{\\text{NoConfidence}}}}\\,        \\\\ \\,\\htmlId{2404}{\\htmlClass{Symbol}{\\text{\\_}}}\\,   \\end{pmatrix}$} v = no \u03bb ()\n  hasPrev record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{2455}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\,     \\\\ \\,\\htmlId{2477}{\\htmlClass{Symbol}{\\text{\\_}}}\\,   \\end{pmatrix}$} v = no \u03bb ()\n  hasPrev record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2522}{\\htmlId{2528}{\\htmlClass{InductiveConstructor}{\\text{NewConstitution}}}}\\,     \\\\ \\,\\htmlId{2550}{\\htmlClass{Symbol}{\\text{\\_}}}\\,   \\end{pmatrix}$} v = no \u03bb ()\n  hasPrev record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{2601}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\,     \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Properties.Computational.html#2623}{\\htmlId{2623}{\\htmlClass{Bound}{\\text{v'}}}}\\,  \\end{pmatrix}$} v = case pvCanFollow? {v'} {v} of \u03bb where\n    (yes p) \u2192 yes (-, refl , p)\n    (no \u00acp) \u2192 no  (\u03bb where (_ , refl , h) \u2192 \u00acp h)\n  hasPrev record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{2786}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\,       \\\\ \\,\\htmlId{2808}{\\htmlClass{Symbol}{\\text{\\_}}}\\,   \\end{pmatrix}$} v = no \u03bb ()\n  hasPrev record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{2859}{\\htmlClass{InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\,  \\\\ \\,\\htmlId{2881}{\\htmlClass{Symbol}{\\text{\\_}}}\\,   \\end{pmatrix}$} v = no \u03bb ()\n  hasPrev record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2674}{\\htmlId{2932}{\\htmlClass{InductiveConstructor}{\\text{Info}}}}\\,                \\\\ \\,\\htmlId{2954}{\\htmlClass{Symbol}{\\text{\\_}}}\\,   \\end{pmatrix}$} v = no \u03bb ()\n\nopaque\n  unfolding validHFAction isRegistered\n\n  instance\n    validHFAction? : \u2200 {p s e} \u2192 validHFAction p s e \u2047\n    validHFAction? {record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2446}{\\htmlId{3129}{\\htmlClass{InductiveConstructor}{\\text{NoConfidence}}}}\\,        \\\\ \\,\\htmlId{3151}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$}} = Dec-\u22a4\n    validHFAction? {record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{3207}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\,     \\\\ \\,\\htmlId{3229}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$}} = Dec-\u22a4\n    validHFAction? {record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2522}{\\htmlId{3285}{\\htmlClass{InductiveConstructor}{\\text{NewConstitution}}}}\\,     \\\\ \\,\\htmlId{3307}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$}} = Dec-\u22a4\n    validHFAction? {record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{3363}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\,     \\\\ \\,\\href{Ledger.Conway.Specification.Gov.Properties.Computational.html#3385}{\\htmlId{3385}{\\htmlClass{Bound}{\\text{v}}}}\\, \\end{pmatrix}$ ; prevAction = prev }} {s} {record { pv = (v' , aid') }}\n      with aid' \u225f prev \u00d7-dec pvCanFollow? {v'} {v} | any? (\u03bb (aid , x) \u2192 aid \u225f prev \u00d7-dec hasPrev x v) s\n    ... | yes p | _ = \u2047 yes (inj\u2081 p)\n    ... | no _ | yes p with ((aid , x) , x\u2208xs , (refl , v , h)) \u2190 P.find p = \u2047 yes (inj\u2082\n      (x , v , to \u2208-fromList x\u2208xs , h))\n    ... | no \u00acp\u2081 | no \u00acp\u2082 = \u2047 no \u03bb\n      { (inj\u2081 x) \u2192 \u00acp\u2081 x\n      ; (inj\u2082 (s , v , (h\u2081 , h\u2082 , h\u2083))) \u2192 \u00acp\u2082 $\n        \u2203\u2208-Any ((prev , s) , (from \u2208-fromList h\u2081 , refl , (v , h\u2082 , h\u2083))) }\n    validHFAction? {record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{3943}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\,       \\\\ \\,\\htmlId{3965}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$}} = Dec-\u22a4\n    validHFAction? {record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{4021}{\\htmlClass{InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\,  \\\\ \\,\\htmlId{4043}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$}} = Dec-\u22a4\n    validHFAction? {record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2674}{\\htmlId{4099}{\\htmlClass{InductiveConstructor}{\\text{Info}}}}\\,                \\\\ \\,\\htmlId{4121}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$}} = Dec-\u22a4\n\n  isRegistered? : \u2200 \u0393 v \u2192 Dec (isRegistered \u0393 v)\n  isRegistered? _ $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{4207}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\,   \\\\ \\,\\htmlId{4214}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$ = \u00bf _ \u2208 _ \u00bf\n  isRegistered? _ $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{4252}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, \\\\ \\,\\htmlId{4259}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$ = \u00bf _ \u2208 _ \u00bf\n  isRegistered? _ $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{4297}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\,  \\\\ \\,\\htmlId{4304}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$ = \u00bf _ \u2208 _ \u00bf\n\nopen GovVoter\n\ninstance\n  Computational-GOV : Computational _\u22a2_\u21c0\u2987_,GOV\u2988_ String\n  Computational-GOV = record {Go} where\n    module Go \u0393 s where\n      open GovEnv (proj\u2081 \u0393)\n      k = proj\u2082 \u0393\n\n      module GoVote sig where\n        open GovVote sig\n\n        computeProof = case lookupActionId pparams (gvRole voter) gid epoch s ,\u2032 isRegistered? (proj\u2081 \u0393) voter of \u03bb where\n            (yes p , yes p') \u2192 case Any\u2194 .from p of \u03bb where\n              (_ , mem , refl , cV , \u00acexp) \u2192 success (_ , GOV-Vote (\u2208-fromList .to mem , cV , p' , \u00acexp))\n            (yes _ , no \u00acp) \u2192 failure (genErrors \u00acp)\n            (no \u00acp , _    ) \u2192 failure (genErrors \u00acp)\n\n        completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 inj\u2081 sig ,GOV\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n        completeness s' (GOV-Vote {ast = ast} (mem , cV , reg , \u00acexpired))\n          with lookupActionId pparams (gvRole voter) gid epoch s | isRegistered? (proj\u2081 \u0393) voter\n        ... | no \u00acp | _ = \u22a5-elim (\u00acp (Any\u2194 .to (_ , \u2208-fromList .from mem , refl , cV , \u00acexpired)))\n        ... | yes _ | no \u00acp = \u22a5-elim $ \u00acp reg\n        ... | yes p | yes q with Any\u2194 .from p\n        ... | ((_ , ast') , mem , refl , cV) = refl\n\n      module GoProp prop where\n        open GovProposal prop\n          renaming (action to a; deposit to d; policy to p; returnAddr to addr; prevAction to prev)\n        open PParams pparams hiding (a)\n\n        instance\n          Dec-actionWellFormed = actionWellFormed?\n          Dec-actionValid = actionValid?\n        {-# INCOHERENT Dec-actionWellFormed #-}\n        {-# INCOHERENT Dec-actionValid #-}\n\n        H = \u00bf actionWellFormed a\n            \u00d7 actionValid rewardCreds p ppolicy epoch a\n            \u00d7 d \u2261 govActionDeposit\n            \u00d7 validHFAction prop s enactState\n            \u00d7 hasParent' enactState s (a .gaType) prev\n            \u00d7 NetworkIdOf addr \u2261 NetworkId\n            \u00d7 CredentialOf addr \u2208 rewardCreds \u00bf\n            ,\u2032 isUpdateCommittee a\n\n        computeProof = case H of \u03bb where\n          (yes (wf , av , dep , vHFA , HasParent' en , goodAddr , regReturn) , yes (new , rem , q , refl)) \u2192\n            case \u00bf \u2200[ e \u2208 range new ] epoch &lt; e \u00d7 dom new \u2229 rem \u2261\u1d49 \u2205 \u00bf of \u03bb where\n              (yes newOk) \u2192 success (-, GOV-Propose {_} {_} {_} {_} {_} {_} {_} {_} {_} {(new , rem , q)} (wf , av , dep , vHFA , en , goodAddr , regReturn))\n              (no \u00acp)     \u2192 failure (genErrors \u00acp)\n          (yes (wf , av , dep , vHFA , HasParent' en , goodAddr , returnReg) , no notNewComm) \u2192 success\n            (-, GOV-Propose {_} {_} {_} {_} {_} {_} {_} {_} {_} {a .gaData} (wf , av , dep , vHFA , en , goodAddr , returnReg))\n          (no \u00acp , _) \u2192 failure (genErrors \u00acp)\n\n        completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 inj\u2082 prop ,GOV\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n        completeness s' (GOV-Propose (wf , av , dep , vHFA , en , goodAddr)) with H\n        ... | (no \u00acp , _) = \u22a5-elim (\u00acp (wf , av , dep , vHFA , HasParent' en , goodAddr))\n        ... | (yes (_ , _ , _ , _ , HasParent' _ , _) , no notNewComm) = refl\n        ... | (yes (_ , (_ , (av\u2081 , av\u2082)) , _ , _ , HasParent' _ , _) , yes (new , rem , q , refl))\n          rewrite dec-yes \u00bf \u2200[ e \u2208 range new ] epoch &lt; e \u00d7 dom new \u2229 rem \u2261\u1d49 \u2205 \u00bf (\u03bb { x \u2192 av\u2081 x , av\u2082 }) .proj\u2082 = refl\n\n      computeProof : (sig : GovVote \u228e GovProposal) \u2192 _\n      computeProof (inj\u2081 s) = GoVote.computeProof s\n      computeProof (inj\u2082 s) = GoProp.computeProof s\n\n      completeness : \u2200 sig s' \u2192 \u0393 \u22a2 s \u21c0\u2987 sig ,GOV\u2988 s' \u2192 _\n      completeness (inj\u2081 s) = GoVote.completeness s\n      completeness (inj\u2082 s) = GoProp.completeness s\n\nComputational-GOVS : Computational _\u22a2_\u21c0\u2987_,GOVS\u2988_ String\nComputational-GOVS = it\n\nallEnactable-singleton : \u2200 {aid s es} \u2192 getHash (s .prevAction) \u2261 getHashES es (GovActionTypeOf s)\n  \u2192 allEnactable es [ (aid , s) ]\nallEnactable-singleton {aid} {s} {es} eq = helper All.\u2237 All.[]\n  where\n    module \u2261\u1d49 = IsEquivalence (\u2261\u1d49-isEquivalence th)\n\n    helper : enactable es (getAidPairsList [ (aid , s) ]) (aid , s)\n    helper with getHashES es (GovActionTypeOf s) | getHash (s .prevAction)\n    ... | just x | just x' with refl &lt;- just-injective eq =\n      [ (aid , x) ] , proj\u2081 \u2261\u1d49.refl , All.[] \u2237 [] , inj\u2081 (refl , refl)\n    ... | just x | nothing = case eq of \u03bb ()\n    ... | nothing | _ = _\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Gov.Properties where\n\nopen import Ledger.Conway.Specification.Gov.Properties.Computational\nopen import Ledger.Conway.Specification.Gov.Properties.ChangePPGroup\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.html","title":"Governance","text":"<p>The behavior of <code>GovState</code> is similar to that of a queue. New proposals are appended at the end, but any proposal can be removed at the epoch boundary. However, for the purposes of enactment, earlier proposals take priority. Note that <code>EnactState</code> used in <code>GovEnv</code> is defined in the Enact module.</p> <pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Gov.Base\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nmodule Ledger.Conway.Specification.Gov (txs : _) (open TransactionStructure txs hiding (epoch)) where\n\nopen import Ledger.Prelude hiding (any?; Any; all?; All; Rel; lookup; \u2208-filter)\n\nopen import Axiom.Set.Properties th using (\u2203-sublist-\u21d4)\n\nopen import Ledger.Conway.Specification.Gov.Actions govStructure using (Vote)\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Ratify txs\nopen import Ledger.Conway.Specification.Certs govStructure\n\nopen import stdlib.Data.List.Subpermutations using (subpermutations; sublists)\nopen import stdlib.Data.List.Subpermutations.Properties\nopen import Data.List.Membership.Propositional.Properties using (Any\u2194; \u2208-filter\u207b; \u2208-filter\u207a)\nopen import Data.List.Relation.Binary.Subset.Propositional using () renaming (_\u2286_ to _\u2286\u02e1_)\nopen import Data.List.Relation.Unary.All using (all?; All)\nopen import Data.List.Relation.Unary.Any using (any?; Any)\nopen import Data.List.Relation.Unary.Unique.DecPropositional using (unique?)\nopen import Data.List.Relation.Unary.Unique.Propositional using (Unique)\nopen import Relation.Nullary.Decidable using () renaming (map to map-Dec)\nopen import Function.Properties.Equivalence using () renaming (sym to sym-Equiv)\nopen import Function.Related.Propositional using (\u2194\u21d2)\n\nopen GovActionState\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.html#governance-types","title":"Governance Types","text":"<p>Derived types</p> <pre>GovState : Type\nGovState = List (GovActionID \u00d7 GovActionState)\n</pre> <pre>record HasGovState {a} (A : Type a) : Type a where\n  field GovStateOf : A \u2192 GovState\nopen HasGovState \u2983...\u2984 public\n</pre> <pre>record GovEnv : Type where\n  field\n    txid        : TxId\n    epoch       : Epoch\n    pparams     : PParams\n    ppolicy     : Maybe ScriptHash\n    enactState  : EnactState\n    certState   : CertState\n    rewardCreds : \u2119 Credential\n</pre> <pre>instance\n  HasPParams-GovEnv : HasPParams GovEnv\n  HasPParams-GovEnv .PParamsOf = GovEnv.pparams\n\n  HasEnactState-GovEnv : HasEnactState GovEnv\n  HasEnactState-GovEnv .EnactStateOf = GovEnv.enactState\n\n  HasCertState-GovEnv : HasCertState GovEnv\n  HasCertState-GovEnv .CertStateOf = GovEnv.certState\n\n  unquoteDecl HasCast-GovEnv = derive-HasCast\n    [ (quote GovEnv , HasCast-GovEnv) ]\n\nprivate variable\n  \u0393      : GovEnv\n  s s'   : GovState\n  aid    : GovActionID\n  voter  : GovVoter\n  vote   : GovVote\n  v      : Vote\n  d      : Coin\n  addr   : RwdAddr\n  a      : GovAction\n  prev   : NeedsHash (gaType a)\n  k      : \u2115\n  p      : Maybe ScriptHash\n\nopen GState\nopen PState\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.html#governance-functions","title":"Governance Functions","text":"<p>The function definitions worth highlighting in this section are the following:</p> <ul> <li> <p><code>addVote</code> inserts (and potentially overrides) a vote   made for a particular governance action (identified by its ID) by a   credential with a role.</p> </li> <li> <p><code>addAction</code> adds a new proposed action at the end of a   given <code>GovState</code>.</p> </li> <li> <p>The <code>validHFAction</code> property indicates whether a given   proposal, if it is a <code>TriggerHardFork</code>   action, can potentially be enacted in the future. For this to be the   case, its <code>prevAction</code> needs to exist, be another   <code>TriggerHardFork</code> action and have a   compatible version.</p> </li> </ul> <pre>govActionPriority : GovActionType \u2192 \u2115\ngovActionPriority NoConfidence        = 0\ngovActionPriority UpdateCommittee     = 1\ngovActionPriority NewConstitution     = 2\ngovActionPriority TriggerHardFork     = 3\ngovActionPriority ChangePParams       = 4\ngovActionPriority TreasuryWithdrawal  = 5\ngovActionPriority Info                = 6\n\nOverlap : GovActionType \u2192 GovActionType \u2192 Type\nOverlap NoConfidence     UpdateCommittee  = \u22a4\nOverlap UpdateCommittee  NoConfidence     = \u22a4\nOverlap a                a'               = a \u2261 a'\n</pre> <pre>-- TODO: cleanup this\nOverlap? : (a a' : GovActionType) \u2192 Dec (Overlap a a')\nOverlap? NoConfidence    UpdateCommittee  = Dec-\u22a4 .dec\nOverlap? UpdateCommittee NoConfidence     = Dec-\u22a4 .dec\nOverlap? NoConfidence NoConfidence = yes refl\nOverlap? NoConfidence NewConstitution = no (\u03bb ())\nOverlap? NoConfidence TriggerHardFork = no (\u03bb ())\nOverlap? NoConfidence ChangePParams = no (\u03bb ())\nOverlap? NoConfidence TreasuryWithdrawal = no (\u03bb ())\nOverlap? NoConfidence Info = no (\u03bb ())\nOverlap? UpdateCommittee UpdateCommittee = yes refl\nOverlap? UpdateCommittee NewConstitution = no (\u03bb ())\nOverlap? UpdateCommittee TriggerHardFork = no (\u03bb ())\nOverlap? UpdateCommittee ChangePParams = no (\u03bb ())\nOverlap? UpdateCommittee TreasuryWithdrawal = no (\u03bb ())\nOverlap? UpdateCommittee Info = no (\u03bb ())\nOverlap? NewConstitution NoConfidence = no (\u03bb ())\nOverlap? NewConstitution UpdateCommittee = no (\u03bb ())\nOverlap? NewConstitution NewConstitution = yes refl\nOverlap? NewConstitution TriggerHardFork = no (\u03bb ())\nOverlap? NewConstitution ChangePParams = no (\u03bb ())\nOverlap? NewConstitution TreasuryWithdrawal = no (\u03bb ())\nOverlap? NewConstitution Info = no (\u03bb ())\nOverlap? TriggerHardFork NoConfidence = no (\u03bb ())\nOverlap? TriggerHardFork UpdateCommittee = no (\u03bb ())\nOverlap? TriggerHardFork NewConstitution = no (\u03bb ())\nOverlap? TriggerHardFork TriggerHardFork = yes refl\nOverlap? TriggerHardFork ChangePParams = no (\u03bb ())\nOverlap? TriggerHardFork TreasuryWithdrawal = no (\u03bb ())\nOverlap? TriggerHardFork Info = no (\u03bb ())\nOverlap? ChangePParams NoConfidence = no (\u03bb ())\nOverlap? ChangePParams UpdateCommittee = no (\u03bb ())\nOverlap? ChangePParams NewConstitution = no (\u03bb ())\nOverlap? ChangePParams TriggerHardFork = no (\u03bb ())\nOverlap? ChangePParams ChangePParams = yes refl\nOverlap? ChangePParams TreasuryWithdrawal = no (\u03bb ())\nOverlap? ChangePParams Info = no (\u03bb ())\nOverlap? TreasuryWithdrawal NoConfidence = no (\u03bb ())\nOverlap? TreasuryWithdrawal UpdateCommittee = no (\u03bb ())\nOverlap? TreasuryWithdrawal NewConstitution = no (\u03bb ())\nOverlap? TreasuryWithdrawal TriggerHardFork = no (\u03bb ())\nOverlap? TreasuryWithdrawal ChangePParams = no (\u03bb ())\nOverlap? TreasuryWithdrawal TreasuryWithdrawal = yes refl\nOverlap? TreasuryWithdrawal Info = no (\u03bb ())\nOverlap? Info NoConfidence = no (\u03bb ())\nOverlap? Info UpdateCommittee = no (\u03bb ())\nOverlap? Info NewConstitution = no (\u03bb ())\nOverlap? Info TriggerHardFork = no (\u03bb ())\nOverlap? Info ChangePParams = no (\u03bb ())\nOverlap? Info TreasuryWithdrawal = no (\u03bb ())\nOverlap? Info Info = yes refl\n</pre> <pre>insertGovAction : GovState \u2192 GovActionID \u00d7 GovActionState \u2192 GovState\ninsertGovAction [] gaPr = [ gaPr ]\ninsertGovAction ((gaID\u2080 , gaSt\u2080) \u2237 gaPrs) (gaID\u2081 , gaSt\u2081)\n  =  if govActionPriority (action gaSt\u2080 .gaType) \u2264 govActionPriority (action gaSt\u2081 .gaType)\n     then (gaID\u2080 , gaSt\u2080) \u2237 insertGovAction gaPrs (gaID\u2081 , gaSt\u2081)\n     else (gaID\u2081 , gaSt\u2081) \u2237 (gaID\u2080 , gaSt\u2080) \u2237 gaPrs\n\nmkGovStatePair :  Epoch \u2192 GovActionID \u2192 RwdAddr \u2192 (a : GovAction) \u2192 NeedsHash (a .gaType)\n                  \u2192 GovActionID \u00d7 GovActionState\nmkGovStatePair e aid addr a prev = (aid , gas)\n  where\n  gas : GovActionState\n  gas = record  { votes = record { gvCC = \u2205 ; gvDRep = \u2205 ; gvSPO = \u2205 }\n                ; returnAddr = addr\n                ; expiresIn = e\n                ; action = a\n                ; prevAction = prev\n                }\n\naddAction :  GovState \u2192 Epoch \u2192 GovActionID \u2192 RwdAddr\n             \u2192 (a : GovAction) \u2192 NeedsHash (a .gaType)\n             \u2192 GovState\naddAction s e aid addr a prev = insertGovAction s (mkGovStatePair e aid addr a prev)\n</pre> <pre>opaque\n</pre> <pre>  addVote : GovState \u2192 GovActionID \u2192 GovVoter \u2192 Vote \u2192 GovState\n  addVote gSt aid voter v = map modifyVotes gSt\n    where\n    modifyVotes : GovActionID \u00d7 GovActionState \u2192 GovActionID \u00d7 GovActionState\n    modifyVotes (gid , gaSt) = gid , (if gid \u2261 aid then record gaSt { votes = votes' voter } else gaSt)\n      where\n      open GovVotes (votes gaSt)\n      votes' : GovVoter \u2192 GovVotes\n      votes' $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{8497}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#8502}{\\htmlId{8502}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix}$ = record { gvCC = insert gvCC c v ; gvDRep = gvDRep ; gvSPO = gvSPO }\n      votes' $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{8593}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#8600}{\\htmlId{8600}{\\htmlClass{Bound}{\\text{c}}}}\\, \\end{pmatrix}$ = record { gvCC = gvCC ; gvDRep = insert gvDRep c v ; gvSPO = gvSPO }\n      votes' $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{8691}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#8697}{\\htmlId{8697}{\\htmlClass{Bound}{\\text{kh}}}}\\, \\end{pmatrix}$ = record { gvCC = gvCC ; gvDRep = gvDRep ; gvSPO = insert gvSPO kh v }\n\n  isRegistered : GovEnv \u2192 GovVoter \u2192 Type\n  isRegistered \u0393 v = case v of\n    \u03bb where\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#970}{\\htmlId{8869}{\\htmlClass{InductiveConstructor}{\\text{CC}}}}\\,   \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#8876}{\\htmlId{8876}{\\htmlClass{Bound}{\\text{c}}}}\\,  \\end{pmatrix}$ \u2192 just c \u2208 range (CCHotKeysOf (CertStateOf \u0393))\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#973}{\\htmlId{8938}{\\htmlClass{InductiveConstructor}{\\text{DRep}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#8945}{\\htmlId{8945}{\\htmlClass{Bound}{\\text{c}}}}\\,  \\end{pmatrix}$ \u2192 c \u2208 dom (DRepsOf (CertStateOf \u0393))\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#978}{\\htmlId{8996}{\\htmlClass{InductiveConstructor}{\\text{SPO}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#9003}{\\htmlId{9003}{\\htmlClass{Bound}{\\text{kh}}}}\\, \\end{pmatrix}$ \u2192 kh \u2208 dom (PoolsOf (CertStateOf \u0393))\n\n  validHFAction : GovProposal \u2192 GovState \u2192 EnactState \u2192 Type\n  validHFAction (record { action = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{9146}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#9164}{\\htmlId{9164}{\\htmlClass{Bound}{\\text{v}}}}\\, \\end{pmatrix}$ ; prevAction = prev }) s e =\n    (aid' \u2261 prev \u00d7 pvCanFollow ver v) \u228e \u2203\u2082[ x , v' ]  (prev , x) \u2208 fromList s\n                                                      \u00d7 x .action \u2261 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{9347}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#9247}{\\htmlId{9365}{\\htmlClass{Bound}{\\text{v'}}}}\\, \\end{pmatrix}$\n                                                      \u00d7 pvCanFollow v' v\n    where\n      ver : ProtVer\n      ver = EnactState.pv e .proj\u2081\n      aid' : GovActionID\n      aid' = EnactState.pv e .proj\u2082\n\n  validHFAction _ _ _ = \u22a4\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.html#enactability-predicate","title":"Enactability Predicate","text":"<p>This section contains some of the functions used to determine whether certain actions are enactable in a given state.  Specifically, <code>allEnactable</code> passes the <code>GovState</code> to <code>getAidPairsList</code> to obtain a list of <code>GovActionID</code>-pairs which is then passed to <code>enactable</code>. The latter uses the <code>_connects_to_</code> function to check whether the list of <code>GovActionID</code>-pairs connects the proposed action to a previously enacted one.<sup>1</sup></p> <p>The function <code>govActionPriority</code> assigns a priority to the various types of governance actions. This is useful for ordering lists of governance actions (see the definition of the <code>insertGovAction</code> function in the Governance Functions section). Priority is also used to check if two actions <code>Overlap</code>; that is, they would modify the same piece of <code>EnactState</code>.</p> <pre>-- Convert list of (GovActionID,GovActionState)-pairs to list of GovActionID pairs.\ngetAidPairsList : GovState \u2192 List (GovActionID \u00d7 GovActionID)\ngetAidPairsList aid\u00d7states =\n  mapMaybe (\u03bb (aid , aState) \u2192 (aid ,_) &lt;$&gt; getHash (prevAction aState)) $ aid\u00d7states\n\n-- A list of GovActionID pairs connects the first GovActionID to the second.\n_connects_to_ : List (GovActionID \u00d7 GovActionID) \u2192 GovActionID \u2192 GovActionID \u2192 Type\n[] connects aidNew to aidOld = aidNew \u2261 aidOld\n((aid , aidPrev) \u2237 s) connects aidNew to aidOld  =\n  aid \u2261 aidNew \u00d7 s connects aidPrev to aidOld \u228e s connects aidNew to aidOld\n</pre> <pre>enactable  : EnactState \u2192 List (GovActionID \u00d7 GovActionID)\n           \u2192 GovActionID \u00d7 GovActionState \u2192 Type\nenactable e aidPairs = \u03bb (aidNew , as) \u2192 case getHashES e (action as .gaType) of\n  \u03bb where\n   nothing        \u2192 \u22a4\n   (just aidOld)  \u2192 \u2203[ t ]  fromList t \u2286 fromList aidPairs\n                            \u00d7 Unique t \u00d7 t connects aidNew to aidOld\n\nallEnactable : EnactState \u2192 GovState \u2192 Type\nallEnactable e aid\u00d7states = All (enactable e (getAidPairsList aid\u00d7states)) aid\u00d7states\n\nhasParentE : EnactState \u2192 GovActionID \u2192 GovActionType \u2192 Type\nhasParentE e aid gaTy = case getHashES e gaTy of\n  \u03bb where\n    nothing    \u2192 \u22a4\n    (just id)  \u2192 id \u2261 aid\n\nhasParent : EnactState \u2192 GovState \u2192 (gaTy : GovActionType) \u2192 NeedsHash gaTy \u2192 Type\nhasParent e s gaTy aid = case getHash aid of\n  \u03bb where\n    nothing      \u2192 \u22a4\n    (just aid')  \u2192 hasParentE e aid' gaTy\n                   \u228e Any (\u03bb (gid , gas) \u2192 gid \u2261 aid' \u00d7 Overlap (GovActionTypeOf gas) gaTy) s\n</pre> <pre>open Equivalence\n\nhasParentE? : \u2200 e aid a \u2192 Dec (hasParentE e aid a)\nhasParentE? e aid gaTy with getHashES e gaTy\n... | nothing   = yes _\n... | (just id) = id \u225f aid\n\nhasParent? : \u2200 e s a aid \u2192 Dec (hasParent e s a aid)\nhasParent? e s gaTy aid with getHash aid\n... | just aid' = hasParentE? e aid' gaTy\n                  \u228e-dec any? (\u03bb (gid , gas) \u2192 gid \u225f aid' \u00d7-dec Overlap? (GovActionTypeOf gas) gaTy) s\n... | nothing = yes _\n\n-- newtype to make the instance resolution work\ndata hasParent' : EnactState \u2192 GovState \u2192 (gaTy : GovActionType) \u2192 NeedsHash gaTy \u2192 Type where\n  HasParent' : \u2200 {x y z w} \u2192 hasParent x y z w \u2192 hasParent' x y z w\n\ninstance\n  hasParent?' : \u2200 {x y z w} \u2192 hasParent' x y z w \u2047\n  hasParent?' = \u2047 map\u2032 HasParent' (\u03bb where (HasParent' x) \u2192 x) (hasParent? _ _ _ _)\n\n[_connects_to_?] : \u2200 l aidNew aidOld \u2192 Dec (l connects aidNew to aidOld)\n[ [] connects aidNew to aidOld ?] = aidNew \u225f aidOld\n\n[ (aid , aidPrev) \u2237 s connects aidNew to aidOld ?] =\n  ((aid \u225f aidNew) \u00d7-dec [ s connects aidPrev to aidOld ?]) \u228e-dec [ s connects aidNew to aidOld ?]\n\nany?-connecting-subperm : \u2200 {u} {v} \u2192 \u2200 L \u2192 Dec (Any(\u03bb l \u2192 Unique l \u00d7 l connects u to v) (subpermutations L))\nany?-connecting-subperm {u} {v} L = any? (\u03bb l \u2192 unique? _\u225f_ l \u00d7-dec [ l connects u to v ?]) (subpermutations L)\n\n\u2203?-connecting-subperm : \u2200 {u} {v} \u2192 \u2200 L \u2192 Dec (\u2203[ l ] l \u2208\u02e1 subpermutations L \u00d7 Unique l \u00d7 l connects u to v)\n\u2203?-connecting-subperm L = map-Dec (sym-Equiv (\u2194\u21d2 Any\u2194)) (any?-connecting-subperm L)\n\n\u2203?-connecting-subset : \u2200 {u} {v} \u2192 \u2200 L \u2192 Dec (\u2203[ l ] l \u2286\u02e1 L \u00d7 Unique l \u00d7 l connects u to v)\n\u2203?-connecting-subset L = map-Dec (sym-Equiv \u2203uniqueSubset\u21d4\u2203uniqueSubperm) (\u2203?-connecting-subperm L)\n\nenactable? : \u2200 eState aidPairs aidNew\u00d7st \u2192 Dec (enactable eState aidPairs aidNew\u00d7st)\nenactable? eState aidPairs (aidNew , as) with getHashES eState (GovActionTypeOf as)\n... | nothing = yes tt\n... | just aidOld = map-Dec (sym-Equiv \u2203-sublist-\u21d4) (\u2203?-connecting-subset aidPairs)\n\nallEnactable? : \u2200 eState aid\u00d7states \u2192 Dec (allEnactable eState aid\u00d7states)\nallEnactable? eState aid\u00d7states =\n  all? (\u03bb aid\u00d7st \u2192 enactable? eState (getAidPairsList aid\u00d7states) aid\u00d7st) aid\u00d7states\n\n-- newtype to make the instance resolution work\ndata allEnactable' : EnactState \u2192 GovState \u2192 Type where\n  AllEnactable' : \u2200 {x y} \u2192 allEnactable x y \u2192 allEnactable' x y\n\ninstance\n  allEnactable?' : \u2200 {x y} \u2192 allEnactable' x y \u2047\n  allEnactable?' = \u2047 map\u2032 AllEnactable' (\u03bb where (AllEnactable' x) \u2192 x) (allEnactable? _ _)\n\n-- `maxAllEnactable` returns a list `ls` of sublists of the given\n-- list (`aid\u00d7states : List (GovActionID \u00d7 GovActionState)`) such that\n--    (i) each sublist `l \u2208 ls` satisfies `allEnactable e l` and\n--   (ii) each sublist `l \u2208 ls` is of maximal length among sublists of `aid\u00d7states` satisfying `allEnactable`.\nmaxAllEnactable : EnactState \u2192 GovState \u2192 List GovState\nmaxAllEnactable e = maxsublists\u22a7P (allEnactable? e)\n\n-- Every sublist returned by `maxAllEnactable` satisfies (i).\n\u2208-maxAllEnactable\u2192allEnactable : \u2200 {e} {aid\u00d7states} l\n  \u2192 l \u2208\u02e1 maxAllEnactable e aid\u00d7states \u2192 allEnactable e l\n\u2208-maxAllEnactable\u2192allEnactable {e} {aid\u00d7states} l l\u2208 =\n  proj\u2082 (\u2208-filter\u207b (allEnactable? e) {l} {sublists aid\u00d7states}\n          (proj\u2081 (\u2208-filter\u207b (\u03bb l \u2192 length l \u225f maxlen (sublists\u22a7P (allEnactable? e) aid\u00d7states)) l\u2208)))\n\n-- Every sublist returned by `maxAllEnactable` satisfies (ii).\n\u2208-maxAllEnactable\u2192maxLength : \u2200 {e aid\u00d7states l l'}\n                              \u2192 l \u2208\u02e1 sublists aid\u00d7states \u2192 allEnactable e l\n                              \u2192 l' \u2208\u02e1 maxAllEnactable e aid\u00d7states\n                              \u2192 length l \u2264 length l'\n\u2208-maxAllEnactable\u2192maxLength {e} {aid\u00d7states} {l} {l'} l\u2208 el l'\u2208 =\n  let ls = sublists\u22a7P (allEnactable? e) aid\u00d7states in\n    subst (length l \u2264_)\n          (sym (proj\u2082 (\u2208-filter\u207b (\u03bb l \u2192 length l \u225f maxlen ls) {xs = ls} l'\u2208)))\n          (\u2208-maxlen-\u2264 l (\u2208-filter\u207a (allEnactable? e) l\u2208 el))\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.html#validity-and-wellformedness-predicates","title":"Validity and Wellformedness Predicates","text":"<p>This section defines predicates used in the <code>GOVPropose</code> case of the GOV rule to ensure that a governance action is valid and well-formed.</p> <pre>actionValid : \u2119 Credential \u2192 Maybe ScriptHash \u2192 Maybe ScriptHash \u2192 Epoch \u2192 GovAction \u2192 Type\nactionValid rewardCreds p ppolicy epoch $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{16452}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\, \\\\ \\,\\htmlId{16468}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$ =\n  p \u2261 ppolicy\nactionValid rewardCreds p ppolicy epoch $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{16532}{\\htmlClass{InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#16554}{\\htmlId{16554}{\\htmlClass{Bound}{\\text{x}}}}\\, \\end{pmatrix}$ =\n  p \u2261 ppolicy \u00d7 map\u02e2 RwdAddr.stake (dom x) \u2286 rewardCreds\nactionValid rewardCreds p ppolicy epoch $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{16661}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\, \\\\ \\,\\htmlId{16679}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.html#16680}{\\htmlId{16680}{\\htmlClass{Bound}{\\text{new}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.html#16686}{\\htmlId{16686}{\\htmlClass{Bound}{\\text{rem}}}}\\, , \\,\\href{Ledger.Conway.Specification.Gov.html#16692}{\\htmlId{16692}{\\htmlClass{Bound}{\\text{q}}}}\\,\\,\\htmlId{16693}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$ =\n  p \u2261 nothing \u00d7 (\u2200[ e \u2208 range new ]  epoch &lt; e) \u00d7 (dom new \u2229 rem \u2261\u1d49 \u2205)\nactionValid rewardCreds p ppolicy epoch _ =\n  p \u2261 nothing\n\nactionWellFormed : GovAction \u2192 Type\nactionWellFormed $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{16886}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#16902}{\\htmlId{16902}{\\htmlClass{Bound}{\\text{x}}}}\\, \\end{pmatrix}$ = ppdWellFormed x\nactionWellFormed $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{16945}{\\htmlClass{InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#16967}{\\htmlId{16967}{\\htmlClass{Bound}{\\text{x}}}}\\, \\end{pmatrix}$ =\n  (\u2200[ a \u2208 dom x ] NetworkIdOf a \u2261 NetworkId) \u00d7 (\u2203[ v \u2208 range x ] \u00ac (v \u2261 0))\nactionWellFormed _                 = \u22a4\n</pre> <ul> <li> <p><code>actionValid</code> ensures that the proposed action is valid    given the current state of the system:</p> <ul> <li> <p>a <code>ChangePParams</code> action is valid if the    proposal policy is provided;</p> </li> <li> <p>a <code>TreasuryWithdrawal</code> action is valid if    the proposal policy is provided and the reward stake credential is    registered;</p> </li> <li> <p>an <code>UpdateCommittee</code> action is valid if    credentials of proposed candidates have not expired, and the action    does not propose to both add and remove the same candidate.</p> </li> </ul> </li> <li> <p><code>actionWellFormed</code> ensures that the proposed action is     well-formed:</p> </li> <li> <p>a <code>ChangePParams</code> action must preserves well-formedness of the protocol parameters;</p> </li> <li> <p>a <code>TreasuryWithdrawal</code> action is well-formed if the       network ID is correct and there is at least one non-zero withdrawal amount in       the given <code>RwdAddrToCoinMap</code> map.</p> </li> </ul> <pre>actionValid? : \u2200 {rewardCreds p ppolicy epoch a} \u2192 actionValid rewardCreds p ppolicy epoch a \u2047\nactionValid? {a = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2446}{\\htmlId{18272}{\\htmlClass{InductiveConstructor}{\\text{NoConfidence}}}}\\,        \\\\ \\,\\htmlId{18294}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionValid? {a = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{18326}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\,     \\\\ \\,\\htmlId{18348}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionValid? {a = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2522}{\\htmlId{18380}{\\htmlClass{InductiveConstructor}{\\text{NewConstitution}}}}\\,     \\\\ \\,\\htmlId{18402}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionValid? {a = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{18434}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\,     \\\\ \\,\\htmlId{18456}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionValid? {a = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{18488}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\,       \\\\ \\,\\htmlId{18510}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionValid? {a = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{18542}{\\htmlClass{InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\,  \\\\ \\,\\htmlId{18564}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionValid? {a = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2674}{\\htmlId{18596}{\\htmlClass{InductiveConstructor}{\\text{Info}}}}\\,                \\\\ \\,\\htmlId{18618}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\n\nactionWellFormed? : \u2200 {a} \u2192 actionWellFormed a \u2047\nactionWellFormed? {$\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2446}{\\htmlId{18701}{\\htmlClass{InductiveConstructor}{\\text{NoConfidence}}}}\\,        \\\\ \\,\\htmlId{18723}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionWellFormed? {$\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2484}{\\htmlId{18756}{\\htmlClass{InductiveConstructor}{\\text{UpdateCommittee}}}}\\,     \\\\ \\,\\htmlId{18778}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionWellFormed? {$\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2522}{\\htmlId{18811}{\\htmlClass{InductiveConstructor}{\\text{NewConstitution}}}}\\,     \\\\ \\,\\htmlId{18833}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionWellFormed? {$\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2560}{\\htmlId{18866}{\\htmlClass{InductiveConstructor}{\\text{TriggerHardFork}}}}\\,     \\\\ \\,\\htmlId{18888}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionWellFormed? {$\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2598}{\\htmlId{18921}{\\htmlClass{InductiveConstructor}{\\text{ChangePParams}}}}\\,       \\\\ \\,\\htmlId{18943}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionWellFormed? {$\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2636}{\\htmlId{18976}{\\htmlClass{InductiveConstructor}{\\text{TreasuryWithdrawal}}}}\\,  \\\\ \\,\\htmlId{18998}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\nactionWellFormed? {$\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.Actions.html#2674}{\\htmlId{19031}{\\htmlClass{InductiveConstructor}{\\text{Info}}}}\\,                \\\\ \\,\\htmlId{19053}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$} = it\n\nopen GovEnv\nopen PParams hiding (a)\nopen GovVoter\n\nvariable\n  machr : Maybe Anchor\n  achr : Anchor\n  ast  : GovActionState\n</pre>"},{"location":"Ledger.Conway.Specification.Gov.html#the-gov-transition-system","title":"The GOV Transition System","text":"<p>The <code>GOV</code> transition rule has the following type signature:</p> <pre>data _\u22a2_\u21c0\u2987_,GOV\u2988_ : GovEnv \u00d7 \u2115 \u2192 GovState \u2192 GovVote \u228e GovProposal \u2192 GovState \u2192 Type where\n\n  GOV-Vote :\n    \u2219 (aid , ast) \u2208 fromList s\n    \u2219 canVote (PParamsOf \u0393) (action ast) (gvRole voter)\n    \u2219 isRegistered \u0393 voter\n    \u2219 \u00ac expired (\u0393 .epoch) ast\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      (\u0393 , k) \u22a2 s \u21c0\u2987 inj\u2081 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Gov.html#2957}{\\htmlId{19699}{\\htmlClass{Generalizable}{\\text{aid}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#2980}{\\htmlId{19705}{\\htmlClass{Generalizable}{\\text{voter}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#3019}{\\htmlId{19713}{\\htmlClass{Generalizable}{\\text{v}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Gov.html#19128}{\\htmlId{19717}{\\htmlClass{Generalizable}{\\text{machr}}}}\\, \\end{pmatrix}$ ,GOV\u2988 addVote s aid voter v\n\n  GOV-Propose :\n    let pp           = PParamsOf \u0393\n        e            = \u0393 .epoch\n        enactState   = EnactStateOf \u0393\n        rewardCreds  = \u0393 .rewardCreds\n        prop         = record { returnAddr = addr ; action = a ; anchor = achr\n                              ; policy = p ; deposit = d ; prevAction = prev }\n    in\n    \u2219 actionWellFormed a\n    \u2219 actionValid rewardCreds p (\u0393 .ppolicy) e a\n    \u2219 d \u2261 pp .govActionDeposit\n    \u2219 validHFAction prop s enactState\n    \u2219 hasParent enactState s (GovActionTypeOf a) prev\n    \u2219 NetworkIdOf addr \u2261 NetworkId\n    \u2219 CredentialOf addr \u2208 rewardCreds\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      (\u0393 , k) \u22a2 s \u21c0\u2987 inj\u2082 prop ,GOV\u2988 addAction s (pp .govActionLifetime +\u1d49 e)\n                                                 (\u0393 .txid , k) addr a prev\n\n</pre> <p>The <code>GOVS</code> transition rule is actually a function with following signature:</p> <pre>_\u22a2_\u21c0\u2987_,GOVS\u2988_ : GovEnv \u2192 GovState \u2192 List (GovVote \u228e GovProposal) \u2192 GovState \u2192 Type\n</pre> <p>Specifically, it is defined as a reduction combinator that applies the <code>GOV</code> rule at each step.<sup>2</sup></p> <pre>_\u22a2_\u21c0\u2987_,GOVS\u2988_ = ReflexiveTransitiveClosure\u1d62 {sts = _\u22a2_\u21c0\u2987_,GOV\u2988_}\n</pre> <p>For <code>GOVVote</code>, we check that the governance action being voted on exists; that the voter\u2019s role is allowed to vote (see <code>canVote</code> in Section [Voting Functions][]; and that the voter\u2019s credential is actually associated with their role (see <code>isRegistered</code> in the section on the [Type signature of the GOV transition relation][].</p> <p>For <code>GOVPropose</code>, we check the correctness of the deposit along with some and some conditions that ensure the action is well-formed and valid; naturally, these checks depend on the type of action being proposed (see the section on Validity and Wellformedness Predicates.</p> <ol> <li> <p>To see the definition of the <code>_connects_to_</code> function, click the \u201cShow more Agda\u201d button.\u00a0\u21a9</p> </li> <li> <p>The Agda code defining various versions of the <code>ReflexiveTransitiveClosure</code>    type is not yet documented as we are in the process of refactoring it.\u00a0\u21a9</p> </li> </ol>"},{"location":"Ledger.Conway.Specification.Ledger.Properties.Base.html","title":"Base","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\nimport Ledger.Conway.Specification.Certs\n\nmodule Ledger.Conway.Specification.Ledger.Properties.Base\n  (txs : _) (open TransactionStructure txs) (open Ledger.Conway.Specification.Certs govStructure)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Utxow txs abs\n\n-- open import Data.List using (map)\nopen import Data.List.Properties using (++-identity\u02b3; map-++)\n\nopen import Axiom.Set.Properties th\n\nopen import Data.Nat.Properties using (+-0-monoid; +-identity\u02b3; +-suc)\nopen import Relation.Binary using (IsEquivalence)\nimport Relation.Binary.Reasoning.Setoid as SetoidReasoning\n\n-- ** Proof that the set equality `govDepsMatch` (below) is a LEDGER invariant.\n\n-- Mapping a list of `GovActionID \u00d7 GovActionState`s to a list of\n-- `DepositPurpose`s is so common, we give it a name `dpMap`;\n-- it's equivalent to `map (\u03bb (id , _) \u2192 GovActionDeposit id)`.\ndpMap : GovState \u2192 List DepositPurpose\ndpMap = map (GovActionDeposit \u2218 proj\u2081)\n\nisGADeposit : DepositPurpose \u2192 Type\nisGADeposit dp = isGADeposit\u1d47 dp \u2261 true\n  where\n  isGADeposit\u1d47 : DepositPurpose \u2192 Bool\n  isGADeposit\u1d47 (GovActionDeposit _) = true\n  isGADeposit\u1d47 _                    = false\n\ngovDepsMatch : LState \u2192 Type\ngovDepsMatch ls =\n  filter\u02e2 isGADeposit (dom (DepositsOf ls)) \u2261\u1d49 fromList (dpMap (GovStateOf ls))\n\nmodule \u2261\u1d49 = IsEquivalence (\u2261\u1d49-isEquivalence {DepositPurpose})\npattern UTXOW-UTXOS x = UTXOW\u21d2UTXO (UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ x)\nopen Equivalence\n\nfilterGA : \u2200 txId n \u2192 filter\u02e2 isGADeposit \u2774 GovActionDeposit (txId , n) \u2775 \u2261\u1d49 \u2774 GovActionDeposit (txId , n) \u2775\nproj\u2081 (filterGA txId n) {a} x = (proj\u2082 (from \u2208-filter x)) where open Equivalence\nproj\u2082 (filterGA txId n) {a} x = to \u2208-filter (\u03be (from \u2208-singleton x) , x)\n  where\n  \u03be : a \u2261 GovActionDeposit (txId , n) \u2192 isGADeposit a\n  \u03be refl = refl\n\nmodule LEDGER-PROPS (tx : Tx) (\u0393 : LEnv) (s : LState) where\n  open Tx tx renaming (body to txb); open TxBody txb\n  open LEnv \u0393 renaming (pparams to pp)\n  open PParams pp using (govActionDeposit; govActionLifetime)\n  open LState s\n  open CertState certState\n  open DState dState\n\n  -- initial utxo deposits\n  utxoDeps : Deposits\n  utxoDeps = UTxOState.deposits (LState.utxoSt s)\n\n  -- GovState definitions and lemmas --\n  mkAction : GovProposal \u2192 \u2115 \u2192 GovActionID \u00d7 GovActionState\n  mkAction p n = let open GovProposal p in\n    mkGovStatePair\n      (govActionLifetime +\u1d49 epoch slot)\n      (txId , n) returnAddr action prevAction\n\n  -- update GovState with a proposal\n  propUpdate : GovState \u2192 GovProposal \u2192 \u2115 \u2192 GovState\n  propUpdate s p n = insertGovAction s (mkAction p n)\n\n  -- update GovState with a vote\n  voteUpdate : GovState \u2192 GovVote \u2192 GovState\n  voteUpdate s v = addVote s gid voter vote\n    where open GovVote v\n\n  -- update GovState with a list of votes and proposals\n  updateGovStates : List (GovVote \u228e GovProposal) \u2192 \u2115 \u2192 GovState \u2192 GovState\n  updateGovStates [] _ s = s\n  updateGovStates (inj\u2081 v \u2237 vps) k s = updateGovStates vps (suc k) (voteUpdate s v)\n  updateGovStates (inj\u2082 p \u2237 vps) k s = updateGovStates vps (suc k) (propUpdate s p k)\n\n  -- updateGovStates faithfully represents a step of the LEDGER sts\n  STS\u2192GovSt\u2261 : \u2200 {s' : LState} \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s'\n               \u2192 isValid \u2261 true \u2192 GovStateOf s' \u2261 updateGovStates (txgov txb) 0 (rmOrphanDRepVotes (CertStateOf s') (GovStateOf s))\n  STS\u2192GovSt\u2261 (LEDGER-V x) refl = STS\u2192updateGovSt\u2261 (txgov txb) 0 (proj\u2082 (proj\u2082 (proj\u2082 x)))\n    where\n    STS\u2192updateGovSt\u2261 : (vps : List (GovVote \u228e GovProposal)) (k : \u2115) {certSt : CertState} {govSt govSt' : GovState}\n      \u2192 (_\u22a2_\u21c0\u27e6_\u27e7\u1d62*'_ {_\u22a2_\u21c0\u27e6_\u27e7\u1d47_ = IdSTS}{_\u22a2_\u21c0\u2987_,GOV\u2988_} ($\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Transaction.html#4766}{\\htmlId{4056}{\\htmlClass{Function}{\\text{txId}}}}\\, \\\\ \\,\\href{Ledger.Core.Specification.Epoch.html#954}{\\htmlId{4063}{\\htmlClass{Function}{\\text{epoch}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1055}{\\htmlId{4069}{\\htmlClass{Function}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.Properties.Base.html#2422}{\\htmlId{4076}{\\htmlClass{Function}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1078}{\\htmlId{4081}{\\htmlClass{Function}{\\text{ppolicy}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1139}{\\htmlId{4091}{\\htmlClass{Function}{\\text{enactState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.Properties.Base.html#3952}{\\htmlId{4104}{\\htmlClass{Bound}{\\text{certSt}}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{4113}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\href{Ledger.Conway.Specification.Certs.html#4335}{\\htmlId{4117}{\\htmlClass{Function}{\\text{rewards}}}}\\, \\end{pmatrix}$ , k) govSt vps govSt')\n      \u2192 govSt' \u2261 updateGovStates vps k govSt\n    STS\u2192updateGovSt\u2261 [] _ (BS-base Id-nop) = refl\n    STS\u2192updateGovSt\u2261 (inj\u2081 v \u2237 vps) k (BS-ind (GOV-Vote x) h)\n      = STS\u2192updateGovSt\u2261 vps (suc k) h\n    STS\u2192updateGovSt\u2261 (inj\u2082 p \u2237 vps) k (BS-ind (GOV-Propose x) h) = STS\u2192updateGovSt\u2261 vps (suc k) h\n\n  opaque\n    unfolding addVote\n\n    dpMap-rmOrphanDRepVotes : \u2200 certState govSt \u2192 dpMap (rmOrphanDRepVotes certState govSt) \u2261 dpMap govSt\n    dpMap-rmOrphanDRepVotes certState govSt = sym (fmap-\u2218 govSt) -- map proj\u2081 \u2218 map (map\u2082 _) \u2261 map (proj\u2081 \u2218 map\u2082 _) \u2261 map proj\u2081\n\n\nmodule SetoidProperties (tx : Tx) (\u0393 : LEnv) (s : LState) where\n  open Tx tx renaming (body to txb); open TxBody txb\n  open LEnv \u0393 renaming (pparams to pp)\n  open LEDGER-PROPS tx \u0393 s using (utxoDeps; propUpdate; mkAction; updateGovStates; STS\u2192GovSt\u2261; voteUpdate; dpMap-rmOrphanDRepVotes)\n  open SetoidReasoning (\u2261\u1d49-Setoid{DepositPurpose})\n\n  CredDepIsNotGADep : \u2200 {a c} \u2192 a \u2261 CredentialDeposit c \u2192 \u00ac isGADeposit a\n  CredDepIsNotGADep refl ()\n\n  PoolDepIsNotGADep : \u2200 {a c} \u2192 a \u2261 PoolDeposit c \u2192 \u00ac isGADeposit a\n  PoolDepIsNotGADep refl ()\n\n  DRepDepIsNotGADep : \u2200 {a c} \u2192 a \u2261 DRepDeposit c \u2192 \u00ac isGADeposit a\n  DRepDepIsNotGADep refl ()\n\n  filterCR : (c : DCert) (deps : Deposits)\n             \u2192 filter\u02e2 isGADeposit (dom ( deps \u2223 certRefund c \u1d9c \u02e2 )) \u2261\u1d49 filter\u02e2 isGADeposit (dom (deps \u02e2))\n  filterCR (dereg c _) deps = \u2261\u1d49.sym $ begin\n    filter\u02e2 isGADeposit (dom (deps \u02e2)) \u2248\u02d8\u27e8 filter-cong $ dom-cong (res-ex-\u222a Dec-\u2208-singleton) \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr)\u02e2 \u222a (deps \u2223 cr \u1d9c)\u02e2)) \u2248\u27e8 filter-cong dom\u222a \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr) \u02e2) \u222a dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr) \u02e2)) \u222a filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 \u222a-cong filter0 \u2261\u1d49.refl \u27e9\n    \u2205 \u222a filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 \u222a-identity\u02e1 $ filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2)) \u220e\n    where\n    cr = \u2774 CredentialDeposit c \u2775\n    filter0 = filter-\u2205 (\u03bb _ \u2192 CredDepIsNotGADep \u2218 (from \u2208-singleton) \u2218 res-dom)\n  filterCR (deregdrep c _) deps = \u2261\u1d49.sym $ begin\n    filter\u02e2 isGADeposit (dom (deps \u02e2)) \u2248\u02d8\u27e8 filter-cong $ dom-cong (res-ex-\u222a Dec-\u2208-singleton) \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr)\u02e2 \u222a (deps \u2223 cr \u1d9c)\u02e2)) \u2248\u27e8 filter-cong dom\u222a \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr) \u02e2) \u222a dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr) \u02e2)) \u222a filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 \u222a-cong filter0 \u2261\u1d49.refl \u27e9\n    \u2205 \u222a filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u2248\u27e8 \u222a-identity\u02e1 $ filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2 )) \u27e9\n    filter\u02e2 isGADeposit (dom ((deps \u2223 cr \u1d9c) \u02e2)) \u220e\n    where\n    cr = \u2774 DRepDeposit c \u2775\n    filter0 = filter-\u2205 (\u03bb _ \u2192 DRepDepIsNotGADep \u2218 (from \u2208-singleton) \u2218 res-dom)\n  filterCR (delegate _ _ _ _)  deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n  filterCR (regpool _ _)       deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n  filterCR (regdrep _ _ _)     deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n  filterCR (retirepool _ _)    deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n  filterCR (ccreghot _ _)      deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n  filterCR (reg _ _)           deps = filter-cong (dom-cong (res\u1d50-\u2205\u1d9c {M = deps}))\n\n  filterCD : (c : DCert) (deps : Deposits) \u2192 filter\u02e2 isGADeposit (dom (certDeposit c pp \u02e2)) \u2261\u1d49 \u2205\n  filterCD (delegate _ _ _ _)  deps = filter-\u2205 \u03bb _ \u2192 CredDepIsNotGADep \u2218 from \u2208-singleton \u2218 dom-single\u2192single\n  filterCD (reg _ _)           deps = filter-\u2205 \u03bb _ \u2192 CredDepIsNotGADep \u2218 from \u2208-singleton \u2218 dom-single\u2192single\n  filterCD (regpool _ _)       deps = filter-\u2205 \u03bb _ \u2192 PoolDepIsNotGADep \u2218 from \u2208-singleton \u2218 dom-single\u2192single\n  filterCD (regdrep _ _ _)     deps = filter-\u2205 \u03bb _ \u2192 DRepDepIsNotGADep \u2218 from \u2208-singleton \u2218 dom-single\u2192single\n  filterCD (dereg _ _)         deps = \u2261\u1d49.trans (filter-cong dom\u2205) $ filter-\u2205 \u03bb _ a\u2208 _ \u2192 \u2209-\u2205 a\u2208\n  filterCD (retirepool _ _)    deps = \u2261\u1d49.trans (filter-cong dom\u2205) $ filter-\u2205 \u03bb _ a\u2208 _ \u2192 \u2209-\u2205 a\u2208\n  filterCD (deregdrep _ _)     deps = \u2261\u1d49.trans (filter-cong dom\u2205) $ filter-\u2205 \u03bb _ a\u2208 _ \u2192 \u2209-\u2205 a\u2208\n  filterCD (ccreghot _ _)      deps = \u2261\u1d49.trans (filter-cong dom\u2205) $ filter-\u2205 \u03bb _ a\u2208 _ \u2192 \u2209-\u2205 a\u2208\n\n  noGACerts : (cs : List DCert) (deps : Deposits)\n    \u2192 filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs deps)) \u2261\u1d49 filter\u02e2 isGADeposit (dom deps)\n  noGACerts [] _ = filter-cong \u2261\u1d49.refl\n  noGACerts (dcert@(delegate _ _ _ _) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u222a\u207a cd))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u222a\u207a cd)) \u2248\u27e8 filter-cong dom\u222a\u207a\u2261\u222adom \u27e9\n    filter\u02e2 isGADeposit (dom deps \u222a dom (cd \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a filter\u02e2 isGADeposit (dom (cd \u02e2)) \u2248\u27e8 \u222a-cong \u2261\u1d49.refl $ filterCD dcert deps \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a \u2205 \u2248\u27e8 \u222a-identity\u02b3 $ filter\u02e2 isGADeposit (dom deps) \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n    where\n      cd = certDeposit dcert pp\n      filter0 = filterCD dcert deps\n  noGACerts (dcert@(reg _ _) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u222a\u207a cd))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u222a\u207a cd)) \u2248\u27e8 filter-cong dom\u222a\u207a\u2261\u222adom \u27e9\n    filter\u02e2 isGADeposit (dom deps \u222a dom (cd \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a filter\u02e2 isGADeposit (dom (cd \u02e2)) \u2248\u27e8 \u222a-cong \u2261\u1d49.refl $ filterCD dcert deps \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a \u2205 \u2248\u27e8 \u222a-identity\u02b3 $ filter\u02e2 isGADeposit (dom deps) \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n    where\n      cd = certDeposit dcert pp\n      filter0 = filterCD dcert deps\n  noGACerts (dcert@(regpool _ _) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u222a\u02e1 cd))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u222a\u02e1 cd)) \u2248\u27e8 filter-cong (dom\u222a\u02e1\u2261\u222adom {m = deps} {m' = cd}) \u27e9\n    filter\u02e2 isGADeposit (dom deps \u222a dom (cd \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a filter\u02e2 isGADeposit (dom (cd \u02e2)) \u2248\u27e8 \u222a-cong \u2261\u1d49.refl filter0 \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a \u2205 \u2248\u27e8 \u222a-identity\u02b3 $ filter\u02e2 isGADeposit (dom deps) \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n    where\n      cd = certDeposit dcert pp\n      filter0 = filterCD dcert deps\n  noGACerts (dcert@(regdrep _ _ _) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u222a\u207a certDeposit dcert pp))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u222a\u207a cd)) \u2248\u27e8 filter-cong dom\u222a\u207a\u2261\u222adom \u27e9\n    filter\u02e2 isGADeposit (dom deps \u222a dom (cd \u02e2 )) \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a filter\u02e2 isGADeposit (dom (cd \u02e2)) \u2248\u27e8 \u222a-cong \u2261\u1d49.refl filter0 \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u222a \u2205 \u2248\u27e8 \u222a-identity\u02b3 $ filter\u02e2 isGADeposit (dom deps) \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n    where\n      cd = certDeposit dcert pp\n      filter0 = filterCD dcert deps\n  noGACerts (dcert@(dereg c v) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u2223 certRefund (dereg c v)\u1d9c))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u2223 certRefund (dereg c v)\u1d9c)) \u2248\u27e8 filterCR dcert deps \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n  noGACerts (dcert@(deregdrep c v) \u2237 cs) deps = begin\n    filter\u02e2 isGADeposit (dom (updateCertDeposits pp cs (deps \u2223 certRefund (deregdrep c v)\u1d9c))) \u2248\u27e8 noGACerts cs _ \u27e9\n    filter\u02e2 isGADeposit (dom (deps \u2223 certRefund (deregdrep c v)\u1d9c)) \u2248\u27e8 filterCR dcert deps \u27e9\n    filter\u02e2 isGADeposit (dom deps) \u220e\n  noGACerts (retirepool _ _ \u2237 cs) deps = noGACerts cs deps\n  noGACerts (ccreghot _ _ \u2237 cs) deps = noGACerts cs deps\n\n  opaque\n    unfolding addVote\n\n    dpMap\u2218voteUpdate\u2261dpMap : (v : GovVote) {govSt : GovState}\n      \u2192 dpMap (voteUpdate govSt v) \u2261 dpMap govSt\n    dpMap\u2218voteUpdate\u2261dpMap v {[]} = refl\n    dpMap\u2218voteUpdate\u2261dpMap v {(aid , ast) \u2237 govSt} =\n      cong (\u03bb x \u2192 (GovActionDeposit \u2218 proj\u2081) (aid , ast) \u2237 x) (dpMap\u2218voteUpdate\u2261dpMap v)\n\n  props-dpMap-votes-invar : (vs : List GovVote) (ps : List GovProposal) {k : \u2115} {govSt : GovState}\n    \u2192 fromList (dpMap (updateGovStates (map inj\u2082 ps ++ map inj\u2081 vs) k govSt ))\n      \u2261\u1d49 fromList (dpMap (updateGovStates (map inj\u2082 ps) k govSt))\n  props-dpMap-votes-invar [] ps {k} {govSt} = \u2261\u1d49.reflexive\n    (cong (\u03bb x \u2192 fromList (dpMap (updateGovStates x k govSt))) (++-identity\u02b3 (map inj\u2082 ps)))\n  props-dpMap-votes-invar (v \u2237 vs) [] {k} {govSt} = begin\n    fromList (dpMap (updateGovStates (map inj\u2081 (v \u2237 vs)) k govSt))\n      \u2248\u27e8 props-dpMap-votes-invar vs [] \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 []) (suc k) (voteUpdate govSt v)))\n      \u2261\u27e8 cong fromList (dpMap\u2218voteUpdate\u2261dpMap v) \u27e9\n    fromList (dpMap govSt)\n      \u220e\n  props-dpMap-votes-invar (v \u2237 vs) (p \u2237 ps) {k} {govSt} = props-dpMap-votes-invar (v \u2237 vs) ps\n\n  dpMap-update-\u222a : \u2200 gSt p k\n    \u2192 fromList (dpMap gSt) \u222a \u2774 GovActionDeposit (txId , k) \u2775\n        \u2261\u1d49 fromList (dpMap (propUpdate gSt p k))\n  dpMap-update-\u222a [] p k = \u222a-identity\u02e1 (fromList (dpMap [ mkAction p k ]))\n  dpMap-update-\u222a (g@(gaID\u2080 , gaSt\u2080) \u2237 gSt) p k\n    with (govActionPriority (GovActionTypeOf gaSt\u2080))\n         \u2264? (govActionPriority (GovActionTypeOf (proj\u2082 (mkAction p k))))\n  ... | yes _  = begin\n      fromList (dpMap (g \u2237 gSt)) \u222a \u2774 GovActionDeposit (txId , k) \u2775\n        \u2248\u27e8 \u222a-cong fromList-\u222a-singleton \u2261\u1d49.refl \u27e9\n      (\u2774 GovActionDeposit gaID\u2080 \u2775 \u222a fromList (dpMap gSt)) \u222a \u2774 GovActionDeposit (txId , k) \u2775\n        \u2248\u27e8 \u222a-assoc \u2774 GovActionDeposit gaID\u2080 \u2775 (fromList (dpMap gSt)) \u2774 GovActionDeposit (txId , k) \u2775 \u27e9\n      \u2774 GovActionDeposit gaID\u2080 \u2775 \u222a (fromList (dpMap gSt) \u222a \u2774 GovActionDeposit (txId , k) \u2775)\n        \u2248\u27e8 \u222a-cong \u2261\u1d49.refl (dpMap-update-\u222a gSt p k) \u27e9\n      \u2774 GovActionDeposit gaID\u2080 \u2775 \u222a fromList (dpMap (propUpdate gSt p k))\n        \u2248\u02d8\u27e8 fromList-\u222a-singleton \u27e9\n      fromList (dpMap (g \u2237 insertGovAction gSt (mkAction p k)))\n        \u220e\n  ... | no _   = begin\n      fromList (dpMap (g \u2237 gSt)) \u222a \u2774 GovActionDeposit (txId , k) \u2775\n        \u2248\u27e8 \u222a-comm (fromList (dpMap (g \u2237 gSt))) \u2774 GovActionDeposit (txId , k) \u2775 \u27e9\n      \u2774 GovActionDeposit (txId , k) \u2775 \u222a fromList (dpMap (g \u2237 gSt))\n        \u2248\u02d8\u27e8 fromList-\u222a-singleton \u27e9\n      fromList (dpMap ((mkAction p k) \u2237 g \u2237 gSt))\n        \u220e\n\n  connex-lemma : \u2200 gSt p ps {k}\n    \u2192 fromList (dpMap (updateGovStates (map inj\u2082 ps) k gSt)) \u222a \u2774 GovActionDeposit (txId , k + length ps) \u2775\n        \u2261\u1d49 fromList (dpMap (updateGovStates (map inj\u2082 ps) (suc k) (propUpdate gSt p k)))\n  connex-lemma gSt p [] {k} = begin\n      fromList (dpMap gSt) \u222a \u2774 GovActionDeposit (txId , k + 0) \u2775\n        \u2261\u27e8 cong (\u03bb x \u2192 fromList (dpMap gSt) \u222a \u2774 GovActionDeposit (txId , x) \u2775) (+-identity\u02b3 k) \u27e9\n      fromList (dpMap gSt) \u222a \u2774 GovActionDeposit (txId , k) \u2775\n        \u2248\u27e8 dpMap-update-\u222a gSt p k \u27e9\n      fromList (dpMap (propUpdate gSt p k))\n        \u220e\n  connex-lemma gSt p (p' \u2237 ps) {k} = begin\n    fromList (dpMap (updateGovStates (map inj\u2082 (p' \u2237 ps)) k gSt))\n      \u222a \u2774 GovActionDeposit (txId , k + length (p' \u2237 ps)) \u2775\n        \u2261\u27e8 cong (\u03bb x \u2192 fromList (dpMap (updateGovStates (map inj\u2082 (p' \u2237 ps)) k gSt))\n            \u222a \u2774 GovActionDeposit (txId , x) \u2775) (+-suc k (length ps)) \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) (suc k) (propUpdate gSt p' k)))\n      \u222a \u2774 GovActionDeposit (txId , (suc k) + length ps) \u2775\n        \u2248\u02d8\u27e8 \u222a-cong (connex-lemma gSt p' ps) \u2261\u1d49.refl \u27e9\n    (fromList (dpMap (updateGovStates (map inj\u2082 ps) k gSt))\n      \u222a \u2774 GovActionDeposit (txId , k + length ps) \u2775)\n      \u222a \u2774 GovActionDeposit (txId , (suc k) + length ps) \u2775\n        \u2248\u27e8 \u222a-cong (connex-lemma gSt p ps) \u2261\u1d49.refl \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) (suc k) (propUpdate gSt p k)))\n      \u222a \u2774 GovActionDeposit (txId , (suc k) + length ps) \u2775\n        \u2248\u27e8 connex-lemma (propUpdate gSt p k) p' ps \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 (p' \u2237 ps)) (suc k) (propUpdate gSt p k)))\n        \u220e\n\n  utxo-govst-connex : \u2200 txp {utxoDs gSt gad}\n    \u2192 filter\u02e2 isGADeposit (dom (utxoDs)) \u2261\u1d49 fromList (dpMap gSt)\n    \u2192 filter\u02e2 isGADeposit (dom (updateProposalDeposits txp txId gad utxoDs))\n      \u2261\u1d49 fromList (dpMap (updateGovStates (map inj\u2082 txp) 0 gSt))\n  utxo-govst-connex [] x = x\n  utxo-govst-connex (p \u2237 ps) {utxoDs} {gSt} {gad} x = begin\n    filter\u02e2 isGADeposit (dom (updateProposalDeposits (p \u2237 ps) txId gad utxoDs))\n      \u2248\u27e8 filter-cong dom\u222a\u207a\u2261\u222adom \u27e9\n    filter\u02e2 isGADeposit ((dom (updateProposalDeposits ps txId gad utxoDs))\n      \u222a (dom{X = Deposits} \u2774 GovActionDeposit (txId , length ps) , gad \u2775))\n      \u2248\u27e8 filter-hom-\u222a \u27e9\n    filter\u02e2 isGADeposit (dom (updateProposalDeposits ps txId gad utxoDs)) \u222a filter\u02e2 isGADeposit\n        (dom{X = Deposits} \u2774 GovActionDeposit (txId , length ps) , gad \u2775)\n      \u2248\u27e8 \u222a-cong (utxo-govst-connex ps x) (filter-cong dom-single\u2261single) \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) 0 gSt))\n      \u222a filter\u02e2 isGADeposit \u2774 GovActionDeposit (txId , length ps) \u2775\n      \u2248\u27e8 \u222a-cong  \u2261\u1d49.refl (filterGA txId _) \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) 0 gSt)) \u222a \u2774 GovActionDeposit (txId , length ps) \u2775\n      \u2248\u27e8 connex-lemma gSt p ps \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 (p \u2237 ps)) 0 gSt)) \u220e\n\n  -- The list of natural numbers from 0 up to `n` - 1.\n  \u27e60:&lt;_\u27e7 : \u2115 \u2192 List \u2115\n  \u27e60:&lt; 0     \u27e7 = []\n  \u27e60:&lt; suc n \u27e7 = \u27e60:&lt; n \u27e7 ++ [ n ]\n\n  connex-lemma-rep : \u2200 k govSt ps \u2192\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) k govSt))\n    \u2261\u1d49\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7)\n  connex-lemma-rep k govSt [] = begin\n    fromList (dpMap govSt)\n      \u2248\u02d8\u27e8 \u222a-identity\u02b3 (fromList (dpMap govSt)) \u27e9\n    fromList (dpMap govSt) \u222a fromList []\n      \u2261\u27e8\u27e9\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; 0 \u27e7) \u220e\n  connex-lemma-rep k govSt (p \u2237 ps) = begin\n    fromList (dpMap (updateGovStates (map inj\u2082 (p \u2237 ps)) k govSt))\n      \u2261\u27e8\u27e9\n    fromList (dpMap (updateGovStates (inj\u2082 p \u2237 map inj\u2082 ps) k govSt))\n      \u2261\u27e8\u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) (suc k) (propUpdate govSt p k)))\n      \u2248\u02d8\u27e8 connex-lemma govSt p ps {k} \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 ps) k govSt)) \u222a \u2774 GovActionDeposit (txId , k + length ps) \u2775\n      \u2248\u27e8 \u222a-cong (connex-lemma-rep k govSt ps) \u2261\u1d49.refl \u27e9\n    (fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7)) \u222a \u2774 GovActionDeposit (txId , k + length ps) \u2775\n      \u2248\u27e8 \u222a-assoc (fromList (dpMap govSt)) (fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7)) \u2774 GovActionDeposit (txId , k + length ps) \u2775 \u27e9\n    fromList (dpMap govSt) \u222a (fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7) \u222a \u2774 GovActionDeposit (txId , k + length ps) \u2775)\n      \u2261\u27e8\u27e9\n    fromList (dpMap govSt) \u222a (fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7) \u222a fromList [ GovActionDeposit (txId , k + length ps) ])\n      \u2248\u27e8 \u222a-cong \u2261\u1d49.refl (\u222a-fromList-++ (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7) [ GovActionDeposit (txId , k + length ps) ]) \u27e9\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length ps \u27e7 ++ [ GovActionDeposit (txId , k + length ps) ])\n      \u2261\u02d8\u27e8 cong (\u03bb x \u2192 fromList (dpMap govSt) \u222a fromList x) (map-++ _ \u27e60:&lt; length ps \u27e7 [ length ps ]) \u27e9\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) (\u27e60:&lt; length ps \u27e7 ++ [ length ps ]))\n      \u2261\u27e8\u27e9\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length (p \u2237 ps) \u27e7) \u220e\n\n  -- Removing orphan DRep votes does not modify the set of GAs in GovState\n  |\u1d52-GAs-pres : \u2200 k govSt certState \u2192\n    fromList (dpMap (updateGovStates (txgov txb) k (rmOrphanDRepVotes certState govSt)))\n    \u2261\u1d49\n    fromList (dpMap (updateGovStates (txgov txb) k govSt))\n  |\u1d52-GAs-pres k govSt certState = begin\n    fromList (dpMap (updateGovStates (txgov txb) k (rmOrphanDRepVotes certState govSt)))\n      \u2248\u27e8 props-dpMap-votes-invar txGovVotes txGovProposals {k} {rmOrphanDRepVotes certState govSt} \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 txGovProposals) k (rmOrphanDRepVotes certState govSt)))\n      \u2248\u27e8 connex-lemma-rep k (rmOrphanDRepVotes certState govSt) txGovProposals \u27e9\n    fromList (dpMap (rmOrphanDRepVotes certState govSt)) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length txGovProposals \u27e7)\n      \u2261\u27e8 cong (\u03bb x \u2192 fromList x \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length txGovProposals \u27e7)) (dpMap-rmOrphanDRepVotes certState govSt) \u27e9\n    fromList (dpMap govSt) \u222a fromList (map (\u03bb i \u2192 GovActionDeposit (txId , k + i)) \u27e60:&lt; length txGovProposals \u27e7)\n      \u2248\u02d8\u27e8 connex-lemma-rep k govSt txGovProposals \u27e9\n    fromList (dpMap (updateGovStates (map inj\u2082 txGovProposals) k govSt))\n      \u2248\u02d8\u27e8 props-dpMap-votes-invar txGovVotes txGovProposals {k} {govSt} \u27e9\n    fromList (dpMap (updateGovStates (txgov txb) k govSt)) \u220e\n</pre>"},{"location":"Ledger.Conway.Specification.Ledger.Properties.Computational.html","title":"Ledger: Computational","text":"<p>This module proves that the <code>LEDGER</code> transition system is computational.</p> <pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\nimport Ledger.Conway.Specification.Certs\n\nmodule Ledger.Conway.Specification.Ledger.Properties.Computational\n  (txs : _) (open TransactionStructure txs) (open Ledger.Conway.Specification.Certs govStructure)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Certs.Properties.Computational govStructure\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Gov.Properties.Computational txs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Utxow txs abs\nopen import Ledger.Conway.Specification.Utxow.Properties.Computational txs abs\n\nopen import Data.Bool.Properties using (\u00ac-not)\n</pre> <pre>instance\n  _ = Monad-ComputationResult\n\n  Computational-LEDGER : Computational _\u22a2_\u21c0\u2987_,LEDGER\u2988_ String\n  Computational-LEDGER = record {go}\n    where\n    open Computational \u2983...\u2984 renaming (computeProof to comp; completeness to complete)\n    computeUtxow = comp {STS = _\u22a2_\u21c0\u2987_,UTXOW\u2988_}\n    computeCerts = comp {STS = _\u22a2_\u21c0\u2987_,CERTS\u2988_}\n    computeGov   = comp {STS = _\u22a2_\u21c0\u2987_,GOVS\u2988_}\n\n    module go\n      (\u0393 : LEnv)   (let open LEnv \u0393)\n      (s : LState) (let open LState s)\n      (tx : Tx)    (let open Tx tx renaming (body to txb); open TxBody txb)\n      where\n      utxo\u0393 = UTxOEnv \u220b record { LEnv \u0393 }\n      cert\u0393 = CertEnv \u220b $\\begin{pmatrix} \\,\\href{Ledger.Core.Specification.Epoch.html#954}{\\htmlId{1837}{\\htmlClass{Function}{\\text{epoch}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1055}{\\htmlId{1843}{\\htmlClass{Field}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1113}{\\htmlId{1850}{\\htmlClass{Field}{\\text{pparams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Transaction.html#5049}{\\htmlId{1860}{\\htmlClass{Function}{\\text{txGovVotes}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Transaction.html#4874}{\\htmlId{1873}{\\htmlClass{Function}{\\text{txWithdrawals}}}}\\, \\\\ \\,\\htmlId{1889}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$\n      gov\u0393 : CertState \u2192 GovEnv\n      gov\u0393 = \u03bb certState \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Transaction.html#4766}{\\htmlId{1954}{\\htmlClass{Function}{\\text{txId}}}}\\, \\\\ \\,\\href{Ledger.Core.Specification.Epoch.html#954}{\\htmlId{1961}{\\htmlClass{Function}{\\text{epoch}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#1055}{\\htmlId{1967}{\\htmlClass{Field}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1113}{\\htmlId{1974}{\\htmlClass{Field}{\\text{pparams}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1078}{\\htmlId{1984}{\\htmlClass{Field}{\\text{ppolicy}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#1139}{\\htmlId{1994}{\\htmlClass{Field}{\\text{enactState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.Properties.Computational.html#1940}{\\htmlId{2007}{\\htmlClass{Bound}{\\text{certState}}}}\\, \\\\ \\,\\htmlId{2019}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$\n\n      computeProof : ComputationResult String (\u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s')\n      computeProof = case isValid \u225f true of \u03bb where\n        (yes p) \u2192 do\n          (utxoSt' , utxoStep) \u2190 computeUtxow utxo\u0393 utxoSt tx\n          (certSt' , certStep) \u2190 computeCerts cert\u0393 certState txCerts\n          (govSt'  , govStep)  \u2190 computeGov (gov\u0393 certSt') (rmOrphanDRepVotes certSt' govSt) (txgov txb)\n          success (_ , LEDGER-V\u22ef p utxoStep certStep govStep)\n        (no \u00acp) \u2192 do\n          (utxoSt' , utxoStep) \u2190 computeUtxow utxo\u0393 utxoSt tx\n          success (_ , LEDGER-I\u22ef (\u00ac-not \u00acp) utxoStep)\n\n      completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s' \u2192 (proj\u2081 &lt;$&gt; computeProof) \u2261 success s'\n      completeness ledgerSt (LEDGER-V\u22ef v utxoStep certStep govStep)\n        with isValid \u225f true\n      ... | no \u00acv = contradiction v \u00acv\n      ... | yes refl\n        with computeUtxow utxo\u0393 utxoSt tx | complete _ _ _ _ utxoStep\n      ... | success (utxoSt' , _) | refl\n        with computeCerts cert\u0393 certState txCerts | complete _ _ _ _ certStep\n      ... | success (certSt' , _) | refl\n        with computeGov (gov\u0393 certSt') (rmOrphanDRepVotes certSt' govSt ) (txgov txb)\n             | complete {STS = _\u22a2_\u21c0\u2987_,GOVS\u2988_} (gov\u0393 certSt') _ _ _ govStep\n      ... | success (govSt' , _) | refl = refl\n      completeness ledgerSt (LEDGER-I\u22ef i utxoStep)\n        with isValid \u225f true\n      ... | yes refl = case i of \u03bb ()\n      ... | no \u00acv\n        with computeUtxow utxo\u0393 utxoSt tx | complete _ _ _ _ utxoStep\n      ... | success (utxoSt' , _) | refl = refl\n\nComputational-LEDGERS : Computational _\u22a2_\u21c0\u2987_,LEDGERS\u2988_ String\nComputational-LEDGERS = it\n</pre>"},{"location":"Ledger.Conway.Specification.Ledger.Properties.GovDepsMatch.html","title":"GovDepsMatch","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Ledger.Properties.GovDepsMatch\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Certs govStructure using (DepositPurpose)\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.Ledger.Properties.Base txs abs\nopen import Ledger.Conway.Specification.Ledger.Properties.Computational txs abs\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Utxo txs abs\n\nopen import Axiom.Set.Properties th\nimport Relation.Binary.Reasoning.Setoid as SetoidReasoning\n\nopen SetoidReasoning (\u2261\u1d49-Setoid{DepositPurpose})\n</pre> <p> Lemma (<code>govDepsMatch</code> is invariant of <code>LEDGER</code> rule).</p> <p>Informally.</p> <p>Suppose <code>s</code> and <code>s'</code> are ledger states such that <code>s</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,LEDGER\u2988</code> <code>s'</code>. Let <code>utxoSt</code> and <code>utxoSt'</code> be their respective <code>UTxOStates</code> and let <code>govSt</code>  and <code>govSt'</code> be their respective <code>GovStates</code>. If the governance action deposits of <code>utxoSt</code> are equal to those of <code>govSt</code>, then the same holds for <code>utxoSt'</code> and <code>govSt'</code>. In other terms, if <code>govDepsMatch</code> <code>s</code>, then <code>govDepsMatch</code> <code>s'</code>.</p> <p>Formally.</p> <pre>LEDGER-govDepsMatch :  LedgerInvariant _\u22a2_\u21c0\u2987_,LEDGER\u2988_ govDepsMatch\n</pre> <p>Proof.</p> <pre>LEDGER-govDepsMatch (LEDGER-I\u22ef refl (UTXOW-UTXOS (Scripts-No _))) aprioriMatch = aprioriMatch\n\nLEDGER-govDepsMatch {\u0393}{s}{tx}{s'}\n    utxosts@(LEDGER-V\u22ef tx-valid (UTXOW-UTXOS (Scripts-Yes x)) _ GOV-sts) aprioriMatch =\n    let  open Tx tx; open TxBody body\n         open LEnv \u0393 renaming (pparams to pp)\n         open PParams pp using (govActionDeposit)\n         open LState s\n         open LState s' renaming (govSt to govSt'; certState to certState')\n         open LEDGER-PROPS tx \u0393 s using (utxoDeps; updateGovStates; STS\u2192GovSt\u2261)\n         open SetoidProperties tx \u0393 s using (|\u1d52-GAs-pres; props-dpMap-votes-invar; utxo-govst-connex; noGACerts)\n    in\n    begin\n      filter\u02e2 isGADeposit (dom (updateDeposits pp body utxoDeps))\n        \u2248\u27e8 noGACerts txCerts (updateProposalDeposits txGovProposals txId govActionDeposit utxoDeps) \u27e9\n      filter\u02e2 isGADeposit (dom (updateProposalDeposits txGovProposals txId govActionDeposit utxoDeps))\n        \u2248\u27e8 utxo-govst-connex txGovProposals aprioriMatch \u27e9\n      fromList (dpMap (updateGovStates (map inj\u2082 txGovProposals) 0 govSt))\n        \u2248\u02d8\u27e8 props-dpMap-votes-invar txGovVotes txGovProposals \u27e9\n      fromList (dpMap (updateGovStates (txgov body) 0 govSt ))\n        \u2248\u02d8\u27e8 |\u1d52-GAs-pres 0 govSt certState' \u27e9\n      fromList (dpMap (updateGovStates (txgov body) 0 (rmOrphanDRepVotes certState' govSt)))\n        \u2261\u02d8\u27e8 cong (fromList \u2218 dpMap ) (STS\u2192GovSt\u2261 utxosts tx-valid) \u27e9\n      fromList (dpMap govSt') \u220e\n\nLEDGER-govDepsMatch {s' = s'} utxosts@(LEDGER-V (() , UTXOW-UTXOS (Scripts-No (_ , refl)) , _ , GOV-sts)) aprioriMatch\n</pre>"},{"location":"Ledger.Conway.Specification.Ledger.Properties.PoV.html","title":"PoV","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Ledger.Properties.PoV\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Chain txs abs\nopen import Ledger.Conway.Specification.Certs.Properties.Computational govStructure\nopen import Ledger.Conway.Specification.Certs.Properties.PoV govStructure\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Utxo.Properties.PoV txs abs\nopen import Ledger.Conway.Specification.Utxow txs abs\n\nopen import Axiom.Set.Properties th\n\nopen import Data.Nat.Properties using (+-0-monoid; +-identity\u02b3; +-comm; +-assoc; *-identity\u02b3; *-zero\u02b3)\n\n-- ** Proof that LEDGER preserves values.\n\ninstance\n  HasCoin-LState : HasCoin LState\n  HasCoin-LState .getCoin s = getCoin (LState.utxoSt s) + getCoin (LState.certState s)\n\nmodule _\n  (tx : Tx) (let open Tx tx; open TxBody body)\n  ( indexedSum\u1d5b'-\u222a  :  {A : Type} \u2983 _ : DecEq A \u2984 (m m' : A \u21c0 Coin)\n                       \u2192 disjoint (dom m) (dom m') \u2192 getCoin (m \u222a\u02e1 m') \u2261 getCoin m + getCoin m' )\n  ( sumConstZero    :  {A : Type} \u2983 _ : DecEq A \u2984 {X : \u2119 A} \u2192 getCoin (constMap X 0) \u2261 0 )\n  ( res-decomp      :  {A : Type} \u2983 _ : DecEq A \u2984 (m m' : A \u21c0 Coin)\n                       \u2192 (m \u222a\u02e1 m')\u02e2 \u2261\u1d49 (m \u222a\u02e1 (m' \u2223 dom (m \u02e2) \u1d9c))\u02e2 )\n  ( getCoin-cong    :  {A : Type} \u2983 _ : DecEq A \u2984 (s : A \u21c0 Coin) (s' : \u2119 (A \u00d7 Coin)) \u2192 s \u02e2 \u2261\u1d49 s'\n                       \u2192 indexedSum' proj\u2082 (s \u02e2) \u2261 indexedSum' proj\u2082 s' )\n  ( \u2261\u1d49-getCoin\u02e2     :  {A A' : Type} \u2983 _ : DecEq A \u2984 \u2983 _ : DecEq A' \u2984 (s : \u2119 (A \u00d7 Coin)) {f : A \u2192 A'}\n                       \u2192 InjectiveOn (dom s) f \u2192 getCoin (map\u02e2 (map\u2081 f) s) \u2261 getCoin s )\n  where\n\n  pattern UTXO-induction r = UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ r _ _ _\n</pre> <p> Theorem (The <code>LEDGER</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>s</code> and <code>s'</code> be ledger states and  let <code>tx</code> : <code>Tx</code> be a fresh transaction, that is, a transaction that is not already part of the <code>UTxOState</code> of <code>s</code>. If <code>s</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,LEDGER\u2988</code> <code>s'</code>, then the coin values of <code>s</code> and <code>s'</code> are equal, that is,  <code>getCoin</code> <code>s</code> \\(\u2261\\) <code>getCoin</code> <code>s'</code>.</p> <p>Formally.</p> <pre>  LEDGER-pov : {\u0393 : LEnv} {s s' : LState}\n    \u2192 txId \u2209 map\u02e2 proj\u2081 (dom (UTxOOf s))\n    \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,LEDGER\u2988 s' \u2192 getCoin s \u2261 getCoin s'\n</pre> <p>Proof.</p> <pre>  LEDGER-pov\n    {s  = s}\n    {s' = s'}\n    h (LEDGER-V {utxoSt' = utxoSt''} ( valid , UTXOW\u21d2UTXO st@(UTXO-induction r) , h' , _ )) =\n    let\n      open LState s\n      open CertState certState\n      open LState s' renaming (utxoSt to utxoSt'; govSt to govSt'; certState to certState')\n      open CertState certState'\n      open \u2261-Reasoning\n      open Certs-PoV indexedSum\u1d5b'-\u222a sumConstZero res-decomp  getCoin-cong \u2261\u1d49-getCoin\u02e2\n      zeroMap    = constMap (map\u02e2 RwdAddr.stake (dom txWithdrawals)) 0\n    in\n    begin\n      getCoin utxoSt + getCoin certState\n        \u2261\u27e8 cong (getCoin utxoSt +_) (CERTS-pov r h') \u27e9\n      getCoin utxoSt + (getCoin certState' + getCoin txWithdrawals)\n        \u2261\u02d8\u27e8 cong (\u03bb x \u2192 getCoin utxoSt + (getCoin certState' + x )) (*-identity\u02b3 (getCoin txWithdrawals)) \u27e9\n      getCoin utxoSt + (getCoin certState' + getCoin txWithdrawals * 1)\n        \u2261\u02d8\u27e8 cong (\u03bb u \u2192 getCoin utxoSt + (getCoin certState' + getCoin txWithdrawals * \u03c7 u)) valid \u27e9\n      getCoin utxoSt + (getCoin certState' + getCoin txWithdrawals * \u03c7 isValid)\n        \u2261\u27e8 cong (getCoin utxoSt +_) (+-comm (getCoin certState') _) \u27e9\n      getCoin utxoSt + (getCoin txWithdrawals * \u03c7 isValid + getCoin certState')\n        \u2261\u02d8\u27e8 +-assoc (getCoin utxoSt) (getCoin txWithdrawals * \u03c7 isValid) (getCoin certState') \u27e9\n      getCoin utxoSt + getCoin txWithdrawals * \u03c7 isValid + getCoin certState'\n        \u2261\u27e8 cong (_+ getCoin certState') (UTXOpov h st) \u27e9\n      getCoin utxoSt' + getCoin certState'\n        \u220e\n\n  LEDGER-pov  {s = s}\n              {s' = s'}\n              h (LEDGER-I {utxoSt' = utxoSt''} (invalid , UTXOW\u21d2UTXO st)) =\n    let\n        open LState s\n        open CertState certState\n        open LState s' renaming (utxoSt to utxoSt'; govSt to govSt'; certState to certState')\n        open UTxOState utxoSt\n        open UTxOState utxoSt' renaming (utxo to utxo'; fees to fees'\n                                        ; deposits to deposits'; donations to donations') in\n    cong (_+ rewardsBalance dState)\n    ( begin\n      getCoin $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.html#2998}{\\htmlId{4868}{\\htmlClass{Function}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3020}{\\htmlId{4875}{\\htmlClass{Function}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{4882}{\\htmlClass{Function}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3068}{\\htmlId{4893}{\\htmlClass{Function}{\\text{donations}}}}\\, \\end{pmatrix}$\n        \u2261\u02d8\u27e8 +-identity\u02b3 (getCoin $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.html#2998}{\\htmlId{4940}{\\htmlClass{Function}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3020}{\\htmlId{4947}{\\htmlClass{Function}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{4954}{\\htmlClass{Function}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3068}{\\htmlId{4965}{\\htmlClass{Function}{\\text{donations}}}}\\, \\end{pmatrix}$) \u27e9\n      getCoin $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.html#2998}{\\htmlId{4996}{\\htmlClass{Function}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3020}{\\htmlId{5003}{\\htmlClass{Function}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{5010}{\\htmlClass{Function}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3068}{\\htmlId{5021}{\\htmlClass{Function}{\\text{donations}}}}\\, \\end{pmatrix}$ + 0\n        \u2261\u02d8\u27e8 cong (getCoin $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.html#2998}{\\htmlId{5065}{\\htmlClass{Function}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3020}{\\htmlId{5072}{\\htmlClass{Function}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{5079}{\\htmlClass{Function}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3068}{\\htmlId{5090}{\\htmlClass{Function}{\\text{donations}}}}\\, \\end{pmatrix}$ +_) (*-zero\u02b3 (getCoin txWithdrawals)) \u27e9\n      getCoin $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.html#2998}{\\htmlId{5158}{\\htmlClass{Function}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3020}{\\htmlId{5165}{\\htmlClass{Function}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{5172}{\\htmlClass{Function}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3068}{\\htmlId{5183}{\\htmlClass{Function}{\\text{donations}}}}\\, \\end{pmatrix}$ + getCoin txWithdrawals * 0\n        \u2261\u02d8\u27e8 cong (\u03bb x \u2192 getCoin $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.html#2998}{\\htmlId{5257}{\\htmlClass{Function}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3020}{\\htmlId{5264}{\\htmlClass{Function}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{5271}{\\htmlClass{Function}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3068}{\\htmlId{5282}{\\htmlClass{Function}{\\text{donations}}}}\\, \\end{pmatrix}$ + getCoin txWithdrawals * \u03c7 x) invalid \u27e9\n      getCoin $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.html#2998}{\\htmlId{5351}{\\htmlClass{Function}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3020}{\\htmlId{5358}{\\htmlClass{Function}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3042}{\\htmlId{5365}{\\htmlClass{Function}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#3068}{\\htmlId{5376}{\\htmlClass{Function}{\\text{donations}}}}\\, \\end{pmatrix}$ + getCoin txWithdrawals * \u03c7 isValid\n        \u2261\u27e8 UTXOpov h st \u27e9\n      getCoin $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ledger.Properties.PoV.html#4690}{\\htmlId{5466}{\\htmlClass{Function}{\\text{utxo'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.Properties.PoV.html#4705}{\\htmlId{5474}{\\htmlClass{Function}{\\text{fees'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.Properties.PoV.html#4765}{\\htmlId{5482}{\\htmlClass{Function}{\\text{deposits'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.Properties.PoV.html#4789}{\\htmlId{5494}{\\htmlClass{Function}{\\text{donations'}}}}\\, \\end{pmatrix}$ \u220e )\n    where open \u2261-Reasoning\n</pre>"},{"location":"Ledger.Conway.Specification.Ledger.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Ledger.Properties where\n\nopen import Ledger.Conway.Specification.Ledger.Properties.Base\nopen import Ledger.Conway.Specification.Ledger.Properties.Computational\nopen import Ledger.Conway.Specification.Ledger.Properties.GovDepsMatch\nopen import Ledger.Conway.Specification.Ledger.Properties.PoV\n</pre>"},{"location":"Ledger.Conway.Specification.Ledger.html","title":"Ledger","text":"<p>This module defines the ledger transition system where valid transactions transform the ledger state.</p> <pre>{-# OPTIONS --safe #-}\n\nimport Data.List as L\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nmodule Ledger.Conway.Specification.Ledger\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Utxow txs abs\nopen import Ledger.Conway.Specification.Certs govStructure\n\nopen Tx\nopen GState\nopen GovActionState\nopen EnactState using (cc)\n</pre>"},{"location":"Ledger.Conway.Specification.Ledger.html#ledger-transition-system-types","title":"LEDGER Transition System Types","text":"<pre>record LEnv : Type where\n  field\n    slot        : Slot\n    ppolicy     : Maybe ScriptHash\n    pparams     : PParams\n    enactState  : EnactState\n    treasury    : Treasury\n</pre> <pre>instance\n  HasPParams-LEnv : HasPParams LEnv\n  HasPParams-LEnv .PParamsOf = LEnv.pparams\n</pre> <pre>record LState : Type where\n</pre> <pre>  constructor \u27e6_,_,_\u27e7\u02e1\n</pre> <pre>  field\n    utxoSt     : UTxOState\n    govSt      : GovState\n    certState  : CertState\n</pre> <pre>record HasLState {a} (A : Type a) : Type a where\n  field LStateOf : A \u2192 LState\nopen HasLState \u2983...\u2984 public\n\ninstance\n  HasUTxOState-LState : HasUTxOState LState\n  HasUTxOState-LState .UTxOStateOf = LState.utxoSt\n\n  HasUTxO-LState : HasUTxO LState\n  HasUTxO-LState .UTxOOf = UTxOOf \u2218 UTxOStateOf\n\n  HasGovState-LState : HasGovState LState\n  HasGovState-LState .GovStateOf = LState.govSt\n\n  HasCertState-LState : HasCertState LState\n  HasCertState-LState .CertStateOf = LState.certState\n\n  HasDeposits-LState : HasDeposits LState\n  HasDeposits-LState .DepositsOf = DepositsOf \u2218 UTxOStateOf\n\n  HasPools-LState : HasPools LState\n  HasPools-LState .PoolsOf = PoolsOf \u2218 CertStateOf\n\n  HasGState-LState : HasGState LState\n  HasGState-LState .GStateOf = GStateOf \u2218 CertStateOf\n\n  HasDState-LState : HasDState LState\n  HasDState-LState .DStateOf = DStateOf \u2218 CertStateOf\n\n  HasPState-LState : HasPState LState\n  HasPState-LState .PStateOf = PStateOf \u2218 CertStateOf\n\n  HasVoteDelegs-LState : HasVoteDelegs LState\n  HasVoteDelegs-LState .VoteDelegsOf = VoteDelegsOf \u2218 DStateOf \u2218 CertStateOf\n\n  HasDonations-LState : HasDonations LState\n  HasDonations-LState .DonationsOf = DonationsOf \u2218 UTxOStateOf\n\n  HasFees-LState : HasFees LState\n  HasFees-LState .FeesOf = FeesOf \u2218 UTxOStateOf\n\n  HasCCHotKeys-LState : HasCCHotKeys LState\n  HasCCHotKeys-LState .CCHotKeysOf = CCHotKeysOf \u2218 GStateOf\n\n  HasDReps-LState : HasDReps LState\n  HasDReps-LState .DRepsOf = DRepsOf \u2218 CertStateOf\n\nopen CertState\nopen DState\nopen GovVotes\n\ninstance\n  unquoteDecl HasCast-LEnv HasCast-LState = derive-HasCast\n    ((quote LEnv , HasCast-LEnv) \u2237 (quote LState , HasCast-LState) \u2237 [])\n</pre>"},{"location":"Ledger.Conway.Specification.Ledger.html#helper-functions","title":"Helper Functions","text":"<pre>txgov : TxBody \u2192 List (GovVote \u228e GovProposal)\ntxgov txb = map inj\u2082 txGovProposals ++ map inj\u2081 txGovVotes\n  where open TxBody txb\n\nrmOrphanDRepVotes : CertState \u2192 GovState \u2192 GovState\nrmOrphanDRepVotes cs govSt = L.map (map\u2082 go) govSt\n  where\n   ifDRepRegistered : Credential \u2192 Type\n   ifDRepRegistered c = c \u2208 dom (DRepsOf cs)\n\n   go : GovActionState \u2192 GovActionState\n   go gas = record gas { votes = record (gas .votes) { gvDRep = filterKeys ifDRepRegistered (gas .votes .gvDRep) } }\n\nallColdCreds : GovState \u2192 EnactState \u2192 \u2119 Credential\nallColdCreds govSt es =\n  ccCreds (es .cc) \u222a concatMap\u02e2 (\u03bb (_ , st) \u2192 proposedCC (GovActionOf st)) (fromList govSt)\n</pre>"},{"location":"Ledger.Conway.Specification.Ledger.html#ledger-transition-system","title":"LEDGER Transition System","text":"<pre>private variable\n  \u0393                     : LEnv\n  s s' s''              : LState\n  utxoSt utxoSt'        : UTxOState\n  govSt govSt'          : GovState\n  certState certState'  : CertState\n  tx                    : Tx\n  slot                  : Slot\n  ppolicy               : Maybe ScriptHash\n  pp                    : PParams\n  enactState            : EnactState\n  treasury              : Treasury\n</pre> <pre>data _\u22a2_\u21c0\u2987_,LEDGER\u2988_ : LEnv \u2192 LState \u2192 Tx \u2192 LState \u2192 Type where\n  LEDGER-V :\n    let  txb = tx .body\n</pre> <pre>         open TxBody txb\n</pre> <pre>    in\n      \u2219 isValid tx \u2261 true\n      \u2219 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ledger.html#4140}{\\htmlId{4537}{\\htmlClass{Generalizable}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4214}{\\htmlId{4544}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4285}{\\htmlId{4549}{\\htmlClass{Generalizable}{\\text{treasury}}}}\\, \\end{pmatrix}$  \u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt'\n      \u2219 $\\begin{pmatrix} \\,\\href{Ledger.Core.Specification.Epoch.html#954}{\\htmlId{4602}{\\htmlClass{Function}{\\text{epoch}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#4140}{\\htmlId{4608}{\\htmlClass{Generalizable}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4214}{\\htmlId{4615}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Transaction.html#5049}{\\htmlId{4620}{\\htmlClass{Function}{\\text{txGovVotes}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Transaction.html#4874}{\\htmlId{4633}{\\htmlClass{Function}{\\text{txWithdrawals}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#3671}{\\htmlId{4649}{\\htmlClass{Function}{\\text{allColdCreds}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#4040}{\\htmlId{4662}{\\htmlClass{Generalizable}{\\text{govSt}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#4248}{\\htmlId{4668}{\\htmlClass{Generalizable}{\\text{enactState}}}}\\, \\end{pmatrix}$ \u22a2 certState \u21c0\u2987 txCerts ,CERTS\u2988 certState'\n      \u2219 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Transaction.html#4766}{\\htmlId{4733}{\\htmlClass{Function}{\\text{txId}}}}\\, \\\\ \\,\\href{Ledger.Core.Specification.Epoch.html#954}{\\htmlId{4740}{\\htmlClass{Function}{\\text{epoch}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#4140}{\\htmlId{4746}{\\htmlClass{Generalizable}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4214}{\\htmlId{4753}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4171}{\\htmlId{4758}{\\htmlClass{Generalizable}{\\text{ppolicy}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4248}{\\htmlId{4768}{\\htmlClass{Generalizable}{\\text{enactState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4085}{\\htmlId{4781}{\\htmlClass{Generalizable}{\\text{certState'}}}}\\, \\\\ \\,\\href{Class.IsSet.html#916}{\\htmlId{4794}{\\htmlClass{Function}{\\text{dom}}}}\\, \\,\\htmlId{4798}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#2028}{\\htmlId{4799}{\\htmlClass{Field}{\\text{RewardsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Ledger.html#4075}{\\htmlId{4809}{\\htmlClass{Generalizable}{\\text{certState}}}}\\,\\,\\htmlId{4818}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$ \u22a2 rmOrphanDRepVotes certState' govSt \u21c0\u2987 txgov txb ,GOVS\u2988 govSt'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ledger.html#4140}{\\htmlId{4933}{\\htmlClass{Generalizable}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4171}{\\htmlId{4940}{\\htmlClass{Generalizable}{\\text{ppolicy}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4214}{\\htmlId{4950}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4248}{\\htmlId{4955}{\\htmlClass{Generalizable}{\\text{enactState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4285}{\\htmlId{4968}{\\htmlClass{Generalizable}{\\text{treasury}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ledger.html#4004}{\\htmlId{4983}{\\htmlClass{Generalizable}{\\text{utxoSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4040}{\\htmlId{4992}{\\htmlClass{Generalizable}{\\text{govSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4075}{\\htmlId{5000}{\\htmlClass{Generalizable}{\\text{certState}}}}\\, \\end{pmatrix}$ \u21c0\u2987 tx ,LEDGER\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ledger.html#4011}{\\htmlId{5029}{\\htmlClass{Generalizable}{\\text{utxoSt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4046}{\\htmlId{5039}{\\htmlClass{Generalizable}{\\text{govSt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4085}{\\htmlId{5048}{\\htmlClass{Generalizable}{\\text{certState'}}}}\\, \\end{pmatrix}$\n\n  LEDGER-I :\n      \u2219 isValid tx \u2261 false\n      \u2219 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ledger.html#4140}{\\htmlId{5112}{\\htmlClass{Generalizable}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4214}{\\htmlId{5119}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4285}{\\htmlId{5124}{\\htmlClass{Generalizable}{\\text{treasury}}}}\\, \\end{pmatrix}$ \u22a2 utxoSt \u21c0\u2987 tx ,UTXOW\u2988 utxoSt'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ledger.html#4140}{\\htmlId{5213}{\\htmlClass{Generalizable}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4171}{\\htmlId{5220}{\\htmlClass{Generalizable}{\\text{ppolicy}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4214}{\\htmlId{5230}{\\htmlClass{Generalizable}{\\text{pp}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4248}{\\htmlId{5235}{\\htmlClass{Generalizable}{\\text{enactState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4285}{\\htmlId{5248}{\\htmlClass{Generalizable}{\\text{treasury}}}}\\, \\end{pmatrix}$ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ledger.html#4004}{\\htmlId{5263}{\\htmlClass{Generalizable}{\\text{utxoSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4040}{\\htmlId{5272}{\\htmlClass{Generalizable}{\\text{govSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4075}{\\htmlId{5280}{\\htmlClass{Generalizable}{\\text{certState}}}}\\, \\end{pmatrix}$ \u21c0\u2987 tx ,LEDGER\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ledger.html#4011}{\\htmlId{5309}{\\htmlClass{Generalizable}{\\text{utxoSt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4040}{\\htmlId{5319}{\\htmlClass{Generalizable}{\\text{govSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ledger.html#4075}{\\htmlId{5327}{\\htmlClass{Generalizable}{\\text{certState}}}}\\, \\end{pmatrix}$\n</pre> <p>The rule <code>LEDGER</code> invokes the <code>GOVS</code> rule to process governance action proposals and votes.</p> Note <p>The governance state used as input to <code>GOVS</code> is filtered to remove votes from <code>DReps</code> that are no longer registered (see function <code>rmOrphanDRepVotes</code>).</p> <p>This mechanism serves to prevent attacks where malicious adversaries could submit transactions that</p> <ol> <li>register a fraudulent <code>DRep</code>,</li> <li>cast numerous votes utilizing that <code>DRep</code>,</li> <li>deregisters the <code>DRep</code> thereby recovering the deposit.</li> </ol> <pre>pattern LEDGER-V\u22ef w x y z = LEDGER-V (w , x , y , z)\npattern LEDGER-I\u22ef y z     = LEDGER-I (y , z)\n</pre>"},{"location":"Ledger.Conway.Specification.Ledger.html#ledgers-transition-system","title":"LEDGERS Transition System","text":"<pre>_\u22a2_\u21c0\u2987_,LEDGERS\u2988_ : LEnv \u2192 LState \u2192 List Tx \u2192 LState \u2192 Type\n_\u22a2_\u21c0\u2987_,LEDGERS\u2988_ = ReflexiveTransitiveClosure {sts = _\u22a2_\u21c0\u2987_,LEDGER\u2988_}\n</pre>"},{"location":"Ledger.Conway.Specification.PParams.html","title":"Protocol Parameters","text":"<p>This section defines the adjustable protocol parameters of the Cardano ledger.</p> <pre>{-# OPTIONS --safe #-}\n\nopen import Data.Product.Properties\nopen import Data.Nat.Properties using (m+1+n\u2262m)\nopen import Data.Rational using (\u211a)\nopen import Relation.Nullary.Decidable\nopen import Data.List.Relation.Unary.Any using (Any; here; there)\n\nopen import Tactic.Derive.Show\n\nopen import Ledger.Prelude\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Script.Base\nopen import Ledger.Core.Specification.Epoch\nopen import Ledger.Prelude.Numeric using (UnitInterval; \u2115\u207a)\n\nmodule Ledger.Conway.Specification.PParams\n  (cs : CryptoStructure )\n  (es : _) (open EpochStructure es)\n  (ss : ScriptStructure cs es) (open ScriptStructure ss)\n  where\n\nprivate variable\n  m n : \u2115\n</pre>"},{"location":"Ledger.Conway.Specification.PParams.html#sec:protocol-parameter-definitions","title":"Protocol Parameter Definitions","text":"<p>Protocol parameters are used in block validation and can affect various features of the system, such as minimum fees, maximum and minimum sizes of certain components, and more.</p> <p>The main protocol parameter type is <code>PParams</code>, defined later in this section.  It contains parameters used in the Cardano ledger, which we group according to the general purpose that each parameter serves.</p> <ul> <li> <p><code>NetworkGroup</code>: parameters related to the network    settings;</p> </li> <li> <p><code>EconomicGroup</code>: parameters related to the economic    aspects of the ledger;</p> </li> <li> <p><code>TechnicalGroup</code>: parameters related to technical    settings;</p> </li> <li> <p><code>GovernanceGroup</code>: parameters related to governance    settings;</p> </li> <li> <p><code>SecurityGroup</code>: parameters that can impact the    security of the system.</p> </li> </ul> <p>The purpose of these groups is to determine voting thresholds for proposals aiming to change parameters.  Given a proposal to change a certain set of parameters, we look at which groups those parameters fall into and from this we determine the voting threshold for that proposal.  (The voting threshold calculation is described in detail in the Ratification Requirements section.)</p> <p>The first four groups have the property that every protocol parameter is associated to precisely one of these groups.  The <code>SecurityGroup</code> is special: a protocol parameter may or may not be in the <code>SecurityGroup</code>.  So, each protocol parameter belongs to at least one and at most two groups.  Note that in CIP-1694 there is no <code>SecurityGroup</code>, but there is the concept of security-relevant protocol parameters (see CKB+23).  The difference between these notions is only social, so we implement security-relevant protocol parameters as a group.</p> <pre>record Acnt : Type where\n</pre> <pre>  constructor \u27e6_,_\u27e7\u1d43\n</pre> <pre>  field\n    treasury reserves : Coin\n</pre> <pre>instance\n  HasTreasury-Acnt : HasTreasury Acnt\n  HasTreasury-Acnt .TreasuryOf = Acnt.treasury\n\n  HasReserves-Acnt : HasReserves Acnt\n  HasReserves-Acnt .ReservesOf = Acnt.reserves\n</pre> <pre>ProtVer : Type\nProtVer = \u2115 \u00d7 \u2115\n</pre> <pre>instance\n  Show-ProtVer : Show ProtVer\n  Show-ProtVer = Show-\u00d7\n</pre> <pre>data pvCanFollow : ProtVer \u2192 ProtVer \u2192 Type where\n  canFollowMajor : pvCanFollow (m , n) (m + 1 , 0)\n  canFollowMinor : pvCanFollow (m , n) (m , n + 1)\n</pre> <pre>instance\n  unquoteDecl HasCast-Acnt = derive-HasCast\n    [ (quote Acnt , HasCast-Acnt) ]\n</pre>"},{"location":"Ledger.Conway.Specification.PParams.html#sec:protocol-parameter-group-definition","title":"Protocol Parameter Group Definition","text":"<pre>data PParamGroup : Type where\n  NetworkGroup     : PParamGroup\n  EconomicGroup    : PParamGroup\n  TechnicalGroup   : PParamGroup\n  GovernanceGroup  : PParamGroup\n  SecurityGroup    : PParamGroup\n</pre>"},{"location":"Ledger.Conway.Specification.PParams.html#sec:protocol-parameter-threshold-definitions","title":"Protocol Parameter Threshold Definitions","text":"<pre>record DrepThresholds : Type where\n  field\n    P1 P2a P2b P3 P4 P5a P5b P5c P5d P6 : \u211a\n\nrecord PoolThresholds : Type where\n  field\n    Q1 Q2a Q2b Q4 Q5 : \u211a\n</pre>"},{"location":"Ledger.Conway.Specification.PParams.html#sec:protocol-parameter-declarations","title":"Protocol Parameter Declarations","text":"<p>This section defines new protocol parameters which denote the following concepts:</p> <ul> <li> <p><code>drepThresholds</code>: governance thresholds for ; these are rational    numbers named <code>Pone</code>, <code>Ptwoa</code>, <code>Ptwob</code>,    <code>Pthree</code>, <code>Pfour</code>, <code>Pfivea</code>,    <code>Pfiveb</code>, <code>Pfivec</code>, <code>Pfived</code>, and    <code>Psix</code>;</p> </li> <li> <p><code>poolThresholds</code>: pool-related governance thresholds; these are    rational numbers named <code>Qone</code>, <code>Qtwoa</code>,    <code>Qtwob</code>, <code>Qfour</code> and <code>Qfive</code>;</p> </li> <li> <p><code>ccMinSize</code>: minimum constitutional committee size;</p> </li> <li> <p><code>ccMaxTermLength</code>: maximum term limit (in epochs) of constitutional    committee members;</p> </li> <li> <p><code>govActionLifetime</code>: governance action expiration;</p> </li> <li> <p><code>govActionDeposit</code>: governance action deposit;</p> </li> <li> <p><code>drepDeposit</code>: <code>DRep</code> deposit amount;</p> </li> <li> <p><code>drepActivity</code>: <code>DRep</code> activity period;</p> </li> <li> <p><code>minimumAVS</code>: the minimum active voting threshold.</p> </li> </ul> <pre>record PParams : Type where\n  field\n</pre> <p>Network group</p> <pre>        maxBlockSize                  : \u2115\n        maxTxSize                     : \u2115\n        maxHeaderSize                 : \u2115\n        maxTxExUnits                  : ExUnits\n        maxBlockExUnits               : ExUnits\n        maxValSize                    : \u2115\n        maxCollateralInputs           : \u2115\n</pre> <pre>        pv                            : ProtVer -- retired, keep for now\n</pre> <p>Economic group</p> <pre>        a                             : \u2115\n        b                             : \u2115\n        keyDeposit                    : Coin\n        poolDeposit                   : Coin\n        monetaryExpansion             : UnitInterval -- formerly: rho\n        treasuryCut                   : UnitInterval -- formerly: tau\n        coinsPerUTxOByte              : Coin\n        prices                        : Prices\n        minFeeRefScriptCoinsPerByte   : \u211a\n        maxRefScriptSizePerTx         : \u2115\n        maxRefScriptSizePerBlock      : \u2115\n        refScriptCostStride           : \u2115\u207a\n        refScriptCostMultiplier       : \u211a\n</pre> <pre>        minUTxOValue                  : Coin -- retired, keep for now\n</pre> <p>Technical group</p> <pre>        Emax                          : Epoch\n        nopt                          : \u2115\n        a0                            : \u211a\n        collateralPercentage          : \u2115\n</pre> <pre>        -- costmdls                   : Language \u2192/\u21c0 CostModel (Does not work with DecEq)\n</pre> <pre>        costmdls                      : CostModel\n</pre> <p>Governance group</p> <pre>        poolThresholds                : PoolThresholds\n        drepThresholds                : DrepThresholds\n        ccMinSize                     : \u2115\n        ccMaxTermLength               : \u2115\n        govActionLifetime             : \u2115\n        govActionDeposit              : Coin\n        drepDeposit                   : Coin\n        drepActivity                  : Epoch\n</pre> <p>Security group</p> <p><code>maxBlockSize</code> <code>maxTxSize</code> <code>maxHeaderSize</code> <code>maxValSize</code> <code>maxBlockExUnits</code> <code>a</code> <code>b</code> <code>minFeeRefScriptCoinsPerByte</code> <code>coinsPerUTxOByte</code> <code>govActionDeposit</code></p> <pre>record HasPParams {a} (A : Type a) : Type a where\n  field PParamsOf : A \u2192 PParams\nopen HasPParams \u2983...\u2984 public\n\nrecord HasCCMaxTermLength {a} (A : Type a) : Type a where\n  field CCMaxTermLengthOf : A \u2192 \u2115\nopen HasCCMaxTermLength \u2983...\u2984 public\n</pre>"},{"location":"Ledger.Conway.Specification.PParams.html#protocol-parameter-well-formedness","title":"Protocol Parameter Well Formedness","text":"<p>We define the function <code>paramsWellFormed</code> which performs some sanity checks on protocol parameters.</p> <pre>positivePParams : PParams \u2192 List \u2115\npositivePParams pp =  ( maxBlockSize \u2237 maxTxSize \u2237 maxHeaderSize\n                      \u2237 maxValSize \u2237 coinsPerUTxOByte\n                      \u2237 poolDeposit \u2237 collateralPercentage \u2237 ccMaxTermLength\n                      \u2237 govActionLifetime \u2237 govActionDeposit \u2237 drepDeposit \u2237 [] )\n</pre> <pre>  where open PParams pp\n</pre> <pre>paramsWellFormed : PParams \u2192 Type\nparamsWellFormed pp = 0 \u2209 fromList (positivePParams pp)\n</pre> <pre>paramsWF-elim : (pp : PParams) \u2192 paramsWellFormed pp \u2192 (n : \u2115) \u2192 n \u2208\u02e1 (positivePParams pp) \u2192 n &gt; 0\nparamsWF-elim pp pwf (suc n) x = z&lt;s\nparamsWF-elim pp pwf 0 0\u2208 = \u22a5-elim (pwf (to \u2208-fromList 0\u2208))\n  where open Equivalence\n\ninstance\n  unquoteDecl DecEq-DrepThresholds = derive-DecEq\n    ((quote DrepThresholds , DecEq-DrepThresholds) \u2237 [])\n  unquoteDecl DecEq-PoolThresholds = derive-DecEq\n    ((quote PoolThresholds , DecEq-PoolThresholds) \u2237 [])\n  unquoteDecl DecEq-PParams        = derive-DecEq\n    ((quote PParams , DecEq-PParams) \u2237 [])\n  unquoteDecl DecEq-PParamGroup    = derive-DecEq\n    ((quote PParamGroup , DecEq-PParamGroup) \u2237 [])\n  unquoteDecl Show-DrepThresholds = derive-Show\n    ((quote DrepThresholds , Show-DrepThresholds) \u2237 [])\n  unquoteDecl Show-PoolThresholds = derive-Show\n    ((quote PoolThresholds , Show-PoolThresholds) \u2237 [])\n  unquoteDecl Show-PParams        = derive-Show\n    ((quote PParams , Show-PParams) \u2237 [])\n\nmodule PParamsUpdate where\n  record PParamsUpdate : Type where\n    field\n          maxBlockSize maxTxSize        : Maybe \u2115\n          maxHeaderSize maxValSize      : Maybe \u2115\n          maxCollateralInputs           : Maybe \u2115\n          maxTxExUnits maxBlockExUnits  : Maybe ExUnits\n          pv                            : Maybe ProtVer -- retired, keep for now\n          a b                           : Maybe \u2115\n          keyDeposit                    : Maybe Coin\n          poolDeposit                   : Maybe Coin\n          monetaryExpansion             : Maybe UnitInterval\n          treasuryCut                   : Maybe UnitInterval\n          coinsPerUTxOByte              : Maybe Coin\n          prices                        : Maybe Prices\n          minFeeRefScriptCoinsPerByte   : Maybe \u211a\n          maxRefScriptSizePerTx         : Maybe \u2115\n          maxRefScriptSizePerBlock      : Maybe \u2115\n          refScriptCostStride           : Maybe \u2115\u207a\n          refScriptCostMultiplier       : Maybe \u211a\n          minUTxOValue                  : Maybe Coin -- retired, keep for now\n          a0                            : Maybe \u211a\n          Emax                          : Maybe Epoch\n          nopt                          : Maybe \u2115\n          collateralPercentage          : Maybe \u2115\n          costmdls                      : Maybe CostModel\n          drepThresholds                : Maybe DrepThresholds\n          poolThresholds                : Maybe PoolThresholds\n          govActionLifetime             : Maybe \u2115\n          govActionDeposit drepDeposit  : Maybe Coin\n          drepActivity                  : Maybe Epoch\n          ccMinSize ccMaxTermLength     : Maybe \u2115\n\n  paramsUpdateWellFormed : PParamsUpdate \u2192 Type\n  paramsUpdateWellFormed ppu =\n       just 0 \u2209 fromList ( maxBlockSize \u2237 maxTxSize \u2237 maxHeaderSize \u2237 maxValSize\n                         \u2237 coinsPerUTxOByte \u2237 poolDeposit \u2237 collateralPercentage \u2237 ccMaxTermLength\n                         \u2237 govActionLifetime \u2237 govActionDeposit \u2237 drepDeposit \u2237 [] )\n    where open PParamsUpdate ppu\n\n  paramsUpdateWellFormed? : ( u : PParamsUpdate ) \u2192 Dec (paramsUpdateWellFormed u)\n  paramsUpdateWellFormed? u = \u00bf paramsUpdateWellFormed u \u00bf\n\n  modifiesNetworkGroup : PParamsUpdate \u2192 Bool\n  modifiesNetworkGroup ppu = let open PParamsUpdate ppu in\n    or\n      ( is-just maxBlockSize\n      \u2237 is-just maxTxSize\n      \u2237 is-just maxHeaderSize\n      \u2237 is-just maxValSize\n      \u2237 is-just maxCollateralInputs\n      \u2237 is-just maxTxExUnits\n      \u2237 is-just maxBlockExUnits\n      \u2237 is-just pv\n      \u2237 [])\n\n  modifiesEconomicGroup : PParamsUpdate \u2192 Bool\n  modifiesEconomicGroup ppu = let open PParamsUpdate ppu in\n    or\n      ( is-just a\n      \u2237 is-just b\n      \u2237 is-just keyDeposit\n      \u2237 is-just poolDeposit\n      \u2237 is-just monetaryExpansion\n      \u2237 is-just treasuryCut\n      \u2237 is-just coinsPerUTxOByte\n      \u2237 is-just minFeeRefScriptCoinsPerByte\n      \u2237 is-just maxRefScriptSizePerTx\n      \u2237 is-just maxRefScriptSizePerBlock\n      \u2237 is-just refScriptCostStride\n      \u2237 is-just refScriptCostMultiplier\n      \u2237 is-just prices\n      \u2237 is-just minUTxOValue\n      \u2237 [])\n\n  modifiesTechnicalGroup : PParamsUpdate \u2192 Bool\n  modifiesTechnicalGroup ppu = let open PParamsUpdate ppu in\n    or\n      ( is-just a0\n      \u2237 is-just Emax\n      \u2237 is-just nopt\n      \u2237 is-just collateralPercentage\n      \u2237 is-just costmdls\n      \u2237 [])\n\n  modifiesGovernanceGroup : PParamsUpdate \u2192 Bool\n  modifiesGovernanceGroup ppu = let open PParamsUpdate ppu in\n    or\n      ( is-just drepThresholds\n      \u2237 is-just poolThresholds\n      \u2237 is-just govActionLifetime\n      \u2237 is-just govActionDeposit\n      \u2237 is-just drepDeposit\n      \u2237 is-just drepActivity\n      \u2237 is-just ccMinSize\n      \u2237 is-just ccMaxTermLength\n      \u2237 [])\n\n  modifiesSecurityGroup : PParamsUpdate \u2192 Bool\n  modifiesSecurityGroup ppu = let open PParamsUpdate ppu in\n    or\n      ( is-just maxBlockSize\n      \u2237 is-just maxTxSize\n      \u2237 is-just maxHeaderSize\n      \u2237 is-just maxValSize\n      \u2237 is-just maxBlockExUnits\n      \u2237 is-just b\n      \u2237 is-just a\n      \u2237 is-just coinsPerUTxOByte\n      \u2237 is-just govActionDeposit\n      \u2237 is-just minFeeRefScriptCoinsPerByte\n      \u2237 []\n      )\n\n  modifiedUpdateGroups : PParamsUpdate \u2192 \u2119 PParamGroup\n  modifiedUpdateGroups ppu =\n    ( modifiesNetworkGroup    ?\u2550\u21d2 NetworkGroup\n    \u222a modifiesEconomicGroup   ?\u2550\u21d2 EconomicGroup\n    \u222a modifiesTechnicalGroup  ?\u2550\u21d2 TechnicalGroup\n    \u222a modifiesGovernanceGroup ?\u2550\u21d2 GovernanceGroup\n    \u222a modifiesSecurityGroup   ?\u2550\u21d2 SecurityGroup\n    )\n    where\n      _?\u2550\u21d2_ : (PParamsUpdate \u2192 Bool) \u2192 PParamGroup \u2192 \u2119 PParamGroup\n      pred ?\u2550\u21d2 grp = if pred ppu then \u2774 grp \u2775 else \u2205\n\n  _?\u2197_ : \u2200 {A : Type} \u2192 Maybe A \u2192 A \u2192 A\n  just x ?\u2197 _ = x\n  nothing ?\u2197 x = x\n\n  \u2261-update : \u2200 {A : Type} {u : Maybe A} {p : A} {x : A} \u2192 u ?\u2197 p \u2261 x \u21d4 (u \u2261 just x \u228e (p \u2261 x \u00d7 u \u2261 nothing))\n  \u2261-update {u} {p} {x} = mk\u21d4 to from\n    where\n      to : \u2200 {A} {u : Maybe A} {p : A} {x : A} \u2192 u ?\u2197 p \u2261 x \u2192 (u \u2261 just x \u228e (p \u2261 x \u00d7 u \u2261 nothing))\n      to {u = just x} refl = inj\u2081 refl\n      to {u = nothing} refl = inj\u2082 (refl , refl)\n\n      from : \u2200 {A} {u : Maybe A} {p : A} {x : A} \u2192 u \u2261 just x \u228e (p \u2261 x \u00d7 u \u2261 nothing) \u2192 u ?\u2197 p \u2261 x\n      from (inj\u2081 refl) = refl\n      from (inj\u2082 (refl , refl)) = refl\n\n  applyPParamsUpdate : PParams \u2192 PParamsUpdate \u2192 PParams\n  applyPParamsUpdate pp ppu =\n    record\n      { maxBlockSize                = U.maxBlockSize ?\u2197 P.maxBlockSize\n      ; maxTxSize                   = U.maxTxSize ?\u2197 P.maxTxSize\n      ; maxHeaderSize               = U.maxHeaderSize ?\u2197 P.maxHeaderSize\n      ; maxValSize                  = U.maxValSize ?\u2197 P.maxValSize\n      ; maxCollateralInputs         = U.maxCollateralInputs ?\u2197 P.maxCollateralInputs\n      ; maxTxExUnits                = U.maxTxExUnits ?\u2197 P.maxTxExUnits\n      ; maxBlockExUnits             = U.maxBlockExUnits ?\u2197 P.maxBlockExUnits\n      ; pv                          = U.pv ?\u2197 P.pv\n      ; a                           = U.a ?\u2197 P.a\n      ; b                           = U.b ?\u2197 P.b\n      ; keyDeposit                  = U.keyDeposit ?\u2197 P.keyDeposit\n      ; poolDeposit                 = U.poolDeposit ?\u2197 P.poolDeposit\n      ; monetaryExpansion           = U.monetaryExpansion ?\u2197 P.monetaryExpansion\n      ; treasuryCut                 = U.treasuryCut ?\u2197 P.treasuryCut\n      ; coinsPerUTxOByte            = U.coinsPerUTxOByte ?\u2197 P.coinsPerUTxOByte\n      ; minFeeRefScriptCoinsPerByte = U.minFeeRefScriptCoinsPerByte ?\u2197 P.minFeeRefScriptCoinsPerByte\n      ; maxRefScriptSizePerTx       = U.maxRefScriptSizePerTx ?\u2197 P.maxRefScriptSizePerTx\n      ; maxRefScriptSizePerBlock    = U.maxRefScriptSizePerBlock ?\u2197 P.maxRefScriptSizePerBlock\n      ; refScriptCostStride         = U.refScriptCostStride ?\u2197 P.refScriptCostStride\n      ; refScriptCostMultiplier     = U.refScriptCostMultiplier ?\u2197 P.refScriptCostMultiplier\n      ; prices                      = U.prices ?\u2197 P.prices\n      ; minUTxOValue                = U.minUTxOValue ?\u2197 P.minUTxOValue\n      ; a0                          = U.a0 ?\u2197 P.a0\n      ; Emax                        = U.Emax ?\u2197 P.Emax\n      ; nopt                        = U.nopt ?\u2197 P.nopt\n      ; collateralPercentage        = U.collateralPercentage ?\u2197 P.collateralPercentage\n      ; costmdls                    = U.costmdls ?\u2197 P.costmdls\n      ; drepThresholds              = U.drepThresholds ?\u2197 P.drepThresholds\n      ; poolThresholds              = U.poolThresholds ?\u2197 P.poolThresholds\n      ; govActionLifetime           = U.govActionLifetime ?\u2197 P.govActionLifetime\n      ; govActionDeposit            = U.govActionDeposit ?\u2197 P.govActionDeposit\n      ; drepDeposit                 = U.drepDeposit ?\u2197 P.drepDeposit\n      ; drepActivity                = U.drepActivity ?\u2197 P.drepActivity\n      ; ccMinSize                   = U.ccMinSize ?\u2197 P.ccMinSize\n      ; ccMaxTermLength             = U.ccMaxTermLength ?\u2197 P.ccMaxTermLength\n      }\n    where\n      open module P = PParams pp\n      open module U = PParamsUpdate ppu\n\n  instance\n    unquoteDecl DecEq-PParamsUpdate  = derive-DecEq\n      ((quote PParamsUpdate , DecEq-PParamsUpdate) \u2237 [])\n\ninstance\n  pvCanFollow? : \u2200 {pv} {pv'} \u2192 Dec (pvCanFollow pv pv')\n  pvCanFollow? {m , n} {pv} with pv \u225f (m + 1 , 0) | pv \u225f (m , n + 1)\n  ... | no \u00acp    | no \u00acp\u2081   = no $ \u03bb where canFollowMajor \u2192 \u00acp  refl\n                                           canFollowMinor \u2192 \u00acp\u2081 refl\n  ... | no \u00acp    | yes refl = yes canFollowMinor\n  ... | yes refl | no \u00acp    = yes canFollowMajor\n  ... | yes refl | yes p    = \u22a5-elim $ m+1+n\u2262m m $ \u00d7-\u2261,\u2261\u2190\u2261 p .proj\u2081\n</pre>"},{"location":"Ledger.Conway.Specification.PParams.html#sec:abstract-type-for-parameter-updates","title":"Abstract Type for Parameter Updates","text":"<p>This section defines an abstract type, <code>UpdateT</code>, and two functions, <code>applyUpdate</code> and <code>updateGroups</code>.  The type <code>UpdateT</code> is to be instantiated by a type that can be</p> <ul> <li> <p>used to update parameters, via the function <code>applyUpdate</code>, and</p> </li> <li> <p>queried about what parameter groups it updates, via the function    <code>updateGroups</code>.</p> </li> </ul> <p>An element of the type <code>UpdateT</code> is well formed if it updates at least one group and applying the update preserves well-formedness.</p> <pre>record PParamsDiff : Type\u2081 where\n  field\n</pre> <p>Abstract types and functions</p> <pre>    UpdateT       : Type\n    applyUpdate   : PParams \u2192 UpdateT \u2192 PParams\n    updateGroups  : UpdateT \u2192 \u2119 PParamGroup\n</pre> <pre>    \u2983 ppWF? \u2984 : \u2200 {u} \u2192 (\u2200 pp \u2192 paramsWellFormed pp \u2192 paramsWellFormed (applyUpdate pp u)) \u2047\n</pre> <p>Well-formedness condition</p> <pre>  ppdWellFormed : UpdateT \u2192 Type\n  ppdWellFormed u =\n    updateGroups u \u2262 \u2205\n    \u00d7 \u2200 pp \u2192 paramsWellFormed pp \u2192 paramsWellFormed (applyUpdate pp u)\n</pre> <pre>record GovParams : Type\u2081 where\n  field ppUpd : PParamsDiff\n  open PParamsDiff ppUpd renaming (UpdateT to PParamsUpdate) public\n  field \u2983 DecEq-UpdT \u2984 : DecEq PParamsUpdate\n--         \u2983 Show-UpdT \u2984 : Show PParamsUpdate\n</pre>"},{"location":"Ledger.Conway.Specification.PParams.html#references","title":"References","text":"<p>[CKB+23]  Jared Corduan and Andre Knispel and Matthias Benkort and Kevin Hammond and Charles Hoskinson and Samuel Leathers. A First Step Towards On-Chain Decentralized Governance. 2023.</p>"},{"location":"Ledger.Conway.Specification.PoolReap.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.PoolReap.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.PoolReap txs abs\n\nopen Computational \u2983...\u2984\n\nmodule _ {e : Epoch} {prs : PoolReapState} where\n  POOLREAP-total : \u2203[ prs' ] _ \u22a2 prs \u21c0\u2987 e ,POOLREAP\u2988 prs'\n  POOLREAP-total = -, POOLREAP\n\n  POOLREAP-complete\n    : \u2200 prs' \u2192 _ \u22a2 prs \u21c0\u2987 e ,POOLREAP\u2988 prs' \u2192 proj\u2081 POOLREAP-total \u2261 prs'\n  POOLREAP-complete prs' POOLREAP = refl\n\n  POOLREAP-deterministic\n    : \u2200 {prs' prs''}\n    \u2192 _ \u22a2 prs \u21c0\u2987 e ,POOLREAP\u2988 prs'\n    \u2192 _ \u22a2 prs \u21c0\u2987 e ,POOLREAP\u2988 prs''\n    \u2192 prs' \u2261 prs''\n  POOLREAP-deterministic POOLREAP POOLREAP = refl\n\nPOOLREAP-deterministic-\u2261 : \u2200 {prs' prs'' e e' prs''' prs''''}\n  \u2192 prs' \u2261 prs''\n  \u2192 e \u2261 e'\n  \u2192 _ \u22a2 prs'  \u21c0\u2987 e  ,POOLREAP\u2988 prs'''\n  \u2192 _ \u22a2 prs'' \u21c0\u2987 e' ,POOLREAP\u2988 prs''''\n  \u2192 prs''' \u2261 prs''''\nPOOLREAP-deterministic-\u2261 refl refl = POOLREAP-deterministic\n</pre>"},{"location":"Ledger.Conway.Specification.PoolReap.html","title":"Pool Reaping Transition","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.PoolReap\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs)\n  where\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Certs govStructure\n</pre> <pre>record PoolReapState : Type where\n</pre> <pre>  inductive\n  constructor \u27e6_,_,_,_\u27e7\u1d56\n</pre> <pre>  field\n    utxoSt     : UTxOState   -- utxo state\n    acnt       : Acnt        -- accounting\n    dState     : DState      -- delegation state\n    pState     : PState      -- pool state\n</pre> <pre>instance\n  unquoteDecl HasCast-PoolReapState = derive-HasCast\n                [ (quote PoolReapState , HasCast-PoolReapState) ]\n\nprivate variable\n  e lastEpoch : Epoch\n  poolReapState : PoolReapState\n\ndata\n</pre> <pre>  _\u22a2_\u21c0\u2987_,POOLREAP\u2988_ : \u22a4 \u2192 PoolReapState \u2192 Epoch \u2192 PoolReapState \u2192 Type where\n  POOLREAP : let\n    open PoolReapState poolReapState\n    open StakePoolParams\n    open UTxOState\n    open PState\n    open DState\n    open Acnt\n    open PParams\n\n    retired    = pState .retiring \u207b\u00b9 e\n    rewardAcnts : DepositPurpose \u21c0 Credential\n    rewardAcnts =\n      mapKeys PoolDeposit $\n      mapValues rewardAccount $\n      pState .pools \u2223 retired\n\n    rewardAcnts' : Credential \u21c0 Coin\n    rewardAcnts' = aggregateBy (rewardAcnts \u02e2) (utxoSt .deposits)\n\n    refunds : Credential \u21c0 Coin\n    refunds = rewardAcnts' \u2223 dom (dState .rewards)\n\n    mRefunds = rewardAcnts' \u2223 dom (dState .rewards) \u1d9c\n\n    unclaimed  = getCoin mRefunds\n\n    retiredDeposits : \u2119 DepositPurpose\n    retiredDeposits = map\u02e2 PoolDeposit retired\n\n    utxoSt' = record utxoSt { deposits = utxoSt .deposits \u2223 retiredDeposits \u1d9c }\n\n    acnt' = record acnt { treasury = acnt .treasury + unclaimed }\n\n    dState' =\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.PoolReap.html#683}{\\htmlId{1979}{\\htmlClass{Function}{\\text{dState}}}}\\, \\,\\htmlId{1986}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4274}{\\htmlId{1987}{\\htmlClass{Field}{\\text{voteDelegs}}}}\\,\n      \\\\ \\,\\href{Ledger.Conway.Specification.PoolReap.html#683}{\\htmlId{2006}{\\htmlClass{Function}{\\text{dState}}}}\\, \\,\\htmlId{2013}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4304}{\\htmlId{2014}{\\htmlClass{Field}{\\text{stakeDelegs}}}}\\, \\,\\href{Axiom.Set.Map.html#17848}{\\htmlId{2026}{\\htmlClass{Function Operator}{\\text{\u2223\\^{}}}}}\\, \\,\\href{Ledger.Conway.Specification.PoolReap.html#1254}{\\htmlId{2029}{\\htmlClass{Bound}{\\text{retired}}}}\\, \\,\\href{Axiom.Set.Map.html#17848}{\\htmlId{2037}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\n      \\\\ \\,\\href{Ledger.Conway.Specification.PoolReap.html#683}{\\htmlId{2047}{\\htmlClass{Function}{\\text{dState}}}}\\, \\,\\htmlId{2054}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4335}{\\htmlId{2055}{\\htmlClass{Field}{\\text{rewards}}}}\\, \\,\\href{Axiom.Set.Map.Dec.html#2149}{\\htmlId{2063}{\\htmlClass{Function Operator}{\\text{\u222a\u207a}}}}\\, \\,\\href{Ledger.Conway.Specification.PoolReap.html#1552}{\\htmlId{2066}{\\htmlClass{Bound}{\\text{refunds}}}}\\,\n      \\end{pmatrix}$\n\n    pState' =\n      $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.PoolReap.html#732}{\\htmlId{2105}{\\htmlClass{Function}{\\text{pState}}}}\\, \\,\\htmlId{2112}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4398}{\\htmlId{2113}{\\htmlClass{Field}{\\text{pools}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{2119}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.PoolReap.html#1254}{\\htmlId{2121}{\\htmlClass{Bound}{\\text{retired}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{2129}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\n      \\\\ \\,\\href{Ledger.Conway.Specification.PoolReap.html#732}{\\htmlId{2139}{\\htmlClass{Function}{\\text{pState}}}}\\, \\,\\htmlId{2146}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4420}{\\htmlId{2147}{\\htmlClass{Field}{\\text{fPools}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{2154}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.PoolReap.html#1254}{\\htmlId{2156}{\\htmlClass{Bound}{\\text{retired}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{2164}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\n      \\\\ \\,\\href{Ledger.Conway.Specification.PoolReap.html#732}{\\htmlId{2174}{\\htmlClass{Function}{\\text{pState}}}}\\, \\,\\htmlId{2181}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Ledger.Conway.Specification.Certs.html#4442}{\\htmlId{2182}{\\htmlClass{Field}{\\text{retiring}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{2191}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.PoolReap.html#1254}{\\htmlId{2193}{\\htmlClass{Bound}{\\text{retired}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{2201}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\n      \\end{pmatrix}$\n\n    in\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    _ \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.PoolReap.html#597}{\\htmlId{2266}{\\htmlClass{Function}{\\text{utxoSt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.PoolReap.html#640}{\\htmlId{2275}{\\htmlClass{Function}{\\text{acnt}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.PoolReap.html#683}{\\htmlId{2282}{\\htmlClass{Function}{\\text{dState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.PoolReap.html#732}{\\htmlId{2291}{\\htmlClass{Function}{\\text{pState}}}}\\, \\end{pmatrix}$ \u21c0\u2987 e ,POOLREAP\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.PoolReap.html#1813}{\\htmlId{2318}{\\htmlClass{Bound}{\\text{utxoSt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.PoolReap.html#1894}{\\htmlId{2328}{\\htmlClass{Bound}{\\text{acnt'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.PoolReap.html#1961}{\\htmlId{2336}{\\htmlClass{Bound}{\\text{dState'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.PoolReap.html#2087}{\\htmlId{2346}{\\htmlClass{Bound}{\\text{pState'}}}}\\, \\end{pmatrix}$\n\n</pre>"},{"location":"Ledger.Conway.Specification.Properties.html","title":"Properties","text":"<p>This section defines some of the types and functions we use to check the validity of transactions and blocks of the Cardano blockchain.</p> <pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Properties\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Chain txs abs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Prelude\n</pre> <p>Transaction validity is complicated. In the truest sense, a transaction is valid if it is part of a valid block; i.e., <code>validTxIn\u2081</code> <code>s</code> <code>tx</code>, where <code>s</code> is a chain state and <code>tx</code> is the transaction in question. However, a transaction can also be seen as valid if it could be applied at a certain slot (with no knowledge of an actual block). This is closer to how the mempool sees transaction validity and is expressed by <code>validTxIn\u2082</code>.</p> <p>Note that these two are not equivalent and in fact there is no implication between the two in either direction. Indeed, <code>validTxIn\u2082</code> <code>=&gt;</code> <code>validTxIn\u2081</code> would require one to come up with a block, which we can't, while <code>validTxIn\u2081</code> <code>=&gt;</code> <code>validTxIn\u2082</code> may fail since the transaction might depend on a previous transaction in the same block.<sup>1</sup></p> <pre>isCredDeposit : DepositPurpose \u2192 Type\nisCredDeposit (CredentialDeposit x) = \u22a4\nisCredDeposit _ = \u22a5\n</pre> <pre>instance\n  isCredDeposit? : isCredDeposit \u2047\u00b9\n  isCredDeposit? {CredentialDeposit x} = \u2047 (yes tt)\n  isCredDeposit? {PoolDeposit x} = \u2047 (no \u03bb ())\n  isCredDeposit? {DRepDeposit x} = \u2047 (no \u03bb ())\n  isCredDeposit? {GovActionDeposit x} = \u2047 (no \u03bb ())\n</pre> <pre>isGADeposit : DepositPurpose \u2192 Type\nisGADeposit (GovActionDeposit x) = \u22a4\nisGADeposit _ = \u22a5\n</pre> <pre>instance\n  isGADeposit? : isGADeposit \u2047\u00b9\n  isGADeposit? {CredentialDeposit x} = \u2047 (no \u03bb ())\n  isGADeposit? {PoolDeposit x} = \u2047 (no \u03bb ())\n  isGADeposit? {DRepDeposit x} = \u2047 (no \u03bb ())\n  isGADeposit? {GovActionDeposit x} = \u2047 (yes tt)\n\ninstance\n  _ : IsSet Block Tx\n  _ = record { toSet = fromList \u2218 Block.ts }\n\n  _ : IsSet TxBody GovProposal\n  _ = record { toSet = fromList \u2218 TxBody.txGovProposals }\n</pre> <pre>validBlockIn : ChainState \u2192 Block \u2192 Type\nvalidBlockIn s b = \u2203[ s' ] _ \u22a2 s \u21c0\u2987 b ,CHAIN\u2988 s'\n\nvalidBlock : Block \u2192 Type\nvalidBlock b = \u2203[ s ] validBlockIn s b\n\nvalidTxIn\u2081 : ChainState \u2192 Tx \u2192 Type\nvalidTxIn\u2081 s tx = \u2203[ b ] tx \u2208 b \u00d7 validBlockIn s b\n</pre> <pre>module _ (s : ChainState) (slot : Slot) where\n  open ChainState s; open NewEpochState newEpochState\n  open EpochState epochState; open EnactState es\n</pre> <pre>  private\n    ledgerEnv = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Properties.html#2959}{\\htmlId{3126}{\\htmlClass{Bound}{\\text{slot}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#1739}{\\htmlId{3133}{\\htmlClass{Function}{\\text{constitution}}}}\\, \\,\\htmlId{3146}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Data.Product.Base.html#636}{\\htmlId{3147}{\\htmlClass{Field}{\\text{proj\u2081}}}}\\, \\,\\htmlId{3153}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Data.Product.Base.html#650}{\\htmlId{3154}{\\htmlClass{Field}{\\text{proj\u2082}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Enact.html#1844}{\\htmlId{3162}{\\htmlClass{Function}{\\text{pparams}}}}\\, \\,\\htmlId{3170}{\\htmlClass{Symbol}{\\text{.}}}\\,\\,\\href{Data.Product.Base.html#636}{\\htmlId{3171}{\\htmlClass{Field}{\\text{proj\u2081}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Epoch.html#2378}{\\htmlId{3179}{\\htmlClass{Function}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.PParams.html#3084}{\\htmlId{3184}{\\htmlClass{Field}{\\text{Acnt.treasury}}}}\\, \\,\\href{Ledger.Conway.Specification.Epoch.html#2305}{\\htmlId{3198}{\\htmlClass{Function}{\\text{acnt}}}}\\, \\end{pmatrix}$\n\n  validTxIn\u2082 : Tx \u2192 Type\n  validTxIn\u2082 tx = \u2203[ ls' ] ledgerEnv \u22a2 ls \u21c0\u2987 tx ,LEDGER\u2988 ls'\n\nvalidTx\u2081 : Tx \u2192 Type\nvalidTx\u2081 tx = \u2203[ s ] validTxIn\u2081 s tx\n</pre> <ol> <li> <p>This could indicate that <code>validTxIn\u2082</code> should be changed so that it allows for applying a list of transactions before the final transaction; the downside would then be that the transaction isn't applied to the given state but to some intermediate one. We expect to have more insight into this matter once we have proved more theorems.\u00a0\u21a9</p> </li> </ol>"},{"location":"Ledger.Conway.Specification.Ratify.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Ratify.Properties.Computational\n  (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Gov txs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Enact.Properties.Computational govStructure\nopen import Ledger.Conway.Specification.Ratify txs\n\nopen Computational \u2983...\u2984 hiding (computeProof; completeness)\n\nprivate\n  module Implementation\n    \u0393 (s : RatifyState) (sig : GovActionID \u00d7 _)\n    (let gid , st = sig)\n    where\n    open RatifyState s\n    open RatifyEnv \u0393; open GovActionState st\n    es'  = compute $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.Properties.Computational.html#742}{\\htmlId{857}{\\htmlClass{Bound}{\\text{gid}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#7983}{\\htmlId{863}{\\htmlClass{Function}{\\text{treasury}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#7868}{\\htmlId{874}{\\htmlClass{Function}{\\text{currentEpoch}}}}\\, \\end{pmatrix}$ es action\n    acc? = accepted? \u0393 es st\n    exp? = expired? currentEpoch st\n    del? = delayed? (action .gaType) prevAction es delay\n\n    opaque\n      acceptConds? : \u2200 a \u2192 Dec (acceptConds \u0393 s a)\n      acceptConds? _ = Dec-\u00d7 \u2983 \u2047 accepted? _ _ _ \u2984\n        \u2983 Dec-\u00d7 \u2983 Dec-\u2192 \u2983 \u2047 delayed? _ _ _ _ \u2984 \u2984 \u2983 \u2047 Computational\u21d2Dec' \u2984 \u2984 .dec\n\n    RATIFY-total : \u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFY\u2988 s'\n    RATIFY-total\n      with acceptConds? sig | exp?\n    ... | yes p@(_ , _ , (_ , q)) | _ = -, RATIFY-Accept (p , q)\n    ... | no \u00acp | no \u00aca = -, RATIFY-Continue (\u00acp , \u00aca)\n    ... | no \u00acp | yes a = -, RATIFY-Reject (\u00acp , a)\n\n    computeProof = success {Err = \u22a5} RATIFY-total\n\n    RATIFY-completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFY\u2988 s' \u2192 RATIFY-total .proj\u2081 \u2261 s'\n    RATIFY-completeness st\u02b3 (RATIFY-Accept (p , a)) with acceptConds? sig\n    ... | no \u00ach = \u22a5-elim (\u00ach p)\n    ... | yes (_ , _ , _ , h) = cong (\u03bb st\u1d49 \u2192 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.Properties.Computational.html#1776}{\\htmlId{1784}{\\htmlClass{Bound}{\\text{st\u1d49}}}}\\, \\\\ \\,\\htmlId{1790}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\\\ \\,\\htmlId{1794}{\\htmlClass{Symbol}{\\text{\\_}}}\\, \\end{pmatrix}$) $ computational\u21d2rightUnique Computational-ENACT h a\n    RATIFY-completeness s' (RATIFY-Reject (\u00acp , a))\n      rewrite dec-no (acceptConds? _) \u00acp | dec-yes exp? a .proj\u2082 = refl\n    RATIFY-completeness s' (RATIFY-Continue (\u00acp , \u00aca))\n      rewrite dec-no (acceptConds? _) \u00acp | dec-no exp? \u00aca = refl\n\n    completeness = cong (success {Err = \u22a5}) \u2218\u2082 RATIFY-completeness\n\ninstance\n  Computational-RATIFY : Computational _\u22a2_\u21c0\u2987_,RATIFY\u2988_ \u22a5\n  Computational-RATIFY = record {Implementation}\n\nComputational-RATIFIES : Computational _\u22a2_\u21c0\u2987_,RATIFIES\u2988_ \u22a5\nComputational-RATIFIES = it\n\nRATIFIES-total : \u2200 {\u0393 s sig} \u2192 \u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s'\nRATIFIES-total = ReflexiveTransitiveClosure-total (Implementation.RATIFY-total _ _ _)\n\nRATIFIES-complete : \u2200 {\u0393 s sig s'} \u2192\n  \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s' \u2192 RATIFIES-total {\u0393} {s} {sig} .proj\u2081 \u2261 s'\nRATIFIES-complete = computational\u21d2rightUnique Computational-RATIFIES (RATIFIES-total .proj\u2082)\n\nopaque\n  RATIFIES-total' : \u2200 {\u0393 s sig} \u2192 \u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s'\n  RATIFIES-total' = RATIFIES-total\n\n  RATIFIES-complete' : \u2200 {\u0393 s sig s'} \u2192\n    \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s' \u2192 RATIFIES-total' {\u0393} {s} {sig} .proj\u2081 \u2261 s'\n  RATIFIES-complete' = RATIFIES-complete\n\n  RATIFIES-deterministic : \u2200 {\u0393 s sig s' s''}\n    \u2192 \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s'\n    \u2192 \u0393 \u22a2 s \u21c0\u2987 sig ,RATIFIES\u2988 s''\n    \u2192 s' \u2261 s''\n  RATIFIES-deterministic p\u2081 p\u2082 = trans (sym (RATIFIES-complete' p\u2081)) (RATIFIES-complete' p\u2082)\n\n  RATIFIES-deterministic-\u2261 : \u2200 {\u0393 \u0393' s s' sig sig' s'' s'''}\n    \u2192 \u0393 \u2261 \u0393'\n    \u2192 s \u2261 s'\n    \u2192 sig \u2261 sig'\n    \u2192 \u0393  \u22a2 s  \u21c0\u2987 sig  ,RATIFIES\u2988 s''\n    \u2192 \u0393' \u22a2 s' \u21c0\u2987 sig' ,RATIFIES\u2988 s'''\n    \u2192 s'' \u2261 s'''\n  RATIFIES-deterministic-\u2261 refl refl refl = RATIFIES-deterministic\n</pre>"},{"location":"Ledger.Conway.Specification.Ratify.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Ratify.Properties where\n\nopen import Ledger.Conway.Specification.Ratify.Properties.Computational\n</pre>"},{"location":"Ledger.Conway.Specification.Ratify.html","title":"Ratification","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction hiding (Vote)\n\nmodule Ledger.Conway.Specification.Ratify (txs : _) (open TransactionStructure txs) where\n\nimport Data.Integer as \u2124\nopen import Data.Rational as \u211a using (\u211a; 0\u211a; _\u2294_)\nopen import Data.Nat.Properties hiding (_\u225f_; _\u2264?_)\n\nopen import Ledger.Prelude hiding (_\u2227_; _\u2228_; _\u2294_) renaming (filter\u1d50 to filter; \u2223_\u2223 to _\u2193)\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Gov.Actions govStructure using (Vote)\n</pre> <p>Governance actions are ratified through on-chain votes. Different kinds of Governance Actions have different ratification requirements but always involve at least two of the three governance bodies.</p> <p>A successful motion of no-confidence, election of a new constitutional committee, a constitutional change, or a hard-fork delays ratification of all other governance actions until the first epoch after their enactment. This gives a new constitutional committee enough time to vote on current proposals, re-evaluate existing proposals with respect to a new constitution, and ensures that the (in principle arbitrary) semantic changes caused by enacting a hard-fork do not have unintended consequences in combination with other actions.</p>"},{"location":"Ledger.Conway.Specification.Ratify.html#sec:ratification-requirements","title":"Ratification Requirements","text":"<p>This section details the ratification requirements for each governance action scenario.  For a governance action to be ratified, all of these requirements must be satisfied, on top of other conditions that are explained further down.  The <code>threshold</code> function is defined as a table, with a row for each type of <code>GovAction</code> and a column for each of the three governing bodies (or \"governance roles\")\u2014<code>CC</code>, <code>DRep</code> and <code>SPO</code>, in that order.</p> <p>The meaning of the symbols are as follows.</p> <ul> <li> <p><code>vote</code> <code>x</code>: For an action to pass, the fraction of    stake associated with yes votes with respect to that associated with yes and    no votes must exceed the threshold <code>x</code>.</p> </li> <li> <p><code>\u2500</code>: The governance role does not participate in voting.</p> </li> <li> <p><code>\u2713</code>: The constitutional committee needs to approve an    action, with the threshold assigned to it.</p> </li> <li> <p><code>\u2713\u2020</code>: Voting is possible, but the action will never be    enacted.  This is equivalent to <code>vote</code> <code>2</code> (or any other    number above <code>1</code>).</p> </li> </ul> <p>Two rows in this table contain functions that compute the <code>DRep</code> and <code>SPO</code> thresholds simultaneously\u2014namely, the <code>UpdateCommittee</code> and <code>ChangePParams</code> rows.</p> <p>For <code>UpdateCommittee</code>, there can be different thresholds depending on whether the system is in a state of no-confidence or not. This information is provided via the <code>ccThreshold</code> argument; if the system is in a state of no-confidence, then <code>ccThreshold</code> is set to <code>nothing</code>.</p> <p>In case of the <code>ChangePParams</code> action, the thresholds further depend on what groups the action is associated with. <code>pparamThreshold</code> associates a pair of thresholds to each individual group. Since an individual update can contain multiple groups, the actual thresholds are then given by taking the maximum of all those thresholds.</p> <p>Note that each protocol parameter belongs to exactly one of the four groups that have a <code>DRep</code> threshold, so a <code>DRep</code> vote will always be required. A protocol parameter may or may not be in the <code>SecurityGroup</code>, so an <code>SPO</code> vote may not be required.</p> <p>Finally, each of the <code>Px</code> and <code>Qx</code> are protocol parameters.</p> <pre>private\n  \u2223_\u2223_\u2223_\u2223 : {A : Type} \u2192 A \u2192 A \u2192 A \u2192 GovRole \u2192 A\n  \u2223 q\u2081 \u2223 q\u2082 \u2223 q\u2083 \u2223 = \u03bb { CC \u2192 q\u2081 ; DRep \u2192 q\u2082 ; SPO \u2192 q\u2083 }\n\n  \u2223_\u2225_\u2223 : {A : Type} \u2192 A \u2192 A \u00d7 A \u2192 GovRole \u2192 A\n  \u2223 q\u2081 \u2225 (q\u2082 , q\u2083) \u2223 = \u03bb { CC \u2192 q\u2081 ; DRep \u2192 q\u2082 ; SPO \u2192 q\u2083 }\n\n</pre> <pre>threshold : PParams \u2192 Maybe \u211a \u2192 GovAction \u2192 GovRole \u2192 Maybe \u211a\nthreshold pp ccThreshold ga =\n  case  ga \u2193 of \u03bb where\n        (NoConfidence        , _       ) \u2192 \u2223 \u2500   \u2223 vote P1      \u2223 vote Q1  \u2223\n        (UpdateCommittee     , _       ) \u2192 \u2223 \u2500   \u2225 P/Q2a/b                 \u2223\n        (NewConstitution     , _       ) \u2192 \u2223 \u2713   \u2223 vote P3      \u2223 \u2500        \u2223\n        (TriggerHardFork     , _       ) \u2192 \u2223 \u2713   \u2223 vote P4      \u2223 vote Q4  \u2223\n        (ChangePParams       , update  ) \u2192 \u2223 \u2713   \u2225 P/Q5 update             \u2223\n        (TreasuryWithdrawal  , _       ) \u2192 \u2223 \u2713   \u2223 vote P6      \u2223 \u2500        \u2223\n        (Info                , _       ) \u2192 \u2223 \u2713\u2020  \u2223 \u2713\u2020           \u2223 \u2713\u2020       \u2223\n          where\n</pre> <pre>          open PParams pp\n          open DrepThresholds drepThresholds\n          open PoolThresholds poolThresholds\n</pre> <pre>          vote : \u211a \u2192 Maybe \u211a\n          vote = just\n\n          defer : \u211a\n          defer = \u211a.1\u211a \u211a.+ \u211a.1\u211a\n\n          maxThreshold : \u2119 (Maybe \u211a) \u2192 Maybe \u211a\n          maxThreshold x = foldl _\u2228_ nothing (proj\u2081 $ finiteness x)\n            where\n            _\u2228_ : Maybe \u211a \u2192 Maybe \u211a \u2192 Maybe \u211a\n            just x  \u2228 just y  = just (x \u2294 y)\n            just x  \u2228 nothing = just x\n            nothing \u2228 just y  = just y\n            nothing \u2228 nothing = nothing\n\n          \u2500 \u2713 \u2713\u2020 : Maybe \u211a\n          \u2500  = nothing\n          \u2713  = maybe just \u2713\u2020 ccThreshold\n          \u2713\u2020 = vote defer\n\n          P/Q2a/b : Maybe \u211a \u00d7 Maybe \u211a\n          P/Q2a/b =  case ccThreshold of \u03bb where\n                     (just _)  \u2192 (vote P2a , vote Q2a)\n                     nothing   \u2192 (vote P2b , vote Q2b)\n\n          pparamThreshold : PParamGroup \u2192 Maybe \u211a \u00d7 Maybe \u211a\n          pparamThreshold NetworkGroup     = (vote P5a  , \u2500        )\n          pparamThreshold EconomicGroup    = (vote P5b  , \u2500        )\n          pparamThreshold TechnicalGroup   = (vote P5c  , \u2500        )\n          pparamThreshold GovernanceGroup  = (vote P5d  , \u2500        )\n          pparamThreshold SecurityGroup    = (\u2500         , vote Q5  )\n\n          P/Q5 : PParamsUpdate \u2192 Maybe \u211a \u00d7 Maybe \u211a\n          P/Q5 ppu = maxThreshold (map\u02e2 (proj\u2081 \u2218 pparamThreshold) (updateGroups ppu))\n                   , maxThreshold (map\u02e2 (proj\u2082 \u2218 pparamThreshold) (updateGroups ppu))\n\ncanVote : PParams \u2192 GovAction \u2192 GovRole \u2192 Type\ncanVote pp a r = Is-just (threshold pp nothing a r)\n</pre>"},{"location":"Ledger.Conway.Specification.Ratify.html#sec:protocol-parameters-and-governance-actions","title":"Protocol Parameters and Governance Actions","text":"<p>Voting thresholds for protocol parameters can be set by group, and we do not require that each protocol parameter governance action be confined to a single group. In case a governance action carries updates for multiple parameters from different groups, the maximum threshold of all the groups involved will apply to any given such governance action.</p> <p>The purpose of the <code>SecurityGroup</code> is to add an additional check to security-relevant protocol parameters. Any proposal that includes a change to a security-relevant protocol parameter must also be accepted by at least half of the <code>SPO</code> stake.</p>"},{"location":"Ledger.Conway.Specification.Ratify.html#sec:ratification-types-and-functions","title":"Ratification Types and Functions","text":"<p>This section defines types and functions used in the <code>RATIFY</code> transition system.</p> <pre>record StakeDistrs : Type where\n  field\n    stakeDistrVDeleg  : VDeleg  \u21c0 Coin\n    stakeDistrPools   : KeyHash \u21c0 Coin\n\nrecord RatifyEnv : Type where\n  field\n    stakeDistrs   : StakeDistrs\n    currentEpoch  : Epoch\n    dreps         : Credential \u21c0 Epoch\n    ccHotKeys     : Credential \u21c0 Maybe Credential\n    treasury      : Treasury\n    pools         : KeyHash \u21c0 StakePoolParams\n    delegatees    : VoteDelegs\n\nrecord RatifyState : Type where\n  field\n    es       : EnactState\n    removed  : \u2119 (GovActionID \u00d7 GovActionState)\n    delay    : Bool\n</pre> <pre>record HasRatifyState {a} (A : Type a) : Type a where\n  field RatifyStateOf : A \u2192 RatifyState\nopen HasRatifyState \u2983...\u2984 public\n\ninstance\n  HasEnactState-RatifyState : HasEnactState RatifyState\n  HasEnactState-RatifyState .EnactStateOf = RatifyState.es\n\n  HasDReps-RatifyEnv : HasDReps RatifyEnv\n  HasDReps-RatifyEnv .DRepsOf = RatifyEnv.dreps\n\n  HasTreasury-RatifyEnv : HasTreasury RatifyEnv\n  HasTreasury-RatifyEnv .TreasuryOf = RatifyEnv.treasury\n</pre> <p>As mentioned earlier, most governance actions must include a <code>GovActionID</code> for the most recently enacted action of the given type. Consequently, two actions of the same type can be enacted at the same time, but they must be deliberately designed to do so.</p> <pre>instance\n  unquoteDecl HasCast-StakeDistrs HasCast-RatifyEnv HasCast-RatifyState = derive-HasCast\n    (   (quote StakeDistrs , HasCast-StakeDistrs)\n    \u2237   (quote RatifyEnv , HasCast-RatifyEnv)\n    \u2237 [ (quote RatifyState , HasCast-RatifyState) ])\n</pre>"},{"location":"Ledger.Conway.Specification.Ratify.html#sec:vote-counting","title":"Vote Counting","text":"<p>This section defines the <code>acceptedBy</code> predicate for each of the governing bodies.  Given the current state of the votes and other parts of the system these functions calculate whether a governance action is ratified by the corresponding body.</p>"},{"location":"Ledger.Conway.Specification.Ratify.html#sec:cc-vote-counting","title":"Constitutional Committee (CC) Vote Counting","text":"<p>This subsection defines the <code>acceptedByCC</code> predicate, which utilizes the following auxiliary definitions.</p> <ul> <li> <p><code>castVotes</code>: This map contains the votes that have been    cast by members of the <code>CC</code> and are    part of the <code>GovActionState</code> <code>gaSt</code>.</p> </li> <li> <p><code>getCCHotCred</code>: This function maps a <code>Credential</code>    and an <code>Epoch</code> to the hot key corresponding to the given    credential, in case this has not expired.</p> </li> <li> <p><code>actualVote</code>: This function sets the default vote for    <code>CC</code> members.  If the given    <code>CC</code> member's term has expired, if they have not    yet registered a hot key, or if they have resigned, then    <code>actualVote</code> returns <code>abstain</code>; if none    of these conditions is met, then</p> <ul> <li> <p>if the <code>CC</code> member has voted, then that    vote is returned;</p> </li> <li> <p>if the <code>CC</code> member has not voted, then    the default value <code>no</code> is returned.</p> </li> </ul> </li> <li> <p><code>actualVotes</code>: This map contains the actual votes of    the <code>CC</code>.  If the commitee does not exists then it is    the empty map, otherwise,</p> <ul> <li> <p>if the number of <code>CC</code> members with a registered hot    key is greater than the protocol parameter <code>ccMinSize</code>, then    <code>actualVote</code> is returned (as a map), otherwise,</p> </li> <li> <p>all commitee members vote <code>no</code>.</p> </li> </ul> </li> <li> <p><code>mT</code>: This is the threshold of the <code>CC</code>.    It may be <code>nothing</code>.</p> </li> <li> <p><code>stakeDistr</code> computes the stake distribution.  Note that every    constitutional committe member has a stake of 1, giving them equal voting power.    However, just as with other delegation, multiple <code>CC</code>    members can delegate to the same hot key, giving a single vote with that hot key    the power of those multiple voting stakes.</p> </li> <li> <p><code>acceptedStake</code>: This is the portion of <code>CC</code>    stake that voted <code>yes</code>.</p> </li> <li> <p><code>totalStake</code>: This is the portion of <code>CC</code>    stake that voted either <code>yes</code> or <code>no</code>.</p> </li> </ul> <p>In addition, it must be the case that either</p> <ul> <li> <p>the size of the <code>CC</code> is greater than    <code>ccMinSize</code>, or</p> </li> <li> <p>the threshold function returns <code>nothing</code>.</p> </li> </ul> <pre>module AcceptedByCC (currentEpoch : Epoch)\n                    (ccHotKeys : Credential \u21c0 Maybe Credential)\n                    (eSt : EnactState)\n                    (gaSt : GovActionState)\n                    where\n</pre> <pre>  open EnactState eSt using (cc)\n  open PParams (PParamsOf eSt)\n  open GovActionState gaSt\n  open GovVotes votes using (gvCC)\n</pre> <pre>  sizeActiveCC : \u2115\n  sizeActiveCC = case proj\u2081 cc of \u03bb where\n    (just ((ccMembers , _) , _)) \u2192 length\u02e2 (filter\u02e2 (activeInEpoch currentEpoch) ccMembers)\n    nothing \u2192 0\n\n  castVotes : Credential \u21c0 Vote\n  castVotes = gvCC\n\n  getCCHotCred : Credential \u00d7 Epoch \u2192 Maybe Credential\n  getCCHotCred (c , e) =\n    if currentEpoch &gt; e\n    then nothing -- credential has expired\n    else case lookup\u1d50? ccHotKeys c of \u03bb where\n      (just (just c'))  \u2192 just c'\n      _                 \u2192 nothing -- hot key not registered or resigned\n\n  actualVote : Credential \u2192 Epoch \u2192 Vote\n  actualVote c e = case getCCHotCred (c , e) of \u03bb where\n    (just c')  \u2192 maybe id Vote.no (lookup\u1d50? castVotes c')\n    _          \u2192 Vote.abstain\n\n  actualVotes : Credential \u21c0 Vote\n  actualVotes = case proj\u2081 cc of \u03bb where\n    nothing         \u2192  \u2205\n    (just (m , _))  \u2192  if ccMinSize \u2264 length\u02e2 (mapFromPartialFun getCCHotCred (m \u02e2))\n                       then mapWithKey actualVote m\n                       else constMap (dom m) Vote.no\n\n  mT : Maybe \u211a\n  mT = threshold (PParamsOf eSt) (proj\u2082 &lt;$&gt; (proj\u2081 cc)) action CC\n\n  t : \u211a\n  t = maybe id 0\u211a mT\n\n  stakeDistr : Credential \u21c0 Coin\n  stakeDistr = constMap (dom actualVotes) 1\n\n  acceptedStake totalStake : Coin\n  acceptedStake  = \u2211[ x \u2190 stakeDistr \u2223 actualVotes \u207b\u00b9 Vote.yes ] x\n  totalStake     = \u2211[ x \u2190 stakeDistr \u2223 dom (actualVotes \u2223^ (\u2774 Vote.yes \u2775 \u222a \u2774 Vote.no \u2775)) ] x\n\n  accepted = (acceptedStake /\u2080 totalStake) \u2265 t\n    \u00d7 (sizeActiveCC \u2265 ccMinSize \u228e (Is-nothing mT \u00d7 ccMinSize \u2261 0))\n</pre> <pre>acceptedByCC\n  : RatifyEnv\n  \u2192 EnactState\n  \u2192 GovActionState\n  \u2192 Type\nacceptedByCC \u0393 = AcceptedByCC.accepted currentEpoch ccHotKeys\n  where open RatifyEnv \u0393 using (currentEpoch; ccHotKeys)\n</pre>"},{"location":"Ledger.Conway.Specification.Ratify.html#sec:drep-vote-counting","title":"DRep Vote Counting","text":"<p>This section defines the predicate <code>acceptedByDRep</code>, which depends on the following auxiliary definitions.</p> <ul> <li> <p><code>activeDReps</code>: This set contains all    <code>DReps</code> whose term has not expired.</p> </li> <li> <p><code>predeterminedDRepVotes</code>: This map collects the predetermined votes    for the <code>VDeleg</code>; it depends on the governance action at hand.</p> </li> <li> <p><code>defaultDRepCredentialVote</code>: This map sets the default vote to    <code>no</code> for all the active <code>DReps</code>.</p> </li> <li> <p><code>actualVotes</code>: This map joins together in order of preference: the    votes cast, the default votes and the predetermined votes.</p> </li> <li> <p><code>acceptedStake</code>: This is the portion of    <code>DRep</code> voting stake that voted <code>yes</code>.</p> </li> <li> <p><code>totalStake</code>: This the portion of <code>DRep</code>    voting stake that voted <code>yes</code> or <code>no</code>.</p> </li> </ul> <pre>module AcceptedByDRep (\u0393 : RatifyEnv)\n                      (eSt : EnactState)\n                      (gaSt : GovActionState)\n                      where\n</pre> <pre>  open EnactState eSt using (cc)\n  open RatifyEnv \u0393 using (currentEpoch; stakeDistrs)\n  open StakeDistrs stakeDistrs\n  open GovActionState gaSt\n  open GovVotes votes using (gvDRep)\n</pre> <pre>  castVotes : VDeleg \u21c0 Vote\n  castVotes = mapKeys vDelegCredential gvDRep\n\n  activeDReps : \u2119 Credential\n  activeDReps = dom (activeDRepsOf \u0393 currentEpoch)\n\n  predeterminedDRepVotes : VDeleg \u21c0 Vote\n  predeterminedDRepVotes = case gaType action of \u03bb where\n      NoConfidence \u2192 \u2774 vDelegAbstain , Vote.abstain \u2775 \u222a\u02e1 \u2774 vDelegNoConfidence , Vote.yes \u2775\n      _            \u2192 \u2774 vDelegAbstain , Vote.abstain \u2775 \u222a\u02e1 \u2774 vDelegNoConfidence , Vote.no  \u2775\n\n  defaultDRepCredentialVotes : VDeleg \u21c0 Vote\n  defaultDRepCredentialVotes = constMap (map\u02e2 vDelegCredential activeDReps) Vote.no\n\n  actualVotes : VDeleg \u21c0 Vote\n  actualVotes  = castVotes \u222a\u02e1 defaultDRepCredentialVotes\n                           \u222a\u02e1 predeterminedDRepVotes\n\n  t : \u211a\n  t = maybe id 0\u211a (threshold (PParamsOf eSt) (proj\u2082 &lt;$&gt; (proj\u2081 cc)) action DRep)\n\n  acceptedStake totalStake : Coin\n  acceptedStake  = \u2211[ x \u2190 stakeDistrVDeleg \u2223 actualVotes \u207b\u00b9 Vote.yes ] x\n  totalStake     = \u2211[ x \u2190 stakeDistrVDeleg \u2223 dom (actualVotes \u2223^ (\u2774 Vote.yes \u2775 \u222a \u2774 Vote.no \u2775)) ] x\n\n  accepted = (acceptedStake /\u2080 totalStake) \u2265 t\n</pre> <pre>acceptedByDRep\n  : RatifyEnv\n  \u2192 EnactState\n  \u2192 GovActionState\n  \u2192 Type\nacceptedByDRep = AcceptedByDRep.accepted\n</pre>"},{"location":"Ledger.Conway.Specification.Ratify.html#sec:spo-vote-counting","title":"Stake Pool Operator (SPO) Vote Counting","text":"<p>This section defines the predicate <code>acceptedBySPO</code>, which uses the following auxiliary definitions.</p> <ul> <li> <p><code>castVotes</code>: This map contains the votes that have been cast by    members of the <code>SPO</code> body and have been collected as    part of the <code>GovActionState</code> <code>gaSt</code>.</p> </li> <li> <p><code>defaultVote</code>: This map sets a default vote to all    <code>SPOs</code> who didn't vote, with the default depending on    the given action, and whether the <code>SPO</code> has delegated    their vote to one of the default <code>DReps</code>.</p> </li> <li> <p><code>actualVotes</code>: This map combines the votes cast by    <code>SPOs</code> with <code>defaultVote</code> using a    left-biased union making cast votes take precedence over default votes.</p> </li> <li> <p><code>t</code>: This rational number is the threshold used to calculate    whether the action is ratified by the <code>SPO</code> body.</p> </li> <li> <p><code>acceptedStake</code>: This is the portion of    <code>SPO</code> stake that voted    <code>yes</code>; it is computed using the stake distribution    <code>stakeDistrPools</code> provided in the environment.</p> </li> <li> <p><code>totalStake</code>: This is the portion of    <code>SPO</code> stake that voted either    <code>yes</code> or <code>no</code>; it is    computed using the stake distribution <code>stakeDistrPools</code> provided in    the environment.</p> </li> </ul> <p>An <code>SPO</code> that did not vote is assumed to have voted <code>no</code>, except under the following circumstances:</p> <ul> <li> <p>if the <code>SPO</code> has delegated its reward credential to an    <code>AlwaysNoConfidence</code> <code>DRep</code>, then their default vote is    <code>yes</code> for <code>NoConfidence</code>    proposals and <code>no</code> for other proposals;</p> </li> <li> <p>if the <code>SPO</code> has delegated its reward credential to an    <code>AlwaysAbstain</code> <code>DRep</code>, then its default vote is    <code>abstain</code> for all proposals.</p> </li> </ul> <p>It is important to note that the credential that can now be used to configure default voting behavior is the credential used to withdraw staking rewards, which is not the same as the credential that is used for standard voting.</p> <p>Vote Counting Methodology</p> <p>The way <code>SPO</code> votes are counted has evolved in response to community feedback.  Previously, if an <code>SPO</code> did not vote, then it would be counted as having voted <code>abstain</code> by default.  Members of the <code>SPO</code> community found this behavior counterintuitive and requested that non-voters be assigned a <code>no</code> vote by default, with the caveat that an <code>SPO</code> could change its default setting by delegating its reward account credential to an <code>AlwaysNoConfidence</code> <code>DRep</code> or an <code>AlwaysAbstain</code> <code>DRep</code>.  (This change applies only after the bootstrap period; during the bootstrap period the logic is unchanged; see the section on Bootstrapping the Governance System.)</p> <pre>module AcceptedBySPO (delegatees : VoteDelegs)\n                     (pools : Pools)\n                     (stakeDistrPools : KeyHash \u21c0 Coin)\n                     (eSt : EnactState)\n                     (gaSt : GovActionState)\n                     where\n</pre> <pre>  open EnactState eSt using (cc)\n  open GovActionState gaSt\n  open GovVotes votes using (gvSPO)\n</pre> <pre>  castVotes : KeyHash \u21c0 Vote\n  castVotes = gvSPO\n\n  defaultVote : KeyHash \u2192 Vote\n  defaultVote kh = case lookup\u1d50? pools kh of \u03bb where\n    nothing   \u2192 Vote.no\n    (just  p) \u2192 case lookup\u1d50? delegatees (StakePoolParams.rewardAccount p) , gaType action of\n      \u03bb where\n      ( _                        , TriggerHardFork  )  \u2192 Vote.no\n      ( just vDelegNoConfidence  , NoConfidence     )  \u2192 Vote.yes\n      ( just vDelegAbstain       , _                )  \u2192 Vote.abstain\n      _                                                \u2192 Vote.no\n\n  actualVotes : KeyHash \u21c0 Vote\n  actualVotes = castVotes \u222a\u02e1 mapFromFun defaultVote (dom stakeDistrPools)\n\n  t : \u211a\n  t = maybe id 0\u211a (threshold (PParamsOf eSt) (proj\u2082 &lt;$&gt; (proj\u2081 cc)) action SPO)\n\n  acceptedStake totalStake : Coin\n  acceptedStake  = \u2211[ x \u2190 stakeDistrPools \u2223 actualVotes \u207b\u00b9 Vote.yes ] x\n  totalStake     = \u2211[ x \u2190 stakeDistrPools \u2223 dom (actualVotes \u2223^ (\u2774 Vote.yes \u2775 \u222a \u2774 Vote.no \u2775)) ] x\n\n  accepted : Type\n  accepted = (acceptedStake /\u2080 totalStake) \u2265 t\n</pre> <pre>acceptedBySPO\n  : RatifyEnv\n  \u2192 EnactState\n  \u2192 GovActionState\n  \u2192 Type\nacceptedBySPO \u0393 = AcceptedBySPO.accepted delegatees pools stakeDistrPools\n  where open RatifyEnv \u0393\n        open StakeDistrs stakeDistrs\n</pre>"},{"location":"Ledger.Conway.Specification.Ratify.html#ratification-functions","title":"Ratification Functions","text":"<p>We first define the <code>accepted</code> and <code>expired</code> functions, which are used in the rules of the <code>RATIFY</code> transition system.</p> <pre>opaque\n</pre> <pre>  accepted : RatifyEnv \u2192 EnactState \u2192 GovActionState \u2192 Type\n  accepted \u0393 es gs = acceptedByCC \u0393 es gs \u00d7 acceptedByDRep \u0393 es gs \u00d7 acceptedBySPO \u0393 es gs\n\n  expired : Epoch \u2192 GovActionState \u2192 Type\n  expired current record { expiresIn = expiresIn } = expiresIn &lt; current\n</pre> <p>Next, we define functions that deal with delays and the acceptance criterion for ratification.</p> <p>A given action can either be delayed if the action contained in <code>EnactState</code> isn\u2019t the one the given action is building on top of, which is checked by <code>verifyPrev</code>, or if a previous action was a <code>delayingAction</code>.</p> <p>Note that <code>delayingAction</code> affects the future; specifically, whenever a <code>delayingAction</code> is accepted all future actions are delayed. <code>delayed</code> then expresses whether an action is delayed.  This happens either because the previous action doesn\u2019t match the current one, or because the previous action was a delaying one.  This information is passed in as an argument.</p> <pre>open EnactState\n</pre> <pre>verifyPrev : (a : GovActionType) \u2192 NeedsHash a \u2192 EnactState \u2192 Type\nverifyPrev NoConfidence        h es  = h \u2261 es .cc .proj\u2082\nverifyPrev UpdateCommittee     h es  = h \u2261 es .cc .proj\u2082\nverifyPrev NewConstitution     h es  = h \u2261 es .constitution .proj\u2082\nverifyPrev TriggerHardFork     h es  = h \u2261 es .pv .proj\u2082\nverifyPrev ChangePParams       h es  = h \u2261 es .pparams .proj\u2082\nverifyPrev TreasuryWithdrawal  _ _   = \u22a4\nverifyPrev Info                _ _   = \u22a4\n\ndelayingAction : GovActionType \u2192 Bool\ndelayingAction NoConfidence        = true\ndelayingAction UpdateCommittee     = true\ndelayingAction NewConstitution     = true\ndelayingAction TriggerHardFork     = true\ndelayingAction ChangePParams       = false\ndelayingAction TreasuryWithdrawal  = false\ndelayingAction Info                = false\n\ndelayed : (a : GovActionType) \u2192 NeedsHash a \u2192 EnactState \u2192 Bool \u2192 Type\ndelayed gaTy h es d = \u00ac verifyPrev gaTy h es \u228e d \u2261 true\n\nacceptConds : RatifyEnv \u2192 RatifyState \u2192 GovActionID \u00d7 GovActionState \u2192 Type\nacceptConds \u0393 st\u02b3 (id , st) =\n  accepted \u0393 es st\n  \u00d7 \u00ac delayed (gaType action) prevAction es delay\n  \u00d7 \u2203[ es' ]  $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.html#24679}{\\htmlId{24775}{\\htmlClass{Bound}{\\text{id}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#7983}{\\htmlId{24780}{\\htmlClass{Function}{\\text{treasury}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#7868}{\\htmlId{24791}{\\htmlClass{Function}{\\text{currentEpoch}}}}\\, \\end{pmatrix}$ \u22a2 es \u21c0\u2987 action ,ENACT\u2988 es'\n</pre> <pre>    where open RatifyEnv \u0393\n          open RatifyState st\u02b3\n          open GovActionState st\n\nopaque\n  unfolding accepted\n\n  verifyPrev? : \u2200 a h es \u2192 Dec (verifyPrev a h es)\n  verifyPrev? NoConfidence        h es = dec\n  verifyPrev? UpdateCommittee     h es = dec\n  verifyPrev? NewConstitution     h es = dec\n  verifyPrev? TriggerHardFork     h es = dec\n  verifyPrev? ChangePParams       h es = dec\n  verifyPrev? TreasuryWithdrawal  h es = dec\n  verifyPrev? Info                h es = dec\n\n  delayed? : \u2200 a h es d \u2192 Dec (delayed a h es d)\n  delayed? a h es d = let instance _ = \u2047 verifyPrev? a h es in dec\n\n  Is-nothing? : \u2200 {A : Set} {x : Maybe A} \u2192 Dec (Is-nothing x)\n  Is-nothing? {x = x} = All.dec (const $ no id) x\n    where import Data.Maybe.Relation.Unary.All as All\n\n  accepted? : \u2200 \u0393 es st \u2192 Dec (accepted \u0393 es st)\n  accepted? \u0393 es st = acceptedByCC? \u0393 es st \u00d7-dec acceptedByDRep? \u0393 es st \u00d7-dec acceptedBySPO? \u0393 es st\n    where\n    acceptedByCC? : \u2200 \u0393 es st \u2192 Dec (acceptedByCC \u0393 es st)\n    acceptedByCC? _ _ _ = _ \u211a.\u2264? _ \u00d7-dec (_ \u2265? _ \u228e-dec (Is-nothing? \u00d7-dec \u00bf _ \u00bf))\n\n    acceptedByDRep? : \u2200 \u0393 es st \u2192 Dec (acceptedByDRep \u0393 es st)\n    acceptedByDRep? _ _ _ = _ \u211a.\u2264? _\n\n    acceptedBySPO? : \u2200 \u0393 es st \u2192 Dec (acceptedBySPO \u0393 es st)\n    acceptedBySPO? _ _ _ = _ \u211a.\u2264? _\n\n  expired? : \u2200 e st \u2192 Dec (expired e st)\n  expired? e st = \u00bf expired e st \u00bf\n\nprivate variable\n  \u0393 : RatifyEnv\n  es es' : EnactState\n  a : GovActionID \u00d7 GovActionState\n  removed : \u2119 (GovActionID \u00d7 GovActionState)\n  d : Bool\n\nopen RatifyEnv\nopen GovActionState\n</pre>"},{"location":"Ledger.Conway.Specification.Ratify.html#the-ratify-transition-system","title":"The RATIFY Transition System","text":"<p>We now define the <code>RATIFY</code> transition system, which is constructed via three rules.</p> <ul> <li> <p><code>RATIFYAccept</code> checks if the votes for a given    <code>GovAction</code> meet the threshold required for acceptance, that the    action is accepted and not delayed, and <code>RATIFYAccept</code>    ratifies the action.</p> </li> <li> <p><code>RATIFYReject</code> asserts that the given    <code>GovAction</code> is not <code>accepted</code> and    <code>expired</code>; it removes the governance action.</p> </li> <li> <p><code>RATIFYContinue</code> covers the remaining cases and keeps    the <code>GovAction</code> around for further voting.</p> </li> </ul> <p>Note that all governance actions eventually either get accepted and enacted via <code>RATIFYAccept</code> or rejected via <code>RATIFYReject</code>.  If an action satisfies all criteria to be accepted but cannot be enacted anyway, it is kept around and tried again at the next epoch boundary.</p> <p>We never remove actions that do not attract sufficient <code>yes</code> votes before they expire, even if it is clear to an outside observer that this action will never be enacted.  Such an action will simply continue to be checked every epoch until it expires.</p> <pre>data _\u22a2_\u21c0\u2987_,RATIFY\u2988_ : RatifyEnv \u2192 RatifyState \u2192 GovActionID \u00d7 GovActionState \u2192 RatifyState \u2192 Type\n  where\n\n  RATIFY-Accept :\n    let treasury       = TreasuryOf \u0393\n        e              = \u0393 .currentEpoch\n        (gaId , gaSt)  = a\n        action         = GovActionOf gaSt\n    in\n    \u2219 acceptConds \u0393 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.html#26239}{\\htmlId{28093}{\\htmlClass{Generalizable}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26296}{\\htmlId{28098}{\\htmlClass{Generalizable}{\\text{removed}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26341}{\\htmlId{28108}{\\htmlClass{Generalizable}{\\text{d}}}}\\, \\end{pmatrix}$ a\n    \u2219 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.html#28004}{\\htmlId{28122}{\\htmlClass{Bound}{\\text{gaId}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#27924}{\\htmlId{28129}{\\htmlClass{Bound}{\\text{treasury}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#27962}{\\htmlId{28140}{\\htmlClass{Bound}{\\text{e}}}}\\, \\end{pmatrix}$ \u22a2 es \u21c0\u2987 action ,ENACT\u2988 es'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.html#26239}{\\htmlId{28222}{\\htmlClass{Generalizable}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26296}{\\htmlId{28227}{\\htmlClass{Generalizable}{\\text{removed}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26341}{\\htmlId{28237}{\\htmlClass{Generalizable}{\\text{d}}}}\\, \\end{pmatrix}$ \u21c0\u2987 a ,RATIFY\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.html#26242}{\\htmlId{28257}{\\htmlClass{Generalizable}{\\text{es'}}}}\\, \\\\ \\,\\href{Class.HasSingleton.html#288}{\\htmlId{28263}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Ratify.html#26261}{\\htmlId{28265}{\\htmlClass{Generalizable}{\\text{a}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{28267}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.html#9137}{\\htmlId{28269}{\\htmlClass{Function Operator}{\\text{\u222a}}}}\\, \\,\\href{Ledger.Conway.Specification.Ratify.html#26296}{\\htmlId{28271}{\\htmlClass{Generalizable}{\\text{removed}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#24120}{\\htmlId{28281}{\\htmlClass{Function}{\\text{delayingAction}}}}\\, \\,\\htmlId{28296}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Gov.Actions.html#4046}{\\htmlId{28297}{\\htmlClass{Field}{\\text{gaType}}}}\\, \\,\\href{Ledger.Conway.Specification.Ratify.html#28030}{\\htmlId{28304}{\\htmlClass{Bound}{\\text{action}}}}\\,\\,\\htmlId{28310}{\\htmlClass{Symbol}{\\text{)}}}\\, \\end{pmatrix}$\n\n  RATIFY-Reject :\n    let e              = \u0393 .currentEpoch\n        (gaId , gaSt)  = a\n    in\n    \u2219 \u00ac acceptConds \u0393 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.html#26239}{\\htmlId{28432}{\\htmlClass{Generalizable}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26296}{\\htmlId{28437}{\\htmlClass{Generalizable}{\\text{removed}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26341}{\\htmlId{28447}{\\htmlClass{Generalizable}{\\text{d}}}}\\, \\end{pmatrix}$ a\n    \u2219 expired e gaSt\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.html#26239}{\\htmlId{28525}{\\htmlClass{Generalizable}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26296}{\\htmlId{28530}{\\htmlClass{Generalizable}{\\text{removed}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26341}{\\htmlId{28540}{\\htmlClass{Generalizable}{\\text{d}}}}\\, \\end{pmatrix}$ \u21c0\u2987 a ,RATIFY\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.html#26239}{\\htmlId{28560}{\\htmlClass{Generalizable}{\\text{es}}}}\\, \\\\ \\,\\href{Class.HasSingleton.html#288}{\\htmlId{28565}{\\htmlClass{Field Operator}{\\text{\u2774}}}}\\, \\,\\href{Ledger.Conway.Specification.Ratify.html#26261}{\\htmlId{28567}{\\htmlClass{Generalizable}{\\text{a}}}}\\, \\,\\href{Class.HasSingleton.html#288}{\\htmlId{28569}{\\htmlClass{Field Operator}{\\text{\u2775}}}}\\, \\,\\href{Axiom.Set.html#9137}{\\htmlId{28571}{\\htmlClass{Function Operator}{\\text{\u222a}}}}\\, \\,\\href{Ledger.Conway.Specification.Ratify.html#26296}{\\htmlId{28573}{\\htmlClass{Generalizable}{\\text{removed}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26341}{\\htmlId{28583}{\\htmlClass{Generalizable}{\\text{d}}}}\\, \\end{pmatrix}$\n\n  RATIFY-Continue :\n     let e              = \u0393 .currentEpoch\n         (gaId , gaSt)  = a\n     in\n     \u2219 \u00ac acceptConds \u0393 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.html#26239}{\\htmlId{28711}{\\htmlClass{Generalizable}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26296}{\\htmlId{28716}{\\htmlClass{Generalizable}{\\text{removed}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26341}{\\htmlId{28726}{\\htmlClass{Generalizable}{\\text{d}}}}\\, \\end{pmatrix}$ a\n     \u2219 \u00ac expired e gaSt\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       \u0393 \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.html#26239}{\\htmlId{28809}{\\htmlClass{Generalizable}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26296}{\\htmlId{28814}{\\htmlClass{Generalizable}{\\text{removed}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26341}{\\htmlId{28824}{\\htmlClass{Generalizable}{\\text{d}}}}\\, \\end{pmatrix}$ \u21c0\u2987 a ,RATIFY\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Ratify.html#26239}{\\htmlId{28844}{\\htmlClass{Generalizable}{\\text{es}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26296}{\\htmlId{28849}{\\htmlClass{Generalizable}{\\text{removed}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Ratify.html#26341}{\\htmlId{28859}{\\htmlClass{Generalizable}{\\text{d}}}}\\, \\end{pmatrix}$\n</pre> <p>Finally, the <code>RATIFIES</code> transition system is defined as the \"reflexive transitive closure\" of the <code>RATIFY</code> rule.</p> <pre>_\u22a2_\u21c0\u2987_,RATIFIES\u2988_ : RatifyEnv \u2192 RatifyState \u2192 List (GovActionID \u00d7 GovActionState) \u2192 RatifyState \u2192 Type\n_\u22a2_\u21c0\u2987_,RATIFIES\u2988_ = ReflexiveTransitiveClosure {sts = _\u22a2_\u21c0\u2987_,RATIFY\u2988_}\n</pre>"},{"location":"Ledger.Conway.Specification.RewardUpdate.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\nopen import Ledger.Conway.Specification.Abstract using (AbstractFunctions)\n\nmodule Ledger.Conway.Specification.RewardUpdate.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\nopen import Ledger.Conway.Specification.RewardUpdate txs abs\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Epoch.Properties.Computational txs abs\nopen import Ledger.Prelude\n\nopen Computational \u2983...\u2984\n\ninstance\n  Computational-RUPD : Computational _\u22a2_\u21c0\u2987_,RUPD\u2988_ \u22a5\n  Computational-RUPD .computeProof _ (just ru) _ =\n    success (just ru , RUPD-Reward-Update-Exists)\n  Computational-RUPD .computeProof _ nothing slot\n    with firstSlot (epoch slot) + RandomnessStabilisationWindow &lt;? slot\n  ... | yes p  =\n    let ru' = _\n     in success (just ru' , RUPD-Create-Reward-Update {ru' = ru'} p)\n  ... | no \u00acp = success (nothing , RUPD-Reward-Too-Early \u00acp)\n\n  Computational-RUPD .completeness _ s slot s' RUPD-Reward-Update-Exists\n    = refl\n  Computational-RUPD .completeness _ s slot (just ru') (RUPD-Create-Reward-Update slot&gt;)\n    with firstSlot (epoch slot) + RandomnessStabilisationWindow &lt;? slot\n  ... | yes _ = refl\n  ... | no slot\u226f = \u22a5-elim (slot\u226f slot&gt;)\n  Computational-RUPD .completeness _ s slot nothing (RUPD-Reward-Too-Early \u00acslot&gt;)\n    with firstSlot (epoch slot) + RandomnessStabilisationWindow &lt;? slot\n  ... | no _ = refl\n  ... | yes slot&gt; = \u22a5-elim $ \u00acslot&gt; slot&gt;\n\n  Computational-TICK : Computational _\u22a2_\u21c0\u2987_,TICK\u2988_ \u22a5\n  Computational-TICK .computeProof _ nes _ = do\n    (nes' , neStep) \u2190 computeProof {STS = _\u22a2_\u21c0\u2987_,NEWEPOCH\u2988_} _ _ _\n    (_ , ruStep) \u2190 computeProof _ (nes' .NewEpochState.ru) _\n    success (_ , TICK (neStep , ruStep))\n\n  Computational-TICK .completeness _ _ _ _ (TICK (neStep , ruStep))\n    with completeness _ _ _ _ neStep\n  ... | refl\n    with recomputeProof ruStep | completeness _ _ _ _ ruStep\n  ... | success _ | refl\n     = refl\n</pre>"},{"location":"Ledger.Conway.Specification.RewardUpdate.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.RewardUpdate.Properties where\n\nopen import Ledger.Conway.Specification.RewardUpdate.Properties.Computational\n</pre>"},{"location":"Ledger.Conway.Specification.RewardUpdate.html","title":"RewardUpdate","text":"<pre>{-# OPTIONS --safe #-}\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\u00a0\nmodule Ledger.Conway.Specification.RewardUpdate\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Rewards txs abs\n</pre>"},{"location":"Ledger.Conway.Specification.RewardUpdate.html#reward-update-transition","title":"Reward Update Transition","text":"<p>The Reward Update Transition calculates a new <code>RewardUpdate</code> to apply in an epoch transition.</p> <p>The environment consists of the produced blocks and the epoch state. The state is an optional reward update.</p> <p>There are three transition cases, one that computes a new reward update, one that leaves the rewards update unchanged as it has not yet been applied and finally one that leaves the reward update unchanged as the transition was started too early.</p> <p>The signal of the transition rule RUPD is the current slot <code>s</code>.</p> <p>The execution of the transition role is as follows:</p> <ul> <li>If the current reward update is empty and <code>s</code> is greater than the   sum of the first slot of its epoch and the duration   <code>RandomnessStabilisationWindow\u1d9c</code>, then a new rewards update is   calculated and the state is updated.</li> <li>If the current reward update is not <code>nothing</code>, i.e.   a reward update has already been calculated but not yet applied, then the   state is not updated.</li> <li>If the current reward update is empty and <code>s</code> is less than or   equal to the sum of the first slot of its epoch and the duration   <code>RandomnessStabilisationWindow\u1d9c</code>, then the state is not updated.</li> </ul> <pre>RUpdEnv : Type\nRUpdEnv = BlocksMade \u00d7 EpochState\n\n\ndata _\u22a2_\u21c0\u2987_,RUPD\u2988_\n  : RUpdEnv \u2192 Maybe RewardUpdate \u2192 Slot \u2192 Maybe RewardUpdate \u2192 Type where\n\n  RUPD-Create-Reward-Update : \u2200 {b es s} {ru' : RewardUpdate} \u2192\n    let\n      ru' = createRUpd SlotsPerEpoch\u1d9c b es MaxLovelaceSupply\u1d9c\n    in\n    \u2219 s &gt; firstSlot (epoch s) + RandomnessStabilisationWindow\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    (b , es) \u22a2 nothing \u21c0\u2987 s ,RUPD\u2988 just ru'\n\n  RUPD-Reward-Update-Exists : \u2200 {b es s ru} \u2192\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    (b , es) \u22a2 just ru \u21c0\u2987 s ,RUPD\u2988 just ru\n\n  RUPD-Reward-Too-Early : \u2200 {b es s} \u2192\n    \u2219 \u00ac s &gt; firstSlot (epoch s) + RandomnessStabilisationWindow\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    (b , es) \u22a2 nothing \u21c0\u2987 s ,RUPD\u2988 nothing\n</pre>"},{"location":"Ledger.Conway.Specification.RewardUpdate.html#chain-tick-transition","title":"Chain Tick Transition","text":"<p>The Chain Tick Transition performs some chain level upkeep. The environment consists of a set of genesis keys, and the state is the epoch specific state necessary for the <code>NEWEPOCH</code> transition.</p> <p>Two transitions are done:</p> <ul> <li>The <code>NEWEPOCH</code> transition performs any state change needed if   it is the first block of a new epoch.</li> <li>The <code>RUPD</code> creates the reward update if it is late enough in   the epoch. Note that for every block header, either <code>NEWEPOCH</code>   or <code>RUPD</code> will be the identity transition.</li> </ul> <pre>data _\u22a2_\u21c0\u2987_,TICK\u2988_\n  : \u22a4 \u2192 NewEpochState \u2192 Slot \u2192 NewEpochState \u2192 Type where\n\n  TICK : \u2200 {slot nes nes' ru''} \u2192\n    let open NewEpochState in\n    -- TODO: Is this really how it should be?\n    -- We are skipping adoptGenesisDelegs here.\n    \u2219 tt \u22a2 nes \u21c0\u2987 epoch slot ,NEWEPOCH\u2988 nes'\n    \u2219 (nes .bprev , nes .epochState) \u22a2 (nes' .ru) \u21c0\u2987 slot ,RUPD\u2988 ru''\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      tt \u22a2 nes \u21c0\u2987 slot ,TICK\u2988 record nes' { ru = ru'' }\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Rewards.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Conway.Specification.Rewards txs abs\n\nmodule _ {lstate : LState} {ss : Snapshots} where\n  SNAP-total : \u2203[ ss' ] lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n  SNAP-total = -, SNAP\n\n  SNAP-complete : \u2200 ss' \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss' \u2192 proj\u2081 SNAP-total \u2261 ss'\n  SNAP-complete ss' SNAP = refl\n\n  SNAP-deterministic : \u2200 {ss' ss''}\n                     \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'\n                     \u2192 lstate \u22a2 ss \u21c0\u2987 tt ,SNAP\u2988 ss'' \u2192 ss' \u2261 ss''\n  SNAP-deterministic SNAP SNAP = refl\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html","title":"Rewards","text":"<p>In this section we define how rewards for stake pools and their delegators are calculated and paid out. This calculation has two main aspects.</p> <ol> <li> <p>The amount of rewards to be paid out. This is defined in the section     Amount of Rewards to be Paid Out.</p> </li> <li> <p>The time when rewards are paid out. This is defined in the section     Timing of Rewards Payout.</p> </li> </ol> <pre>\n{-# OPTIONS --safe #-}\n\nopen import Data.Integer using () renaming (+_ to pos)\nopen import Data.Rational using (\u211a; floor; _*_; _\u00f7_; _/_; _-_; &gt;-nonZero; _\u2293_)\n                          renaming (_\u2294_ to _\u2294\u211a_; NonZero to NonZero\u211a)\nopen import Data.Rational.Literals using (number; from\u2124)\nopen import Data.Rational.Properties using (pos\u21d2nonZero; positive\u207b\u00b9; +-mono-&lt;-\u2264; normalize-pos; p\u2264p\u2294q)\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Prelude.Numeric.UnitInterval\n\nopen import Agda.Builtin.FromNat\nopen        Number number renaming (fromNat to from\u2115)\n\nmodule Ledger.Conway.Specification.Rewards\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs)\n  where\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Prelude hiding (_/_; _*_; _-_; &gt;-nonZero; _\u2293_)\nopen import Ledger.Conway.Specification.Utxo txs abs\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:rewards-motivation","title":"Rewards Motivation","text":"<p>In order to operate, any blockchain needs to attract parties that are willing to spend computational and network resources on processing transactions and producing new blocks. These parties, called block producers, are incentivized by monetary rewards.</p> <p>Cardano is a proof-of-stake (PoS) blockchain: through a random lottery, one block producer is selected to produce one particular block. The probability for being select depends on their stake of Ada, that is the amount of Ada that they (and their delegators) own relative to the total amount of Ada. (We will explain delegation below.) After successful block production, the block producer is eligible for a share of the rewards.</p> <p>The rewards for block producers come from two sources: during an initial period, rewards are paid out from the reserve, which is an initial allocation of Ada created for this very purpose. Over time, the reserve is depleted, and rewards are sourced from transaction fees.</p> <p>Rewards are paid out epoch by epoch.</p> <p>Rewards are collective, but depend on performance: after every epoch, a fraction of the available reserve and the transaction fees accumulated during that epoch are added together. This sum is paid out to the block producers proportionally to how many blocks they have created each. In order to avoid perverse incentives, block producers do not receive individual rewards that depend on the content of their blocks.</p> <p>Not all people can or want to set up and administer a dedicated computer that produces blocks. However, these people still own Ada, and their stake is relevant for block production. Specifically, these people have the option to delegate their stake to a stake pool, which belongs to a block producer. This stake counts towards the stake of the pool in the block production lottery. In turn, the protocol distributes the rewards for produced blocks to the stake pool owner and their delegators. The owner receives a fixed fee (\u201ccost\u201d) and a share of the rewards (\u201cmargin\u201d). The remainder is distributed among delegators in proportion to their stake. By design, delegation and ownership are separate\u2014delegation counts towards the stake of the pool, but delegators remain in full control of their Ada, stake pools cannot spend delegated Ada.</p> <p>Stake pools compete for delegators based on fees and performance. In order to achieve stable blockchain operation, the rewards are chosen such that they incentivize the system to evolve into a large, but fixed number of stake pools that attract most of the stake. For more details about the design and rationale of the rewards and delegation system, see Team18.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:amount-of-rewards-to-be-paid-out","title":"Amount of Rewards to be Paid Out","text":""},{"location":"Ledger.Conway.Specification.Rewards.html#sec:precision-rewards","title":"Precision of Arithmetic Operations","text":"<p>When computing rewards, all intermediate results are computed using rational numbers, <code>\u211a</code>, and converted to <code>Coin</code> using the <code>floor</code> function at the very end of the computation.</p> <p>Note for implementors</p> <p>Values in <code>\u211a</code> can have arbitrarily large nominators and denominators. Please use an appropriate type that represents rational numbers as fractions of unbounded nominators and denominators. Types such as <code>Double</code>, <code>Float</code>, <code>BigDecimal</code> (Java Platform), or <code>Fixed</code> (fixed-precision arithmetic) do not faithfully represent the rational numbers, and are not suitable for computing rewards according to this specification!</p> <p>We use the following arithmetic operations besides basic arithmetic:</p> <ul> <li> <p><code>from\u2115</code>: Interpret a natural number as a rational number.</p> </li> <li> <p><code>floor</code>: Round a rational number to the next smaller integer.</p> </li> <li> <p><code>posPart</code>: Convert an integer to a natural number by mapping all    negative numbers to zero.</p> </li> <li> <p><code>\u00f7</code>: Division of rational numbers.</p> </li> <li> <p><code>\u00f7\u2080</code>: Division operator that returns zero when the denominator is zero.</p> </li> <li> <p><code>/</code>: Division operator that maps integer arguments to a rational number.</p> </li> <li> <p><code>/\u2080</code>: Like <code>\u00f7\u2080</code>, but with integer arguments.</p> </li> </ul>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:rewards-distribution-calculation","title":"Rewards Distribution Calculation","text":"<p>This section defines the amount of rewards that are paid out to stake pools and their delegators.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:maxpool","title":"The maxPool Function","text":"<p>This subsection defines the function <code>maxPool</code> which gives the maximum reward a stake pool can receive in an epoch. Relevant quantities are the following:</p> <ul> <li> <p><code>rewardPot</code>: Total rewards to be paid out after the epoch.</p> </li> <li> <p><code>stake</code>: Relative stake of the pool.</p> </li> <li> <p><code>pledge</code>: Relative stake that the pool owner has pledged themselves to the pool.</p> </li> <li> <p><code>z0</code>: Relative stake of a fully saturated pool.</p> </li> <li> <p><code>nopt</code>: Protocol parameter, planned number of block producers.</p> </li> <li> <p><code>a0</code>: Protocol parameter that incentivizes higher pledges.</p> </li> <li> <p><code>reward\u211a</code>: Pool rewards as a rational number.</p> </li> <li> <p><code>reward\u2115</code>: Pool rewards after rounding to a natural number of lovelace.</p> </li> </ul> <pre>nonZero-max-1 : \u2200 (n : \u2115) \u2192 NonZero (1 \u2294 n)\nnonZero-max-1 zero = nonZero\nnonZero-max-1 (suc n) = nonZero\n\nnonZero-1/n : \u2200 (n : \u2115) \u2192 .{{_ : NonZero n}} \u2192 NonZero\u211a (1 / n)\nnonZero-1/n n {{prf}} =\n  pos\u21d2nonZero (1 / n) {{normalize-pos 1 n {{prf}} {{_}} }}\n\nnonZero-1+max0-x : \u2200 (x : \u211a) \u2192 NonZero\u211a (1 + (0 \u2294\u211a x))\nnonZero-1+max0-x x =\n  &gt;-nonZero (+-mono-&lt;-\u2264 (positive\u207b\u00b9 1 {{_}}) (p\u2264p\u2294q 0 x))\n</pre> <pre>maxPool : PParams \u2192 Coin \u2192 UnitInterval \u2192 UnitInterval \u2192 Coin\nmaxPool pparams rewardPot stake pledge = reward\u2115\n  where\n    a0    = 0 \u2294\u211a pparams .PParams.a0\n    1+a0  = 1 + a0\n    nopt  = 1 \u2294 pparams .PParams.nopt\n</pre> <pre>    instance\n      nonZero-nopt : NonZero nopt\n      nonZero-nopt = nonZero-max-1 (pparams .PParams.nopt)\n</pre> <pre>    z0       = 1 / nopt\n    stake'   = fromUnitInterval stake \u2293 z0\n    pledge'  = fromUnitInterval pledge \u2293 z0\n</pre> <pre>    instance\n      nonZeroz0 : NonZero\u211a z0\n      nonZeroz0 = nonZero-1/n nopt\n\n      nonZero-1+a0 : NonZero\u211a (1+a0)\n      nonZero-1+a0 = nonZero-1+max0-x (pparams .PParams.a0)\n</pre> <pre>    reward\u211a =  from\u2115 rewardPot \u00f7 1+a0\n               *  (  stake' + pledge' * a0\n                    * ( stake' - pledge' * (z0 - stake') \u00f7 z0 )\n                    \u00f7 z0\n                  )\n    reward\u2115 = posPart (floor reward\u211a)\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:mkApparentPerformance","title":"The mkApparentPerformance Function","text":"<p>This section defines the <code>mkApparentPerformance</code> function, which is used for computing a Reward Update; it computes the apparent performance of a stake pool.  Relevant quantities are the following:</p> <ul> <li> <p><code>stake</code>: Relative active stake of the pool.</p> </li> <li> <p><code>poolBlocks</code>: Number of blocks that the pool added to the chain in the last epoch.</p> </li> <li> <p><code>totalBlocks</code>: Total number of blocks added in the last epoch.</p> </li> </ul> <pre>mkApparentPerformance : UnitInterval \u2192 \u2115 \u2192 \u2115 \u2192 \u211a\nmkApparentPerformance stake poolBlocks totalBlocks = ratioBlocks \u00f7\u2080 (fromUnitInterval stake)\n  where\n</pre> <pre>    instance\n      nonZero-totalBlocks : NonZero (1 \u2294 totalBlocks)\n      nonZero-totalBlocks = nonZero-max-1 totalBlocks\n\n    ratioBlocks : .\u2983 _ : NonZero (1 \u2294 totalBlocks) \u2984 \u2192 \u211a\n</pre> <pre>    ratioBlocks = (pos poolBlocks) / (1 \u2294 totalBlocks)\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:rewardOwners-and-rewardMember","title":"The rewardOwners and rewardMember Functions","text":"<p>This subsection defines the functions <code>rewardOwners</code> and <code>rewardMember</code>.  Their purpose is to divide the reward for one pool between pool owners and individual delegators by taking into account a fixed pool cost, a relative pool margin, and the stake of each member.  The rewards will be distributed as follows:</p> <ul> <li> <p><code>rewardOwners</code>: These funds will go to the    <code>rewardAccount</code> specified in the pool registration certificate.</p> </li> <li> <p><code>rewardMember</code>: These funds will go to the reward accounts of the individual delegators.</p> </li> </ul> <p>Relevant quantities for these functions are the following:</p> <ul> <li> <p><code>rewards</code>: Rewards paid out to this pool.</p> </li> <li> <p><code>poolParams</code>: Pool parameters, such as cost and margin.</p> </li> <li> <p><code>ownerStake</code>: Stake of the pool owners relative to the total amount of Ada.</p> </li> <li> <p><code>memberStake</code>: Stake of the pool member relative to the total amount of Ada.</p> </li> <li> <p><code>stake</code>: Stake of the whole pool relative to the total amount of Ada.</p> </li> </ul> <pre>rewardOwners : Coin \u2192 StakePoolParams \u2192 UnitInterval \u2192 UnitInterval \u2192 Coin\nrewardOwners rewards poolParams ownerStake stake = if rewards \u2264 cost\n  then rewards\n  else cost + posPart (floor (\n        (from\u2115 rewards - from\u2115 cost) * (margin + (1 - margin) * ratioStake)))\n  where\n    ratioStake  = fromUnitInterval ownerStake \u00f7\u2080 fromUnitInterval stake\n    cost        = poolParams .StakePoolParams.cost\n    margin      = fromUnitInterval (poolParams .StakePoolParams.margin)\n\nrewardMember : Coin \u2192 StakePoolParams \u2192 UnitInterval \u2192 UnitInterval \u2192 Coin\nrewardMember rewards poolParams memberStake stake = if rewards \u2264 cost\n  then 0\n  else posPart (floor (\n         (from\u2115 rewards - from\u2115 cost) * ((1 - margin) * ratioStake)))\n  where\n    ratioStake  = fromUnitInterval memberStake \u00f7\u2080 fromUnitInterval stake\n    cost        = poolParams .StakePoolParams.cost\n    margin      = fromUnitInterval (poolParams .StakePoolParams.margin)\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:rewardOnePool","title":"The rewardOnePool Function","text":"<p>This subsection defines the function <code>rewardOnePool</code> which calculates the rewards given out to each member of a given pool. Relevant quantities are:</p> <ul> <li> <p><code>rewardPot</code>: Total rewards to be paid out for this   epoch.</p> </li> <li> <p><code>n</code>: Number of blocks produced by the pool in the last   epoch.</p> </li> <li> <p><code>N</code>: Expectation value of the number of blocks to be   produced by the pool.</p> </li> <li> <p><code>stakeDistr</code>: Distribution of stake, as mapping from   <code>Credential</code> to <code>Coin</code>.</p> </li> <li> <p><code>\u03c3</code>: Total relative stake controlled by the pool.</p> </li> <li> <p><code>\u03c3a</code>: Total active relative stake controlled by the   pool, used for selecting block producers.</p> </li> <li> <p><code>tot</code>: Total amount of Ada in circulation, for   computing the relative stake.</p> </li> <li> <p><code>mkRelativeStake</code>: Compute stake relative to the total   amount in circulation.</p> </li> <li> <p><code>ownerStake</code>: Total amount of stake controlled by the   stake pool operator and owners.</p> </li> <li> <p><code>maxP</code>: Maximum rewards the pool can claim if the   pledge is met, and zero otherwise.</p> </li> <li> <p><code>poolReward</code>: Actual rewards to be paid out to this   pool.</p> </li> </ul> <pre>rewardOnePool :  PParams \u2192 Coin \u2192 \u2115 \u2192 \u2115 \u2192 StakePoolParams\n                 \u2192 Stake \u2192 UnitInterval \u2192 UnitInterval \u2192 Coin \u2192 Stake\n\nrewardOnePool pp rewardPot n N poolParams stakeDistr \u03c3 \u03c3a tot = memberRewards \u222a\u207a ownersRewards\n  where\n  mkRelativeStake : Coin \u2192 UnitInterval\n  mkRelativeStake = \u03bb coin \u2192 clamp (coin /\u2080 tot)\n\n  owners : \u2119 Credential\n  owners = map\u02e2 KeyHashObj (poolParams .StakePoolParams.owners)\n\n  ownerStake pledge maxP poolReward : Coin\n  ownerStake  = \u2211[ c \u2190 stakeDistr \u2223 owners ] c\n  pledge      = poolParams .StakePoolParams.pledge\n  maxP        =  if pledge \u2264 ownerStake\n                 then maxPool pp rewardPot \u03c3 (mkRelativeStake pledge)\n                 else 0\n  poolReward  = posPart $ floor $ (mkApparentPerformance \u03c3a n N) * from\u2115 maxP\n\n  stakeMap[_] :  (Coin \u2192 StakePoolParams \u2192 UnitInterval \u2192 UnitInterval \u2192 Coin)\n                 \u2192 Coin \u2192 UnitInterval \u2192 Coin\n  stakeMap[ f ] = (f poolReward poolParams) \u2218 mkRelativeStake\n\n  memberRewards : Stake\n  memberRewards = mapValues (\u03bb coin \u2192 stakeMap[ rewardMember ] coin \u03c3)\n                            (stakeDistr \u2223 owners \u1d9c)\n\n  ownersRewards : Stake\n  ownersRewards =  \u2774 poolParams .StakePoolParams.rewardAccount\n                   , stakeMap[ rewardOwners ] ownerStake \u03c3 \u2775\u1d50\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#filtering-the-stake-distribution-to-one-stake-pool","title":"Filtering the Stake Distribution to One Stake Pool","text":"<p>This section defines the <code>poolStake</code> function which filters the stake distribution to one stake pool. Relevant quantities are:</p> <ul> <li> <p><code>hk</code>: <code>KeyHash</code> of the stake pool to be   filtered by.</p> </li> <li> <p><code>delegs</code>: Mapping from <code>Credentials</code> to   stake pool that they delegate to.</p> </li> <li> <p><code>stake</code>: Distribution of stake for all   <code>Credentials</code>.</p> </li> </ul> <pre>poolStake  : KeyHash \u2192 StakeDelegs \u2192 Stake \u2192 Stake\npoolStake hk delegs stake = stake \u2223 dom (delegs \u2223^ \u2774 hk \u2775)\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:computing-a-reward-update","title":"Computing a Reward Update","text":"<p>This section defines the <code>reward</code> function which applies <code>rewardOnePool</code> to each registered stake pool. Relevant quantities are the following:</p> <ul> <li> <p><code>uncurry\u1d50</code>: Helper function to rearrange a nested mapping.</p> </li> <li> <p><code>blocks</code>: Number of blocks produced by pools in the last epoch, as    a mapping from pool <code>KeyHash</code> to number.</p> </li> <li> <p><code>poolParams</code>: Parameters of all known stake pools.</p> </li> <li> <p><code>stake</code>: Distribution of stake, as mapping from    <code>Credential</code> to <code>Coin</code>.</p> </li> <li> <p><code>delegs</code>: Mapping from <code>Credentials</code> to stake pool    that they delegate to.</p> </li> <li> <p><code>total</code>: Total stake \\(=\\) amount of Ada in circulation, for    computing the relative stake.</p> </li> <li> <p><code>active</code>: Active stake \\(=\\) amount of Ada that was used for    selecting block producers.</p> </li> <li> <p><code>\u03a3_/total</code>: Sum of stake divided by total stake.</p> </li> <li> <p><code>\u03a3_/active</code>: Sum of stake divided by active stake.</p> </li> <li> <p><code>N</code>: Total number of blocks produced in the last epoch.</p> </li> <li> <p><code>pdata</code>: Data needed to compute rewards for each pool.</p> </li> </ul> <pre>BlocksMade : Type\nBlocksMade = KeyHash \u21c0 \u2115\n\nuncurry\u1d50 :\n</pre> <pre>  \u2200 {A B C : Type} \u2983 _ : DecEq A \u2984 \u2983 _ : DecEq B \u2984 \u2192\n</pre> <pre>  A \u21c0 (B \u21c0 C) \u2192 (A \u00d7 B) \u21c0 C\n</pre> <pre>uncurry\u1d50 {A} {B} {C} abc = mapFromPartialFun lookup' domain'\n  where\n    lookup' : (A \u00d7 B) \u2192 Maybe C\n    lookup' (a , b) = lookup\u1d50? abc a &gt;&gt;= (\u03bb bc \u2192 lookup\u1d50? bc b)\n\n    join\u02e2 : \u2200 {X} \u2192 \u2119 (\u2119 X) \u2192 \u2119 X\n    join\u02e2 = concatMap\u02e2 id\n\n    domain' : \u2119 (A \u00d7 B)\n    domain' = join\u02e2 (range (mapWithKey (\u03bb a bc \u2192 range (mapWithKey (\u03bb b _ \u2192 (a , b)) bc)) abc))\n</pre> <pre>reward :  PParams \u2192 BlocksMade \u2192 Coin \u2192 Pools \u2192 Stake \u2192 StakeDelegs \u2192 Coin \u2192 Stake\nreward pp blocks rewardPot pools stake delegs total = rewards\n  where\n    active      = \u2211[ c \u2190 stake ] c\n    \u03a3_/total    = \u03bb st \u2192 clamp ((\u2211[ c \u2190 st ] c) /\u2080 total)\n    \u03a3_/active   = \u03bb st \u2192 clamp ((\u2211[ c \u2190 st ] c) /\u2080 active)\n    N           = \u2211[ m \u2190 blocks ] m\n    mkPoolData  = \u03bb hk p \u2192 map  (\u03bb n \u2192 (n , p , poolStake hk delegs stake))\n                                (lookup\u1d50? blocks hk)\n    pdata       = mapMaybeWithKey\u1d50 mkPoolData pools\n\n    f : \u2115 \u00d7 StakePoolParams \u00d7 Stake \u2192 Stake\n    f = (\u03bb (n , p , s) \u2192 rewardOnePool pp rewardPot n N p s (\u03a3 s /total) (\u03a3 s /active) total)\n\n    results : (KeyHash \u00d7 Credential) \u21c0 Coin\n    results =  uncurry\u1d50 (mapValues f pdata)\n    rewards  = aggregateBy (map\u02e2 (\u03bb (kh , cred) \u2192 (kh , cred) , cred) (dom results)) results\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:reward-update","title":"Reward Update","text":"<p>This section defines the <code>RewardUpdate</code> type, which records the net flow of Ada due to paying out rewards after an epoch. The update consists of four net flows.</p> <ul> <li> <p><code>\u0394t</code>: The change to the treasury. This will be a positive value.</p> </li> <li> <p><code>\u0394r</code>: The change to the reserves. We typically expect this to be a negative value.</p> </li> <li> <p><code>\u0394f</code>: The change to the fee pot. This will be a negative value.</p> </li> <li> <p><code>rs</code>: The map of new individual rewards, to be added to the existing rewards.</p> </li> </ul> <p>We require these net flows to satisfy certain constraints that are also stored in the <code>RewardUpdate</code> data type.  Specifically, <code>flowConservation</code> asserts that all four net flows add up to zero.  We also state the directions of <code>\u0394t</code> and <code>\u0394f</code>.</p> <pre>record RewardUpdate : Set where\n  field\n    \u0394t \u0394r \u0394f          : \u2124\n    rs                : Stake\n    flowConservation  : \u0394t + \u0394r + \u0394f + pos (\u2211[ c \u2190 rs ] c) \u2261 0\n    \u0394t-nonnegative    : 0 \u2264 \u0394t\n    \u0394f-nonpositive    : \u0394f \u2264 0\n</pre> <p>The function <code>createRUpd</code> calculates the <code>RewardUpdate</code>, but requires the definition of the type <code>EpochState</code>, so we have to defer the definition of this function until the Epoch module.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:diagram-rewards","title":"Diagram: Preservation of Funds and Rewards","text":"<p>The flowchart in this section illustrates the potential flows of funds through the entire system that can happen during one transition step as described in this document.</p> <p>Exception. Withdrawals from the \u201cTreasury\u201d are not shown in the diagram; they can move funds into \u201cReward accounts.\u201d</p> <p>Potential flows of funds during one transition step</p> <p> </p> <p>Value flows between accounting pots, but the total amount of value in the system remains constant.  In particular, the red subgraph represents the inputs and outputs to the <code>rewardPot</code>, a temporary variable used during the reward update calculation in the function <code>createRUpd</code>.  Each red arrow corresponds to one field of the <code>RewardUpdate</code> data type.  The blue arrows represent the flow of funds after they have passed through the <code>rewardPot</code>.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:stake-distribution-calculation","title":"Stake Distribution Calculation","text":"<p>This section defines the calculation of the stake distribution for the purpose of calculating rewards.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#definitions-of-the-snapshot-type","title":"Definitions of the Snapshot type","text":"<p>This subsection defines the <code>Snapshot</code> type which represents a stake distribution snapshot.  Such a snapshot contains the essential data needed to compute rewards.</p> <ul> <li> <p><code>stake</code> A stake distribution, that is a mapping from stake credentials    to the active stake that they own in coins.</p> </li> <li> <p><code>delegations</code>: A delegation map, that is a mapping from stake    credentials to the stake pools that they delegate to.</p> </li> <li> <p><code>pools</code>: A mapping that stores the pool parameters of each stake pool.</p> </li> </ul> <pre>record Snapshot : Set where\n  field\n    stake        : Stake\n    delegations  : StakeDelegs\n    pools        : Pools\n</pre> <pre>instance\n  HasStake-Snapshot : HasStake Snapshot\n  HasStake-Snapshot .StakeOf = Snapshot.stake\n\n  HasStakeDelegs-Snapshot : HasStakeDelegs Snapshot\n  HasStakeDelegs-Snapshot .StakeDelegsOf = Snapshot.delegations\n\n  HasPools-Snapshot : HasPools Snapshot\n  HasPools-Snapshot .PoolsOf = Snapshot.pools\n\n  unquoteDecl HasCast-Snapshot =\n    derive-HasCast [ (quote Snapshot , HasCast-Snapshot) ]\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#functions-for-computing-stake-distributions","title":"Functions for Computing Stake Distributions","text":"<p>This section defines the calculation of the stake distribution from the data contained in a ledger state.  Here,</p> <ul> <li> <p><code>utxoBalance</code> computes the coin balance of all those    UTxO with a given stake <code>Credential</code>.</p> </li> <li> <p><code>activeDelegs</code> represents the active stake    <code>Credentials</code>, i.e., those that delegate to an existing    pool and that have a registered reward account.</p> </li> <li> <p><code>activeRewards</code> is a mapping from active stake    <code>Credentials</code> to the balance of their reward account.</p> </li> <li> <p><code>activeStake</code> stores the stake for each active    <code>Credential</code>, i.e., the sum of coins from the UTxO set    plus the reward account balance.</p> </li> </ul> <pre>private\n  getStakeCred : TxOut \u2192 Maybe Credential\n  getStakeCred (a , _ , _ , _) = stakeCred a\n\nopaque\n</pre> <pre>  stakeDistr : UTxO \u2192 DState \u2192 PState \u2192 Snapshot\n  stakeDistr utxo dState pState = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Rewards.html#22254}{\\htmlId{21827}{\\htmlClass{Function}{\\text{activeStake}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Certs.html#2193}{\\htmlId{21841}{\\htmlClass{Field}{\\text{StakeDelegsOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Rewards.html#21809}{\\htmlId{21855}{\\htmlClass{Bound}{\\text{dState}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Rewards.html#21886}{\\htmlId{21864}{\\htmlClass{Function}{\\text{pools}}}}\\, \\end{pmatrix}$\n    where\n    pools : Pools\n    pools = PoolsOf pState\n\n    utxoBalance : Credential \u2192 Coin\n    utxoBalance = \u03bb cred \u2192 cbalance (utxo \u2223^' \u03bb txout \u2192 getStakeCred txout \u2261 just cred)\n\n    activeDelegs : StakeDelegs\n    activeDelegs = (StakeDelegsOf dState \u2223 dom (RewardsOf dState)) \u2223^ dom pools\n\n    activeRewards : Rewards\n    activeRewards = RewardsOf dState \u2223 dom activeDelegs\n\n    activeStake : Stake\n    activeStake = mapWithKey (\u03bb c rewardBalance \u2192 utxoBalance c + rewardBalance) activeRewards\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:timing-of-rewards-payout","title":"Timing of Rewards Payout","text":""},{"location":"Ledger.Conway.Specification.Rewards.html#sec:rewards-calculation-timeline","title":"Rewards Calculation Timeline","text":"<p>As described in the Rewards Motivation section, the probability of producing a block depends on the stake delegated to the block producer.  However, the stake distribution changes over time, as funds are transferred between parties.  This raises the question: What is the point in time from which we take the stake distribution?  Right at the moment of producing a block?  Some time in the past?  How do we deal with the fact that the blockchain is only eventually consistent (i.e., blocks can be rolled back before a stable consensus on the chain is formed)?</p> <p>On Cardano, the answer to these questions is to group time into epochs.  An epoch is long enough such that at the beginning of a new epoch, the beginning of the previous epoch has become stable.  An epoch is also long enough for human users to react to parameter changes, such as stake pool costs or performance.  But an epoch is also short enough so that changes to the stake distribution will be reflected in block production within a reasonable time frame.</p> <p>The rewards for the blocks produced during a given epoch \\(e_i\\) involve the two epochs surrounding it.  In particular, the stake distribution will come from the previous epoch and the rewards will be calculated in the following epoch.  At each epoch boundary, one snapshot of the stake distribution is taken; changes to the stake distribution within an epoch are not considered until the next snapshot is taken. More concretely:</p> <ol> <li> <p>A stake distribution snapshot is taken at the begining of epoch \\(e_{i-1}\\).</p> </li> <li> <p>The randomness for leader election is fixed during epoch \\(e_{i-1}\\)</p> </li> <li> <p>Epoch \\(e_{i}\\) begins, blocks are produced using the snapshot taken at (A).</p> </li> <li> <p>Epoch \\(e_{i}\\) ends.  A snapshot is taken of the stake pool performance during     epoch \\(e_{i}\\). A snapshot is also taken of the fee pot.</p> </li> <li> <p>The snapshots from (D) are stable and the reward calculation can begin.</p> </li> <li> <p>The reward calculation is finished and an update to the ledger state is ready to     be applied.</p> </li> <li> <p>Rewards are given out.</p> </li> </ol> <p>Timeline of the rewards calculation</p> <p>The snapshot taken at (A) is labeled \u201cmark\u201d during epoch \\(e_{i-1}\\), \u201cset\u201d during epoch \\(e_i\\) and \u201cgo\u201d during epoch \\(e_{i+1}\\).  At (G) the snapshot taken at (A) is no longer needed and will be discarded.</p> <p> </p> <p>N.B.  Between time D and E we are concerned with chain growth and stability. Therefore this duration can be stated as 2k blocks (to state it in slots requires details about the particular version of the Ouroboros protocol). The duration between F and G is also 2k blocks.  Between E and F a single honest block is enough to ensure a random nonce.</p> <p>In order to specify this logic, we store the last three snapshots of the stake distributions.  The mnemonic \u201cmark, set, go\u201d will be used to keep track of the snapshots, where the label \u201cmark\u201d refers to the most recent snapshot, and \u201cgo\u201d refers to the snapshot that is ready to be used in the reward calculation.  Blocks will be produced using the snapshot labeled \u201cset\u201d, whereas rewards are computed from the snapshot labeled \u201cgo\u201d.</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:illustration-reward-cycle","title":"Example Illustration of the Reward Cycle","text":"<p>For better understanding, here an example of the logic described in the previous section.</p> <p>1.00,0.50,0.00 0.65,0.00,0.00 0.00,0.50,0.00 0.00,0.95,0.00 0.00,0.00,0.90 0.00,0.60,0.90</p> <p>Bob registers his stake pool in epoch \\(e_1\\). Alice delegates to Bob\u2019s stake pool in epoch \\(e_1\\). Just before the end of epoch \\(e_1\\), Bob submits a stake pool re-registration, changing his pool parameters. The change in parameters is not immediate, as shown by the curved arrow around the epoch boundary.</p> <p>A snapshot is taken on the \\(e_1\\)/\\(e_2\\) boundary. It is labeled \u201cmark\u201d initially. This snapshot includes Alice\u2019s delegation to Bob\u2019s pool, and Bob\u2019s pool parameters and listed in the initial pool registration certificate.</p> <p>If Alice changes her delegation choice any time during epoch \\(e_2\\), she will never be effected by Bob\u2019s change of parameters.</p> <p>A new snapshot is taken on the \\(e_2\\)/\\(e_3\\) boundary. The previous (darker blue) snapshot is now labeled \u201cset\u201d, and the new one labeled \u201cmark\u201d. The \u201cset\u201d snapshot is used for leader election in epoch \\(e_3\\).</p> <p>On the \\(e_3\\)/\\(e_4\\) boundary, the darker blue snapshot is labeled \u201cgo\u201d and the lighter blue snapshot is labeled \u201cset\u201d. Bob\u2019s stake pool performance during epoch \\(e_3\\) (he produced 4 blocks) will be used with the darker blue snapshot for the rewards which will be handed out at the beginning of epoch \\(e_5\\).</p>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:stake-distribution-snapshots","title":"Stake Distribution Snapshots","text":"<p>This section defines the SNAP transition rule for stake distribution snapshots, including the type <code>Snapshots</code> that contains the data that needs to be saved at the end of an epoch.  This relevant data are:</p> <ul> <li> <p><code>mark</code>, <code>set</code>, <code>go</code>: Three stake    distribution snapshots as explained in the Rewards Calculation Timeline    section.</p> </li> <li> <p><code>feeSS</code>: stores the fees which are added to the reward pot    during the next reward update calculation, which is then subtracted    from the fee pot on the epoch boundary.</p> </li> </ul> <pre>record Snapshots : Set where\n  field\n    mark set go  : Snapshot\n    feeSS        : Fees\n</pre> <pre>record HasSnapshots {a} (A : Type a) : Type a where\n  field SnapshotsOf : A \u2192 Snapshots\nopen HasSnapshots \u2983...\u2984 public\n\ninstance\n  HasFees-Snapshots : HasFees Snapshots\n  HasFees-Snapshots .FeesOf = Snapshots.feeSS\n\n  unquoteDecl HasCast-Snapshots =\n    derive-HasCast [ (quote Snapshots , HasCast-Snapshots) ]\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#sec:snap-transition-system","title":"The SNAP Transition System","text":"<p>The snapshot transition rule has no preconditions and results in the following state change:</p> <ul> <li> <p>The oldest snapshot is replaced with the penultimate one.</p> </li> <li> <p>The penultimate snapshot is replaced with the newest one.</p> </li> <li> <p>The newest snapshot is replaced with one just calculated.</p> </li> <li> <p>The current fees pot is stored in <code>feeSS</code>.  Note that this value will    not change during the epoch, unlike the <code>fees</code> value in the UTxO state.</p> </li> </ul> <pre>private variable\n  ls : LState\n  mark set go : Snapshot\n  feeSS : Coin\n</pre> <pre>data _\u22a2_\u21c0\u2987_,SNAP\u2988_ : LState \u2192 Snapshots \u2192 \u22a4 \u2192 Snapshots \u2192 Type where\n  SNAP :\n    let stake = stakeDistr (UTxOOf ls) (DStateOf ls) (PStateOf ls) in\n    ls \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Rewards.html#28869}{\\htmlId{29083}{\\htmlClass{Generalizable}{\\text{mark}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Rewards.html#28874}{\\htmlId{29090}{\\htmlClass{Generalizable}{\\text{set}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Rewards.html#28878}{\\htmlId{29096}{\\htmlClass{Generalizable}{\\text{go}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Rewards.html#28894}{\\htmlId{29101}{\\htmlClass{Generalizable}{\\text{feeSS}}}}\\, \\end{pmatrix}$ \u21c0\u2987 tt ,SNAP\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Rewards.html#29010}{\\htmlId{29124}{\\htmlClass{Bound}{\\text{stake}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Rewards.html#28869}{\\htmlId{29132}{\\htmlClass{Generalizable}{\\text{mark}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Rewards.html#28874}{\\htmlId{29139}{\\htmlClass{Generalizable}{\\text{set}}}}\\, \\\\ \\,\\href{Ledger.Prelude.Base.html#765}{\\htmlId{29145}{\\htmlClass{Field}{\\text{FeesOf}}}}\\, \\,\\href{Ledger.Conway.Specification.Rewards.html#28855}{\\htmlId{29152}{\\htmlClass{Generalizable}{\\text{ls}}}}\\, \\end{pmatrix}$\n</pre>"},{"location":"Ledger.Conway.Specification.Rewards.html#references","title":"References","text":"<p>[Team18]  IOHK Formal Methods Team. Design Specification for Delegation and Incentives in Cardano, IOHK Deliverable SL-D1. 2018.</p>"},{"location":"Ledger.Conway.Specification.Script.Base.html","title":"Base","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Algebra.Morphism\nopen import Data.List.Relation.Unary.All using (All; []; _\u2237_; all?; uncons)\nopen import Data.List.Relation.Unary.Any\nopen import Data.Nat.Properties using (+-0-commutativeMonoid; suc-injective)\n\nopen import stdlib.Data.List.Relation.Unary.MOf\n\n\nopen import Ledger.Prelude hiding (All; Any; all?; any?; _\u2237\u02b3_; uncons; _\u2286_)\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\n\nmodule Ledger.Conway.Specification.Script.Base\n  (cs : _) (open CryptoStructure cs)\n  (es : _) (open EpochStructure es)\n  where\n\nrecord P1ScriptStructure : Type\u2081 where\n  field P1Script : Type\n        validP1Script : \u2119 KeyHash \u2192 Maybe Slot \u00d7 Maybe Slot \u2192 P1Script \u2192 Type\n        \u2983 Dec-validP1Script \u2984 : validP1Script \u2047\u00b3\n        \u2983 Hashable-P1Script \u2984 : Hashable P1Script ScriptHash\n        \u2983 DecEq-P1Script    \u2984 : DecEq P1Script\n\nrecord PlutusStructure : Type\u2081 where\n  field Data\u02b0 : HashableSet\n        Language PlutusScript CostModel Prices LangDepView ExUnits : Type\n        PlutusV1 PlutusV2 PlutusV3   : Language\n        \u2983 ExUnit-CommutativeMonoid \u2984 : CommutativeMonoid 0\u2113 0\u2113 ExUnits\n        \u2983 Hashable-PlutusScript    \u2984 : Hashable PlutusScript ScriptHash\n        \u2983 DecEq-Language           \u2984 : DecEq Language\n        \u2983 DecEq-CostModel          \u2984 : DecEq CostModel\n        \u2983 DecEq-LangDepView        \u2984 : DecEq LangDepView\n        \u2983 Show-CostModel           \u2984 : Show CostModel\n\n  field  _\u2265\u1d49_              : ExUnits \u2192 ExUnits \u2192 Type\n         \u2983 DecEq-ExUnits \u2984 : DecEq ExUnits\n         \u2983 DecEQ-Prices  \u2984 : DecEq Prices\n         \u2983 Show-ExUnits  \u2984 : Show ExUnits\n         \u2983 Show-Prices   \u2984 : Show Prices\n\n  open HashableSet Data\u02b0 renaming (T to Data; THash to DataHash) public\n\n  -- Type aliases for Data\n  Datum    = Data\n  Redeemer = Data\n\n  field validPlutusScript : CostModel \u2192 List Data \u2192 ExUnits \u2192 PlutusScript \u2192 Type\n        \u2983 Dec-validPlutusScript \u2984 : \u2200 {x} \u2192 (validPlutusScript x \u2047\u00b3)\n        language : PlutusScript \u2192 Language\n       -- toData : \u2200 {A : Type} \u2192 A \u2192 Data\n\nrecord ScriptStructure : Type\u2081 where\n\n  field p1s : P1ScriptStructure\n\n  open P1ScriptStructure p1s public\n\n  field hashRespectsUnion :\n          {A B Hash : Type} \u2192 Hashable A Hash \u2192 Hashable B Hash \u2192 Hashable (A \u228e B) Hash\n\n  field ps : PlutusStructure\n  open PlutusStructure ps public\n    renaming ( PlutusScript       to P2Script\n             ; validPlutusScript  to validP2Script\n             )\n\n  Script = P1Script \u228e P2Script\n\n  open import Data.Empty\n  open import Agda.Builtin.Equality\n  open import Relation.Binary.PropositionalEquality\n\n  instance\n    Hashable-Script : Hashable Script ScriptHash\n    Hashable-Script = hashRespectsUnion Hashable-P1Script Hashable-PlutusScript\n\n  isP1Script : Script \u2192 Type\n  isP1Script = T \u2218 is-just \u2218 isInj\u2081\n\n  isP1Script? : \u2200 {s} \u2192 isP1Script s \u2047\n  isP1Script? {inj\u2081 x} .dec = yes tt\n  isP1Script? {inj\u2082 y} .dec = no \u03bb ()\n\n  isNativeScript : Script \u2192 Type\n  isNativeScript = isP1Script\n\n  toP1Script : Script \u2192 Maybe P1Script\n  toP1Script = isInj\u2081\n\n  isP2Script : Script \u2192 Type\n  isP2Script = T \u2218 is-just \u2218 isInj\u2082\n\n  isP2Script? : \u2200 {s} \u2192 isP2Script s \u2047\n  isP2Script? {inj\u2081 x} .dec = no \u03bb ()\n  isP2Script? {inj\u2082 y} .dec = yes tt\n\n  toP2Script : Script \u2192 Maybe P2Script\n  toP2Script = isInj\u2082\n</pre>"},{"location":"Ledger.Conway.Specification.Script.ScriptPurpose.html","title":"Script Purpose","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Script.ScriptPurpose (txs : TransactionStructure) where\n\nopen import Ledger.Prelude\nopen TransactionStructure txs\nopen import Ledger.Conway.Specification.Certs govStructure\n</pre> <pre>data ScriptPurpose : Type where\n  Cert     : DCert        \u2192 ScriptPurpose\n  Rwrd     : RwdAddr      \u2192 ScriptPurpose\n  Mint     : ScriptHash   \u2192 ScriptPurpose\n  Spend    : TxIn         \u2192 ScriptPurpose\n  Vote     : GovVoter     \u2192 ScriptPurpose\n  Propose  : GovProposal  \u2192 ScriptPurpose\n\nrecord TxInfo : Type where\n  field realizedInputs : UTxO\n        txOuts         : Ix \u21c0 TxOut\n        fee            : Value\n        mint           : Value\n        txCerts        : List DCert\n        txWithdrawals  : Withdrawals\n        txVldt         : Maybe Slot \u00d7 Maybe Slot\n        vkKey          : \u2119 KeyHash\n        txdats         : \u2119 Datum\n        txId           : TxId\n</pre>"},{"location":"Ledger.Conway.Specification.Script.Timelock.html","title":"Timelock Scripts","text":"<p>This section defines <code>Timelock</code> scripts, which verify the presence of keys and whether a transaction happens in a certain slot interval.  The scripts are executed as part of the regular witnessing.</p> <pre>{-# OPTIONS --safe #-}\n\nopen import Algebra.Morphism\nopen import Data.List.Relation.Unary.All using (All; []; _\u2237_; all?; uncons)\nopen import Data.List.Relation.Unary.Any\nopen import Data.Nat.Properties using (+-0-commutativeMonoid; suc-injective)\n\nopen import stdlib.Data.List.Relation.Unary.MOf\n\nopen import Tactic.Derive.DecEq\nopen import Tactic.Inline\n\nopen import Ledger.Prelude hiding (All; Any; all?; any?; _\u2237\u02b3_; uncons; _\u2286_)\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\n\nmodule Ledger.Conway.Specification.Script.Timelock\n  (cs : _) (open CryptoStructure cs)\n  (es : _) (open EpochStructure es)\n  where\n\nopen import Ledger.Prelude\n  hiding (All; Any; all?; any?; _\u2237\u02b3_; uncons; _\u2286_)\n\nopen import Data.List.Relation.Unary.All\n  using (All; []; _\u2237_; all?; uncons)\nopen import Data.List.Relation.Unary.Any\n  using (Any; any?)\nopen import stdlib.Data.List.Relation.Unary.MOf\n</pre>"},{"location":"Ledger.Conway.Specification.Script.Timelock.html#sec:the-timelock-type","title":"The Timelock Type","text":"<pre>data Timelock : Type where\n  RequireAllOf       : List Timelock      \u2192 Timelock\n  RequireAnyOf       : List Timelock      \u2192 Timelock\n  RequireMOf         : \u2115 \u2192 List Timelock  \u2192 Timelock\n  RequireSig         : KeyHash            \u2192 Timelock\n  RequireTimeStart   : Slot               \u2192 Timelock\n  RequireTimeExpire  : Slot               \u2192 Timelock\n</pre> <pre>unquoteDecl DecEq-Timelock = derive-DecEq ((quote Timelock , DecEq-Timelock) \u2237 [])\n\nprivate variable\n  s : Timelock\n  ss ss' : List Timelock\n  m : \u2115\n  x : KeyHash\n  a l r : Slot\n\nopen import Data.List.Relation.Binary.Sublist.Propositional as S\nimport Data.Maybe.Relation.Unary.Any as M\n</pre>"},{"location":"Ledger.Conway.Specification.Script.Timelock.html#sec:the-evaltimelock-type","title":"The evalTimelock Type","text":"<pre>data evalTimelock (khs : \u2119 KeyHash) (I : Maybe Slot \u00d7 Maybe Slot) : Timelock \u2192 Type where\n  evalAll : All (evalTimelock khs I) ss \u2192 (evalTimelock khs I) (RequireAllOf ss)\n  evalAny : Any (evalTimelock khs I) ss \u2192 (evalTimelock khs I) (RequireAnyOf ss)\n  evalMOf : MOf m (evalTimelock khs I) ss \u2192 (evalTimelock khs I) (RequireMOf m ss)\n  evalSig : x \u2208 khs \u2192 (evalTimelock khs I) (RequireSig x)\n  evalTSt : M.Any (a \u2264_) (I .proj\u2081) \u2192 (evalTimelock khs I) (RequireTimeStart a)\n  evalTEx : M.Any (_\u2264 a) (I .proj\u2082) \u2192 (evalTimelock khs I) (RequireTimeExpire a)\n</pre> <pre>instance\n  Dec-evalTimelock : evalTimelock \u2047\u00b3\n  Dec-evalTimelock {khs} {I} {tl} .dec = go? tl\n    where mutual\n      go = evalTimelock khs I\n\n      -- ** inversion principles for `evalTimelock`\n      evalAll\u02d8 : \u2200 {ss} \u2192 go (RequireAllOf ss) \u2192 All go ss\n      evalAll\u02d8 (evalAll p) = p\n\n      evalAny\u02d8 : \u2200 {ss} \u2192 go (RequireAnyOf ss) \u2192 Any go ss\n      evalAny\u02d8 (evalAny p) = p\n\n      evalTSt\u02d8 : go (RequireTimeStart a) \u2192 M.Any (a \u2264_) (I .proj\u2081)\n      evalTSt\u02d8 (evalTSt p) = p\n\n      evalTEx\u02d8 : go (RequireTimeExpire a) \u2192 M.Any (_\u2264 a) (I .proj\u2082)\n      evalTEx\u02d8 (evalTEx p) = p\n\n      evalSig\u02d8 : go (RequireSig x) \u2192 x \u2208 khs\n      evalSig\u02d8 (evalSig p) = p\n\n      evalMOf\u02d8 : \u2200 {m xs}\n        \u2192 go (RequireMOf m xs)\n        \u2192 MOf m go xs\n      evalMOf\u02d8 (evalMOf p) = p\n\n      -- ** inlining recursive decision procedures to please the termination checker\n      MOf-go? : \u2200 m xs \u2192 Dec (MOf m go xs)\n      unquoteDef MOf-go? = inline MOf-go? (quoteTerm (MOf? go?))\n\n      all-go? : Decidable\u00b9 (All go)\n      unquoteDef all-go? = inline all-go? (quoteTerm (all? go?))\n\n      any-go? : Decidable\u00b9 (Any go)\n      unquoteDef any-go? = inline any-go? (quoteTerm (any? go?))\n\n      -- ** the actual decision procedure\n      go? : Decidable\u00b9 go\n      go? = \u03bb where\n        (RequireAllOf ss)     \u2192 mapDec evalAll evalAll\u02d8 (all-go? ss)\n        (RequireAnyOf ss)     \u2192 mapDec evalAny evalAny\u02d8 (any-go? ss)\n        (RequireSig x)        \u2192 mapDec evalSig evalSig\u02d8 dec\n        (RequireTimeStart a)  \u2192 mapDec evalTSt evalTSt\u02d8 dec\n        (RequireTimeExpire a) \u2192 mapDec evalTEx evalTEx\u02d8 dec\n        (RequireMOf m xs)     \u2192 mapDec evalMOf evalMOf\u02d8 (MOf-go? m xs)\n</pre>"},{"location":"Ledger.Conway.Specification.Script.Validation.html","title":"Script Validation","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Conway.Specification.Abstract\n\nmodule Ledger.Conway.Specification.Script.Validation\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs) (open indexOf indexOfImp)\n  where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Certs govStructure\n\n\nopen import Ledger.Conway.Specification.Abstract txs\nopen import Ledger.Conway.Specification.Script.ScriptPurpose txs\n\nrdptr : TxBody \u2192 ScriptPurpose \u2192 Maybe RdmrPtr\nrdptr txb = \u03bb where\n  (Cert h)     \u2192 map (Cert    ,_) $ indexOfDCert    h txCerts\n  (Rwrd h)     \u2192 map (Rewrd   ,_) $ indexOfRwdAddr  h txWithdrawals\n  (Mint h)     \u2192 map (Mint    ,_) $ indexOfPolicyId h (policies mint)\n  (Spend h)    \u2192 map (Spend   ,_) $ indexOfTxIn     h txIns\n  (Vote h)     \u2192 map (Vote    ,_) $ indexOfVote     h (map GovVote.voter txGovVotes)\n  (Propose h)  \u2192 map (Propose ,_) $ indexOfProposal h txGovProposals\n where open TxBody txb\n\nindexedRdmrs : Tx \u2192 ScriptPurpose \u2192 Maybe (Redeemer \u00d7 ExUnits)\nindexedRdmrs tx sp = maybe (\u03bb x \u2192 lookup\u1d50? txrdmrs x) nothing (rdptr body sp)\n  where open Tx tx; open TxWitnesses wits\n\ngetDatum : Tx \u2192 UTxO \u2192 ScriptPurpose \u2192 Maybe Datum\ngetDatum tx utxo (Spend txin) =\n  do (_ , _ , just d , _) \u2190 lookup\u1d50? utxo txin\n                          where\n                            (_ , _ , nothing , _) \u2192 nothing\n     case d of \u03bb where\n       (inj\u2081 d) \u2192 just d\n       (inj\u2082 h) \u2192 lookup\u1d50? m h\n     where\n       m = setToMap (map\u02e2 &lt; hash , id &gt; (TxWitnesses.txdats (Tx.wits tx)))\ngetDatum tx utxo _ = nothing\n</pre> <pre>txInfo : Language \u2192 PParams\n                  \u2192 UTxO\n                  \u2192 Tx\n                  \u2192 TxInfo\ntxInfo l pp utxo tx = record\n  { TxBody body\n  ; TxWitnesses wits\n  ; realizedInputs = utxo \u2223 txIns\n  ; fee = inject txFee\n  ; mint = mint\n  ; vkKey = reqSignerHashes\n  } where open Tx tx; open TxBody body\n\ncredsNeeded : UTxO \u2192 TxBody \u2192 \u2119 (ScriptPurpose \u00d7 Credential)\ncredsNeeded utxo txb\n  =  map\u02e2 (\u03bb (i , o)  \u2192 (Spend  i , payCred (proj\u2081 o))) ((utxo \u2223 (txIns \u222a collateralInputs)) \u02e2)\n  \u222a  map\u02e2 (\u03bb a        \u2192 (Rwrd   a , stake a)) (dom \u2223 txWithdrawals \u2223)\n  \u222a  mapPartial (\u03bb c  \u2192 (Cert   c ,_) &lt;$&gt; cwitness c) (fromList txCerts)\n  \u222a  map\u02e2 (\u03bb x        \u2192 (Mint   x , ScriptObj x)) (policies mint)\n  \u222a  mapPartial (\u03bb v \u2192 if isGovVoterCredential v then (\u03bb {c} \u2192 just (Vote v , c)) else nothing)\n                (fromList (map voter txGovVotes))\n  \u222a  mapPartial (\u03bb p \u2192 if p .policy then (\u03bb {sh} \u2192 just (Propose  p , ScriptObj sh)) else nothing)\n                (fromList txGovProposals)\n</pre> <p>&lt;!--</p> <pre>  where open TxBody txb; open GovVote; open RwdAddr; open GovProposal\n\n-- valContext : TxInfo \u2192 ScriptPurpose \u2192 Data\n-- valContext txinfo sp = toData (txinfo , sp)\n\ntxOutToDataHash : TxOut \u2192 Maybe DataHash\ntxOutToDataHash (_ , _ , d , _) = d &gt;&gt;= isInj\u2082\n\ntxOutToP2Script\n  : UTxO \u2192 Tx\n  \u2192 TxOut \u2192 Maybe P2Script\ntxOutToP2Script utxo tx (a , _) =\n  do sh \u2190 isScriptObj (payCred a)\n     s  \u2190 lookupScriptHash sh tx utxo\n     toP2Script s\n\nopaque\n  collectP2ScriptsWithContext\n    : PParams \u2192 Tx \u2192 UTxO\n    \u2192 List (P2Script \u00d7 List Data \u00d7 ExUnits \u00d7 CostModel)\n  collectP2ScriptsWithContext pp tx utxo\n    = setToList\n    $ mapPartial (\u03bb (sp , c) \u2192 if isScriptObj c\n                                then (\u03bb {sh} \u2192 toScriptInput sp sh)\n                                else nothing)\n    $ credsNeeded utxo (tx .Tx.body)\n    where\n      toScriptInput\n        : ScriptPurpose \u2192 ScriptHash\n        \u2192 Maybe (P2Script \u00d7 List Data \u00d7 ExUnits \u00d7 CostModel)\n      toScriptInput sp sh =\n        do s \u2190 lookupScriptHash sh tx utxo\n           p2s \u2190 toP2Script s\n           (rdmr , exunits) \u2190 indexedRdmrs tx sp\n           let data'     = maybe [_] [] (getDatum tx utxo sp) ++ rdmr \u2237 [ valContext (txInfo (language p2s) pp utxo tx) sp ]\n               costModel = PParams.costmdls pp\n           just (p2s , data' , exunits , costModel)\n\nevalP2Scripts : List (P2Script \u00d7 List Data \u00d7 ExUnits \u00d7 CostModel) \u2192 Bool\nevalP2Scripts = all (\u03bb (s , d , eu , cm) \u2192 runPLCScript cm s eu d)\n</pre>"},{"location":"Ledger.Conway.Specification.Script.html","title":"Script","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\n\nmodule Ledger.Conway.Specification.Script\n  (cs : _) (open CryptoStructure cs)\n  (es : _) (open EpochStructure es)\n  where\n\nopen import Ledger.Conway.Specification.Script.Base cs es public\nopen import Ledger.Conway.Specification.Script.Timelock cs es public\n</pre>"},{"location":"Ledger.Conway.Specification.TokenAlgebra.Base.html","title":"Token Algebras","text":"<p>Token algebras are used for multiple assets.</p> <pre>{-# OPTIONS --safe #-}\nopen import Prelude using (Type)\nmodule Ledger.Conway.Specification.TokenAlgebra.Base (\n</pre> <p>Abstract types</p> <pre>  PolicyId\n</pre> <pre>  : Type) where\nopen import Ledger.Prelude\n\nopen import Algebra              using (Monoid)\nopen import Algebra.Morphism     using (module MonoidMorphisms )\nopen import Data.Nat.Properties  using (+-0-monoid)\nopen import Relation.Binary      using (Rel)\nopen import Relation.Unary       using (Pred)\n\nMemoryEstimate : Set\nMemoryEstimate = \u2115\n</pre> <p>Derived types</p> <pre>record TokenAlgebra : Type\u2081 where\n  field\n    Value : Set\n    \u2983 Value-CommutativeMonoid \u2984 : CommutativeMonoid 0\u2113 0\u2113 Value\n</pre> <pre>  open Algebra.CommutativeMonoid (Conversion.toBundle Value-CommutativeMonoid) public\n    using (_\u2248_ ; \u03b5 ; monoid ; rawMonoid)\n    renaming (_\u2219_ to _+\u1d5b_)\n\n  open MonoidMorphisms (rawMonoid) (Monoid.rawMonoid +-0-monoid) public\n  field\n</pre> <pre>\n    coin                      : Value \u2192 Coin\n    inject                    : Coin \u2192 Value\n    policies                  : Value \u2192 \u2119 PolicyId\n    size                      : Value \u2192 MemoryEstimate\n    _\u2264\u1d57_                      : Value \u2192 Value \u2192 Type\n    coin\u2218inject\u2257id            : coin \u2218 inject \u2257 id\n    coinIsMonoidHomomorphism  : IsMonoidHomomorphism coin\n</pre> <pre>\n    \u2983 DecEq-Value \u2984 : DecEq Value\n    \u2983 Dec-\u2264\u1d57 \u2984      : _\u2264\u1d57_ \u2047\u00b2\n\n  instance\n    addValue : HasAdd Value\n    addValue = record { _+_ = _+\u1d5b_ }\n\n  coin-inject-lemma : \u2200 {val} {c} \u2192 coin (val + inject c) \u2261 coin val + c\n  coin-inject-lemma {val} {c} = begin\n    coin (val + inject c)         \u2261\u27e8 homo coinIsMonoidHomomorphism val (inject c) \u27e9\n    coin val + (coin \u2218 inject) c  \u2261\u27e8 cong (coin val +_) (coin\u2218inject\u2257id c) \u27e9\n    coin val + c                  \u220e\n    where\n    open \u2261-Reasoning\n    open MonoidMorphisms.IsMonoidHomomorphism\n</pre> <p>Helper functions</p> <pre>  sum\u1d5b : List Value \u2192 Value\n  sum\u1d5b [] = inject 0\n  sum\u1d5b (x \u2237 l) = x + sum\u1d5b l\n</pre>"},{"location":"Ledger.Conway.Specification.TokenAlgebra.Coin.html","title":"Coin","text":"<pre>{-# OPTIONS --safe #-}\nopen import Ledger.Prelude\n\nmodule Ledger.Conway.Specification.TokenAlgebra.Coin (X : Type) where\n\nopen import Algebra.Morphism.Construct.Identity\n  using (isMonoidHomomorphism)\n\nopen import Ledger.Conway.Specification.TokenAlgebra.Base X\n\nopen TokenAlgebra\n\nCoin-TokenAlgebra : TokenAlgebra\nCoin-TokenAlgebra = \u03bb where\n  .Value                      \u2192 Coin\n  .Value-CommutativeMonoid    \u2192 it\n    -- ^ Agda bug? Without this line, `coinIsMonoidHomomorphism` doesn't type check anymore\n  .coin                       \u2192 id\n  .inject                     \u2192 id\n  .policies                   \u2192 \u03bb _ \u2192 \u2205\n  .size                       \u2192 \u03bb x \u2192 1 -- there is only ada in this token algebra\n  ._\u2264\u1d57_                       \u2192 _\u2264_\n  .coin\u2218inject\u2257id             \u2192 \u03bb _ \u2192 refl\n  .coinIsMonoidHomomorphism   \u2192 isMonoidHomomorphism _ refl\n</pre>"},{"location":"Ledger.Conway.Specification.TokenAlgebra.ValueSet.html","title":"ValueSet","text":""},{"location":"Ledger.Conway.Specification.TokenAlgebra.ValueSet.html#sec:value-set","title":"Value Set","text":"<pre>\n{-# OPTIONS --safe --no-import-sorts #-}\n\nopen import Prelude using (Type)\n\nmodule Ledger.Conway.Specification.TokenAlgebra.ValueSet (PolicyId AssetName : Type) where\n\nopen import Ledger.Prelude                         hiding (lookup ; update ; isMagma ; isEquivalence) renaming (TotalMap to _\u21d2_)\nopen _\u21d2_\nopen import Ledger.Conway.Specification.TokenAlgebra.Base PolicyId using (TokenAlgebra)\n\nopen import Algebra                                using (Op\u2082 ; IsSemigroup ; IsMonoid ; IsMagma ; IsCommutativeMonoid)\nopen import Algebra.Morphism                       using (IsMonoidHomomorphism ; IsMagmaHomomorphism)\nopen import Data.Nat.Properties                    using (+-comm ; +-assoc ; +-identity\u02b3 ; +-0-commutativeMonoid)\nopen import Relation.Binary                        using (IsEquivalence)\nopen import Relation.Binary.Morphism               using (IsRelHomomorphism)\nopen import Relation.Binary.PropositionalEquality  using (module \u2261-Reasoning)\n\nimport Relation.Binary.PropositionalEquality as \u2261\nimport Relation.Binary.Core  as stdlib\n</pre>"},{"location":"Ledger.Conway.Specification.TokenAlgebra.ValueSet.html#derived-types","title":"Derived Types","text":"<p>(See Fig 3 of the Mary ledger specification.)</p> <ul> <li> <p><code>AssetName</code> is a byte string used to distinguish different   assets with the same <code>PolicyId</code>.</p> </li> <li> <p><code>AssetId</code> is a product type consisting of a   <code>PolicyId</code> and an <code>AssetName</code>.</p> </li> <li> <p><code>AdaId</code> is the Id for the asset Ada.</p> </li> <li> <p><code>Quantity</code> is the type of amounts of assets.</p> </li> </ul> <p>In the formal ledger specification <code>AssetId</code> is sometimes viewed as a direct sum type, the inhabitants of which belong to either <code>AdaIdType</code> or the product <code>PolicyId</code> <code>\u00d7</code> <code>AssetName</code>; if we were adhering to that point of view, then we would have defined <code>AssetId</code> = <code>AdaIdType</code> <code>\u228e</code> (<code>PolicyId</code> <code>\u00d7</code> <code>AssetName</code>).</p> <p>Finally, we define a record type with a single inhabitant with which we may wish to represent the type of Ada (rather than viewing Ada as just another asset).</p> <pre>record AdaIdType : Type where\n  instance constructor AdaId\n</pre>"},{"location":"Ledger.Conway.Specification.TokenAlgebra.ValueSet.html#value-monoid-definition","title":"Value Monoid Definition","text":"<p>An inhabitant of \u2018Value\u2018 is a map denoting a finite collection of quantities of assets.</p> <pre>open Algebra.CommutativeMonoid renaming (_\u2219_ to _\u22c6_) hiding (refl ; sym ; trans)\n\nAssetId  = PolicyId \u00d7 AssetName\nQuantity = \u2115\n</pre> <pre>module _\n</pre> <pre>  {X : \u2119 AssetId}\n  {\u22c1A : isMaximal X}\n  \u2983 DecEq-PolicyId  : DecEq PolicyId \u2984\n  \u2983 DecEq-AssetName : DecEq AssetName \u2984\n  \u2983 DecEq-Tot : DecEq (AssetId \u21d2 \u2115) \u2984\n  (Dec-lookup\u2264 : \u2200 {u v : AssetId \u21d2 \u2115}\n    \u2192 (\u2200 {a p q} \u2192 lookup u (a , p) \u2264 lookup v (a , q)) \u2047)\n</pre> <pre>  where\n  open \u2261-Reasoning\n  open FunTot X \u22c1A\n</pre> <pre>  _\u2295_ : Op\u2082 (AssetId \u21d2 Quantity)\n  u \u2295 v = Fun\u21d2TotalMap \u03bb aa \u2192 (lookup u) aa + (lookup v) aa\n\n  \u2295-lemma :  (u v : AssetId \u21d2 Quantity){aa : AssetId}\n             \u2192 lookup (u \u2295 v) aa \u2261 lookup u aa + lookup v aa\n  \u2295-lemma _ _ = lookup\u2218Fun\u21d2TotalMap-id\n\n  zeroFun : AssetId \u2192 Quantity\n  zeroFun = \u03bb _ \u2192 0\n\n  \u03b9 : AssetId \u21d2 Quantity\n  \u03b9 = Fun\u21d2TotalMap zeroFun\n\n  lookup\u03b9\u22610 :  \u2200{a} \u2192 lookup \u03b9 a \u2261 0\n  lookup\u03b9\u22610 = \u2208-rel\u21d2lookup-\u2261 \u03b9 (\u2208-map\u2032 \u22c1A)\n\n  _\u224b_ : stdlib.Rel (AssetId \u21d2 Quantity) 0\u2113\n  u \u224b v = \u2200{aa} \u2192 (lookup u) aa \u2261 (lookup v) aa\n\n  \u224b-isEquivalence : IsEquivalence {0\u2113} _\u224b_\n  \u224b-isEquivalence = record { refl = \u2261.refl ; sym = \u03bb x \u2192 \u2261.sym x ; trans = \u03bb x y \u2192 \u2261.trans x y }\n\n  \u2295-cong : Algebra.Congruent\u2082 _\u224b_ _\u2295_\n  \u2295-cong {x}{y}{u}{v} x\u224by u\u224bv {a} = begin\n    lookup (x \u2295 u) a         \u2261\u27e8 \u2295-lemma x u \u27e9\n    lookup x a + lookup u a  \u2261\u27e8 cong\u2082 _+_ x\u224by u\u224bv \u27e9\n    lookup y a + lookup v a  \u2261\u27e8 \u2261.sym (\u2295-lemma y v) \u27e9\n    lookup (y \u2295 v) a         \u220e\n\n  \u2295-comm : Algebra.Commutative _\u224b_ _\u2295_\n  \u2295-comm u v {aa} = begin\n    lookup (u \u2295 v) aa          \u2261\u27e8 \u2295-lemma u v \u27e9\n    lookup u aa + lookup v aa  \u2261\u27e8 +-comm (lookup u aa) (lookup v aa) \u27e9\n    lookup v aa + lookup u aa  \u2261\u27e8 \u2261.sym (\u2295-lemma v u) \u27e9\n    lookup (v \u2295 u) aa          \u220e\n\n  \u2295-assoc : Algebra.Associative _\u224b_ _\u2295_\n  \u2295-assoc x y z {a} = begin\n    lookup ((x \u2295 y) \u2295 z) a                  \u2261\u27e8 \u2295-lemma (x \u2295 y) z \u27e9\n    lookup (x \u2295 y) a + lookup z a           \u2261\u27e8 cong (_+ lookup z a) (\u2295-lemma x y) \u27e9\n    lookup x a + lookup y a + lookup z a    \u2261\u27e8 +-assoc (lookup x a) (lookup y a) (lookup z a) \u27e9\n    lookup x a + (lookup y a + lookup z a)  \u2261\u27e8 cong (lookup x a +_) (\u2261.sym (\u2295-lemma y z)) \u27e9\n    lookup x a + lookup (y \u2295 z) a           \u2261\u27e8 \u2261.sym (\u2295-lemma x (y \u2295 z)) \u27e9\n    lookup (x \u2295 (y \u2295 z)) a                  \u220e\n\n  \u03b9-identity : Algebra.Identity _\u224b_ \u03b9 _\u2295_\n  \u03b9-identity .proj\u2081 tm {aa} = begin\n    lookup (\u03b9 \u2295 tm) aa          \u2261\u27e8 \u2295-lemma \u03b9 tm \u27e9\n    lookup \u03b9 aa + lookup tm aa  \u2261\u27e8 cong (_+ lookup tm aa) lookup\u03b9\u22610 \u27e9\n    lookup tm aa                \u220e\n  \u03b9-identity .proj\u2082 tm {aa} = begin\n    lookup (tm \u2295 \u03b9) aa          \u2261\u27e8 \u2295-lemma tm \u03b9 \u27e9\n    lookup tm aa + lookup \u03b9 aa  \u2261\u27e8 cong (lookup tm aa +_) lookup\u03b9\u22610 \u27e9\n    lookup tm aa + 0            \u2261\u27e8 +-identity\u02b3 (lookup tm aa) \u27e9\n    lookup tm aa                \u220e\n\n  open IsSemigroup\n  open IsMagma\n  isSemigrp : IsSemigroup _\u224b_ _\u2295_\n  isSemigrp .isMagma .isEquivalence        = \u224b-isEquivalence\n  isSemigrp .isMagma .\u2219-cong {u}{v}{x}{y}  = \u2295-cong {u}{v}{x}{y}\n  isSemigrp .assoc                         = \u2295-assoc\n\n  open IsMonoid\n  \u224b-\u2295-\u03b9-isMonoid : IsMonoid _\u224b_ _\u2295_ \u03b9\n  \u224b-\u2295-\u03b9-isMonoid .isSemigroup  = isSemigrp\n  \u224b-\u2295-\u03b9-isMonoid .identity     = \u03b9-identity\n</pre> <p>We are now in a position to define the commutative monoid.</p> <pre>  open IsCommutativeMonoid\n\n  Vcm : Algebra.CommutativeMonoid 0\u2113 0\u2113\n  Vcm .Carrier                        = AssetId \u21d2 Quantity\n  Vcm ._\u2248_                            = _\u224b_\n  Vcm ._\u22c6_                            = _\u2295_\n  Vcm .\u03b5                              = \u03b9\n  Vcm .isCommutativeMonoid .isMonoid  = \u224b-\u2295-\u03b9-isMonoid\n  Vcm .isCommutativeMonoid .comm      = \u2295-comm\n\n  instance _ = Conversion.fromBundle Vcm\n\n  Value-TokenAlgebra :\n    (specialPolicy : PolicyId)\n    (specialAsset : AssetName)\n    (size : AssetId \u21d2 Quantity \u2192 \u2115)\n    --------------------------------------\n    \u2192 TokenAlgebra\n  Value-TokenAlgebra specialPolicy specialAsset size = record\n    { coin                      = totalMap\u21a0coin\n    ; inject                    = coin\u21aatotalMap\n    ; policies                  = policies\n    ; size                      = size\n    ; _\u2264\u1d57_                      = leq\n    ; coin\u2218inject\u2257id            = compose-to-id\n    ; coinIsMonoidHomomorphism  = CoinMonHom\n    ; Dec-\u2264\u1d57 = \u03bb {x}{y} \u2192 Dec-lookup\u2264 {x}{y}\n    }\n    where\n\n    specId : AssetId\n    specId = (specialPolicy , specialAsset)\n\n    open Update\n\n    totalMap\u21a0coin : AssetId \u21d2 Quantity \u2192 Coin\n    totalMap\u21a0coin tm = lookup tm specId\n\n    coin\u21aatotalMap : Coin \u2192 AssetId \u21d2 Quantity\n    coin\u21aatotalMap c = update specId c \u03b9\n\n    policies : AssetId \u21d2 Quantity \u2192 \u2119 PolicyId\n    policies tm = map\u02e2 proj\u2081 $ dom tm\n\n    leq : AssetId \u21d2 Quantity \u2192 AssetId \u21d2 Quantity \u2192 Type\n    leq u v = \u2200 {a}{p}{q} \u2192 lookup u (a , p) \u2264 lookup v (a , q)\n\n    compose-to-id : totalMap\u21a0coin \u2218 coin\u21aatotalMap \u2257 id\n    compose-to-id _ = lookup-update-id \u03b9\n      where open LookupUpdate {X = X} {specId} {a\u2208X = \u22c1A}\n\n    open Algebra.CommutativeMonoid Vcm                    using () renaming (rawMonoid to Vcm-mon)\n    open Algebra.CommutativeMonoid +-0-commutativeMonoid  using () renaming (rawMonoid to \u2115-mon)\n    open IsMonoidHomomorphism                             using (isMagmaHomomorphism ; \u03b5-homo)\n    open IsMagmaHomomorphism                              using (isRelHomomorphism ; homo)\n    open IsRelHomomorphism                                using () renaming (cong to \u27e6\u27e7-cong)\n\n    CoinMonHom : IsMonoidHomomorphism Vcm-mon \u2115-mon totalMap\u21a0coin\n    CoinMonHom .isMagmaHomomorphism .isRelHomomorphism .\u27e6\u27e7-cong  = \u03bb x \u2192 x\n    CoinMonHom .isMagmaHomomorphism .homo                        = \u03bb x y \u2192 \u2295-lemma x y\n    CoinMonHom .\u03b5-homo                                           = lookup\u03b9\u22610\n</pre>"},{"location":"Ledger.Conway.Specification.TokenAlgebra.ValueVector.html","title":"ValueVector","text":"<pre>{-# OPTIONS --safe #-}\nopen import Ledger.Prelude hiding (_\u2219_; \u03b5)\n\nmodule Ledger.Conway.Specification.TokenAlgebra.ValueVector (PolicyId : Type) (n : \u2115) where\n\nimport Algebra as Alg\nopen import Algebra.Construct.DirectProduct\nopen import stdlib.Algebra.Morphism.Construct.DirectProduct\nopen import Data.Nat.Properties using (+-0-commutativeMonoid)\nimport Data.Product.Relation.Binary.Pointwise.NonDependent as Product\nopen import Data.Vec as Vec\n  hiding (fromList)\nimport stdlib.Data.Vec.Instances as Vec\nimport Data.Vec.Relation.Binary.Pointwise.Inductive as Vec\n\nopen import Ledger.Conway.Specification.TokenAlgebra.Base PolicyId\n\nQuantity = \u2115\n\nVec-commutativeMonoid = Vec.commutativeMonoid n +-0-commutativeMonoid\n\nmodule +-0-commutativeMonoid = Alg.CommutativeMonoid +-0-commutativeMonoid\nmodule Vec-commutativeMonoid = Alg.CommutativeMonoid Vec-commutativeMonoid\n\nmodule _ (Policies : Vec PolicyId n) where\n  Value-TokenAlgebra : TokenAlgebra\n  Value-TokenAlgebra = record {go}\n    where\n      module go where\n        Value : Type\n        Value = Coin \u00d7 Vec Quantity n\n\n        Value-CommutativeMonoid : CommutativeMonoid 0\u2113 0\u2113 Value\n        Value-CommutativeMonoid = Conversion.fromBundle (commutativeMonoid +-0-commutativeMonoid Vec-commutativeMonoid)\n\n        coin : Value \u2192 Coin\n        coin = proj\u2081\n\n        inject : Coin \u2192 Value\n        inject c = c , Vec.replicate n 0\n\n        policies                   = \u03bb _ \u2192 fromList (toList Policies)\n        size                       = \u03bb _ \u2192 1 + n\n        _\u2264\u1d57_                       = Product.Pointwise _\u2264_ (Vec.Pointwise _\u2264_)\n\n        coin\u2218inject\u2257id             = \u03bb _ \u2192 refl\n        coinIsMonoidHomomorphism   = Monoid-Export.proj\u2081 {refl = refl}\n\n        Dec-\u2264\u1d57 : _\u2264\u1d57_ \u2047\u00b2\n        Dec-\u2264\u1d57 {(c\u2081 , v\u2081)} {(c\u2082 , v\u2082)} = Dec-\u00d7 \u2983 \u2115-Dec-\u2264 \u2984 \u2983 \u2047 Vec.decidable dec\u00b2 v\u2081 v\u2082 \u2984\n</pre>"},{"location":"Ledger.Conway.Specification.Transaction.html","title":"Transactions","text":"<p>A transaction consists of a transaction body, a collection of witnesses and some optional auxiliary data.</p> <pre>{-# OPTIONS --safe #-}\n--------------------------------------------------------------------------------\n-- NOTE: Everything in this module is part of TransactionStructure\n--------------------------------------------------------------------------------\nmodule Ledger.Conway.Specification.Transaction where\n\nimport Data.Maybe.Base as M\n\nopen import Ledger.Prelude renaming (filter\u1d50 to filter)\n\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\nopen import Ledger.Conway.Specification.Gov.Base\nimport Ledger.Conway.Specification.PParams\nimport Ledger.Conway.Specification.Script.Base\nimport Ledger.Conway.Specification.Gov.Actions\nimport Ledger.Conway.Specification.Certs\nimport Ledger.Conway.Specification.TokenAlgebra.Base\nimport Ledger.Core.Specification.Address\n\nopen import Relation.Nullary.Decidable using (\u230a_\u230b)\n\ndata Tag : Type where\n  Spend Mint Cert Rewrd Vote Propose : Tag\nunquoteDecl DecEq-Tag = derive-DecEq ((quote Tag , DecEq-Tag) \u2237 [])\n</pre> <p>Here are some key components of the transaction body.</p> <ul> <li> <p><code>txIns</code> denotes a set of transaction inputs; each input consists of a    transaction id and an index that points to a unique output from a previous transaction.</p> </li> <li> <p><code>txOuts</code> denotes an indexed collection of transaction outputs; each output    consists of an address and a coin value.</p> </li> <li> <p><code>txFee</code> denotes a transaction fee to be added to the fee pot.</p> </li> <li> <p><code>txId</code> denotes the hash of the serialized form of the    transaction\u2014the form in which the transaction is included in a block.</p> </li> </ul> <p>In addition to these, the Conway era introduces some new fields to the transaction body.</p> <ul> <li> <p><code>txGovVotes</code> denotes the list of votes for governance actions.</p> </li> <li> <p><code>txGovProposals</code> denotes the list of governance proposals.</p> </li> <li> <p><code>txDonation</code> denotes the amount of <code>Coin</code> to donate to    treasury, e.g., to return funds to the treasury after a governance action.</p> </li> <li> <p><code>currentTreasury</code> denotes the current value of the treasury; this serves    as a precondition to executing Plutus scripts that access the value of the treasury.</p> </li> </ul>"},{"location":"Ledger.Conway.Specification.Transaction.html#transaction-types","title":"Transaction Types","text":"<pre>record TransactionStructure : Type\u2081 where\n  field\n</pre> <p>Abstract types</p> <pre>    Ix TxId AuxiliaryData : Type\n</pre> <pre>    \u2983 DecEq-Ix   \u2984 : DecEq Ix\n    \u2983 DecEq-TxId \u2984 : DecEq TxId\n    adHashingScheme : isHashableSet AuxiliaryData\n  open isHashableSet adHashingScheme renaming (THash to ADHash) public\n\n  field globalConstants : _\n  open GlobalConstants globalConstants public\n\n  field cryptoStructure : _\n  open CryptoStructure cryptoStructure public\n  open Ledger.Conway.Specification.TokenAlgebra.Base ScriptHash public\n  open Ledger.Core.Specification.Address Network KeyHash ScriptHash \u2983 it \u2984 \u2983 it \u2984 \u2983 it \u2984 public\n\n  field epochStructure : _\n  open EpochStructure epochStructure public\n  open Ledger.Conway.Specification.Script.Base cryptoStructure epochStructure public\n\n  field scriptStructure : _\n  open ScriptStructure scriptStructure public\n  open Ledger.Conway.Specification.PParams cryptoStructure epochStructure scriptStructure public\n\n  field govParams : _\n  open GovParams govParams public\n\n  field tokenAlgebra : TokenAlgebra\n  open TokenAlgebra tokenAlgebra public\n\n  field txidBytes : TxId \u2192 Ser\n\n  govStructure : GovStructure\n  govStructure = record\n    -- TODO: figure out what to do with the hash\n    { TxId = TxId; DocHash = ADHash\n    ; cryptoStructure = cryptoStructure\n    ; epochStructure = epochStructure\n    ; scriptStructure = scriptStructure\n    ; govParams = govParams\n    ; globalConstants = globalConstants\n    }\n\n  module GovActions = Ledger.Conway.Specification.Gov.Actions govStructure\n  open GovActions hiding (Vote; yes; no; abstain) public\n\n  open import Ledger.Conway.Specification.Certs govStructure\n</pre> <p>Derived types</p> <pre>  TxIn               = TxId \u00d7 Ix\n  TxOut              = Addr \u00d7 Value \u00d7 Maybe (Datum \u228e DataHash) \u00d7 Maybe Script\n  UTxO               = TxIn \u21c0 TxOut\n  RdmrPtr            = Tag \u00d7 Ix\n  ProposedPPUpdates  = KeyHash \u21c0 PParamsUpdate\n  Update             = ProposedPPUpdates \u00d7 Epoch\n</pre> <pre>  record HasUTxO {a} (A : Type a) : Type a where\n    field UTxOOf : A \u2192 UTxO\n  open HasUTxO \u2983...\u2984 public\n</pre> <p>Transaction types</p> <pre>  record TxBody : Type where\n    field\n      txIns                : \u2119 TxIn\n      refInputs            : \u2119 TxIn\n      collateralInputs     : \u2119 TxIn\n      txOuts               : Ix \u21c0 TxOut\n      txId                 : TxId\n      txCerts              : List DCert\n      txFee                : Fees\n      txWithdrawals        : Withdrawals\n      txVldt               : Maybe Slot \u00d7 Maybe Slot\n      txADhash             : Maybe ADHash\n      txDonation           : Donations\n      txGovVotes           : List GovVote\n      txGovProposals       : List GovProposal\n      txNetworkId          : Maybe Network\n      currentTreasury      : Maybe Treasury\n      mint                 : Value\n      reqSignerHashes      : \u2119 KeyHash\n      scriptIntegrityHash  : Maybe ScriptHash\n      -- txup              : Maybe Update   -- deprecated; leave for now\n</pre> <pre>  record HasTxBody {a} (A : Type a) : Type a where\n    field TxBodyOf : A \u2192 TxBody\n  open HasTxBody  \u2983...\u2984 public\n\n  record HasDCerts {a} (A : Type a) : Type a where\n    field DCertsOf : A \u2192 List DCert\n  open HasDCerts \u2983...\u2984 public\n\n  record HasGovProposals {a} (A : Type a) : Type a where\n    field GovProposalsOf  : A \u2192 List GovProposal\n  open HasGovProposals \u2983...\u2984 public\n\n  record HasTxId {a} (A : Type a) : Type a where\n    field TxIdOf    : A \u2192 TxId\n  open HasTxId \u2983...\u2984 public\n\n  instance\n    HasDonations-TxBody : HasDonations TxBody\n    HasDonations-TxBody .DonationsOf = TxBody.txDonation\n</pre> <pre>  record TxWitnesses : Type where\n    field\n      vkSigs   : VKey \u21c0 Sig\n      scripts  : \u2119 Script\n      txdats   : \u2119 Datum\n      txrdmrs  : RdmrPtr  \u21c0 Redeemer \u00d7 ExUnits\n\n    scriptsP1 : \u2119 P1Script\n    scriptsP1 = mapPartial toP1Script scripts\n\n  record Tx : Type where\n    field\n      body     : TxBody\n      wits     : TxWitnesses\n      txsize   : \u2115\n      isValid  : Bool\n      txAD     : Maybe AuxiliaryData\n</pre> <pre>  instance\n    HasTxBody-Tx : HasTxBody Tx\n    HasTxBody-Tx .TxBodyOf = Tx.body\n\n    HasFees-Tx : HasFees Tx\n    HasFees-Tx .FeesOf = TxBody.txFee \u2218 TxBodyOf\n\n    HasDCerts-Tx : HasDCerts Tx\n    HasDCerts-Tx .DCertsOf = TxBody.txCerts \u2218 TxBodyOf\n\n    HasGovProposals-Tx : HasGovProposals Tx\n    HasGovProposals-Tx .GovProposalsOf = TxBody.txGovProposals \u2218 TxBodyOf\n\n    HasWithdrawals-TxBody : HasWithdrawals TxBody\n    HasWithdrawals-TxBody .WithdrawalsOf = TxBody.txWithdrawals\n\n    HasWithdrawals-Tx : HasWithdrawals Tx\n    HasWithdrawals-Tx .WithdrawalsOf = WithdrawalsOf \u2218 TxBodyOf\n\n    HasTxId-Tx : HasTxId Tx\n    HasTxId-Tx .TxIdOf = TxBody.txId \u2218 TxBodyOf\n\n    HasDonations-Tx : HasDonations Tx\n    HasDonations-Tx .DonationsOf = DonationsOf \u2218 TxBodyOf\n</pre>"},{"location":"Ledger.Conway.Specification.Transaction.html#transaction-functions","title":"Transaction Functions","text":"<pre>  getValue : TxOut \u2192 Value\n  getValue (_ , v , _) = v\n\n  TxOut\u02b0 = Addr \u00d7 Value \u00d7 Maybe (Datum \u228e DataHash) \u00d7 Maybe ScriptHash\n\n  txOutHash : TxOut \u2192 TxOut\u02b0\n  txOutHash (a , v , d , s) = a , (v , (d , M.map hash s))\n\n  getValue\u02b0 : TxOut\u02b0 \u2192 Value\n  getValue\u02b0 (_ , v , _) = v\n\n  txInsVKey : \u2119 TxIn \u2192 UTxO \u2192 \u2119 TxIn\n  txInsVKey txIns utxo = txIns \u2229 dom (utxo \u2223^' (isVKeyAddr \u2218 proj\u2081))\n\n  scriptOuts : UTxO \u2192 UTxO\n  scriptOuts utxo = filter (\u03bb (_ , addr , _) \u2192 isScriptAddr addr) utxo\n\n  txInsScript : \u2119 TxIn \u2192 UTxO \u2192 \u2119 TxIn\n  txInsScript txIns utxo = txIns \u2229 dom (proj\u2081 (scriptOuts utxo))\n\n  refScripts : Tx \u2192 UTxO \u2192 \u2119 Script\n  refScripts tx utxo =\n    mapPartial (proj\u2082 \u2218 proj\u2082 \u2218 proj\u2082) (range (utxo \u2223 (txIns \u222a refInputs)))\n    where open Tx; open TxBody (tx .body)\n\n  txscripts : Tx \u2192 UTxO \u2192 \u2119 Script\n  txscripts tx utxo = scripts (tx .wits) \u222a refScripts tx utxo\n    where open Tx; open TxWitnesses\n\n  lookupScriptHash : ScriptHash \u2192 Tx \u2192 UTxO \u2192 Maybe Script\n  lookupScriptHash sh tx utxo = lookup\u1d50? m sh\n    where m = setToMap (map\u02e2 &lt; hash , id &gt; (txscripts tx utxo))\n</pre> <pre>  instance\n    HasCoin-TxOut : HasCoin TxOut\n    HasCoin-TxOut .getCoin = coin \u2218 proj\u2081 \u2218 proj\u2082\n</pre>"},{"location":"Ledger.Conway.Specification.Types.GovStructure.html","title":"GovStructure","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Types.GovStructure where\n\nopen import Prelude using (Type)\nopen import Class.DecEq\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Script.Base\nopen import Ledger.Core.Specification.Epoch\nimport Ledger.Conway.Specification.PParams\n\nrecord GovStructure : Type\u2081 where\n  field TxId DocHash : Type\n        \u2983 DecEq-TxId \u2984 : DecEq TxId\n\n  field cryptoStructure : _\n  open CryptoStructure cryptoStructure public\n\n  field epochStructure : _\n  open EpochStructure epochStructure public\n\n  field scriptStructure : ScriptStructure cryptoStructure epochStructure\n  open ScriptStructure scriptStructure public\n\n  open Ledger.Conway.Specification.PParams cryptoStructure epochStructure scriptStructure public\n\n  field govParams : GovParams\n  open GovParams govParams public\n\n  field globalConstants : _\n  open GlobalConstants globalConstants public\n\n  open import Ledger.Core.Specification.Address Network KeyHash ScriptHash public\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.Base.html","title":"Base","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Utxo.Properties.Base\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Prelude; open Equivalence\nopen import Ledger.Prelude hiding (\u2264-trans; \u2264-antisym; All); open Properties\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Utxo txs abs\n\nopen import Tactic.EquationalReasoning using (module \u2261-Reasoning)\nopen import Tactic.Cong using (cong!)\nopen import stdlib-meta.Tactic.MonoidSolver.NonNormalising using (solve-macro)\n\nopen import Data.Nat.Properties hiding (_\u225f_)\nimport Data.Nat as \u2115\nimport Data.Integer as \u2124\nopen import Data.Integer.Properties as Int\n  using ( +-injective; n\u2296n\u22610; distrib\u02b3-\u2296-+-pos; \u2296-swap; pos-+; \u2296-\u2265\n        ; m-n\u2261m\u2296n; +-inverse\u02e1)\n\nopen import Relation.Binary             using (IsEquivalence)\n\nopen import Algebra.Morphism              using (module MonoidMorphisms; IsMagmaHomomorphism)\nopen import Algebra.Definitions.RawMagma +-rawMagma using () renaming (_,_ to _,\u2264_)\n\n\nposPart-negPart\u2261x : {x : \u2124} \u2192 posPart x - negPart x \u2261 x\nposPart-negPart\u2261x {\u2124.+_ n}     = refl\nposPart-negPart\u2261x {\u2124.negsuc n} = refl\n\n\u03c7 : Bool \u2192 \u2115\n\u03c7 false  = 0\n\u03c7 true   = 1\n\nopen MonoidMorphisms.IsMonoidHomomorphism\nprivate\n  \u2219-homo-Coin = IsMagmaHomomorphism.homo (isMagmaHomomorphism coinIsMonoidHomomorphism)\n\nmodule _\n  {txb : _} (open TxBody txb)\n  {utxo : UTxO}\n  where\n  opaque\n    unfolding outs\n    open Tactic.EquationalReasoning.\u2261-Reasoning {A = \u2115} (solve-macro (quoteTerm +-0-monoid))\n\n    newTxid\u21d2disj : txId \u2209 map\u02e2 proj\u2081 (dom utxo)\n                \u2192 disjoint' (dom utxo) (dom (outs txb))\n    newTxid\u21d2disj id\u2209utxo = disjoint\u21d2disjoint' \u03bb h h' \u2192 id\u2209utxo $ to \u2208-map\n      (-, (case from \u2208-map h' of \u03bb where\n            (_ , refl , h'') \u2192 case from \u2208-map h'' of \u03bb where (_ , refl , _) \u2192 refl) , h)\n\n    consumedCoinEquality : \u2200 {utxoState} {pp}\n      \u2192 coin mint \u2261 0\n      \u2192 coin (consumed pp utxoState txb)\n      \u2261 cbalance ((UTxOState.utxo utxoState) \u2223 txIns) + depositRefunds pp utxoState txb + getCoin txWithdrawals\n    consumedCoinEquality {utxoState} {pp} h =\n      let  utxo = UTxOState.utxo utxoState\n           dRefs = depositRefunds pp utxoState txb\n           sWdls = getCoin txWithdrawals\n      in begin\n      coin (balance (utxo \u2223 txIns) + mint + inject dRefs + inject sWdls)\n        \u2261\u27e8 \u2219-homo-Coin _ _ \u27e9\n      coin (balance (utxo \u2223 txIns) + mint + inject dRefs) + coin (inject $ sWdls)\n        \u2261\u27e8 cong (coin (balance (utxo \u2223 txIns) + mint + inject dRefs) +_) (coin\u2218inject\u2257id _) \u27e9\n      coin (balance (utxo \u2223 txIns) + mint + inject dRefs) + sWdls\n        \u2261\u27e8 cong (_+ sWdls) (\u2219-homo-Coin _ _) \u27e9\n      coin (balance (utxo \u2223 txIns) + mint) + coin (inject $ dRefs) + sWdls\n        \u2261\u27e8 cong (\u03bb u \u2192 coin (balance (utxo \u2223 txIns) + mint) + u + sWdls) (coin\u2218inject\u2257id _) \u27e9\n      coin (balance (utxo \u2223 txIns) + mint) + dRefs + sWdls\n        \u2261\u27e8 cong (\u03bb u \u2192 u + dRefs + sWdls) (\u2219-homo-Coin _ _) \u27e9\n      cbalance (utxo \u2223 txIns) + coin mint + dRefs + sWdls\n        \u2261\u27e8 cong (\u03bb x \u2192 cbalance (utxo \u2223 txIns) + x + dRefs + sWdls) h \u27e9\n      cbalance (utxo \u2223 txIns) + 0 + dRefs + sWdls\n        \u2261\u27e8 cong (\u03bb x \u2192 x + dRefs + sWdls) (+-identity\u02b3 (cbalance (utxo \u2223 txIns))) \u27e9\n      cbalance (utxo \u2223 txIns) + dRefs + sWdls\n        \u220e\n\n    producedCoinEquality : \u2200 {utxoState} {pp}\n      \u2192 coin (produced pp utxoState txb)\n      \u2261 cbalance (outs txb) + txFee + newDeposits pp utxoState txb + txDonation\n    producedCoinEquality {utxoState} {pp} =\n        begin\n      coin (balance (outs txb) + inject txFee\n        + inject (newDeposits pp utxoState txb) + inject txDonation)\n        \u2261\u27e8 \u2219-homo-Coin _ _ \u27e9\n      coin (balance (outs txb) + inject txFee\n        + inject (newDeposits pp utxoState txb)) + coin (inject txDonation)\n        \u2261\u27e8 cong (_+ coin (inject txDonation)) (begin\n          coin (balance (outs txb) + inject txFee\n            + inject (newDeposits pp utxoState txb))\n            \u2261\u27e8 \u2219-homo-Coin _ _ \u27e9\n          coin (balance (outs txb) +\u1d5b inject txFee)\n            \u2115.+ coin (inject (newDeposits pp utxoState txb))\n            \u2261\u27e8 cong! (coin\u2218inject\u2257id _) \u27e9\n          coin (balance (outs txb) +\u1d5b inject txFee)\n            \u2115.+ newDeposits pp utxoState txb\n            \u2261\u27e8 cong! (\u2219-homo-Coin _ _) \u27e9\n          coin (balance (outs txb)) \u2115.+ coin (inject txFee)\n            \u2115.+ newDeposits pp utxoState txb\n            \u2261\u27e8 cong (\u03bb x \u2192 cbalance (outs txb) + x + newDeposits pp utxoState txb)\n                  $ coin\u2218inject\u2257id txFee \u27e9\n          cbalance (outs txb) + txFee + newDeposits pp utxoState txb\n            \u220e\n        )\u27e9\n      cbalance (outs txb) + txFee\n        + newDeposits pp utxoState txb + coin (inject txDonation)\n        \u2261\u27e8 cong (cbalance (outs txb) + txFee + newDeposits pp utxoState txb +_)\n              $ coin\u2218inject\u2257id _ \u27e9\n      cbalance (outs txb) + txFee + newDeposits pp utxoState txb + txDonation\n        \u220e\n\n    balValueToCoin : \u2200 {utxoState} {pp}\n      \u2192 coin mint \u2261 0\n      \u2192 consumed pp utxoState txb \u2261 produced pp utxoState txb\n      \u2192 cbalance ((UTxOState.utxo utxoState) \u2223 txIns)\n      + depositRefunds pp utxoState txb + getCoin txWithdrawals\n      \u2261 cbalance (outs txb) + txFee + newDeposits pp utxoState txb + txDonation\n    balValueToCoin {utxoState} {pp} h h' = begin\n      cbalance ((UTxOState.utxo utxoState) \u2223 txIns) + depositRefunds pp utxoState txb + getCoin txWithdrawals\n        \u2261\u02d8\u27e8 consumedCoinEquality {utxoState} {pp} h \u27e9\n      coin (consumed pp utxoState txb)\n        \u2261\u27e8 cong! h' \u27e9\n      coin (produced pp utxoState txb)\n        \u2261\u27e8 producedCoinEquality {utxoState} {pp} \u27e9\n      cbalance (outs txb) + txFee + newDeposits pp utxoState txb + txDonation\n        \u220e\n\nmodule _ {utxo utxo' : UTxO} where\n\n  opaque\n    unfolding balance\n    balance-cong :  \u2223 utxo \u2223 \u2261\u1d49 \u2223 utxo' \u2223 \u2192 balance utxo \u2248 balance utxo'\n    balance-cong eq = indexedSum\u1d50-cong {M = Value} {x = (mapValues txOutHash utxo) \u1da0\u1d50} {(mapValues txOutHash utxo') \u1da0\u1d50} (map-\u2261\u1d49 eq)\n\n    balance-cong-coin : \u2223 utxo \u2223 \u2261\u1d49 \u2223 utxo' \u2223 \u2192 cbalance utxo \u2261 cbalance utxo'\n    balance-cong-coin x =\n      coinIsMonoidHomomorphism .\u27e6\u27e7-cong (balance-cong x)\n      where open MonoidMorphisms.IsMonoidHomomorphism\n\n    balance-\u222a : disjoint (dom utxo) (dom utxo')\n                         \u2192 cbalance (utxo \u222a\u02e1 utxo') \u2261 cbalance utxo + cbalance utxo'\n    balance-\u222a h = begin\n      cbalance (utxo \u222a\u02e1 utxo')\n        \u2261\u27e8 \u27e6\u27e7-cong coinIsMonoidHomomorphism\n        $ indexedSum\u1d50-cong {f = getValue\u02b0 \u2218 proj\u2082} {x = (mapValues txOutHash (utxo \u222a\u02e1 utxo')) \u1da0\u1d50} {((mapValues txOutHash utxo) \u1da0\u1d50) \u222a\u02e1\u1da0 ((mapValues txOutHash utxo') \u1da0\u1d50)} (disjoint-\u222a\u02e1-mapValues {M = utxo} {utxo'} _ h)\n        \u27e9\n      coin (indexedSum\u1d50 _ (((mapValues txOutHash utxo) \u1da0\u1d50) \u222a\u02e1\u1da0 ((mapValues txOutHash utxo') \u1da0\u1d50)))\n        \u2261\u27e8 \u27e6\u27e7-cong coinIsMonoidHomomorphism\n         $ indexedSum\u1d50-\u222a {M = Value} {X = (mapValues txOutHash utxo) \u1da0\u1d50} {(mapValues txOutHash utxo') \u1da0\u1d50}\n         (\u03bb x x\u2081 \u2192 h (dom-map\u02b3\u2286 x) (dom-map\u02b3\u2286 x\u2081))\n         \u27e9\n      coin (balance utxo + balance utxo')\n        \u2261\u27e8 \u2219-homo-Coin _ _ \u27e9\n      cbalance utxo + cbalance utxo'\n        \u220e\n      where open Tactic.EquationalReasoning.\u2261-Reasoning {A = \u2115} (solve-macro (quoteTerm +-0-monoid))\n\n\nmodule _\n  {utxo utxo' : UTxO}\n  {fees fees' : Fees}\n  {deposits deposits' : Deposits}\n  {donations donations' : Donations}\n  {tx : Tx} (let open Tx tx renaming (body to txb); open TxBody txb)\n  {\u0393 : UTxOEnv}\n  (step  : \u0393 \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7393}{\\htmlId{7607}{\\htmlClass{Bound}{\\text{utxo}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7415}{\\htmlId{7615}{\\htmlClass{Bound}{\\text{fees}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7437}{\\htmlId{7623}{\\htmlClass{Bound}{\\text{deposits}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7471}{\\htmlId{7635}{\\htmlClass{Bound}{\\text{donations}}}}\\,  \\end{pmatrix}$ \u21c0\u2987 tx ,UTXO\u2988\n               $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7398}{\\htmlId{7678}{\\htmlClass{Bound}{\\text{utxo'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7420}{\\htmlId{7686}{\\htmlClass{Bound}{\\text{fees'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7446}{\\htmlId{7694}{\\htmlClass{Bound}{\\text{deposits'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7481}{\\htmlId{7706}{\\htmlClass{Bound}{\\text{donations'}}}}\\, \\end{pmatrix}$)\n  (h' : txId \u2209 map\u02e2 proj\u2081 (dom utxo))\n  where\n  open Tactic.EquationalReasoning.\u2261-Reasoning {A = \u2115} (solve-macro (quoteTerm +-0-monoid))\n\n  private\n    stepS : \u0393 \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7393}{\\htmlId{7886}{\\htmlClass{Bound}{\\text{utxo}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7415}{\\htmlId{7894}{\\htmlClass{Bound}{\\text{fees}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7437}{\\htmlId{7902}{\\htmlClass{Bound}{\\text{deposits}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7471}{\\htmlId{7914}{\\htmlClass{Bound}{\\text{donations}}}}\\,  \\end{pmatrix}$ \u21c0\u2987 tx ,UTXOS\u2988\n                $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7398}{\\htmlId{7959}{\\htmlClass{Bound}{\\text{utxo'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7420}{\\htmlId{7967}{\\htmlClass{Bound}{\\text{fees'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7446}{\\htmlId{7975}{\\htmlClass{Bound}{\\text{deposits'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7481}{\\htmlId{7987}{\\htmlClass{Bound}{\\text{donations'}}}}\\, \\end{pmatrix}$\n    stepS = case step of \u03bb where\n      (UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ h) \u2192 h\n\n    pp : PParams\n    pp = UTxOEnv.pparams \u0393\n    dep : Coin\n    dep = getCoin deposits\n    uDep : Coin\n    uDep = getCoin (updateDeposits pp txb deposits)\n    \u0394dep : \u2124\n    \u0394dep = depositsChange pp txb deposits\n    utxoSt : UTxOState\n    utxoSt = $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7393}{\\htmlId{8351}{\\htmlClass{Bound}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7415}{\\htmlId{8358}{\\htmlClass{Bound}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7437}{\\htmlId{8365}{\\htmlClass{Bound}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7471}{\\htmlId{8376}{\\htmlClass{Bound}{\\text{donations}}}}\\, \\end{pmatrix}$\n    ref tot : Coin\n    ref = depositRefunds pp utxoSt txb\n    wdls = getCoin txWithdrawals\n    tot = newDeposits    pp utxoSt txb\n    h : disjoint (dom (utxo \u2223 txIns \u1d9c)) (dom (outs txb))\n    h = \u03bb h\u2081 h\u2082 \u2192 \u2209-\u2205 $ proj\u2081 (newTxid\u21d2disj {txb} {utxo} h')\n                      $ to \u2208-\u2229 (res-comp-dom\u1d50 h\u2081 , h\u2082)\n    newBal' : \u0393 \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7393}{\\htmlId{8711}{\\htmlClass{Bound}{\\text{utxo}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7415}{\\htmlId{8719}{\\htmlClass{Bound}{\\text{fees}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7437}{\\htmlId{8727}{\\htmlClass{Bound}{\\text{deposits}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7471}{\\htmlId{8739}{\\htmlClass{Bound}{\\text{donations}}}}\\,  \\end{pmatrix}$ \u21c0\u2987 tx ,UTXO\u2988\n                  $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7398}{\\htmlId{8785}{\\htmlClass{Bound}{\\text{utxo'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7420}{\\htmlId{8793}{\\htmlClass{Bound}{\\text{fees'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7446}{\\htmlId{8801}{\\htmlClass{Bound}{\\text{deposits'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7481}{\\htmlId{8813}{\\htmlClass{Bound}{\\text{donations'}}}}\\, \\end{pmatrix}$\n            \u2192 consumed pp utxoSt txb \u2261 produced pp utxoSt txb\n    newBal' (UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ x _ _ _ _ _ _ _ _ _ _ _) = x\n    newBal : consumed pp utxoSt txb \u2261 produced pp utxoSt txb\n    newBal = newBal' step\n    noMintAda' : \u0393 \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7393}{\\htmlId{9074}{\\htmlClass{Bound}{\\text{utxo}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7415}{\\htmlId{9082}{\\htmlClass{Bound}{\\text{fees}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7437}{\\htmlId{9090}{\\htmlClass{Bound}{\\text{deposits}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7471}{\\htmlId{9102}{\\htmlClass{Bound}{\\text{donations}}}}\\,  \\end{pmatrix}$ \u21c0\u2987 tx ,UTXO\u2988\n                     $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7398}{\\htmlId{9151}{\\htmlClass{Bound}{\\text{utxo'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7420}{\\htmlId{9159}{\\htmlClass{Bound}{\\text{fees'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7446}{\\htmlId{9167}{\\htmlClass{Bound}{\\text{deposits'}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.Base.html#7481}{\\htmlId{9179}{\\htmlClass{Bound}{\\text{donations'}}}}\\, \\end{pmatrix}$\n               \u2192 coin (mint) \u2261 0\n    noMintAda' (UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ x _ _ _ _ _ _ _ _ _ _) = x\n    noMintAda : coin mint \u2261 0\n    noMintAda = noMintAda' step\n    remDepTot : Coin\n    remDepTot = getCoin deposits - ref\n\n  deposits-change' : \u0394dep \u2261 tot - ref\n  deposits-change' = sym posPart-negPart\u2261x\n\n  dep-ref : tot \u2261 0 \u2192 uDep + ref \u2261 dep\n  dep-ref tot\u22610 = +-injective $ begin\n    \u2124.+_ (uDep + ref)          \u2261\u27e8 pos-+ uDep ref \u27e9\n    \u2124.+_ uDep \u2124.+ (ref - 0)    \u2261\u02d8\u27e8 cong (\u03bb u \u2192 \u2124.+_ uDep \u2124.+ (ref - u)) tot\u22610 \u27e9\n    \u2124.+_ uDep \u2124.+ (ref - tot)  \u2261\u27e8 cong ((\u2124.+ uDep) +_) (\u2296-swap ref tot) \u27e9\n    \u2124.+_ uDep \u2124.- (tot - ref)  \u2261\u02d8\u27e8 cong (\u03bb u \u2192  \u2124.+_ uDep \u2124.- u) deposits-change' \u27e9\n    \u2124.+_ uDep \u2124.- \u0394dep         \u2261\u02d8\u27e8 cong ((\u2124.+ uDep) +_) (\u2296-swap dep uDep) \u27e9\n    \u2124.+_ uDep + (dep - uDep)   \u2261\u27e8 Int.distrib\u02b3-\u2296-+-pos uDep dep uDep \u27e9\n    (uDep + dep) - uDep        \u2261\u27e8 cong (_- uDep) (+-comm uDep dep) \u27e9\n    (dep + uDep) - uDep        \u2261\u02d8\u27e8 Int.distrib\u02b3-\u2296-+-pos dep uDep uDep \u27e9\n    \u2124.+_ dep \u2124.+ (uDep - uDep) \u2261\u27e8 cong (\u03bb u \u2192 \u2124.+_ dep \u2124.+ u) (n\u2296n\u22610 uDep) \u27e9\n    \u2124.+_ dep \u2124.+ \u2124.0\u2124          \u2261\u27e8 Int.+-identity\u02b3 _ \u27e9\n    \u2124.+_ dep \u220e\n\n  ref-tot-0 : ref \u2262 0 \u2192 tot \u2261 0\n  ref-tot-0 ref\u22620 with \u0394dep\n  ... | \u2124.+_ n     = \u22a5-elim (ref\u22620 refl)\n  ... | \u2124.negsuc n = refl\n\n  ref\u2264dep : ref \u2264 dep\n  ref\u2264dep with ref \u225f 0\n  ... | no \u00acp = \u2264\u2033\u21d2\u2264 $ _ ,\u2264_ $ begin\n    ref + uDep \u2261\u27e8 +-comm ref uDep \u27e9\n    uDep + ref \u2261\u27e8 dep-ref $ ref-tot-0 \u00acp \u27e9\n    dep        \u220e\n  ... | yes p rewrite p = z\u2264n\n\n  deposits-change : uDep \u2261 dep + tot - ref\n  deposits-change = +-injective $ begin\n    \u2124.+_ uDep                                 \u2261\u02d8\u27e8 Int.+-identity\u02b3 _ \u27e9\n    \u2124.+_ uDep \u2124.+ \u2124.0\u2124                        \u2261\u02d8\u27e8 cong! (+-inverse\u02e1 (\u2124.+_ dep)) \u27e9\n    \u2124.+_ uDep \u2124.+ (\u2124.-_ (\u2124.+_ dep) \u2124.+ (\u2124.+_ dep))\n      \u2261\u02d8\u27e8 Int.+-assoc (\u2124.+_ uDep) (\u2124.-_ (\u2124.+_ dep)) (\u2124.+_ dep) \u27e9\n    (\u2124.+_ uDep \u2124.- (\u2124.+_ dep)) \u2124.+ (\u2124.+_ dep) \u2261\u27e8 cong! (m-n\u2261m\u2296n uDep dep) \u27e9\n    \u0394dep \u2124.+ (\u2124.+_ dep)                       \u2261\u27e8 Int.+-comm \u0394dep (\u2124.+_ dep) \u27e9\n    (\u2124.+_ dep) \u2124.+ \u0394dep                       \u2261\u27e8 cong! deposits-change' \u27e9\n    (\u2124.+_ dep) \u2124.+ (tot - ref)                \u2261\u27e8 distrib\u02b3-\u2296-+-pos dep tot ref \u27e9\n    (dep + tot) - ref                         \u2261\u27e8 \u2296-\u2265 (m\u2264n\u21d2m\u2264n+o tot ref\u2264dep) \u27e9\n    \u2124.+_ (dep + tot - ref) \u220e\n\n  split-balance : \u2200 keys \u2192 cbalance utxo \u2261 cbalance (utxo \u2223 keys \u1d9c) + cbalance (utxo \u2223 keys)\n  split-balance keys = begin\n                      cbalance utxo\n                        \u2261\u02d8\u27e8 balance-cong-coin {utxo = (utxo \u2223 keys \u1d9c) \u222a\u02e1 (utxo \u2223 keys)}{utxo}\n                          $ disjoint-\u222a\u02e1-\u222a (disjoint-sym res-ex-disjoint)\n                          \u2261\u1d49-\u2218 \u222a-sym\n                          \u2261\u1d49-\u2218 res-ex-\u222a (_\u2208? keys) \u27e9\n                      cbalance ((utxo \u2223 keys \u1d9c) \u222a\u02e1 (utxo \u2223 keys))\n                        \u2261\u27e8 balance-\u222a {utxo \u2223 keys \u1d9c} {utxo \u2223 keys} $ flip res-ex-disjoint \u27e9\n                      cbalance (utxo \u2223 keys \u1d9c) + cbalance (utxo \u2223 keys)\n                        \u220e\n    where open IsEquivalence \u2261\u1d49-isEquivalence renaming (trans to infixl 4 _\u2261\u1d49-\u2218_)\n\n  module _ (balanceUtxo balanceIns balanceNoIns balanceOuts balanceUtxo' : Coin)\n           (ref txFee txDonation tot : Coin)\n           (splitUtxo : balanceUtxo \u2261 balanceNoIns + balanceIns)\n           (splitUtxo' : balanceUtxo' \u2261 balanceNoIns + balanceOuts)\n           (balanced : balanceIns + ref + wdls \u2261 balanceOuts + txFee + tot + txDonation) where\n\n    utxo-ref-prop-worker :\n      balanceUtxo + ref + wdls \u2261 balanceUtxo' + txFee + txDonation + tot\n    utxo-ref-prop-worker = begin\n      balanceUtxo + ref + wdls\n        \u2261\u27e8 cong (\u03bb u \u2192 u + ref + wdls) splitUtxo \u27e9\n      balanceNoIns \u2115.+ balanceIns \u2115.+ ref \u2115.+ wdls\n        \u2261t\u27e8\u27e9\n      balanceNoIns \u2115.+ (balanceIns \u2115.+ ref \u2115.+ wdls)\n        \u2261\u27e8 cong (balanceNoIns +_) balanced \u27e9\n      balanceNoIns \u2115.+ (balanceOuts \u2115.+ txFee \u2115.+ tot \u2115.+ txDonation)\n        \u2261t\u27e8\u27e9\n      (balanceNoIns \u2115.+ balanceOuts \u2115.+ txFee) \u2115.+ tot \u2115.+ txDonation\n        \u2261\u02d8\u27e8 cong (\u03bb x \u2192 (x + txFee) + tot + txDonation) splitUtxo' \u27e9\n      (balanceUtxo' \u2115.+ txFee) \u2115.+ tot \u2115.+ txDonation\n        \u2261t\u27e8\u27e9\n      balanceUtxo' \u2115.+ txFee \u2115.+ (tot \u2115.+ txDonation)\n        \u2261\u27e8 cong (balanceUtxo' + txFee +_) $ +-comm tot txDonation \u27e9\n      balanceUtxo' \u2115.+ txFee \u2115.+ (txDonation \u2115.+ tot)\n        \u2261t\u27e8\u27e9\n      (balanceUtxo' \u2115.+ txFee) \u2115.+ txDonation \u2115.+ tot\n        \u220e\n\n  utxo-ref-prop :\n    cbalance utxo + ref + wdls \u2261\n    cbalance ((utxo \u2223 txIns \u1d9c) \u222a\u02e1 outs txb) + txFee + txDonation + tot\n  utxo-ref-prop = utxo-ref-prop-worker\n                    (cbalance utxo)\n                    (cbalance (utxo \u2223 txIns))\n                    (cbalance (utxo \u2223 txIns \u1d9c))\n                    (cbalance (outs txb))\n                    (cbalance ((utxo \u2223 txIns \u1d9c) \u222a\u02e1 outs txb))\n                    ref txFee txDonation tot\n                    (split-balance txIns)\n                    (balance-\u222a {utxo \u2223 txIns \u1d9c} {outs txb} h)\n                    (balValueToCoin {utxo = utxo} {utxoSt} {UTxOEnv.pparams \u0393} noMintAda newBal)\n\n  rearrange0 :\n      (bal : \u2115)\n    \u2192 deposits' \u2261 updateDeposits pp txb deposits\n    \u2192 bal + txFee + txDonation + tot + (remDepTot + fees)\n    \u2261 bal + (fees + txFee + getCoin deposits' + txDonation)\n  rearrange0 bal h = begin\n    bal \u2115.+ txFee \u2115.+ txDonation \u2115.+ tot \u2115.+ (remDepTot \u2115.+ fees)\n      \u2261t\u27e8\u27e9\n    bal \u2115.+ (txFee \u2115.+ txDonation \u2115.+ (tot \u2115.+ remDepTot) \u2115.+ fees)\n      \u2261\u27e8 cong (bal +_) $ begin\n        txFee + txDonation + (tot + remDepTot) + fees\n          \u2261\u27e8 +-comm _ fees \u27e9\n        fees \u2115.+ (txFee \u2115.+ txDonation \u2115.+ (tot \u2115.+ remDepTot))\n          \u2261t\u27e8\u27e9\n        (fees \u2115.+ txFee) \u2115.+ (txDonation \u2115.+ (tot \u2115.+ remDepTot))\n          \u2261\u27e8 cong ((fees + txFee) +_) $ +-comm txDonation (tot + remDepTot) \u27e9\n        (fees + txFee) \u2115.+ ((tot + remDepTot) \u2115.+ txDonation)\n          \u2261t\u27e8\u27e9\n        (fees + txFee) \u2115.+ (tot + remDepTot) \u2115.+ txDonation\n          \u2261\u27e8 cong (\u03bb x \u2192 (fees + txFee) + x + txDonation)\n          $ begin tot + (dep - ref) \u2261\u02d8\u27e8 +-\u2238-assoc tot ref\u2264dep \u27e9\n                  (tot + dep) - ref \u2261\u27e8 cong (_- ref) $ +-comm tot dep \u27e9\n                  (dep + tot) - ref \u2261\u02d8\u27e8 deposits-change \u27e9\n                  uDep              \u2261\u27e8 cong getCoin $ sym h \u27e9\n                  getCoin deposits' \u220e \u27e9\n        (fees + txFee) + getCoin deposits' + txDonation\n          \u220e \u27e9\n    bal + ((fees + txFee) + getCoin deposits' + txDonation)\n      \u220e\n\n  module _ (balanceUtxo balanceUtxo' : Coin)\n           (ref-prop : balanceUtxo + ref + wdls \u2261 balanceUtxo' + txFee + txDonation + tot)\n           (h : deposits' \u2261 updateDeposits pp txb deposits)\n           where\n\n    pov-scripts-worker :  isValid \u2261 true\n                          \u2192  balanceUtxo + fees + getCoin deposits + donations + wdls * \u03c7(isValid)\n                             \u2261 balanceUtxo' + (fees + txFee) + getCoin deposits' + (donations + txDonation)\n    pov-scripts-worker valid = begin\n      balanceUtxo + fees + dep + donations + wdls * \u03c7(isValid)\n        \u2261\u27e8 cong (\u03bb x \u2192 balanceUtxo + fees + dep + donations + wdls * \u03c7 x) valid \u27e9\n      balanceUtxo + fees + dep + donations + wdls * 1\n        \u2261\u27e8 cong (balanceUtxo + fees + dep + donations +_) (*-identity\u02b3 wdls) \u27e9\n      balanceUtxo + fees + dep + donations + wdls\n        \u2261\u27e8 +-assoc (balanceUtxo + fees + dep) donations wdls \u27e9\n      balanceUtxo + fees + dep + (donations + wdls)\n        \u2261\u27e8 cong (balanceUtxo + fees + dep +_) (+-comm donations wdls) \u27e9\n      balanceUtxo + fees + dep + (wdls + donations)\n        \u2261\u02d8\u27e8 +-assoc (balanceUtxo + fees + dep) wdls donations  \u27e9\n      balanceUtxo + fees + dep + wdls + donations\n        \u2261\u27e8 cong (_+ donations)\n        $ begin\n            balanceUtxo + fees + dep + wdls\n              \u2261\u02d8\u27e8 cong (\u03bb x \u2192 balanceUtxo + fees + x + wdls) (m+[n\u2238m]\u2261n ref\u2264dep) \u27e9\n            balanceUtxo + fees + (ref + remDepTot) + wdls\n              \u2261\u27e8 cong (_+ wdls) (+-assoc balanceUtxo fees (ref + remDepTot)) \u27e9\n            balanceUtxo + (fees + (ref + remDepTot)) + wdls\n              \u2261\u27e8 cong (\u03bb x \u2192 balanceUtxo + x + wdls) (+-comm fees (ref + remDepTot)) \u27e9\n            balanceUtxo + (ref + remDepTot + fees) + wdls\n              \u2261\u27e8 cong (\u03bb x \u2192 balanceUtxo + x + wdls) (+-assoc ref remDepTot fees) \u27e9 --\n            balanceUtxo + (ref + (remDepTot + fees)) + wdls\n              \u2261\u27e8 +-assoc balanceUtxo (ref + (remDepTot + fees)) wdls \u27e9 --\n            balanceUtxo + (ref + (remDepTot + fees) + wdls)\n              \u2261\u27e8 cong (balanceUtxo +_) (+-assoc ref (remDepTot + fees) wdls) \u27e9\n            balanceUtxo + (ref + ((remDepTot + fees) + wdls))\n              \u2261\u27e8 cong (\u03bb x \u2192 balanceUtxo + (ref + x)) (+-comm (remDepTot + fees) wdls) \u27e9\n            balanceUtxo + (ref + (wdls + (remDepTot + fees)))\n              \u2261\u02d8\u27e8 +-assoc balanceUtxo ref (wdls + (remDepTot + fees)) \u27e9\n            balanceUtxo + ref + (wdls + (remDepTot + fees))\n              \u2261\u02d8\u27e8 +-assoc (balanceUtxo + ref) wdls (remDepTot + fees) \u27e9\n            balanceUtxo + ref + wdls + (remDepTot + fees)\n              \u2261\u27e8 cong (_+ (remDepTot + fees)) ref-prop \u27e9\n            balanceUtxo' + txFee + txDonation + tot + (remDepTot + fees)\n              \u2261\u27e8 rearrange0 (balanceUtxo') h \u27e9\n            balanceUtxo' + (fees + txFee + getCoin deposits' + txDonation)\n              \u220e \u27e9\n      balanceUtxo' \u2115.+ (fees + txFee \u2115.+ getCoin deposits' \u2115.+ txDonation) \u2115.+ donations\n        \u2261t\u27e8\u27e9\n      balanceUtxo' \u2115.+ (fees + txFee) \u2115.+ getCoin deposits' \u2115.+ (txDonation \u2115.+ donations)\n        \u2261\u27e8 cong (balanceUtxo' + (fees + txFee) + getCoin deposits' \u2115.+_)\n         $ +-comm txDonation donations \u27e9\n      balanceUtxo' + (fees + txFee) + getCoin deposits' + (donations + txDonation)\n        \u220e\n\n  pov-scripts :  deposits' \u2261 updateDeposits pp txb deposits\n                 \u2192  isValid \u2261 true\n                 \u2192  cbalance utxo + fees + dep + donations + wdls * \u03c7(isValid)\n                    \u2261  cbalance ((utxo \u2223 txIns \u1d9c) \u222a\u02e1 outs txb)\n                       + (fees + txFee) + getCoin deposits' + (donations + txDonation)\n  pov-scripts h valid = pov-scripts-worker (cbalance utxo) (cbalance ((utxo \u2223 txIns \u1d9c) \u222a\u02e1 outs txb)) utxo-ref-prop h valid\n\n  pov-no-scripts :  isValid \u2261 false\n                    \u2192  cbalance utxo + fees + dep + donations + wdls * \u03c7(isValid)\n                       \u2261 cbalance (utxo \u2223 collateralInputs \u1d9c) + (fees + cbalance (utxo \u2223 collateralInputs)) + dep + donations\n  pov-no-scripts invalid = begin\n    cbalance utxo + fees + dep + donations + wdls * \u03c7(isValid) \u2261\u27e8 cong (\u03bb x \u2192 cbalance utxo + fees + dep + donations + wdls * \u03c7 x) invalid \u27e9\n    cbalance utxo + fees + dep + donations + wdls * 0 \u2261\u27e8 cong (cbalance utxo + fees + dep + donations +_ ) (*-zero\u02b3 wdls) \u27e9\n    cbalance utxo + fees + dep + donations + 0 \u2261\u27e8 +-identity\u02b3 _ \u27e9\n    cbalance utxo + fees + dep + donations \u2261\u27e8 cong (\u03bb x \u2192 x + dep + donations) $ begin\n      cbalance utxo \u2115.+ fees \u2261\u27e8 cong (_+ fees) (split-balance collateralInputs) \u27e9\n      cbalance (utxo \u2223 collateralInputs \u1d9c) \u2115.+ cbalance (utxo \u2223 collateralInputs) \u2115.+ fees \u2261t\u27e8\u27e9\n      cbalance (utxo \u2223 collateralInputs \u1d9c) \u2115.+ (cbalance (utxo \u2223 collateralInputs) \u2115.+ fees) \u2261\u27e8 cong (cbalance (utxo \u2223 collateralInputs \u1d9c) +_) (+-comm _ fees) \u27e9\n      cbalance (utxo \u2223 collateralInputs \u1d9c) \u2115.+ (fees \u2115.+ cbalance (utxo \u2223 collateralInputs)) \u220e \u27e9\n    cbalance (utxo \u2223 collateralInputs \u1d9c) + (fees + cbalance (utxo \u2223 collateralInputs)) + dep + donations\n    \u220e\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Utxo.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Algebra.Morphism              using (module MonoidMorphisms; IsMagmaHomomorphism)\nopen import Data.Integer as \u2124             using (\u2124)\nopen import Data.List.Relation.Unary.All  using (All)\nimport Data.Nat as \u2115\nopen import Data.Nat.Properties           hiding (_\u225f_)\nopen import Data.String.Base              using () renaming (_++_ to _+\u02e2_)\n\nopen import Prelude; open Equivalence\nopen import Ledger.Prelude hiding (\u2264-trans; \u2264-antisym; All); open Properties\n\nopen import Tactic.Cong                 using (cong!)\nopen import Tactic.EquationalReasoning  using (module \u2261-Reasoning)\nopen import stdlib-meta.Tactic.MonoidSolver.NonNormalising using (solve-macro)\n\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Script.Validation txs abs\nopen import Ledger.Conway.Specification.Certs govStructure\n\ninstance\n  _ = TokenAlgebra.Value-CommutativeMonoid tokenAlgebra\n  _ = +-0-monoid\n  _ = Functor-ComputationResult\n\ninstance\n  Computational-UTXOS : Computational _\u22a2_\u21c0\u2987_,UTXOS\u2988_ String\n  Computational-UTXOS = record {go} where\n    module go (\u0393 : UTxOEnv) (s : UTxOState) (tx : Tx)\n      (let open UTxOState s)\n      (let H-Yes , \u2047 H-Yes? = Scripts-Yes-premises {\u0393} {tx} {utxo} {deposits})\n      (let H-No  , \u2047 H-No?  = Scripts-No-premises  {\u0393} {tx} {utxo}) where\n      open Tx tx renaming (body to txb); open TxBody txb\n      open UTxOEnv \u0393 renaming (pparams to pp)\n      sLst = collectP2ScriptsWithContext pp tx utxo\n\n      computeProof =\n        case H-Yes? ,\u2032 H-No? of \u03bb where\n          (yes p , no _ ) \u2192 success (_ , (Scripts-Yes p))\n          (no _  , yes p) \u2192 success (_ , (Scripts-No p))\n          (_     , _    ) \u2192 failure \"isValid check failed\"\n\n      completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n      completeness _ (Scripts-Yes p) with H-No? | H-Yes?\n      ... | yes (_ , refl) | _     = case proj\u2082 p of \u03bb ()\n      ... | no _           | yes _ = refl\n      ... | no _           | no \u00acp = case \u00acp p of \u03bb ()\n      completeness _ (Scripts-No p) with H-Yes? | H-No?\n      ... | yes (_ , _ , refl) | _     = case proj\u2082 p of \u03bb ()\n      ... | no _               | yes _ = refl\n      ... | no _               | no \u00acp = case \u00acp p of \u03bb ()\n\ninstance\n  Computational-UTXO' : Computational _\u22a2_\u21c0\u2987_,UTXO\u2988_ String\n  Computational-UTXO' = record {Go}\n    where\n      module Go \u0393 s tx (let H , \u2047 H? = UTXO-premises {\u0393 = \u0393} {s = s} {tx = tx}) where\n\n        open Computational Computational-UTXOS\n          renaming (computeProof to computeProof'; completeness to completeness')\n\n        genErr : \u00ac H \u2192 String\n        genErr  \u00acp = case dec-de-morgan \u00acp of \u03bb where\n          (inj\u2081 a) \u2192 \"\u00ac TxBody.txIns (Tx.body tx) \u2262 \u2205\"\n          (inj\u2082 b) \u2192 case dec-de-morgan b of \u03bb where\n            (inj\u2081 a\u2081) \u2192 \"\u00ac TxBody.txIns (Tx.body tx) \u2286 dom (UTxOOf s)\"\n            (inj\u2082 b\u2081) \u2192 case dec-de-morgan b\u2081 of \u03bb where\n                (inj\u2081 a\u2081') \u2192 \"\u00ac refInputs \u2286 dom utxo \"\n                (inj\u2082 b\u2082') \u2192 case dec-de-morgan b\u2082' of \u03bb where\n                  (inj\u2081 a\u2082) \u2192 \"\u00ac inInterval (UTxOEnv.slot \u0393) (txvldt (Tx.body tx))\"\n                  (inj\u2082 b\u2082) \u2192 case dec-de-morgan b\u2082 of \u03bb where\n                    (inj\u2081 a\u2083) \u2192 \"\u00ac feesOK pp tx utxo\"\n                    (inj\u2082 b\u2083) \u2192 case dec-de-morgan b\u2083 of \u03bb where\n                        (inj\u2081 a\u2084) \u2192\n                          let\n                            pp = PParamsOf \u0393\n                            txb = TxBodyOf tx\n                            con = consumed pp s txb\n                            prod = produced pp s txb\n                            showValue = show \u2218 coin\n                          in\n                            ( \"\u00acconsumed (UTxOEnv.pparams \u0393) s (Tx.body tx) \u2261 produced (PParamsOf \u0393) s (Tx.body tx)\"\n                            +\u02e2 \"\\n  consumed =\\t\\t\" +\u02e2 showValue con\n                            +\u02e2 \"\\n    ins  =\\t\\t\" +\u02e2 showValue (balance (UTxOOf s \u2223 txb .TxBody.txIns))\n                            +\u02e2 \"\\n    mint =\\t\\t\" +\u02e2 showValue (TxBody.mint txb)\n                            +\u02e2 \"\\n    depositRefunds =\\t\" +\u02e2 showValue (inject (depositRefunds pp s txb))\n                            +\u02e2 \"\\n  produced =\\t\\t\" +\u02e2 showValue prod\n                            +\u02e2 \"\\n    outs =\\t\\t\" +\u02e2 showValue (balance $ outs txb)\n                            +\u02e2 \"\\n    fee  =\\t\\t\" +\u02e2 show (FeesOf tx)\n                            +\u02e2 \"\\n    newDeposits  =\\t\" +\u02e2 show (newDeposits pp s txb)\n                            +\u02e2 \"\\n    donation  =\\t\\t\" +\u02e2 show (DonationsOf txb)\n                            )\n                        (inj\u2082 b\u2084) \u2192 case dec-de-morgan b\u2084 of \u03bb where\n                          (inj\u2081 a\u2085) \u2192 \"\u00ac coin (TxBody.mint (Tx.body tx)) \u2261 0\"\n                          (inj\u2082 b\u2085) \u2192 case dec-de-morgan b\u2085 of \u03bb where\n                              (inj\u2081 a\u2086) \u2192 \"\u00ac((Tx.txsize tx) Data.Nat.Base.\u2264 maxTxSize (UTxOEnv.pparams \u0393))\"\n                              (inj\u2082 b\u2086) \u2192 case dec-de-morgan b\u2086 of \u03bb where\n                                (inj\u2081 a\u2087) \u2192 \"\u2200[ (_ , txout) \u2208 txOuts .proj\u2081 ] inject (utxoEntrySize txout * coinsPerUTxOByte pp) \u2264\u1d57 getValue txout\"\n                                (inj\u2082 b\u2087) \u2192 case dec-de-morgan b\u2087 of \u03bb where\n                                    (inj\u2081 a\u2088) \u2192 \"\u2200[ (_ , txout) \u2208 txOuts .proj\u2081 ] serSize (getValue txout) \u2264 maxValSize pp\"\n                                    (inj\u2082 b\u2088) \u2192 case dec-de-morgan b\u2088 of \u03bb where\n                                      (inj\u2081 a\u2089) \u2192 \"\u2200[ (a , _) \u2208 range txOuts ] Sum.All (const \u22a4) (\u03bb a \u2192 a .BootstrapAddr.attrsSize \u2264 64) a\"\n                                      (inj\u2082 _) \u2192 \"something else broke\"\n\n        computeProofH : Dec H \u2192 ComputationResult String (\u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s')\n        computeProofH (yes (x , y , z , e , k , l , m , c , v , j , n , o , p , q , r , t , u)) =\n            map\u2082\u2032 (UTXO-inductive\u22ef _ _ _ x y z e k l m c v j n o p q r t u) &lt;$&gt; computeProof' \u0393 s tx\n        computeProofH (no \u00acp) = failure $ genErr \u00acp\n\n        computeProof : ComputationResult String (\u2203[ s' ] \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s')\n        computeProof = computeProofH H?\n\n        completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s' \u2192 map proj\u2081 computeProof \u2261 success s'\n        completeness s' (UTXO-inductive\u22ef _ _ _ x y z w k l m c v j n o p q r t u h) with H?\n        ... | no \u00acp = \u22a5-elim $ \u00acp (x , y , z , w , k , l , m , c , v , j , n , o , p , q , r , t , u)\n        ... | yes _ with computeProof' \u0393 s tx | completeness' _ _ _ _ h\n        ... | success _ | refl = refl\n\nopen Computational \u2983...\u2984\n\nopaque\n  unfolding List-Model\n  Computational-UTXO : Computational _\u22a2_\u21c0\u2987_,UTXO\u2988_ String\n  Computational-UTXO = Computational-UTXO'\n\nprivate variable\n  tx                    : Tx\n  \u0393                     : UTxOEnv\n  utxoState utxoState'  : UTxOState\n\nUTXO-step : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 ComputationResult String UTxOState\nUTXO-step = compute \u2983 Computational-UTXO \u2984\n\nUTXO-step-computes-UTXO  :  UTXO-step \u0393 utxoState tx \u2261 success utxoState'\n                         \u21d4  \u0393 \u22a2 utxoState \u21c0\u2987 tx ,UTXO\u2988 utxoState'\nUTXO-step-computes-UTXO = \u2261-success\u21d4STS \u2983 Computational-UTXO \u2984\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html","title":"GenMinspend","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Utxo.Properties.GenMinSpend\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Prelude; open Equivalence\nopen import Ledger.Prelude hiding (\u2264-trans; \u2264-antisym; All); open Properties\nopen import Data.List.Relation.Unary.All  using (All)\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Data.Nat.Properties hiding (_\u225f_)\n\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#general-minimum-spending-condition","title":"General Minimum Spending Condition","text":"<pre>isRefundCert : DCert \u2192 Bool\nisRefundCert (dereg c _) = true\nisRefundCert (deregdrep c _) = true\nisRefundCert _ = false\n\nnoRefundCert : List DCert \u2192 Type _\nnoRefundCert l = All (\u03bb cert \u2192 isRefundCert cert \u2261 false) l\n\nopaque\n  unfolding List-Model\n  unfolding finiteness\n  fin\u2218list[] : {A : Type} \u2192 proj\u2081 (finiteness{A = A} \u2205) \u2261 []\n  fin\u2218list[] = refl\n  fin\u2218list\u2237[] : {A : Type} {a : A} \u2192 proj\u2081 (finiteness \u2774 a \u2775) \u2261 [ a ]\n  fin\u2218list\u2237[] = refl\n\ncoin\u2205 : getCoin{A = Deposits} \u2205 \u2261 0\ncoin\u2205 = begin\n  foldr (\u03bb x \u2192 (proj\u2082 x) +_) 0 (deduplicate _\u225f_ (proj\u2081 (finiteness \u2205)))\n    \u2261\u27e8 cong (\u03bb u \u2192 (foldr (\u03bb x \u2192 (proj\u2082 x) +_) 0 (deduplicate _\u225f_ u))) fin\u2218list[] \u27e9\n  foldr (\u03bb (x : DepositPurpose \u00d7 Coin) \u2192 (proj\u2082 x) +_) 0 (deduplicate _\u225f_ [])\n    \u2261\u27e8 cong (\u03bb u \u2192 (foldr (\u03bb (x : DepositPurpose \u00d7 Coin) \u2192 (proj\u2082 x) +_) 0  u))\n            {x = deduplicate _\u225f_ []} {y = []} refl \u27e9\n  foldr (\u03bb (x : DepositPurpose \u00d7 Coin) \u2192 (proj\u2082 x) +_) 0 []\n    \u2261\u27e8 refl \u27e9\n  0 \u220e\n  where open Prelude.\u2261-Reasoning\n\ngetCoin-singleton : ((dp , c) : DepositPurpose \u00d7 Coin) \u2192 indexedSum\u1d5b' id \u2774 (dp , c) \u2775 \u2261 c\ngetCoin-singleton _ = indexedSum-singleton' {A = DepositPurpose \u00d7 Coin} {f = proj\u2082} (finiteness _)\n\nmodule _ -- ASSUMPTION --\n         (gc-hom : (d\u2081 d\u2082 : Deposits) \u2192 getCoin (d\u2081 \u222a\u207a d\u2082) \u2261 getCoin d\u2081 + getCoin d\u2082)\n  where\n  \u222a\u207asingleton\u2261 : {deps : Deposits} {(dp , c) : DepositPurpose \u00d7 Coin}\n                 \u2192 getCoin (deps \u222a\u207a \u2774 (dp , c) \u2775\u1d50) \u2261 getCoin deps + c\n  \u222a\u207asingleton\u2261 {deps} {(dp , c)} = begin\n    getCoin (deps \u222a\u207a \u2774 (dp , c) \u2775)\n      \u2261\u27e8 gc-hom deps \u2774 (dp , c) \u2775 \u27e9\n    getCoin deps + getCoin{A = Deposits} \u2774 (dp , c) \u2775\n      \u2261\u27e8 cong (getCoin deps +_) (getCoin-singleton (dp , c)) \u27e9\n    getCoin deps + c\n      \u220e\n    where open Prelude.\u2261-Reasoning\n\n  module _ {deposits : Deposits} {txid : TxId} {gaDep : Coin} where\n\n    \u2264updatePropDeps : (props : List GovProposal)\n      \u2192 getCoin deposits \u2264 getCoin (updateProposalDeposits props txid gaDep deposits)\n    \u2264updatePropDeps [] = \u2264-reflexive refl\n    \u2264updatePropDeps (x \u2237 props) = \u2264-trans (\u2264updatePropDeps props)\n                                          (\u2264-trans (m\u2264m+n _ _)\n                                                   (\u2264-reflexive $ sym $ \u222a\u207asingleton\u2261))\n    updatePropDeps\u2261 : (ps : List GovProposal)\n      \u2192 getCoin (updateProposalDeposits ps txid gaDep deposits) - getCoin deposits \u2261 (length ps) * gaDep\n    updatePropDeps\u2261 [] = n\u2238n\u22610 (getCoin deposits)\n    updatePropDeps\u2261 (_ \u2237 ps) = let\n      upD = updateProposalDeposits ps txid gaDep deposits in\n      begin\n        getCoin (upD \u222a\u207a \u2774 GovActionDeposit (txid , length ps) , gaDep \u2775\u1d50) \u2238 getCoin deposits\n          \u2261\u27e8 cong (_\u2238 getCoin deposits) \u222a\u207asingleton\u2261 \u27e9\n        getCoin upD + gaDep \u2238 getCoin deposits\n          \u2261\u27e8 +-\u2238-comm _ (\u2264updatePropDeps ps) \u27e9\n        (getCoin upD \u2238 getCoin deposits) + gaDep\n          \u2261\u27e8 cong (_+ gaDep) (updatePropDeps\u2261 ps) \u27e9\n        (length ps) * gaDep + gaDep\n          \u2261\u27e8 +-comm ((length ps) * gaDep) gaDep \u27e9\n        gaDep + (length ps) * gaDep\n          \u220e\n        where open Prelude.\u2261-Reasoning\n\n  \u2264certDeps  :  {d : Deposits} {(dp , c) : DepositPurpose \u00d7 Coin}\n             \u2192  getCoin d \u2264 getCoin (d \u222a\u207a \u2774 (dp , c) \u2775)\n\n  \u2264certDeps {d} = begin\n    getCoin d                      \u2264\u27e8 m\u2264m+n (getCoin d) _ \u27e9\n    getCoin d + _                  \u2261\u27e8 sym \u222a\u207asingleton\u2261 \u27e9\n    getCoin (d \u222a\u207a \u2774 _ \u2775)           \u220e\n    where open \u2264-Reasoning\n\n\n  \u2264certDeps\u222a\u02e1 : {d : Deposits} {(dp , c) : DepositPurpose \u00d7 Coin}\n              \u2192 getCoin d \u2264 getCoin (d \u222a\u02e1 \u2774 (dp , c) \u2775)\n\n  \u2264certDeps\u222a\u02e1 {d} {dp , c} with dp \u2208? dom d\n  ... | yes dp\u2208 =\n      from \u2264\u21d4&lt;\u2228\u2248 $ inj\u2082 $\n        indexedSum\u1d5b'-cong {C = Coin} {x = d} {y = d \u222a\u02e1 \u2774 dp , c \u2775} $\n        begin\n          d \u02e2 \u2248\u27e8 \u2261\u1d49.sym $ singleton-\u2208-\u222a\u02e1 {m = d} dp\u2208 \u27e9\n          (d \u222a\u02e1 \u2774 (dp , c) \u2775) \u02e2\n        \u220e\n    where\n      open import Relation.Binary.Structures using (IsEquivalence; IsPreorder)\n      open import Relation.Binary.Reasoning.Setoid (\u2261\u1d49-Setoid {A = DepositPurpose \u00d7 Coin})\n      module \u2261\u1d49 = IsEquivalence \u2261\u1d49-isEquivalence\n\n  ... | no \u00acp = begin\n      getCoin d             \u2264\u27e8 m\u2264m+n (getCoin d) _ \u27e9\n      getCoin d + _         \u2261\u27e8 sym $ indexedSum\u1d50-\u222a\n                                 {X = d \u1da0\u1d50}\n                                 {Y = \u2774 dp , c \u2775 \u1da0\u1d50}\n                                 {f = proj\u2082}\n                                 (disjoint-sing \u00acp)\n                             \u27e9\n      indexedSum\u1d50 proj\u2082 ((d \u1da0\u1d50) \u222a\u02e1\u1da0 (\u2774 dp , c \u2775 \u1da0\u1d50))\n                            \u2261\u27e8 sym $ indexedSum\u1d50-\u222a\u02e1-\u222a\u02e1\u1da0 {B = \u22a4} d \u2774 dp , c \u2775 \u27e9\n      getCoin (d \u222a\u02e1 \u2774 dp , c \u2775)\n      \u220e\n    where\n      open \u2264-Reasoning\n\n      disjoint-sing : dp \u2209 dom d \u2192 disjoint (dom d) (dom \u2774 dp , c \u2775\u02e2)\n      disjoint-sing dp\u2209d a\u2208d a\u2208sing\n        rewrite from \u2208-dom-singleton-pair a\u2208sing = dp\u2209d a\u2208d\n\n  \u2264updateCertDeps : (cs : List DCert) {pp : PParams} {deposits : Deposits}\n    \u2192 noRefundCert cs\n    \u2192 getCoin deposits \u2264 getCoin (updateCertDeposits pp cs deposits)\n  \u2264updateCertDeps [] nrf = \u2264-reflexive refl\n  \u2264updateCertDeps (reg c v \u2237 cs) {pp} {deposits} (_ All.\u2237 nrf) =\n    \u2264-trans \u2264certDeps (\u2264updateCertDeps cs {pp} {deposits \u222a\u207a \u2774 CredentialDeposit c , pp .PParams.keyDeposit \u2775} nrf)\n  \u2264updateCertDeps (delegate c _ _ v \u2237 cs) {pp} {deposits} (_ All.\u2237 nrf) =\n    \u2264-trans \u2264certDeps (\u2264updateCertDeps cs {pp} {deposits \u222a\u207a \u2774 CredentialDeposit c , v \u2775} nrf)\n  \u2264updateCertDeps (regpool _ _ \u2237 cs) {_} {deposits} (_ All.\u2237 nrf) =\n    \u2264-trans (\u2264certDeps\u222a\u02e1 {d = deposits}) (\u2264updateCertDeps cs nrf)\n  \u2264updateCertDeps (retirepool _ _ \u2237 cs)    (_ All.\u2237 nrf) = \u2264updateCertDeps cs nrf\n  \u2264updateCertDeps (regdrep _ _ _ \u2237 cs)     (_ All.\u2237 nrf) = \u2264-trans \u2264certDeps (\u2264updateCertDeps cs nrf)\n  \u2264updateCertDeps (ccreghot _ _ \u2237 cs)      (_ All.\u2237 nrf) = \u2264updateCertDeps cs nrf\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#main-theorem-general-minimum-spending-condition","title":"Main Theorem: General Minimum Spending Condition","text":"<pre>  private variable\n    tx                    : Tx\n    utxo utxo'            : UTxO\n    \u0393                     : UTxOEnv\n    fees fees'            : Fees\n    utxoState             : UTxOState\n    donations donations'  : Donations\n    deposits deposits'    : Deposits\n</pre> <pre>  gmsc :  let open Tx tx renaming (body to txb); open TxBody txb\n              pp = UTxOEnv.pparams \u0393; open PParams pp\n              open UTxOState utxoState\n                renaming (utxo to st; fees to fs; deposits to deps; donations to dons)\n          in\n    \u0393 \u22a2  $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#6884}{\\htmlId{6961}{\\htmlClass{Function}{\\text{st}}}}\\,   \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#6896}{\\htmlId{6968}{\\htmlClass{Function}{\\text{fs}}}}\\,   \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#6912}{\\htmlId{6975}{\\htmlClass{Function}{\\text{deps}}}}\\,   \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#6931}{\\htmlId{6984}{\\htmlClass{Function}{\\text{dons}}}}\\,   \\end{pmatrix}$ \u21c0\u2987 tx ,UTXO\u2988\n         $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#6469}{\\htmlId{7017}{\\htmlClass{Generalizable}{\\text{utxo'}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#6538}{\\htmlId{7026}{\\htmlClass{Generalizable}{\\text{fees'}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#6651}{\\htmlId{7035}{\\htmlClass{Generalizable}{\\text{deposits'}}}}\\,  \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.Properties.GenMinSpend.html#6614}{\\htmlId{7048}{\\htmlClass{Generalizable}{\\text{donations'}}}}\\,  \\end{pmatrix}$\n\n    \u2192 noRefundCert txCerts -- FINAL ASSUMPTION --\n\n       -------------------------------------------------------------------\n    \u2192  coin (consumed pp utxoState txb) \u2265 length txGovProposals * govActionDeposit\n\n  gmsc step@(UTXO-inductive\u22ef tx \u0393 utxoState _ _ _ _ _ _ c\u2261p cmint\u22610 _ _ _ _ _ _ _ _ _ _) nrf =\n    begin\n    length txGovProposals * govActionDeposit\n      \u2261\u02d8\u27e8 updatePropDeps\u2261 txGovProposals \u27e9\n    getCoin (updateProposalDeposits txGovProposals txId govActionDeposit deps) \u2238 getCoin deps\n      \u2264\u27e8 \u2238-mono\u02e1-\u2264 (getCoin deps) (\u2264updateCertDeps txCerts nrf) \u27e9\n    getCoin (updateDeposits pp txb deps) - getCoin deps\n      \u2261\u27e8 \u2238\u2261posPart\u2296 {getCoin (updateDeposits pp txb deps)} {getCoin deps} \u27e9\n    newDeps\n      \u2264\u27e8 m\u2264n+m newDeps (coin balOut + txFee + txDonation) \u27e9\n    coin balOut + txFee + txDonation + newDeps\n      \u2261\u27e8 +-assoc (coin balOut + txFee) txDonation newDeps \u27e9\n    coin balOut + txFee + (txDonation + newDeps)\n      \u2261\u27e8 cong (coin balOut + txFee +_) (+-comm txDonation newDeps) \u27e9\n    coin balOut + txFee + (newDeps + txDonation)\n      \u2261\u02d8\u27e8 +-assoc (coin balOut + txFee) newDeps txDonation \u27e9\n    coin balOut + txFee + newDeps + txDonation\n      \u2261\u02d8\u27e8 cong (\u03bb x \u2192 x + newDeps + txDonation) coin-inject-lemma \u27e9\n    coin (balOut + inject txFee) + newDeps + txDonation\n      \u2261\u02d8\u27e8 cong (_+ txDonation) coin-inject-lemma \u27e9\n    coin (balOut + inject txFee + inject newDeps) + txDonation\n      \u2261\u02d8\u27e8 coin-inject-lemma \u27e9\n    coin (balOut + inject txFee + inject newDeps + inject txDonation)\n      \u2261\u02d8\u27e8 cong coin c\u2261p \u27e9\n    coin (balIn + mint + inject refunds + inject wdrls) \u220e\n    where\n    open \u2264-Reasoning\n    pp : PParams\n    pp = UTxOEnv.pparams \u0393; open PParams pp\n    open Tx tx renaming (body to txb); open TxBody txb\n    open UTxOState utxoState renaming (utxo to st; fees to fs; deposits to deps; donations to dons)\n\n    newDeps refunds wdrls : Coin\n    newDeps = newDeposits pp utxoState txb\n    refunds = depositRefunds pp utxoState txb\n    wdrls = getCoin txWithdrawals\n\n    balIn balOut : Value\n    balIn = balance (st \u2223 txIns)\n    balOut = balance (outs txb)\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.MinSpend.html","title":"MinSpend","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Utxo.Properties.MinSpend\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Conway.Specification.Chain txs abs\nopen import Ledger.Conway.Specification.Enact govStructure\nopen import Ledger.Conway.Specification.Epoch txs abs\nopen import Ledger.Conway.Specification.Ledger txs abs\nopen import Ledger.Prelude hiding (\u2264-trans; \u2264-antisym; All)\nopen import Ledger.Conway.Specification.Properties txs abs using (validTxIn\u2082)\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Utxo.Properties.GenMinSpend txs abs\n\nopen import Data.List.Relation.Unary.All  using (All)\nopen import Data.Nat.Properties           hiding (_\u225f_)\n\nmodule _\n  where\n\n</pre> <p> Theorem (general spend lower bound).</p> <p>Informally.</p> <p>Let <code>tx</code> : <code>Tx</code> be a valid transaction and let <code>txCerts</code> be its list of <code>DCerts</code>.  Denote by <code>noRefundCert</code> <code>txCerts</code> the assertion that no element in <code>txCerts</code> is one of the two refund types (i.e., an element of <code>l</code> is neither a <code>dereg</code> nor a <code>deregdrep</code>).  Let <code>s</code>, <code>s'</code> : <code>UTxOState</code> be two UTxO states. If <code>s</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,UTXO\u2988</code> <code>s'</code> and if <code>noRefundCert</code> <code>txCerts</code>, then the coin consumed by <code>tx</code> is at least the sum of the governance action deposits of the proposals in <code>tx</code>.</p> <p>Formally.</p> <pre>module _\n  -- ASSUMPTION --\n  (gc-hom : (d\u2081 d\u2082 : DepositPurpose \u21c0 Coin) \u2192 getCoin (d\u2081 \u222a\u207a d\u2082) \u2261 getCoin d\u2081 + getCoin d\u2082)\n  {\u0393 : UTxOEnv}\n  where\n    open module \u0393 = UTxOEnv \u0393\n    govActionDeps : Coin\n    govActionDeps = PParams.govActionDeposit \u0393.pparams\n\n    utxoMinSpend : {tx : Tx} {s s' : UTxOState}\n      \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s'\n      \u2192 noRefundCert (DCertsOf tx)\n      \u2192 coin (consumed _ s (TxBodyOf tx)) \u2265 length (GovProposalsOf tx) * govActionDeps\n</pre> <p>Proof.</p> <pre>    utxoMinSpend step@(UTXO-inductive\u22ef tx \u0393 utxoSt _ _ _ _ _ _ c\u2261p cmint\u22610 _ _ _ _ _ _ _ _ _ _) nrf =\n      begin\n      length txGovProposals * govActionDeps\n        \u2261\u02d8\u27e8 updatePropDeps\u2261 gc-hom txGovProposals \u27e9\n      getCoin (updateProposalDeposits txGovProposals txId (govActionDeps) deposits) \u2238 getCoin deposits\n        \u2264\u27e8 \u2238-mono\u02e1-\u2264 (getCoin deposits) (\u2264updateCertDeps gc-hom txCerts nrf) \u27e9\n      getCoin (updateDeposits (PParamsOf \u0393) txb deposits) - getCoin deposits\n        \u2261\u27e8 \u2238\u2261posPart\u2296 {getCoin (updateDeposits (PParamsOf \u0393) txb deposits)} {getCoin deposits} \u27e9\n      newDeps\n        \u2264\u27e8 m\u2264n+m newDeps (coin balOut + txFee + txDonation) \u27e9\n      coin balOut + txFee + txDonation + newDeps\n        \u2261\u27e8 +-assoc (coin balOut + txFee) txDonation newDeps \u27e9\n      coin balOut + txFee + (txDonation + newDeps)\n        \u2261\u27e8 cong (coin balOut + txFee +_) (+-comm txDonation newDeps) \u27e9\n      coin balOut + txFee + (newDeps + txDonation)\n        \u2261\u02d8\u27e8 +-assoc (coin balOut + txFee) newDeps txDonation \u27e9\n      coin balOut + txFee + newDeps + txDonation\n        \u2261\u02d8\u27e8 cong (\u03bb x \u2192 x + newDeps + txDonation) coin-inject-lemma \u27e9\n      coin (balOut + inject txFee) + newDeps + txDonation\n        \u2261\u02d8\u27e8 cong (_+ txDonation) coin-inject-lemma \u27e9\n      coin (balOut + inject txFee + inject newDeps) + txDonation\n        \u2261\u02d8\u27e8 coin-inject-lemma \u27e9\n      coin (balOut + inject txFee + inject newDeps + inject txDonation)\n        \u2261\u02d8\u27e8 cong coin c\u2261p \u27e9\n      coin (balIn + mint + inject refunds + inject wdrls) \u220e\n      where\n      open \u2264-Reasoning\n      open Tx tx renaming (body to txb); open TxBody txb\n      open UTxOState utxoSt\n\n      newDeps refunds wdrls : Coin\n      newDeps = newDeposits (PParamsOf \u0393) utxoSt txb\n      refunds = depositRefunds (PParamsOf \u0393) utxoSt txb\n      wdrls = getCoin (WithdrawalsOf tx)\n\n      balIn balOut : Value\n      balIn = balance (utxo \u2223 txIns)\n      balOut = balance (outs txb)\n</pre> <p> Theorem (spend lower bound for proposals).</p> <p>Preliminary remarks.</p> <ol> <li> <p>Define <code>noRefundCert</code> <code>l</code> and     <code>pp</code> as in the \"min spend\" theorem above.</p> </li> <li> <p>Given a ledger state <code>ls</code> and a transaction     <code>tx</code>, denote by     <code>validTxIn\u2082</code> <code>tx</code> the assertion that there exists     ledger state     <code>ls'</code> such that <code>ls</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,LEDGER\u2988</code> <code>ls'</code>.</p> </li> <li> <p>Assume the following additive property of the <code>\u222a\u207a</code> operator holds: </p> </li> </ol> <pre>\nmodule _\n    ( indexedSum-\u222a\u207a-hom :  {A V : Type}\n                           \u2983 _ : DecEq A \u2984 \u2983 _ : DecEq V \u2984\n                           \u2983 _ : CommutativeMonoid 0\u2113 0\u2113 V \u2984\n                           (d\u2081 d\u2082 : A \u21c0 V)\n       \u2192\n</pre> <pre>\n                           \u2211[ x \u2190 d\u2081 \u222a\u207a d\u2082 ] x \u2261 \u2211[ x \u2190 d\u2081 ] x \u25c7 \u2211[ x \u2190 d\u2082 ] x\n</pre> <pre>\n    )\n  where\n  open import Ledger.Conway.Specification.Utxow txs abs\n  open ChainState; open NewEpochState; open EpochState\n  open LState; open EnactState;  open PParams\n</pre> <p>Informally.</p> <p>Let <code>tx</code> : <code>Tx</code> be a valid transaction and let <code>cs</code> : <code>ChainState</code> be a  chain state. If the condition <code>validTxIn\u2082</code> <code>tx</code> (described above) holds, then the coin consumed by <code>tx</code> is at least the sum of the governance action deposits of the proposals in <code>tx</code>.</p> <p>Formally.</p> <pre>  propose-minSpend :  {slot : Slot} {tx : Tx} {cs : ChainState}\n                      ( let  pp      = PParamsOf cs\n                             utxoSt  = UTxOStateOf cs )\n</pre> <pre>\n    ( open Tx tx )\n    ( open TxBody body )\n</pre> <pre>    \u2192 noRefundCert txCerts\n    \u2192 validTxIn\u2082 cs slot tx\n    \u2192 coin (consumed pp utxoSt body) \u2265 length txGovProposals * pp .govActionDeposit\n</pre> <p>Proof.</p> <pre>  propose-minSpend noRef valid = case valid of \u03bb where\n    (_ , LEDGER-V (_ , UTXOW\u21d2UTXO x , _ , _)) \u2192 utxoMinSpend indexedSum-\u222a\u207a-hom x noRef\n    (_ , LEDGER-I (_ , UTXOW\u21d2UTXO x))         \u2192 utxoMinSpend indexedSum-\u222a\u207a-hom x noRef\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.PoV.html","title":"PoV","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Utxo.Properties.PoV\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs)\n  where\n\nopen import Ledger.Conway.Specification.Certs govStructure\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Utxo.Properties.Base txs abs public\nopen UTxOState; open Tx; open TxBody\n</pre> <p>Lemma (The <code>UTXO</code> rule preserves value).</p> <p>Informally.</p> <p>Let <code>s</code> and <code>s'</code> be <code>UTxOStates</code>, let <code>tx</code> : <code>Tx</code> be a fresh transaction with withdrawals <code>txWithdrawals</code>, and suppose <code>s</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,UTXO\u2988</code> <code>s'</code>. If <code>tx</code> is valid.  Then the coin value of <code>s'</code> is equal to the sum of the coin values of <code>s</code> and <code>txWithdrawals</code>. If <code>tx</code> is not valid, then the coin values of <code>s</code> and <code>s'</code> are equal.  We can express this concisely as follows:</p> <pre>getCoin s + getCoin (wdrlsOf tx) * \u03c7 (tx .isValid) \u2261 getCoin s'\n</pre> <p>where <code>\u03c7</code> : <code>Bool</code> \u2192 \\(\\{0, 1\\}\\) is the characteristic function, which returns 0 for false and 1 for true.</p> <p>Formally.</p> <pre>UTXOpov : {\u0393 : UTxOEnv} {tx : Tx} {s s' : UTxOState}\n  \u2192 TxIdOf tx \u2209 map\u02e2 proj\u2081 (dom (UTxOOf s))\n  \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s'\n  \u2192 getCoin s + getCoin (WithdrawalsOf tx) * \u03c7 (tx .isValid) \u2261 getCoin s'\n</pre> <p>Proof.</p> <pre>\nUTXOpov h' step@(UTXO-inductive\u22ef _ \u0393 _ _ _ _ _ _ _ newBal noMintAda _ _ _ _ _ _ _ _ _ (Scripts-Yes (_ , _ , valid)))\n  = pov-scripts step h' refl valid\n\nUTXOpov h' step@(UTXO-inductive\u22ef _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ (Scripts-No (_ , invalid)))\n  = pov-no-scripts step h' invalid\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Utxo.Properties where\n\nopen import Ledger.Conway.Specification.Utxo.Properties.Base\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational\nopen import Ledger.Conway.Specification.Utxo.Properties.GenMinSpend\nopen import Ledger.Conway.Specification.Utxo.Properties.MinSpend\nopen import Ledger.Conway.Specification.Utxo.Properties.PoV\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.html","title":"UTxO","text":"<p>The UTxO transition system is built up from a number of smaller parts defined in this section, culminating in the <code>UTXO</code> rule given in the final subsection below (UTXO Inference Rule).</p>"},{"location":"Ledger.Conway.Specification.Utxo.html#sec:accounting","title":"Accounting","text":"<p>The deposits have been reworked since the original Shelley design. We now track the amount of every deposit individually. This fixes an issue in the original design: An increase in deposit amounts would allow an attacker to make lots of deposits before that change and refund them after the change. The additional funds necessary would have been provided by the treasury. Since changes to protocol parameters were (and still are) known publicly and guaranteed before they are enacted, this comes at zero risk for an attacker. This means the deposit amounts could realistically never be increased. This issue is gone with the new design. (See also Corduan22.)</p> <pre>{-# OPTIONS --safe #-}\n\nopen import Algebra              using (CommutativeMonoid)\nopen import Data.Nat.Properties  using (+-0-monoid)\nimport Data.Maybe as M\nimport Data.Sum.Relation.Unary.All as Sum\nimport Data.Integer as \u2124\nimport Data.Rational as \u211a\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Utxo\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Script.Validation txs abs\nopen import Ledger.Conway.Specification.Fees txs using (scriptsCost)\nopen import Ledger.Conway.Specification.Certs govStructure\n\ninstance\n  _ = +-0-monoid\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.html#sec:functions-supporting-utxo-rules","title":"Functions supporting UTxO rules","text":"<p>This section defines types and functions needed for the UTxO transition system.</p> <pre>totExUnits : Tx \u2192 ExUnits\ntotExUnits tx = \u2211[ (_ , eu) \u2190 tx .wits .txrdmrs ] eu\n</pre> <pre>  where open Tx; open TxWitnesses\n\n-- utxoEntrySizeWithoutVal = 27 words (8 bytes)\nutxoEntrySizeWithoutVal : MemoryEstimate\nutxoEntrySizeWithoutVal = 8\n\nutxoEntrySize : TxOut\u02b0 \u2192 MemoryEstimate\nutxoEntrySize o = utxoEntrySizeWithoutVal + size (getValue\u02b0 o)\n\nopen PParams\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.html#sec:utxo-transition-system-types","title":"UTxO transition system types","text":"<p>As its name indicates, <code>DepositPurpose</code> specifies the purpose of a deposit.  Deposits are stored in the <code>deposits</code> field of the <code>UTxOState</code> type defined in this section. (The <code>DepositPurpose</code> and <code>Deposits</code> types are defined in the Deposit Types section of the <code>Certs</code> module.)</p> <p>UTxO environment</p> <pre>\nrecord UTxOEnv : Type where\n  field\n    slot      : Slot\n    pparams   : PParams\n    treasury  : Treasury\n</pre> <p>UTxO states</p> <pre>\nrecord UTxOState : Type where\n</pre> <pre>  constructor \u27e6_,_,_,_\u27e7\u1d58\n</pre> <pre>  field\n    utxo       : UTxO\n    fees       : Fees\n    deposits   : Deposits\n    donations  : Donations\n</pre> <pre>record HasUTxOState {a} (A : Type a) : Type a where\n  field UTxOStateOf : A \u2192 UTxOState\nopen HasUTxOState \u2983...\u2984 public\n\ninstance\n  HasPParams-UTxOEnv : HasPParams UTxOEnv\n  HasPParams-UTxOEnv .PParamsOf = UTxOEnv.pparams\n\n  HasUTxO-UTxOState : HasUTxO UTxOState\n  HasUTxO-UTxOState .UTxOOf = UTxOState.utxo\n\n  HasFee-UTxOState : HasFees UTxOState\n  HasFee-UTxOState .FeesOf = UTxOState.fees\n\n  HasDeposits-UTxOState : HasDeposits UTxOState\n  HasDeposits-UTxOState .DepositsOf = UTxOState.deposits\n\n  HasDonations-UTxOState : HasDonations UTxOState\n  HasDonations-UTxOState .DonationsOf = UTxOState.donations\n\n  unquoteDecl HasCast-UTxOEnv HasCast-UTxOState = derive-HasCast\n    ( (quote UTxOEnv   , HasCast-UTxOEnv  ) \u2237\n    [ (quote UTxOState , HasCast-UTxOState) ])\n</pre> <p>UTxO transitions</p> <pre>data _\u22a2_\u21c0\u2987_,UTXO\u2988_ : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 UTxOState \u2192 Type\n</pre> <p>(The main constructor of this type, <code>UTXO-inductive</code>, is defined in the UTXO Inference Rule subsection below.)</p>"},{"location":"Ledger.Conway.Specification.Utxo.html#functions-used-in-utxo-rules","title":"Functions used in UTxO rules","text":"<p>Here we define, among other things,</p> <ul> <li> <p>the <code>outs</code> function, which creates the unspent outputs generated by    a transaction; it maps the transaction id and output index to the output;</p> </li> <li> <p>the <code>balance</code> function, which calculates sum total of all the coin in a    given UTxO;</p> </li> <li> <p>the <code>minfee</code> function, which includes the cost for reference    scripts, calculated using the <code>scriptsCost</code> function    defined in the Fees module.</p> </li> </ul> <pre>module _ (let open Tx; open TxBody; open TxWitnesses) where opaque\n</pre> <pre>  outs : TxBody \u2192 UTxO\n  outs tx = mapKeys (tx .txId ,_) (tx .txOuts)\n\n  balance : UTxO \u2192 Value\n  balance utxo = \u2211[ x \u2190 mapValues txOutHash utxo ] getValue\u02b0 x\n\n  cbalance : UTxO \u2192 Coin\n  cbalance utxo = coin (balance utxo)\n\n  refScriptsSize : UTxO \u2192 Tx \u2192 \u2115\n  refScriptsSize utxo tx = sum (map scriptSize (setToList (refScripts tx utxo)))\n\n  minfee : PParams \u2192 UTxO \u2192 Tx \u2192 Coin\n  minfee pp utxo tx  = pp .a * tx .txsize + pp .b\n                     + txscriptfee (pp .prices) (totExUnits tx)\n                     + scriptsCost pp (refScriptsSize utxo tx)\n</pre> <pre>instance\n  HasCoin-UTxO : HasCoin UTxO\n  HasCoin-UTxO .getCoin = cbalance\n</pre> <pre>certDeposit : DCert \u2192 PParams \u2192 Deposits\ncertDeposit (delegate c _ _ v) _   = \u2774 CredentialDeposit c , v \u2775\ncertDeposit (reg c _)          pp  = \u2774 CredentialDeposit c , pp .keyDeposit \u2775\ncertDeposit (regpool kh _)     pp  = \u2774 PoolDeposit kh , pp .poolDeposit \u2775\ncertDeposit (regdrep c v _)    _   = \u2774 DRepDeposit c , v \u2775\ncertDeposit _                  _   = \u2205\n\ncertRefund : DCert \u2192 \u2119 DepositPurpose\ncertRefund (dereg c _)      = \u2774 CredentialDeposit c \u2775\ncertRefund (deregdrep c _)  = \u2774 DRepDeposit c \u2775\ncertRefund _                = \u2205\n</pre> <p>The type <code>ValidCertDeposits</code> has the following signature:</p> <pre>data ValidCertDeposits (pp : PParams) (deps : Deposits) : List DCert \u2192 Set\n</pre> <p>Inhabitants of this type are constructed in one of eight ways, corresponding to seven certificate types plus one for an empty list of certificates.  Suffice it to say that <code>ValidCertDeposits</code> is used to check the validity of the deposits in a transaction so that the function <code>updateCertDeposits</code> can correctly register and deregister deposits in the UTxO state based on the certificates in the transaction.</p> <pre>  where\n  []         : ValidCertDeposits pp deps []\n  delegate   : \u2200 {c del kh v certs}\n             \u2192 ValidCertDeposits pp (deps \u222a\u207a \u2774 CredentialDeposit c , v \u2775) certs\n             \u2192 ValidCertDeposits pp deps (delegate c del kh v \u2237 certs)\n  regpool    : \u2200 {kh p certs}\n             \u2192 ValidCertDeposits pp (deps \u222a\u207a \u2774 PoolDeposit kh , pp .poolDeposit \u2775) certs\n             \u2192 ValidCertDeposits pp deps (regpool kh p \u2237 certs)\n  regdrep    : \u2200 {c v a certs}\n             \u2192 ValidCertDeposits pp (deps \u222a\u207a \u2774 DRepDeposit c , v \u2775) certs\n             \u2192 ValidCertDeposits pp deps (regdrep c v a \u2237 certs)\n  reg        : \u2200 {c v certs}\n             \u2192 ValidCertDeposits pp (deps \u222a\u207a \u2774 CredentialDeposit c , pp .keyDeposit \u2775) certs\n             \u2192 ValidCertDeposits pp deps (reg c v \u2237 certs)\n  dereg      : \u2200 {c md d certs}\n             \u2192 (CredentialDeposit c , d) \u2208 deps\n             \u2192 md \u2261 nothing \u228e md \u2261 just d\n             \u2192 ValidCertDeposits pp (deps \u2223 \u2774 CredentialDeposit c \u2775 \u1d9c) certs\n             \u2192 ValidCertDeposits pp deps (dereg c md \u2237 certs)\n  deregdrep  : \u2200 {c d certs}\n             \u2192 (DRepDeposit c , d) \u2208 deps\n             \u2192 ValidCertDeposits pp (deps \u2223 \u2774 DRepDeposit c \u2775 \u1d9c) certs\n             \u2192 ValidCertDeposits pp deps (deregdrep c d \u2237 certs)\n  ccreghot   : \u2200 {c v certs}\n             \u2192 ValidCertDeposits pp deps certs\n             \u2192 ValidCertDeposits pp deps (ccreghot c v \u2237 certs)\n  retirepool : \u2200 {kh e certs}\n             \u2192 ValidCertDeposits pp deps certs\n             \u2192 ValidCertDeposits pp deps (retirepool kh e  \u2237 certs)\n\nprivate\n  validCertDeposits? : \u2200 {pp} deps certs \u2192 Dec (ValidCertDeposits pp deps certs)\n  validCertDeposits? deps [] = yes []\n  validCertDeposits? deps (delegate _ _ _ _ \u2237 certs) =\n    mapDec delegate (\u03bb where (delegate p) \u2192 p) (validCertDeposits? _ _)\n  validCertDeposits? deps (regpool _ _ \u2237 certs) =\n    mapDec regpool (\u03bb where (regpool p) \u2192 p) (validCertDeposits? _ _)\n  validCertDeposits? deps (regdrep _ _ _ \u2237 certs) =\n    mapDec regdrep (\u03bb where (regdrep p) \u2192 p) (validCertDeposits? _ _)\n  validCertDeposits? deps (retirepool _ _ \u2237 certs) =\n    mapDec retirepool (\u03bb where (retirepool p) \u2192 p) (validCertDeposits? _ _)\n  validCertDeposits? deps (ccreghot _ _ \u2237 certs) =\n    mapDec ccreghot (\u03bb where (ccreghot p) \u2192 p) (validCertDeposits? _ _)\n  validCertDeposits? deps (reg _ _ \u2237 certs) =\n    mapDec reg (\u03bb where (reg p) \u2192 p) (validCertDeposits? _ _)\n  validCertDeposits? deps (dereg c nothing \u2237 certs) with \u00bf CredentialDeposit c \u2208 dom deps \u00bf\n  ... | yes p = mapDec (dereg (proj\u2082 (Equivalence.from dom\u2208 p)) (inj\u2081 refl)) (\u03bb { (dereg _ _ p) \u2192 p }) (validCertDeposits? _ _)\n  ... | no \u00acp = no \u03bb { (dereg x _ _) \u2192 \u00acp (Equivalence.to dom\u2208 (_ , x)) }\n  validCertDeposits? deps (dereg c (just d) \u2237 certs) with \u00bf (CredentialDeposit c , d) \u2208 deps \u00bf\n  ... | yes p = mapDec (dereg p (inj\u2082 refl)) (\u03bb { (dereg _ _ p) \u2192 p }) (validCertDeposits? _ _)\n  ... | no \u00acp = no \u03bb { (dereg x (inj\u2082 refl) _) \u2192 \u00acp x }\n  validCertDeposits? deps (deregdrep c d \u2237 certs) with \u00bf (DRepDeposit c , d) \u2208 deps \u00bf\n  ... | yes p = mapDec (deregdrep p)  (\u03bb where (deregdrep _ v) \u2192 v) (validCertDeposits? _ _)\n  ... | no \u00acp = no (\u03bb where (deregdrep p _) \u2192 \u00acp p)\n\ninstance\n  Dec-ValidCertDeposits : \u2200 {pp deps certs} \u2192 ValidCertDeposits pp deps certs \u2047\n  Dec-ValidCertDeposits = \u2047 (validCertDeposits? _ _)\n</pre> <p>The <code>updateDeposits</code> function is responsible for updating this map; it is split into <code>updateCertDeposits</code> and <code>updateProposalDeposits</code>, which are responsible for certificates and proposals, respectively.  These functions iterate over the relevant fields of the transaction body and insert or remove deposits depending on the information seen. Note that some deposits can only be refunded at the epoch boundary and are not removed by these functions.</p> <p>There are two equivalent ways to introduce this tracking of the deposits.  One option would be to populate the <code>deposits</code> field of <code>UTxOState</code> with the correct keys and values that can be extracted from the state of the previous era at the transition into the Conway era.  Alternatively, we can effectively treat the old handling of deposits as an erratum in the Shelley specification, which we fix by implementing the new deposits logic in older eras and then replaying the chain. (The handling of deposits in the Shelley era is discussed in Corduan22 and CVG19.)</p> <pre>updateCertDeposits  : PParams \u2192 List DCert \u2192 Deposits \u2192 Deposits\nupdateCertDeposits pp [] deposits = deposits\n</pre> <pre>updateCertDeposits pp (reg c v \u2237 certs) deposits\n  = updateCertDeposits pp certs (deposits \u222a\u207a certDeposit (reg c v) pp)\n</pre> <pre>updateCertDeposits pp (delegate c vd khs v \u2237 certs) deposits\n  = updateCertDeposits pp certs (deposits \u222a\u207a certDeposit (delegate c vd khs v) pp)\nupdateCertDeposits pp (regpool kh p \u2237 certs) deposits\n  -- pool deposits are not added a second time if they are already present\n  -- (reregistrations or duplicate certificates).\n  = updateCertDeposits pp certs (deposits \u222a\u02e1 certDeposit (regpool kh p) pp)\nupdateCertDeposits pp (regdrep c v a \u2237 certs) deposits\n  = updateCertDeposits pp certs (deposits \u222a\u207a certDeposit (regdrep c v a) pp)\nupdateCertDeposits pp (dereg c v \u2237 certs) deposits\n  = updateCertDeposits pp certs (deposits \u2223 certRefund (dereg c v)\u1d9c)\nupdateCertDeposits pp (deregdrep c v \u2237 certs) deposits\n  = updateCertDeposits pp certs (deposits \u2223 certRefund (deregdrep c v)\u1d9c)\nupdateCertDeposits pp (_ \u2237 certs) deposits\n  = updateCertDeposits pp certs deposits\n\nupdateProposalDeposits : List GovProposal \u2192 TxId \u2192 Coin \u2192 Deposits \u2192 Deposits\nupdateProposalDeposits []        _     _      deposits  = deposits\nupdateProposalDeposits (_ \u2237 ps)  txid  gaDep  deposits  =\n  updateProposalDeposits ps txid gaDep deposits\n  \u222a\u207a \u2774 GovActionDeposit (txid , length ps) , gaDep \u2775\n\nupdateDeposits : PParams \u2192 TxBody \u2192 Deposits \u2192 Deposits\nupdateDeposits pp txb = updateCertDeposits pp txCerts\n                        \u2218 updateProposalDeposits txGovProposals txId (pp .govActionDeposit)\n</pre> <pre>  where open TxBody txb\n\nproposalDeposits\u0394 : List GovProposal \u2192 PParams \u2192 TxBody \u2192 Deposits\nproposalDeposits\u0394 props pp txb = updateProposalDeposits props txId (pp .govActionDeposit) \u2205\n  where open TxBody txb\n</pre> <pre>depositsChange : PParams \u2192 TxBody \u2192 Deposits \u2192 \u2124\ndepositsChange pp txb deposits =\n  getCoin (updateDeposits pp txb deposits) - getCoin deposits\n\ndata inInterval (slot : Slot) : (Maybe Slot \u00d7 Maybe Slot) \u2192 Type where\n  both   : \u2200 {l r}  \u2192 l \u2264 slot \u00d7 slot \u2264 r  \u2192  inInterval slot (just l   , just r)\n  lower  : \u2200 {l}    \u2192 l \u2264 slot             \u2192  inInterval slot (just l   , nothing)\n  upper  : \u2200 {r}    \u2192 slot \u2264 r             \u2192  inInterval slot (nothing  , just r)\n  none   :                                    inInterval slot (nothing  , nothing)\n</pre> <pre>-- Note: inInterval has to be a type definition for inference to work\ninstance\n  Dec-inInterval : inInterval \u2047\u00b2\n  Dec-inInterval {slot} {just x  , just y } .dec with x \u2264? slot | slot \u2264? y\n  ... | no \u00acp\u2081 | _      = no \u03bb where (both (h\u2081 , h\u2082)) \u2192 \u00acp\u2081 h\u2081\n  ... | yes p\u2081 | no \u00acp\u2082 = no \u03bb where (both (h\u2081 , h\u2082)) \u2192 \u00acp\u2082 h\u2082\n  ... | yes p\u2081 | yes p\u2082 = yes (both (p\u2081 , p\u2082))\n  Dec-inInterval {slot} {just x  , nothing} .dec with x \u2264? slot\n  ... | no \u00acp = no  (\u03bb where (lower h) \u2192 \u00acp h)\n  ... | yes p = yes (lower p)\n  Dec-inInterval {slot} {nothing , just x } .dec with slot \u2264? x\n  ... | no \u00acp = no  (\u03bb where (upper h) \u2192 \u00acp h)\n  ... | yes p = yes (upper p)\n  Dec-inInterval {slot} {nothing , nothing} .dec = yes none\n\n  HasCoin-UTxOState : HasCoin UTxOState\n  HasCoin-UTxOState .getCoin s = getCoin (UTxOState.utxo s)\n                               + (UTxOState.fees s)\n                               + getCoin (UTxOState.deposits s)\n                               + UTxOState.donations s\n\ncoinPolicies : \u2119 ScriptHash\ncoinPolicies = policies (inject 1)\n\nisAdaOnly : Value \u2192 Type\nisAdaOnly v = policies v \u2261\u1d49 coinPolicies\n</pre> <pre>collateralCheck : PParams \u2192 Tx \u2192 UTxO \u2192 Type\ncollateralCheck pp tx utxo =\n  All (\u03bb (addr , _) \u2192 isVKeyAddr addr) (range (utxo \u2223 collateralInputs))\n  \u00d7 isAdaOnly balance\u2032\n  \u00d7 coin balance\u2032 * 100 \u2265 txFee * pp .collateralPercentage\n  \u00d7 collateralInputs \u2262 \u2205\n  where\n    open Tx tx; open TxBody body\n    balance\u2032 = balance (utxo \u2223 collateralInputs)\n</pre> <pre>module _ (let open UTxOState; open TxBody) where\n</pre> <p>We redefine <code>depositRefunds</code> and <code>newDeposits</code> via <code>depositsChange</code>, which computes the difference between the total deposits before and after their application.  This simplifies their definitions and some correctness proofs.  We then add the absolute value of <code>depositsChange</code> to <code>consumed</code> or <code>produced</code> depending on its sign. This is done via <code>negPart</code> and <code>posPart</code>, which satisfy the key property that their difference is the identity function.</p> <pre>  depositRefunds : PParams \u2192 UTxOState \u2192 TxBody \u2192 Coin\n  depositRefunds pp st txb = negPart (depositsChange pp txb (st .deposits))\n\n  newDeposits : PParams \u2192 UTxOState \u2192 TxBody \u2192 Coin\n  newDeposits pp st txb = posPart (depositsChange pp txb (st .deposits))\n\n  consumed : PParams \u2192 UTxOState \u2192 TxBody \u2192 Value\n  consumed pp st txb\n    =  balance (st .utxo \u2223 txb .txIns)\n    +  txb .mint\n    +  inject (depositRefunds pp st txb)\n    +  inject (getCoin (txb .txWithdrawals))\n\n  produced : PParams \u2192 UTxOState \u2192 TxBody \u2192 Value\n  produced pp st txb = balance (outs txb)\n                     + inject (txb .txFee)\n                     + inject (newDeposits pp st txb)\n                     + inject (txb .txDonation)\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.html#sec:the-utxos-transition-rule","title":"The UTXOS Transition Rule","text":"<pre>open PParams\nprivate variable\n  \u0393 : UTxOEnv\n  s s' : UTxOState\n  tx : Tx\n  utxo : UTxO\n  fees : Fees\n  donations : Donations\n  deposits : Deposits\n\nopen UTxOEnv\n</pre> <pre>data _\u22a2_\u21c0\u2987_,UTXOS\u2988_ : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 UTxOState \u2192 Type where\n\n  Scripts-Yes :\n    let  pp         = \u0393 .pparams\n</pre> <pre>         open Tx tx renaming (body to txb); open TxBody txb\n</pre> <pre>         p2Scripts  = collectP2ScriptsWithContext pp tx utxo\n      in\n        \u2219 ValidCertDeposits pp deposits txCerts\n        \u2219 evalP2Scripts p2Scripts \u2261 isValid\n        \u2219 isValid \u2261 true\n          \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n          \u0393 \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.html#16483}{\\htmlId{17047}{\\htmlClass{Generalizable}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#16497}{\\htmlId{17054}{\\htmlClass{Generalizable}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#16535}{\\htmlId{17061}{\\htmlClass{Generalizable}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#16511}{\\htmlId{17072}{\\htmlClass{Generalizable}{\\text{donations}}}}\\, \\end{pmatrix}$ \u21c0\u2987 tx ,UTXOS\u2988 $\\begin{pmatrix} \\,\\htmlId{17100}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Utxo.html#16483}{\\htmlId{17101}{\\htmlClass{Generalizable}{\\text{utxo}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{17106}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.Transaction.html#4618}{\\htmlId{17108}{\\htmlClass{Function}{\\text{txIns}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{17114}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\,\\,\\htmlId{17115}{\\htmlClass{Symbol}{\\text{)}}}\\, \\,\\href{Axiom.Set.Map.html#7638}{\\htmlId{17117}{\\htmlClass{Function Operator}{\\text{\u222a\u02e1}}}}\\, \\,\\htmlId{17120}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Utxo.html#4772}{\\htmlId{17121}{\\htmlClass{Function}{\\text{outs}}}}\\, \\,\\href{Ledger.Conway.Specification.Utxo.html#16763}{\\htmlId{17126}{\\htmlClass{Function}{\\text{txb}}}}\\,\\,\\htmlId{17129}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#16497}{\\htmlId{17133}{\\htmlClass{Generalizable}{\\text{fees}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{17138}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Transaction.html#4840}{\\htmlId{17140}{\\htmlClass{Function}{\\text{txFee}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#12452}{\\htmlId{17148}{\\htmlClass{Function}{\\text{updateDeposits}}}}\\, \\,\\href{Ledger.Conway.Specification.Utxo.html#16684}{\\htmlId{17163}{\\htmlClass{Bound}{\\text{pp}}}}\\, \\,\\href{Ledger.Conway.Specification.Utxo.html#16763}{\\htmlId{17166}{\\htmlClass{Function}{\\text{txb}}}}\\, \\,\\href{Ledger.Conway.Specification.Utxo.html#16535}{\\htmlId{17170}{\\htmlClass{Generalizable}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#16511}{\\htmlId{17181}{\\htmlClass{Generalizable}{\\text{donations}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{17191}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Transaction.html#5010}{\\htmlId{17193}{\\htmlClass{Function}{\\text{txDonation}}}}\\, \\end{pmatrix}$\n  Scripts-No :\n    let  pp         = \u0393 .pparams\n</pre> <pre>         open Tx tx renaming (body to txb); open TxBody txb\n</pre> <pre>         p2Scripts  = collectP2ScriptsWithContext pp tx utxo\n    in\n        \u2219 evalP2Scripts p2Scripts \u2261 isValid\n        \u2219 isValid \u2261 false\n          \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n          \u0393 \u22a2 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.html#16483}{\\htmlId{17544}{\\htmlClass{Generalizable}{\\text{utxo}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#16497}{\\htmlId{17551}{\\htmlClass{Generalizable}{\\text{fees}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#16535}{\\htmlId{17558}{\\htmlClass{Generalizable}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#16511}{\\htmlId{17569}{\\htmlClass{Generalizable}{\\text{donations}}}}\\, \\end{pmatrix}$ \u21c0\u2987 tx ,UTXOS\u2988 $\\begin{pmatrix} \\,\\href{Ledger.Conway.Specification.Utxo.html#16483}{\\htmlId{17597}{\\htmlClass{Generalizable}{\\text{utxo}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{17602}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.Transaction.html#4690}{\\htmlId{17604}{\\htmlClass{Function}{\\text{collateralInputs}}}}\\, \\,\\href{Axiom.Set.Map.html#13604}{\\htmlId{17621}{\\htmlClass{Function Operator}{\\text{\u1d9c}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#16497}{\\htmlId{17625}{\\htmlClass{Generalizable}{\\text{fees}}}}\\, \\,\\href{Class.HasAdd.Core.html#162}{\\htmlId{17630}{\\htmlClass{Field Operator}{\\text{+}}}}\\, \\,\\href{Ledger.Conway.Specification.Utxo.html#4932}{\\htmlId{17632}{\\htmlClass{Function}{\\text{cbalance}}}}\\, \\,\\htmlId{17641}{\\htmlClass{Symbol}{\\text{(}}}\\,\\,\\href{Ledger.Conway.Specification.Utxo.html#16483}{\\htmlId{17642}{\\htmlClass{Generalizable}{\\text{utxo}}}}\\, \\,\\href{Axiom.Set.Map.html#13534}{\\htmlId{17647}{\\htmlClass{Function Operator}{\\text{\u2223}}}}\\, \\,\\href{Ledger.Conway.Specification.Transaction.html#4690}{\\htmlId{17649}{\\htmlClass{Function}{\\text{collateralInputs}}}}\\,\\,\\htmlId{17665}{\\htmlClass{Symbol}{\\text{)}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#16535}{\\htmlId{17669}{\\htmlClass{Generalizable}{\\text{deposits}}}}\\, \\\\ \\,\\href{Ledger.Conway.Specification.Utxo.html#16511}{\\htmlId{17680}{\\htmlClass{Generalizable}{\\text{donations}}}}\\, \\end{pmatrix}$\n</pre> <pre>unquoteDecl Scripts-Yes-premises = genPremises Scripts-Yes-premises (quote Scripts-Yes)\nunquoteDecl Scripts-No-premises  = genPremises Scripts-No-premises  (quote Scripts-No)\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.html#sec:the-utxo-transition-system","title":"The UTXO Transition System","text":"<p>This section ties all the pieces of the UTXO rule together.</p> <p>(The symbol <code>\u2261?</code> is explained in Section Notation.)</p> <pre>data _\u22a2_\u21c0\u2987_,UTXO\u2988_ where\n\n  UTXO-inductive :\n    let pp        = \u0393 .pparams\n        slot      = \u0393 .slot\n        treasury  = \u0393 .treasury\n        utxo      = s .UTxOState.utxo\n</pre> <pre>        open Tx tx renaming (body to txb); open TxBody txb\n        open TxWitnesses wits\n</pre> <pre>        txOuts\u02b0   = mapValues txOutHash txOuts\n        overhead  = 160\n    in\n    \u2219 txIns \u2262 \u2205                              \u2219 txIns \u222a refInputs \u2286 dom utxo\n    \u2219 txIns \u2229 refInputs \u2261 \u2205                  \u2219 inInterval slot txVldt\n    \u2219 minfee pp utxo tx \u2264 txFee              \u2219 (txrdmrs \u02e2 \u2262 \u2205 \u2192 collateralCheck pp tx utxo)\n    \u2219 consumed pp s txb \u2261 produced pp s txb  \u2219 coin mint \u2261 0\n    \u2219 txsize \u2264 maxTxSize pp\n    \u2219 refScriptsSize utxo tx \u2264 pp .maxRefScriptSizePerTx\n    \u2219 \u2200[ (_ , txout) \u2208 \u2223 txOuts\u02b0 \u2223 ]\n        inject ((overhead + utxoEntrySize txout) * coinsPerUTxOByte pp) \u2264\u1d57 getValue\u02b0 txout\n    \u2219 \u2200[ (_ , txout) \u2208 \u2223 txOuts\u02b0 \u2223 ]\n        serSize (getValue\u02b0 txout) \u2264 maxValSize pp\n    \u2219 \u2200[ (a , _) \u2208 range txOuts\u02b0 ]\n        Sum.All (const \u22a4) (\u03bb a \u2192 a .BootstrapAddr.attrsSize \u2264 64) a\n    \u2219 \u2200[ (a , _) \u2208 range txOuts\u02b0 ]  netId a        \u2261 NetworkId\n    \u2219 \u2200[ a \u2208 dom txWithdrawals ]    NetworkIdOf a  \u2261 NetworkId\n    \u2219 txNetworkId  ~ just NetworkId\n    \u2219 currentTreasury  ~ just treasury\n    \u2219 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOS\u2988 s'\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s'\n</pre> <pre>pattern UTXO-inductive\u22ef tx \u0393 s x y z w k l m c v j n o p q r t u h\n  = UTXO-inductive {\u0393 = \u0393} {s = s} {tx = tx} (x , y , z , w , k , l , m , c , v , j , n , o , p , q , r , t , u , h)\nunquoteDecl UTXO-premises = genPremises UTXO-premises (quote UTXO-inductive)\n</pre>"},{"location":"Ledger.Conway.Specification.Utxo.html#references","title":"References","text":"<p>[Corduan22]  Jared Corduan. Track individual deposits. 2022.</p> <p>[CVG19]  Jared Corduan and Polina Vinogradova and Matthias G\u00fcdemann. A Formal Specification of the Cardano Ledger. 2019.</p>"},{"location":"Ledger.Conway.Specification.Utxow.Properties.Computational.html","title":"Computational","text":"<pre>{-# OPTIONS --safe #-}\n\nimport Data.Maybe as M\n\nopen import Ledger.Prelude\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Utxow.Properties.Computational\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\n\nopen import Ledger.Conway.Specification.Utxow txs abs\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational txs abs\n\ninstance\n  Computational-UTXOW : Computational _\u22a2_\u21c0\u2987_,UTXOW\u2988_ String\n  Computational-UTXOW = record {Go}\n    where module Go \u0393 s tx (let H , \u2047 H? = UTXOW-inductive-premises {tx}{s}) where\n\n    open Computational Computational-UTXO\n      renaming (computeProof to computeProof'; completeness to completeness')\n\n    genErr : \u00ac H \u2192 String\n    genErr  \u00acp = case dec-de-morgan \u00acp of \u03bb where\n      (inj\u2081 a) \u2192 \"\u00ac \u2200[ (vk , \u03c3) \u2208 vkSigs ] isSigned vk (txidBytes txid) \u03c3\"\n      (inj\u2082 b) \u2192 case dec-de-morgan b of \u03bb where\n        (inj\u2081 a\u2081) \u2192 \"\u2200[ s \u2208 scriptsP1 ] validP1Script witsKeyHashes txvldt s\"\n        (inj\u2082 b\u2081) \u2192 case dec-de-morgan b\u2081 of \u03bb where\n          (inj\u2081 a\u2082) \u2192 \"witsVKeyNeeded utxo txb \u2286 witsKeyHashes\"\n          (inj\u2082 b\u2082) \u2192 case dec-de-morgan b\u2082 of \u03bb where\n            (inj\u2081 a\u2083) \u2192 \"(neededHashes - refScriptHashes) \u2261\u1d49 witsScriptHashes\"\n            (inj\u2082 b\u2083) \u2192 case dec-de-morgan b\u2083 of \u03bb where\n              (inj\u2081 a\u2084) \u2192 \"inputHashes \u2286 txdatsHashes\"\n              (inj\u2082 b\u2084) \u2192 case dec-de-morgan b\u2084 of \u03bb where\n                (inj\u2081 a\u2085) \u2192 \"txdatsHashes \u2286 (inputHashes \u222a allOutHashes \u222a getDataHashes (range (utxo \u2223 refInputs)))\"\n                (inj\u2082 b\u2085) \u2192 case dec-de-morgan b\u2085 of \u03bb where\n                  (inj\u2081 a\u2086) \u2192 \"languages \u2286 allowedLanguages\"\n                  (inj\u2082 b\u2086) \u2192 \"txADhash \u2261 map hash txAD\"\n\n    computeProof : ComputationResult String (\u2203 (\u0393 \u22a2 s \u21c0\u2987 tx ,UTXOW\u2988_))\n    computeProof =\n      case H? of \u03bb where\n        (yes (p\u2081 , p\u2082 , p\u2083 , p\u2084 , p\u2085 , p\u2086 , p\u2087 , p\u2088)) \u2192\n          map (map\u2082\u2032 (UTXOW-inductive\u22ef p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 p\u2087 p\u2088)) (computeProof' \u0393 s tx)\n        (no \u00acp) \u2192 failure $ genErr \u00acp\n\n    completeness : \u2200 s' \u2192 \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n                        \u2192 map proj\u2081 computeProof \u2261 success s'\n    completeness s' (UTXOW-inductive\u22ef p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 p\u2087 p\u2088 h) with H?\n    ... | no \u00acp = \u22a5-elim $ \u00acp ((p\u2081 , p\u2082 , p\u2083 , p\u2084 , p\u2085 , p\u2086 , p\u2087 , p\u2088))\n    ... | yes _ with computeProof' \u0393 s tx | completeness' _ _ _ _ h\n    ... | success _ | refl = refl\n</pre>"},{"location":"Ledger.Conway.Specification.Utxow.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Conway.Specification.Utxow.Properties where\n\nopen import Ledger.Conway.Specification.Utxow.Properties.Computational\n</pre>"},{"location":"Ledger.Conway.Specification.Utxow.html","title":"Witnessing","text":"<p>The purpose of witnessing is make sure the actions specified a transaction are authorized by the holder of the signing key. (For details see CVG19.) This section formalizes the mechanisms use by the Cardano ledger to support witnessing.</p> <pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Abstract\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.Conway.Specification.Utxow\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs)\n  where\nopen import Ledger.Conway.Specification.Utxo txs abs\nopen import Ledger.Conway.Specification.Script.Validation txs abs\nopen import Ledger.Conway.Specification.Certs govStructure\n</pre>"},{"location":"Ledger.Conway.Specification.Utxow.html#sec:witnessing-functions","title":"Witnessing Functions","text":"<pre>module _ (o : TxOut) where\n  d = proj\u2081 (proj\u2082 (proj\u2082 o))\n  data HasInlineDatum : Set where\n    InlineDatum  : \u2200 {d'} \u2192 d \u2261 just (inj\u2081 d') \u2192 HasInlineDatum\n\ninstance\n  Dec-HasInlineDatum : \u2200 {o} \u2192 HasInlineDatum o \u2047\n  Dec-HasInlineDatum {_ , _ , just (inj\u2081 x) , _} = \u2047 yes (InlineDatum refl)\n  Dec-HasInlineDatum {_ , _ , just (inj\u2082 x) , _} = \u2047 no \u03bb where\n    (InlineDatum x) \u2192 case x of \u03bb ()\n  Dec-HasInlineDatum {_ , _ , nothing , _} = \u2047 no \u03bb where\n    (InlineDatum x) \u2192 case x of \u03bb ()\n\nmodule _ (txb : TxBody) (let open TxBody txb) where\n  data UsesV3Features : Set where\n    HasVotes : txGovVotes \u2262 [] \u2192 UsesV3Features\n    HasProps : txGovProposals \u2262 [] \u2192 UsesV3Features\n    HasDonation : txDonation \u2262 0 \u2192 UsesV3Features\n    HasTreasure : currentTreasury \u2262 nothing \u2192 UsesV3Features\n\ninstance\n  Dec-UsesV3Features : \u2200 {txb} \u2192 UsesV3Features txb \u2047\n  Dec-UsesV3Features {record { txGovVotes = [] ; txGovProposals = [] ; txDonation = zero ; currentTreasury = nothing }}\n    = \u2047 no \u03bb where (HasVotes x)    \u2192 x refl\n                   (HasProps x)    \u2192 x refl\n                   (HasDonation x) \u2192 x refl\n                   (HasTreasure x) \u2192 x refl\n  Dec-UsesV3Features {record { txGovVotes = [] ; txGovProposals = [] ; txDonation = zero ; currentTreasury = just x }}\n    = \u2047 yes (HasTreasure (\u03bb ()))\n  Dec-UsesV3Features {record { txGovVotes = [] ; txGovProposals = [] ; txDonation = suc txDonation }}\n    = \u2047 yes (HasDonation (\u03bb ()))\n  Dec-UsesV3Features {record { txGovVotes = [] ; txGovProposals = x \u2237 txGovProposals }} = \u2047 yes (HasProps (\u03bb ()))\n  Dec-UsesV3Features {record { txGovVotes = x \u2237 txGovVotes }} = \u2047 yes (HasVotes (\u03bb ()))\n\nlanguages : Tx \u2192 UTxO \u2192 \u2119 Language\nlanguages tx utxo = mapPartial getLanguage (txscripts tx utxo)\n  where\n    getLanguage : Script \u2192 Maybe Language\n    getLanguage (inj\u2081 _) = nothing\n    getLanguage (inj\u2082 s) = just (language s)\n</pre> <p>We begin with the definition of <code>allowedLanguages</code>, which includes conditions for new features in Conway.  If a transaction contains any votes, proposals, a treasury donation or asserts the treasury amount, it is only allowed to contain Plutus V3 scripts.  Additionally, the presence of reference scripts or inline scripts does not prevent Plutus V1 scripts from being used in a transaction anymore. Only inline datums are now disallowed from appearing together with a Plutus V1 script.</p> <pre>allowedLanguages : Tx \u2192 UTxO \u2192 \u2119 Language\nallowedLanguages tx utxo =\n  if (\u2203[ o \u2208 os ] isBootstrapAddr (proj\u2081 o))\n    then \u2205\n  else if UsesV3Features txb\n    then fromList (PlutusV3 \u2237 [])\n  else if \u2203[ o \u2208 os ] HasInlineDatum o\n    then fromList (PlutusV2 \u2237 PlutusV3 \u2237 [])\n  else\n    fromList (PlutusV1 \u2237 PlutusV2 \u2237 PlutusV3 \u2237 [])\n  where\n    txb = tx .Tx.body; open TxBody txb\n    os = range (outs txb) \u222a range (utxo \u2223 (txIns \u222a refInputs))\n</pre>"},{"location":"Ledger.Conway.Specification.Utxow.html#sec:the-utxow-transition-system","title":"The UTXOW Transition System","text":"<pre>\nprivate variable\n  \u0393     : UTxOEnv\n  s s'  : UTxOState\n  tx    : Tx\n\nopen UTxOState\n</pre> <pre>data _\u22a2_\u21c0\u2987_,UTXOW\u2988_ : UTxOEnv \u2192 UTxOState \u2192 Tx \u2192 UTxOState \u2192 Type where\n\n  UTXOW-inductive :\n    let  open Tx tx renaming (body to txb); open TxBody txb; open TxWitnesses wits\n         utxo                = s .utxo\n         witsKeyHashes       = map\u02e2 hash (dom vkSigs)\n         witsScriptHashes    = map\u02e2 hash scripts\n         refScriptHashes     = map\u02e2 hash (refScripts tx utxo)\n         neededScriptHashes  = mapPartial (isScriptObj  \u2218 proj\u2082) (credsNeeded utxo txb)\n         neededVKeyHashes    = mapPartial (isKeyHashObj \u2218 proj\u2082) (credsNeeded utxo txb)\n         txdatsHashes        = map\u02e2 hash txdats\n         inputsDataHashes    = mapPartial (\u03bb txout \u2192  if txOutToP2Script utxo tx txout\n                                                      then txOutToDataHash txout\n                                                      else nothing) (range (utxo \u2223 txIns))\n         refInputsDataHashes = mapPartial txOutToDataHash (range (utxo \u2223 refInputs))\n         outputsDataHashes   = mapPartial txOutToDataHash (range txOuts)\n         nativeScripts       = mapPartial toP1Script (txscripts tx utxo)\n    in\n    \u2219  \u2200[ (vk , \u03c3) \u2208 vkSigs ] isSigned vk (txidBytes txId) \u03c3\n    \u2219  \u2200[ s \u2208 nativeScripts ] (hash s \u2208 neededScriptHashes \u2192 validP1Script witsKeyHashes txVldt s)\n    \u2219  neededVKeyHashes \u2286 witsKeyHashes\n    \u2219  neededScriptHashes - refScriptHashes \u2261\u1d49 witsScriptHashes\n    \u2219  inputsDataHashes \u2286 txdatsHashes\n    \u2219  txdatsHashes \u2286 inputsDataHashes \u222a outputsDataHashes \u222a refInputsDataHashes\n    \u2219  languages tx utxo \u2286 allowedLanguages tx utxo\n    \u2219  txADhash \u2261 map hash txAD\n    \u2219  \u0393 \u22a2 s \u21c0\u2987 tx ,UTXO\u2988 s'\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       \u0393 \u22a2 s \u21c0\u2987 tx ,UTXOW\u2988 s'\n</pre> <p>Remarks</p> <ul> <li> <p>the line <code>inputsDataHashes</code> <code>\u2286</code> <code>txdatsHashes</code>    compares two inhabitants of type <code>PowerSet</code> <code>DataHash</code>.    In the Alonzo era, these two terms inhabited the <code>\u2119</code>    (<code>Maybe</code> <code>DataHash</code>) type, where a    <code>nothing</code> was simply thrown out VK21,.</p> </li> <li> <p><code>neededScriptHashes</code> and <code>neededVKeyHashes</code> are    defined by projecting information out of <code>credsNeeded</code>.  Also, the    last component of the <code>credsNeeded</code> function (defined in the    Script Validation module) adds the script in the proposal policy only if it is present.</p> </li> </ul> <pre>pattern UTXOW-inductive\u22ef p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 p\u2087 p\u2088 h\n      = UTXOW-inductive (p\u2081 , p\u2082 , p\u2083 , p\u2084 , p\u2085 , p\u2086 , p\u2087 , p\u2088 , h)\npattern UTXOW\u21d2UTXO x = UTXOW-inductive\u22ef _ _ _ _ _ _ _ _ x\n\nunquoteDecl UTXOW-inductive-premises =\n  genPremises UTXOW-inductive-premises (quote UTXOW-inductive)\n</pre> <p>Plutus Script Context</p> <p>CIP-0069 unifies the arguments given to all types of Plutus scripts currently available: spending, certifying, rewarding, minting, voting, proposing.</p> <p>The formal specification permits running spending scripts in the absence datums in the Conway era.  However, since the interface with Plutus is kept abstract in this specification, changes to the representation of the script context which are part of CIP-0069 are not included here.</p> <p>To supply this specification with a CIP-0069-conformant implementation of Plutus, an additional step processing the <code>List</code> <code>Data</code> argument we provide would be required.</p>"},{"location":"Ledger.Conway.Specification.Utxow.html#references","title":"References","text":"<p>[CVG19]  Jared Corduan and Polina Vinogradova and Matthias G\u00fcdemann. A Formal Specification of the Cardano Ledger. 2019.</p> <p>[VK21]  Polina Vinogradova and Andre Knispel. A Formal Specification of the Cardano Ledger integrating Plutus Core. 2021.</p>"},{"location":"Ledger.Conway.Specification.html","title":"Introduction","text":"<p>This is the formal specification of the Cardano ledger for the Conway era.</p> <p>The Agda source code which formalizes the ledger specification in the Conway era consists of the modules listed below.  How these modules fit together to form a collection of interdependent state transition systems is illustrated by the STS Diagram in the Introduction section.</p> <pre>{-# OPTIONS --safe #-}\nmodule Ledger.Conway.Specification where\n</pre>"},{"location":"Ledger.Conway.Specification.html#blockbody","title":"BlockBody","text":"<p>The Block Body Transition updates the block body state which comprises the ledger state and the map describing the produced blocks.</p> <pre>import Ledger.Conway.Specification.BlockBody\nimport Ledger.Conway.Specification.BlockBody.Properties\n</pre>"},{"location":"Ledger.Conway.Specification.html#certificates","title":"Certificates","text":"<pre>import Ledger.Conway.Specification.Certs\nimport Ledger.Conway.Specification.Certs.Properties\n</pre>"},{"location":"Ledger.Conway.Specification.html#chain","title":"Chain","text":"<pre>import Ledger.Conway.Specification.Chain\nimport Ledger.Conway.Specification.Chain.Properties\n</pre>"},{"location":"Ledger.Conway.Specification.html#enactment","title":"Enactment","text":"<p>These modules concern the enactment of governance proposals and actions.</p> <pre>import Ledger.Conway.Specification.Enact\nimport Ledger.Conway.Specification.Enact.Properties\n</pre>"},{"location":"Ledger.Conway.Specification.html#epoch","title":"Epoch","text":"<pre>import Ledger.Conway.Specification.Epoch\nimport Ledger.Conway.Specification.Epoch.Properties\n</pre>"},{"location":"Ledger.Conway.Specification.html#fees","title":"Fees","text":"<p>This module defines a function that calculates the fee for reference scripts in a transaction.</p> <pre>import Ledger.Conway.Specification.Fees\n</pre>"},{"location":"Ledger.Conway.Specification.html#governance","title":"Governance","text":"<pre>import Ledger.Conway.Specification.Gov\nimport Ledger.Conway.Specification.Gov.Actions\nimport Ledger.Conway.Specification.Gov.Properties\nimport Ledger.Conway.Specification.Gov.Properties.ChangePPGroup\nimport Ledger.Conway.Specification.Types.GovStructure\n</pre>"},{"location":"Ledger.Conway.Specification.html#ledger","title":"Ledger","text":"<p>The <code>Ledger</code> module defines the ledger transition system where valid transactions transform the ledger state.</p> <pre>import Ledger.Conway.Specification.Ledger\nimport Ledger.Conway.Specification.Ledger.Properties\n</pre>"},{"location":"Ledger.Conway.Specification.html#protocol-parameters","title":"Protocol Parameters","text":"<p>The defines the adjustable protocol parameters of the Cardano ledger.</p> <pre>import Ledger.Conway.Specification.PParams\n</pre>"},{"location":"Ledger.Conway.Specification.html#properties-of-the-ledger-specification","title":"Properties of the Ledger Specification","text":"<pre>import Ledger.Conway.Specification.Properties\n</pre>"},{"location":"Ledger.Conway.Specification.html#ratification","title":"Ratification","text":"<pre>import Ledger.Conway.Specification.Ratify\nimport Ledger.Conway.Specification.Ratify.Properties\n</pre>"},{"location":"Ledger.Conway.Specification.html#rewards","title":"Rewards","text":"<pre>import Ledger.Conway.Specification.Rewards\nimport Ledger.Conway.Specification.RewardUpdate\nimport Ledger.Conway.Specification.RewardUpdate.Properties\n</pre>"},{"location":"Ledger.Conway.Specification.html#scripts","title":"Scripts","text":"<pre>import Ledger.Conway.Specification.Script\nimport Ledger.Conway.Specification.Script.Validation\n</pre>"},{"location":"Ledger.Conway.Specification.html#token-algebras","title":"Token Algebras","text":"<pre>import Ledger.Conway.Specification.TokenAlgebra.Base\nimport Ledger.Conway.Specification.TokenAlgebra.Coin\nimport Ledger.Conway.Specification.TokenAlgebra.ValueSet\nimport Ledger.Conway.Specification.TokenAlgebra.ValueVector\n</pre>"},{"location":"Ledger.Conway.Specification.html#transactions","title":"Transactions","text":"<pre>import Ledger.Conway.Specification.Transaction\n</pre>"},{"location":"Ledger.Conway.Specification.html#utxo","title":"Utxo","text":"<pre>import Ledger.Conway.Specification.Utxo\nimport Ledger.Conway.Specification.Utxo.Properties\n</pre>"},{"location":"Ledger.Conway.Specification.html#utxow","title":"Utxow","text":"<pre>import Ledger.Conway.Specification.Utxow\nimport Ledger.Conway.Specification.Utxow.Properties\n</pre>"},{"location":"Ledger.Conway.html","title":"Ledger.Conway","text":"<pre>module Ledger.Conway where\n\n--- ** Cardano ledger in the Conway era\nimport Ledger.Conway.Specification\n\n-- ** Conformance test reconciliation\nimport Ledger.Conway.Conformance\n\n-- ** Haskell code extraction\nimport Ledger.Conway.Foreign.HSLedger\n\n-- ** Not currently used\nimport Foreign.Convertible.DerivingTest\n</pre>"},{"location":"Ledger.Core.Specification.Address.html","title":"Addresses","text":"<p>This section defines credentials and various address types.</p> <p>A credential contains a hash, either of a verifying (public) key (<code>isVKey</code>) or of a script (<code>isScript</code>).</p> <p>N.B. in the Shelley era the type of the <code>stake</code> field of the <code>BaseAddr</code> record was <code>CredentialType</code> (see CVG19, ); to specify an address with no stake, we would use an \u201centerprise\u201d address. In contrast, the type of <code>stake</code> in the Conway era is <code>Maybe</code> <code>CredentialType</code>, so we now use <code>BaseAddr</code> to specify an address with no stake by setting <code>stake</code> to <code>nothing</code>.</p> <pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\n\nopen import Tactic.Derive.Show\n\nmodule Ledger.Core.Specification.Address (\n</pre>"},{"location":"Ledger.Core.Specification.Address.html#address-definitions","title":"Address Definitions","text":"<p>Abstract types</p> <pre>  Network\n  KeyHash\n  ScriptHash\n</pre> <pre>  : Type)  \u2983 _ : DecEq Network \u2984 \u2983 _ : DecEq KeyHash \u2984 \u2983 _ : DecEq ScriptHash \u2984 where\n</pre> <p>Derived types</p> <pre>data Credential : Type where\n  KeyHashObj : KeyHash \u2192 Credential\n  ScriptObj  : ScriptHash \u2192 Credential\n</pre> <pre>record HasCredential {a} (A : Type a) : Type a where\n  field CredentialOf : A \u2192 Credential\nopen HasCredential \u2983...\u2984 public\n\nisKeyHashObj : Credential \u2192 Maybe KeyHash\nisKeyHashObj (KeyHashObj h) = just h\nisKeyHashObj (ScriptObj _)  = nothing\n\nisKeyHashObj\u1d47 : Credential \u2192 Bool\nisKeyHashObj\u1d47 (KeyHashObj _) = true\nisKeyHashObj\u1d47 _ = false\n\nisKeyHash : Credential \u2192 Type\nisKeyHash x = isKeyHashObj\u1d47 x \u2261 true\n\nisScriptObj : Credential \u2192 Maybe ScriptHash\nisScriptObj (KeyHashObj _) = nothing\nisScriptObj (ScriptObj h)  = just h\n\ndata isVKey : Credential \u2192 Type where\n  VKeyisVKey : (kh : KeyHash) \u2192 isVKey (KeyHashObj kh)\n\ndata isScript : Credential \u2192 Type where\n  SHisScript : (sh : ScriptHash) \u2192 isScript (ScriptObj sh)\n</pre> <pre>record BaseAddr : Type where\n  field\n    net    : Network\n    pay    : Credential\n    stake  : Maybe Credential\n\nrecord BootstrapAddr : Type where\n  field\n    net        : Network\n    pay        : Credential\n    attrsSize  : \u2115\n\nrecord RwdAddr : Type where\n  field\n    net    : Network\n    stake  : Credential\n\nWithdrawals : Type\nWithdrawals = RwdAddr \u21c0 Coin\n</pre> <pre>open BaseAddr; open BootstrapAddr; open BaseAddr; open BootstrapAddr\n\nrecord HasNetworkId {a} (A : Type a) : Type a where\n  field NetworkIdOf : A \u2192 Network\nopen HasNetworkId \u2983...\u2984 public\n\nrecord HasWithdrawals {a} (A : Type a) : Type a where\n  field WithdrawalsOf : A \u2192 Withdrawals\nopen HasWithdrawals \u2983...\u2984 public\n\ninstance\n  HasNetworkId-BaseAddr : HasNetworkId BaseAddr\n  HasNetworkId-BaseAddr .NetworkIdOf = BaseAddr.net\n\n  HasNetworkId-BootstrapAddr : HasNetworkId BootstrapAddr\n  HasNetworkId-BootstrapAddr .NetworkIdOf = BootstrapAddr.net\n\n  HasNetworkId-RwdAddr : HasNetworkId RwdAddr\n  HasNetworkId-RwdAddr .NetworkIdOf = RwdAddr.net\n\n  HasCredential-RwdAddr : HasCredential RwdAddr\n  HasCredential-RwdAddr .CredentialOf = RwdAddr.stake\n</pre> <pre>VKeyBaseAddr         = \u03a3[ addr \u2208 BaseAddr       ] isVKey    (addr .pay)\nVKeyBootstrapAddr    = \u03a3[ addr \u2208 BootstrapAddr  ] isVKey    (addr .pay)\nScriptBaseAddr       = \u03a3[ addr \u2208 BaseAddr       ] isScript  (addr .pay)\nScriptBootstrapAddr  = \u03a3[ addr \u2208 BootstrapAddr  ] isScript  (addr .pay)\n\nAddr        = BaseAddr        \u228e BootstrapAddr\nVKeyAddr    = VKeyBaseAddr    \u228e VKeyBootstrapAddr\nScriptAddr  = ScriptBaseAddr  \u228e ScriptBootstrapAddr\n</pre> <p>Helper functions</p> <pre>payCred       : Addr \u2192 Credential\nstakeCred     : Addr \u2192 Maybe Credential\nnetId         : Addr \u2192 Network\nisVKeyAddr    : Addr \u2192 Type\nisScriptAddr  : Addr \u2192 Type\n\nisVKeyAddr       = isVKey \u2218 payCred\nisScriptAddr     = isScript \u2218 payCred\nisScriptRwdAddr  = isScript \u2218 CredentialOf\n</pre> <pre>payCred (inj\u2081 record {pay = pay}) = pay\npayCred (inj\u2082 record {pay = pay}) = pay\n\nstakeCred (inj\u2081 record {stake = stake}) = stake\nstakeCred (inj\u2082 _) = nothing\n\nnetId (inj\u2081 record {net = net}) = net\nnetId (inj\u2082 record {net = net}) = net\n\ndata isBootstrapAddr : Addr \u2192 Set where\n IsBootstrapAddr : \u2200 a \u2192 isBootstrapAddr (inj\u2082 a)\n\ninstance\n  isBootstrapAddr? : \u2200 {a} \u2192 isBootstrapAddr a \u2047\n  isBootstrapAddr? {inj\u2081 _} = \u2047 no \u03bb ()\n  isBootstrapAddr? {inj\u2082 a} = \u2047 yes (IsBootstrapAddr a)\n\ninstance\n  unquoteDecl DecEq-Credential = derive-DecEq ((quote Credential , DecEq-Credential) \u2237 [])\n\n  Dec-isVKey : isVKey \u2047\u00b9\n  Dec-isVKey {x = c} .dec with c\n  ... | KeyHashObj h = yes (VKeyisVKey h)\n  ... | ScriptObj  _ = no  \u03bb ()\n\n  Dec-isScript : isScript \u2047\u00b9\n  Dec-isScript {x = x} .dec with x\n  ... | KeyHashObj _ = no \u03bb ()\n  ... | ScriptObj  y = yes (SHisScript y)\n\n_ = isVKey \u2047\u00b9 \u220b it\n_ = isVKeyAddr \u2047\u00b9 \u220b it\n_ = isScript \u2047\u00b9 \u220b it\n_ = isScriptAddr \u2047\u00b9 \u220b it\n_ = isScriptRwdAddr \u2047\u00b9 \u220b it\n\ngetScriptHash : \u2200 a \u2192 isScriptAddr a \u2192 ScriptHash\ngetScriptHash (inj\u2081 _) (SHisScript sh) = sh\ngetScriptHash (inj\u2082 _) (SHisScript sh) = sh\n\ninstance abstract\n  unquoteDecl DecEq-BaseAddr DecEq-BootstrapAddr DecEq-RwdAddr = derive-DecEq\n    ( (quote BaseAddr      , DecEq-BaseAddr)\n    \u2237 (quote BootstrapAddr , DecEq-BootstrapAddr)\n    \u2237 (quote RwdAddr       , DecEq-RwdAddr)\n    \u2237 [] )\n\nmodule _ \u2983 _ : Show Network  \u2984 \u2983 _ : Show KeyHash  \u2984 \u2983 _ : Show ScriptHash  \u2984 where\n  instance\n    unquoteDecl Show-Credential = derive-Show [ (quote Credential , Show-Credential) ]\n    unquoteDecl Show-RwdAddr = derive-Show [ (quote RwdAddr , Show-RwdAddr) ]\n    Show-Credential\u00d7Coin : Show (Credential \u00d7 Coin)\n    Show-Credential\u00d7Coin = Show-\u00d7\n</pre>"},{"location":"Ledger.Core.Specification.Address.html#references","title":"References","text":"<p>[CVG19]  Jared Corduan and Polina Vinogradova and Matthias G\u00fcdemann. A Formal Specification of the Cardano Ledger. 2019.</p>"},{"location":"Ledger.Core.Specification.Crypto.html","title":"Cryptographic Primitives","text":"<p>We rely on a public key signing scheme for verification of spending. This section shows some of the types, functions and properties of this scheme.</p> <pre>\n{-# OPTIONS --safe #-}\nmodule Ledger.Core.Specification.Crypto where\n\nopen import Ledger.Prelude hiding (T)\nopen import Ledger.Prelude.Numeric.UnitInterval\n\nrecord isHashableSet (T : Type) : Type\u2081 where\n  constructor mkIsHashableSet\n  field THash : Type\n        \u2983 DecEq-THash \u2984 : DecEq      THash\n        \u2983 Show-THash  \u2984 : Show       THash\n        \u2983 DecEq-T     \u2984 : DecEq    T\n        \u2983 T-Hashable  \u2984 : Hashable T THash\nopen isHashableSet\n\nrecord HashableSet : Type\u2081 where\n  constructor mkHashableSet\n  field T : Type; \u2983 T-isHashable \u2984 : isHashableSet T\n  open isHashableSet T-isHashable public\n</pre>"},{"location":"Ledger.Core.Specification.Crypto.html#public-key-signature-scheme-definitions","title":"Public Key Signature Scheme Definitions","text":"<pre>record PKKScheme : Type\u2081 where\n  field\n</pre> <p>Types &amp; functions</p> <pre>    SKey VKey Sig Ser  : Type\n    isKeyPair          : SKey \u2192 VKey \u2192 Type\n    isSigned           : VKey \u2192 Ser \u2192 Sig \u2192 Type\n    sign               : SKey \u2192 Ser \u2192 Sig\n\n  KeyPair = \u03a3[ sk \u2208 SKey ] \u03a3[ vk \u2208 VKey ] isKeyPair sk vk\n</pre> <pre>  field\n    \u2983 Dec-isSigned \u2984 : isSigned \u2047\u00b3\n</pre> <p>Property of signatures</p> <pre>    isSigned-correct  : ((sk , vk , _) : KeyPair) (d : Ser) (\u03c3 : Sig)\n                      \u2192 sign sk d \u2261 \u03c3 \u2192 isSigned vk d \u03c3\n</pre> <pre>    \u2983 DecEq-Sig  \u2984 : DecEq Sig\n    \u2983 DecEq-Ser  \u2984 : DecEq Ser\n\nrecord CryptoStructure : Type\u2081 where\n  field pkk : PKKScheme\n\n  open PKKScheme pkk public\n\n  field \u2983 khs \u2984    : isHashableSet VKey\n        ScriptHash : Type; \u2983 DecEq-ScriptHash \u2984 : DecEq ScriptHash ; \u2983 Show-ScriptHash \u2984 : Show ScriptHash\n\n  open isHashableSet khs renaming (THash to KeyHash) hiding (DecEq-T) public\n\n-- TODO: KES and VRF\n</pre>"},{"location":"Ledger.Core.Specification.Epoch.html","title":"Epoch","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Core.Specification.Epoch where\n\nopen import Ledger.Prelude hiding (compare; Rel)\n\nopen import Agda.Builtin.FromNat\nopen import Algebra using (Semiring)\nopen import Data.Nat.Properties using (+-mono\u02e1-\u2264; +-cancel\u02e1-&lt;; +-*-semiring; suc-injective)\nopen import Data.Rational using (\u211a)\nimport      Data.Rational as \u211a\nimport      Data.Rational.Properties as \u211a\nopen import Data.Sum using ([_,_]\u2032)\n\nadditionVia : \u2200{A : Set} \u2192 (A \u2192 A) \u2192 \u2115 \u2192 A \u2192 A\nadditionVia sucFun zero r = r\nadditionVia sucFun (suc l) r = sucFun (additionVia sucFun l r)\n\nrecord EpochStructure : Type\u2081 where\n  field Slot\u02b3 : Semiring 0\u2113 0\u2113\n        Epoch : Type; \u2983 DecEq-Epoch \u2984 : DecEq Epoch; \u2983 Show-Epoch \u2984 : Show Epoch\n\n  Slot = Semiring.Carrier Slot\u02b3\n\n  field \u2983 DecPo-Slot \u2984   : HasDecPartialOrder\u2261 {A = Slot}\n        \u2983 DecEq-Slot \u2984   : DecEq Slot\n\n        epoch                         : Slot \u2192 Epoch\n        firstSlot                     : Epoch \u2192 Slot\n        RandomnessStabilisationWindow : Slot\n        StabilityWindow               : Slot\n        suc\u1d49                          : Epoch \u2192 Epoch\n\n  _+\u1d49_ = additionVia suc\u1d49\n\n  field\n        _+\u1d49'_           : \u2115 \u2192 Epoch \u2192 Epoch\n        +\u1d49\u2261+\u1d49'          : \u2200 {a b} \u2192 a +\u1d49 b \u2261 a +\u1d49' b\n\n  -- preorders and partial orders\n\n  instance\n    preoEpoch : HasPreorder\n    preoEpoch = hasPreorderFromStrictPartialOrder {_&lt;_ = _&lt;_ on firstSlot}\n      record\n        { isEquivalence = isEquivalence\n        ; irrefl = \u03bb where refl \u2192 &lt;-irrefl {A = Slot} refl\n        ; trans  = &lt;-trans {A = Slot}\n        ; &lt;-resp-\u2248 = (\u03bb where refl \u2192 id) , (\u03bb where refl \u2192 id)\n        }\n\n  field\n    e&lt;suc\u1d49 : \u2200 {e : Epoch} \u2192 e &lt; suc\u1d49 e\n    \u2264-pred\u1d49 : \u2200 {e e' : Epoch} \u2192 suc\u1d49 e \u2264 suc\u1d49 e' \u2192 e \u2264 e'\n\n  _ = _&lt;_ {A = Slot}  \u2047\u00b2 \u220b it\n  _ = _\u2264_ {A = Slot}  \u2047\u00b2 \u220b it\n  _ = _&lt;_ {A = Epoch} \u2047\u00b2 \u220b it\n  _ = _\u2264_ {A = Epoch} \u2047\u00b2 \u220b it\n\n  -- addition\n\n  open Semiring Slot\u02b3 renaming (_+_ to _+\u02e2_)\n\n  \u2115toEpoch : \u2115 \u2192 Epoch\n  \u2115toEpoch zero    = epoch 0#\n  \u2115toEpoch (suc n) = suc\u1d49 (\u2115toEpoch n)\n\n  instance\n    addSlot : HasAdd Slot\n    addSlot ._+_ = _+\u02e2_\n\n    addEpoch : HasAdd Epoch\n    addEpoch ._+_ e e' = epoch (firstSlot e + firstSlot e')\n\n    Number-Epoch : Number Epoch\n    Number-Epoch .Number.Constraint _ = \u22a4\n    Number-Epoch .Number.fromNat    x = \u2115toEpoch x\n\nrecord GlobalConstants : Type\u2081 where\n  field  Network : Type; \u2983 DecEq-Netw \u2984 : DecEq Network; \u2983 Show-Network \u2984 : Show Network\n         SlotsPerEpoch\u1d9c   : \u2115; \u2983 NonZero-SlotsPerEpoch\u1d9c \u2984 : NonZero SlotsPerEpoch\u1d9c\n         ActiveSlotCoeff  : \u211a; \u2983 Positive-ActiveSlotCoeff \u2984 : \u211a.Positive ActiveSlotCoeff\n         RandomnessStabilisationWindow\u1d9c : \u2115\n         StabilityWindow\u1d9c : \u2115\n         MaxLovelaceSupply\u1d9c : Coin\n         Quorum : \u2115\n         NetworkId : Network\n\n  instance\n    NonZero-ActiveSlotCoeff : \u211a.NonZero ActiveSlotCoeff\n    NonZero-ActiveSlotCoeff = \u211a.&gt;-nonZero (\u211a.positive\u207b\u00b9 ActiveSlotCoeff)\n\n  \u2115+\u1d49\u2261+\u1d49' : \u2200 {a b} \u2192 additionVia suc a b \u2261 a + b\n  \u2115+\u1d49\u2261+\u1d49' {zero} {b} = refl\n  \u2115+\u1d49\u2261+\u1d49' {suc a} {b} = cong suc (\u2115+\u1d49\u2261+\u1d49' {a} {b})\n\n  \u2115EpochStructure : EpochStructure\n  \u2115EpochStructure = \u03bb where\n    .Slot\u02b3                         \u2192 +-*-semiring\n    .DecPo-Slot                    \u2192 \u2115-hasDecPartialOrder\n    .Epoch                         \u2192 \u2115\n    .epoch slot                    \u2192 slot / SlotsPerEpoch\u1d9c\n    .firstSlot e                   \u2192 e * SlotsPerEpoch\u1d9c\n    .RandomnessStabilisationWindow \u2192 RandomnessStabilisationWindow\u1d9c\n    .StabilityWindow               \u2192 StabilityWindow\u1d9c\n    .suc\u1d49                          \u2192 suc\n    .e&lt;suc\u1d49                        \u2192 +-mono\u02e1-\u2264 _ (&gt;-nonZero\u207b\u00b9 SlotsPerEpoch\u1d9c)\n    .\u2264-pred\u1d49                       \u2192 [ (\u03bb p \u2192 inj\u2081 (+-cancel\u02e1-&lt; _ _ _ p)) , (\u03bb p \u2192 inj\u2082 (suc-injective p)) ]\u2032\n    ._+\u1d49'_                         \u2192 _+_\n    .+\u1d49\u2261+\u1d49' {a} {b}                \u2192 \u2115+\u1d49\u2261+\u1d49' {a} {b}\n\n   where open EpochStructure\n\nopen GlobalConstants using (\u2115EpochStructure) public\n</pre>"},{"location":"Ledger.Core.Specification.html","title":"Introduction","text":"<p>The submodules collected here, under the <code>Ledger.Core.Specification</code> module, define some of the core types of the ledger that remain unchanged across ledger eras.</p> <pre>module Ledger.Core.Specification where\n</pre>"},{"location":"Ledger.Core.Specification.html#addresses","title":"Addresses","text":"<p>The <code>Address</code> module defines credentials and various address types.</p> <pre>import Ledger.Core.Specification.Address\n</pre>"},{"location":"Ledger.Core.Specification.html#cryptography","title":"Cryptography","text":"<p>The <code>Crypto</code> module defines cryptographic primitives and structures.</p> <pre>import Ledger.Core.Specification.Crypto\n</pre>"},{"location":"Ledger.Core.Specification.html#epoch","title":"Epoch","text":"<p>The <code>Epoch</code> module defines epoch-related concepts and structures.</p> <pre>import Ledger.Core.Specification.Epoch\n</pre>"},{"location":"Ledger.Core.html","title":"Ledger.Core","text":"<pre>module Ledger.Core where\n\nimport Ledger.Core.Specification\n</pre>"},{"location":"Ledger.Dijkstra.Specification.Abstract.html","title":"Abstract","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\nopen import Ledger.Dijkstra.Specification.Transaction\n\nmodule Ledger.Dijkstra.Specification.Abstract (txs : TransactionStructure) where\n\nopen TransactionStructure txs\nopen import Ledger.Dijkstra.Specification.Certs govStructure\n\nrecord indexOf : Type where\n  field\n    indexOfDCert    : DCert \u2192 List DCert \u2192 Maybe Ix\n    indexOfRwdAddr  : RewardAddress \u2192 Withdrawals \u2192 Maybe Ix\n    indexOfTxIn     : TxIn \u2192 \u2119 TxIn \u2192 Maybe Ix\n    indexOfPolicyId : ScriptHash \u2192 \u2119 ScriptHash \u2192 Maybe Ix\n    indexOfVote     : GovVoter \u2192 List GovVoter \u2192 Maybe Ix\n    indexOfProposal : GovProposal \u2192 List GovProposal \u2192 Maybe Ix\n    indexOfGuard    : TxId \u00d7 ScriptHash \u2192 \u2119 (TxId \u00d7 ScriptHash) \u2192 Maybe Ix\n\nrecord AbstractFunctions : Type where\n  field txScriptFee     : Prices \u2192 ExUnits \u2192 Fees\n        serializedSize  : Value \u2192 MemoryEstimate\n        indexOfImp      : indexOf\n        runPLCScript    : CostModel \u2192 P2Script \u2192 ExUnits \u2192 List Data \u2192 Bool\n        scriptSize      : Script \u2192 \u2115\n</pre>"},{"location":"Ledger.Dijkstra.Specification.Certs.html","title":"Certs","text":"<pre>{-# OPTIONS --safe #-}\nopen import Ledger.Conway.Specification.Gov.Base\n  using (GovStructure)\n\nmodule Ledger.Dijkstra.Specification.Certs\n  (gs : GovStructure) where\n\nopen import Ledger.Conway.Specification.Certs gs public\n</pre>"},{"location":"Ledger.Dijkstra.Specification.Gov.Actions.html","title":"Actions","text":"<pre>{-# OPTIONS --safe #-}\nopen import Ledger.Conway.Specification.Gov.Base\n  using (GovStructure)\nmodule Ledger.Dijkstra.Specification.Gov.Actions\n  (gs : GovStructure) where\n\nopen import Ledger.Conway.Specification.Gov.Actions gs public\n</pre>"},{"location":"Ledger.Dijkstra.Specification.Gov.Base.html","title":"Base","text":"<pre>{-# OPTIONS --safe #-}\nmodule Ledger.Dijkstra.Specification.Gov.Base where\n\nopen import Ledger.Conway.Specification.Gov.Base public\n</pre>"},{"location":"Ledger.Dijkstra.Specification.PParams.html","title":"PParams","text":"<pre>{-# OPTIONS --safe #-}\nopen import Ledger.Core.Specification.Crypto\n  using (CryptoStructure)\nopen import Ledger.Dijkstra.Specification.Script\n  using (ScriptStructure)\nopen import Ledger.Core.Specification.Epoch\n  using (EpochStructure)\n\nmodule Ledger.Dijkstra.Specification.PParams\n  (crypto : CryptoStructure )\n  (es     : EpochStructure)\n  (ss     : ScriptStructure crypto es)\n  where\n\nopen import Ledger.Conway.Specification.PParams crypto es ss public\n</pre>"},{"location":"Ledger.Dijkstra.Specification.Script.Validation.html","title":"Validation","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Dijkstra.Specification.Transaction\nopen import Ledger.Dijkstra.Specification.Abstract\n\nmodule Ledger.Dijkstra.Specification.Script.Validation\n  (txs : _) (open TransactionStructure txs)\n  (abs : AbstractFunctions txs) (open AbstractFunctions abs) (open indexOf indexOfImp)\n  where\n\nopen import Ledger.Prelude\nopen import Ledger.Dijkstra.Specification.Certs govStructure\n</pre> <pre>data ScriptPurpose : Type where\n  Cert     : DCert               \u2192 ScriptPurpose\n  Rwrd     : RewardAddress       \u2192 ScriptPurpose\n  Mint     : ScriptHash          \u2192 ScriptPurpose\n  Spend    : TxIn                \u2192 ScriptPurpose\n  Vote     : GovVoter            \u2192 ScriptPurpose\n  Propose  : GovProposal         \u2192 ScriptPurpose\n  Guard    : (TxId \u00d7 ScriptHash) \u2192 ScriptPurpose\n</pre> <pre>private variable\n  \u2113 : TxLevel\n\nrdptr : (Tx \u2113) \u2192 ScriptPurpose \u2192 Maybe (RedeemerPtr \u2113)\nrdptr tx = \u03bb where\n  (Cert h)              \u2192 map (Cert    ,_) $ indexOfDCert    h txCerts\n  (Rwrd h)              \u2192 map (Reward  ,_) $ indexOfRwdAddr  h txWithdrawals\n  (Mint h)              \u2192 map (Mint    ,_) $ indexOfPolicyId h (policies mint)\n  (Spend h)             \u2192 map (Spend   ,_) $ indexOfTxIn     h txIns\n  (Vote h)              \u2192 map (Vote    ,_) $ indexOfVote     h (map GovVote.voter txGovVotes)\n  (Propose h)           \u2192 map (Propose ,_) $ indexOfProposal h txGovProposals\n  (Guard h)             \u2192 map (Guard   ,_) $ indexOfGuard    h (getTxScripts tx)\n where open TxBody (TxBodyOf tx)\n-- getSubTxScripts : TopLevelTx \u2192 \u2119 (TxId \u00d7 ScriptHash)\n\nindexedRdmrs : (Tx \u2113) \u2192 ScriptPurpose \u2192 Maybe (Redeemer \u00d7 ExUnits)\nindexedRdmrs tx sp = maybe (\u03bb x \u2192 lookup\u1d50? txRedeemers x) nothing (rdptr tx sp)\n  where open Tx tx; open TxWitnesses txWitnesses\n\ngetDatum : Tx \u2113 \u2192 UTxO \u2192 ScriptPurpose \u2192 Maybe Datum\ngetDatum tx utxo (Spend txin) =\n  do (_ , _ , just d , _) \u2190 lookup\u1d50? utxo txin where\n                            (_ , _ , nothing , _) \u2192 nothing\n     case d of \u03bb where\n       (inj\u2081 d) \u2192 just d\n       (inj\u2082 h) \u2192 lookup\u1d50? (setToMap (map\u02e2 &lt; hash , id &gt; (DataOf tx))) h\ngetDatum tx utxo _ = nothing\n</pre> <pre>record TxInfo : Type where\n  field realizedInputs : UTxO\n        txOuts         : Ix \u21c0 TxOut\n        txFee          : Maybe Fees\n        mint           : Value\n        txCerts        : List DCert\n        txWithdrawals  : Withdrawals\n        txVldt         : Maybe Slot \u00d7 Maybe Slot\n        vkKey          : \u2119 KeyHash\n        txData         : \u2119 Datum\n        txId           : TxId\n\n\ntxInfo : (\u2113 : TxLevel) \u2192 UTxO \u2192 Tx \u2113 \u2192 TxInfo\n\ntxInfo TxLevelTop utxo tx =\n  record  { realizedInputs = utxo \u2223 txIns\n          ; txOuts = txOuts\n          ; txFee = just txFee\n          ; mint = mint\n          ; txCerts = txCerts\n          ; txWithdrawals = txWithdrawals\n          ; txVldt = txVldt\n          ; vkKey = txRequiredGuards -- ?\n          ; txData = DataOf tx\n          ; txId = txId\n          } where open Tx tx; open TxBody txBody\n\ntxInfo TxLevelSub utxo tx =\n  record  { realizedInputs = utxo \u2223 txIns\n          ; txOuts = txOuts\n          ; txFee = nothing\n          ; mint = mint\n          ; txCerts = txCerts\n          ; txWithdrawals = txWithdrawals\n          ; txVldt = txVldt\n          ; vkKey = txRequiredGuards  -- ?\n          ; txData = DataOf tx\n          ; txId = txId\n          } where open Tx tx; open TxBody txBody\n</pre> <pre>credsNeededMinusCollateral : {\u2113 : TxLevel} \u2192 TxBody \u2113 \u2192 \u2119 (ScriptPurpose \u00d7 Credential)\ncredsNeededMinusCollateral txb = a \u222a b \u222a c \u222a d \u222a e\n  where\n  a b c d e : \u2119 (ScriptPurpose \u00d7 Credential)\n  a = map\u02e2 (\u03bb a \u2192 (Rwrd a , CredentialOf a)) (dom \u2223 WithdrawalsOf txb \u2223)\n  b = mapPartial (\u03bb c \u2192 (Cert c ,_) &lt;$&gt; cwitness c) (fromList (DCertsOf txb))\n  c = map\u02e2 (\u03bb x \u2192 (Mint x , ScriptObj x)) (policies (ValueOf txb))\n  d = mapPartial (\u03bb v \u2192 if isGovVoterCredential v then (\u03bb {c} \u2192 just (Vote v , c)) else nothing)\n                 (fromList (map GovVoterOf (GovVotesOf txb)))\n  e = mapPartial (\u03bb p \u2192 if PolicyOf p then (\u03bb {sh} \u2192 just (Propose  p , ScriptObj sh)) else nothing)\n                 (fromList (GovProposalsOf txb))\n\ncredsNeeded : (\u2113 : TxLevel) \u2192 UTxO \u2192 (TxBody \u2113) \u2192 \u2119 (ScriptPurpose \u00d7 Credential)\ncredsNeeded TxLevelTop utxo txb = credsNeededMinusCollateral txb\n  \u222a map\u02e2 (\u03bb (i , o) \u2192 (Spend  i , payCred (proj\u2081 o))) ((utxo \u2223 (txIns \u222a collateralInputs)) \u02e2)\n  where open TxBody txb\n\ncredsNeeded TxLevelSub utxo txb = credsNeededMinusCollateral txb\n  \u222a map\u02e2 (\u03bb (i , o) \u2192 (Spend  i , payCred (proj\u2081 o))) ((utxo \u2223 txIns) \u02e2)\n  where open TxBody txb\n\n--valContext : TxInfo \u2192 ScriptPurpose \u2192 Data\n--valContext txinfo sp = toData (txinfo , sp)\n\ntxOutToDataHash : TxOut \u2192 Maybe DataHash\ntxOutToDataHash (_ , _ , d , _) = d &gt;&gt;= isInj\u2082\n\ntxOutToP2Script\n  : UTxO \u2192 (Tx \u2113)\n  \u2192 TxOut \u2192 Maybe P2Script\ntxOutToP2Script utxo tx (a , _) =\n  do sh \u2190 isScriptObj (payCred a)\n     s  \u2190 lookupScriptHash sh tx utxo\n     toP2Script s\n-- opaque\n--   collectP2ScriptsWithContext\n--     : PParams \u2192 (Tx \u2113) \u2192 UTxO\n--     \u2192 List (P2Script \u00d7 List Data \u00d7 ExUnits \u00d7 CostModel)\n--   collectP2ScriptsWithContext pp tx utxo\n--     = setToList\n--     $ mapPartial (\u03bb (sp , c) \u2192 if isScriptObj c\n--                                 then (\u03bb {sh} \u2192 toScriptInput sp sh)\n--                                 else nothing)\n--     $ credsNeeded utxo (TxBodyOf tx)\n--     where\n--       toScriptInput\n--         : ScriptPurpose \u2192 ScriptHash\n--         \u2192 Maybe (P2Script \u00d7 List Data \u00d7 ExUnits \u00d7 CostModel)\n--       toScriptInput sp sh =\n--         do s \u2190 lookupScriptHash sh tx utxo\n--            p2s \u2190 toP2Script s\n--            (rdmr , exunits) \u2190 indexedRdmrs tx sp\n--            let data'     = maybe [_] [] (getDatum tx utxo sp) ++ rdmr \u2237 [ valContext (txInfo (language p2s) pp utxo tx) sp ]\n--                costModel = PParams.costmdls pp\n--            just (p2s , data' , exunits , costModel)\n\nevalP2Scripts : List (P2Script \u00d7 List Data \u00d7 ExUnits \u00d7 CostModel) \u2192 Bool\nevalP2Scripts = all (\u03bb (s , d , eu , cm) \u2192 runPLCScript cm s eu d)\n</pre>"},{"location":"Ledger.Dijkstra.Specification.Script.html","title":"Script","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Core.Specification.Crypto using (CryptoStructure)\nopen import Ledger.Core.Specification.Epoch using (EpochStructure)\n\nmodule Ledger.Dijkstra.Specification.Script\n  (crypto : CryptoStructure)\n  (es     : EpochStructure) where\n\nopen import Ledger.Conway.Specification.Script crypto es public\n</pre>"},{"location":"Ledger.Dijkstra.Specification.TokenAlgebra.Base.html","title":"TokenAlgebra","text":"<pre>{-# OPTIONS --safe #-}\nopen import Prelude using (Type)\nmodule Ledger.Dijkstra.Specification.TokenAlgebra.Base (PolicyId : Type) where\n\nopen import Ledger.Conway.Specification.TokenAlgebra.Base PolicyId public\n</pre>"},{"location":"Ledger.Dijkstra.Specification.Transaction.html","title":"Transactions","text":"<p>A transaction in Dijkstra is very similar to a transaction in Conway except that now, as described in CIP 0118<sup>1</sup>, it may include</p> <ul> <li>other (sub)transactions as part of its body;</li> <li>guard scripts.</li> </ul> <pre>{-# OPTIONS --safe #-}\nmodule Ledger.Dijkstra.Specification.Transaction where\n\nimport Data.Maybe.Base as M\n\nopen import Ledger.Prelude renaming (filter\u1d50 to filter)\n\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Core.Specification.Epoch\nopen import Ledger.Dijkstra.Specification.Gov.Base\n\nimport Ledger.Core.Specification.Address renaming (RwdAddr to RewardAddress)\nimport Ledger.Dijkstra.Specification.Certs\nimport Ledger.Dijkstra.Specification.Gov.Actions\nimport Ledger.Dijkstra.Specification.PParams\nimport Ledger.Dijkstra.Specification.Script\nimport Ledger.Dijkstra.Specification.TokenAlgebra.Base\n\nopen import Tactic.Derive.DecEq\nopen import Relation.Nullary.Decidable using (\u230a_\u230b)\n</pre>"},{"location":"Ledger.Dijkstra.Specification.Transaction.html#sec:transaction-levels","title":"Transaction Levels","text":"<p>To differentiate between the two types of transactions (i.e. top-level and sub-level), we define the type of transaction level.</p> <pre>data TxLevel : Type where\n  TxLevelTop TxLevelSub : TxLevel\n</pre> <p>This type will be used, among other purposes, to provide a concise definition of the types of top-level and sub transactions in the Transaction Structure section below.</p> <p>Transactions cannot be arbitrarily nested. That is, a transaction (henceforth refered as top-level transaction) can include subtransactions, but these cannot include other subtransactions.</p> <p>To that end, we define two auxiliary functions that will aid in specifying which record fields of a transaction body are present at each <code>TxLevel</code>:</p> <pre>InTopLevel : TxLevel \u2192 Type \u2192 Type\nInTopLevel TxLevelTop X = X\nInTopLevel TxLevelSub _ = \u22a4\n\nInSubLevel : TxLevel \u2192 Type \u2192 Type\nInSubLevel TxLevelSub X = X\nInSubLevel TxLevelTop _ = \u22a4\n</pre> <p>These functions discriminate on an argument of type <code>TxLevel</code> and either act as the identity function on types or as the constant function that returns the unit type.</p> <pre>unquoteDecl DecEq-TxLevel = derive-DecEq ((quote TxLevel , DecEq-TxLevel) \u2237 [])\n\nprivate\n  variable\n    txLevel : TxLevel\n\ndata Tag : TxLevel \u2192 Type where\n  Spend Mint Cert Reward Vote Propose Guard : Tag txLevel\n  SubGuard : Tag TxLevelSub\n\nunquoteDecl DecEq-Tag = derive-DecEq ((quote Tag , DecEq-Tag) \u2237 [])\n</pre>"},{"location":"Ledger.Dijkstra.Specification.Transaction.html#sec:transaction-structure","title":"Transaction Structure","text":"<pre>record TransactionStructure : Type\u2081 where\n  field\n    Ix TxId AuxiliaryData  : Type\n    adHashingScheme        : isHashableSet AuxiliaryData\n    globalConstants        : GlobalConstants\n    crypto                 : CryptoStructure\n    epochStructure         : EpochStructure\n</pre> <pre>    \u2983 DecEq-Ix   \u2984 : DecEq Ix\n    \u2983 DecEq-TxId \u2984 : DecEq TxId\n  open isHashableSet adHashingScheme renaming (THash to ADHash) public\n  open GlobalConstants globalConstants public\n  open CryptoStructure crypto public\n  open Ledger.Dijkstra.Specification.TokenAlgebra.Base ScriptHash public\n  open Ledger.Core.Specification.Address Network KeyHash ScriptHash \u2983 it \u2984 \u2983 it \u2984 \u2983 it \u2984 public\n  open EpochStructure epochStructure public\n  open Ledger.Dijkstra.Specification.Script crypto epochStructure public\n  field\n</pre> <pre>    scriptStructure        : ScriptStructure\n</pre> <pre>  open ScriptStructure scriptStructure public\n  open Ledger.Dijkstra.Specification.PParams crypto epochStructure scriptStructure public\n  field\n</pre> <pre>    govParams              : GovParams\n    tokenAlgebra           : TokenAlgebra\n    txidBytes              : TxId \u2192 Ser\n</pre> <pre>  open GovParams govParams public\n  open TokenAlgebra tokenAlgebra public\n</pre> <pre>  govStructure : GovStructure\n  govStructure = record\n    -- TODO: figure out what to do with the hash\n    { TxId = TxId; DocHash = ADHash\n    ; cryptoStructure = crypto\n    ; epochStructure = epochStructure\n    ; scriptStructure = scriptStructure\n    ; govParams = govParams\n    ; globalConstants = globalConstants\n    }\n</pre> <pre>  module GovernanceActions = Ledger.Dijkstra.Specification.Gov.Actions govStructure\n  open GovernanceActions hiding (Vote; yes; no; abstain) public\n\n  open import Ledger.Dijkstra.Specification.Certs govStructure\n</pre> <pre>  TxIn : Type\n  TxIn = TxId \u00d7 Ix\n\n  TxOut : Type\n  TxOut = Addr \u00d7 Value \u00d7 Maybe (Datum \u228e DataHash) \u00d7 Maybe Script\n\n  UTxO : Type\n  UTxO = TxIn \u21c0 TxOut\n\n  RedeemerPtr : TxLevel \u2192 Type\n  RedeemerPtr txLevel  = Tag txLevel \u00d7 Ix\n\n  ProposedPPUpdates : Type\n  ProposedPPUpdates = KeyHash \u21c0 PParamsUpdate\n\n  Update : Type\n  Update = ProposedPPUpdates \u00d7 Epoch\n\n  record HasUTxO {a} (A : Type a) : Type a where\n    field UTxOOf : A \u2192 UTxO\n  open HasUTxO \u2983...\u2984 public\n</pre> <p>The type of transactions is defined as three mutually recursive records parameterised by a value of type <code>TxLevel</code>.</p> <p>The fields that depend on the transaction level use the auxiliary functions <code>InTopLevel</code> and <code>InSubLevel</code> defined in the section on Transaction Levels.</p> <pre>  mutual\n    record Tx (txLevel : TxLevel) : Type where\n      inductive\n      field\n        txBody       : TxBody txLevel\n        txWitnesses  : TxWitnesses txLevel\n        isValid      : InTopLevel txLevel Bool\n        txAuxData    : Maybe AuxiliaryData\n\n    record TxBody (txLevel : TxLevel) : Type where\n      inductive\n      field\n        txIns                : \u2119 TxIn\n        refInputs            : \u2119 TxIn\n        collateralInputs     : InTopLevel txLevel (\u2119 TxIn) -- only in top-level tx\n        txOuts               : Ix \u21c0 TxOut\n        txId                 : TxId\n        txCerts              : List DCert\n        txFee                : InTopLevel txLevel Fees -- only in top-level tx\n        txWithdrawals        : Withdrawals\n        txVldt               : Maybe Slot \u00d7 Maybe Slot\n        txADhash             : Maybe ADHash\n        txDonation           : Donations\n        txGovVotes           : List GovVote\n        txGovProposals       : List GovProposal\n        txNetworkId          : Maybe Network\n        currentTreasury      : Maybe Coin\n        mint                 : Value\n        scriptIntegrityHash  : Maybe ScriptHash\n\n        -- New in Dijkstra --\n        --\n        txSubTransactions    : InTopLevel txLevel (List (Tx TxLevelSub)) -- only in top-level tx\n        -- ^^^^^^^^^^ should this be a set? i.e. InTopLevel txLevel (\u2119 (Tx TxLevelSub))\n        --            (in getTxScripts function below we need it as a set)\n        --\n        txRequiredGuards          : \u2119 KeyHash -- replaces reqSigHash : \u2119 KeyHash\n        txRequiredTopLevelGuards  : InSubLevel txLevel (ScriptHash \u21c0 Datum) -- only in sub-level tx\n        ---------------------\n\n    record TxWitnesses (txLevel : TxLevel) : Type where\n      inductive\n      field\n        vKeySigs     : VKey \u21c0 Sig\n        scripts      : \u2119 Script\n        txData       : DataHash \u21c0 Datum\n        txRedeemers  : RedeemerPtr txLevel \u21c0 Redeemer \u00d7 ExUnits\n\n      scriptsP1 : \u2119 P1Script\n      scriptsP1 = mapPartial isInj\u2081 scripts\n</pre> <p>Using these types, we define the types of top-level and sub transaction as follows:</p> <pre>  TopLevelTx : Type\n  TopLevelTx = Tx TxLevelTop\n\n  SubLevelTx : Type\n  SubLevelTx = Tx TxLevelSub\n</pre> <p>In addition, we define the type of transactions in which its level could be either of them.</p> <pre>  AnyLevelTx : Type\n  AnyLevelTx = TopLevelTx \u228e SubLevelTx\n</pre> <pre>  record HasTxBody {txLevel} {a} (A : Type a) : Type a where\n    field TxBodyOf : A \u2192 TxBody txLevel\n  open HasTxBody  \u2983...\u2984 public\n\n  record HasTxId    {a} (A : Type a) : Type a where\n    field TxIdOf    : A \u2192 TxId\n  open HasTxId    \u2983...\u2984 public\n\n  record HasFees? {a} (A : Type a) : Type a where\n    field FeesOf? : A \u2192 Maybe Fees\n  open HasFees? \u2983...\u2984 public\n\n  record HasDCerts {a} (A : Type a) : Type a where\n    field DCertsOf : A \u2192 List DCert\n  open HasDCerts \u2983...\u2984 public\n\n  record HasData {a} (A : Type a) : Type a where\n    field DataOf : A \u2192 \u2119 Datum\n  open HasData \u2983...\u2984 public\n\n  record HasTxWitnesses {txLevel} {a} (A : Type a) : Type a where\n    field TxWitnessesOf : A \u2192 TxWitnesses txLevel\n  open HasTxWitnesses \u2983...\u2984 public\n\n  record HasValue {a} (A : Type a) : Type a where\n    field ValueOf : A \u2192 Value\n  open HasValue \u2983...\u2984 public\n\n  record HasGovProposals {a} (A : Type a) : Type a where\n    field GovProposalsOf : A \u2192 List GovProposal\n  open HasGovProposals \u2983...\u2984 public\n\n  record HasGovVotes {a} (A : Type a) : Type a where\n    field GovVotesOf : A \u2192 List GovVote\n  open HasGovVotes \u2983...\u2984 public\n\n  instance\n    HasTxBody-Tx : HasTxBody (Tx txLevel)\n    HasTxBody-Tx .TxBodyOf = Tx.txBody\n\n    HasTxWitnesses-Tx : HasTxWitnesses (Tx txLevel)\n    HasTxWitnesses-Tx .TxWitnessesOf = Tx.txWitnesses\n\n    HasDCerts-TxBody : HasDCerts (TxBody txLevel)\n    HasDCerts-TxBody .DCertsOf = TxBody.txCerts\n\n    HasWithdrawals-TxBody : HasWithdrawals (TxBody txLevel)\n    HasWithdrawals-TxBody .WithdrawalsOf = TxBody.txWithdrawals\n\n    HasWithdrawals-Tx : HasWithdrawals (Tx txLevel)\n    HasWithdrawals-Tx .WithdrawalsOf = WithdrawalsOf \u2218 TxBodyOf\n\n    HasValue-TxBody : HasValue (TxBody txLevel)\n    HasValue-TxBody .ValueOf = TxBody.mint\n\n    HasGovVotes-TxBody : HasGovVotes (TxBody txLevel)\n    HasGovVotes-TxBody .GovVotesOf = TxBody.txGovVotes\n\n    HasGovVotes-Tx : HasGovVotes (Tx txLevel)\n    HasGovVotes-Tx .GovVotesOf = GovVotesOf \u2218 TxBodyOf\n\n    HasGovProposals-TxBody : HasGovProposals (TxBody txLevel)\n    HasGovProposals-TxBody .GovProposalsOf = TxBody.txGovProposals\n\n    HasGovProposals-Tx : HasGovProposals (Tx txLevel)\n    HasGovProposals-Tx .GovProposalsOf = GovProposalsOf \u2218 TxBodyOf\n\n    HasFees?-TxBody : {\u2113 : TxLevel} \u2192 HasFees? (TxBody \u2113)\n    HasFees?-TxBody {TxLevelTop} .FeesOf? tbTop = just (TxBody.txFee tbTop)\n    HasFees?-TxBody {TxLevelSub} .FeesOf? tbSub = nothing\n\n    HasFees?-Tx : HasFees? (Tx txLevel)\n    HasFees?-Tx .FeesOf? = FeesOf? \u2218 TxBodyOf\n\n    HasTxId-Tx : HasTxId (Tx txLevel)\n    HasTxId-Tx .TxIdOf = TxBody.txId \u2218 TxBodyOf\n\n    HasCoin-TxOut : HasCoin TxOut\n    HasCoin-TxOut .getCoin = coin \u2218 proj\u2081 \u2218 proj\u2082\n\n    HasData-TxWitnesses : HasData (TxWitnesses txLevel)\n    HasData-TxWitnesses .DataOf = range \u2218 TxWitnesses.txData\n\n    HasData-Tx : HasData (Tx txLevel)\n    HasData-Tx .DataOf = DataOf \u2218 TxWitnessesOf\n\n  getValue : TxOut \u2192 Value\n  getValue (_ , v , _) = v\n\n  TxOut\u02b0 = Addr \u00d7 Value \u00d7 Maybe (Datum \u228e DataHash) \u00d7 Maybe ScriptHash\n\n  txOutHash : TxOut \u2192 TxOut\u02b0\n  txOutHash (a , v , d , s) = a , (v , (d , M.map hash s))\n\n  getValue\u02b0 : TxOut\u02b0 \u2192 Value\n  getValue\u02b0 (_ , v , _) = v\n\n  txinsVKey : \u2119 TxIn \u2192 UTxO \u2192 \u2119 TxIn\n  txinsVKey txins utxo = txins \u2229 dom (utxo \u2223^' (isVKeyAddr \u2218 proj\u2081))\n\n  scriptOuts : UTxO \u2192 UTxO\n  scriptOuts utxo = filter (\u03bb (_ , addr , _) \u2192 isScriptAddr addr) utxo\n\n  txinsScript : \u2119 TxIn \u2192 UTxO \u2192 \u2119 TxIn\n  txinsScript txins utxo = txins \u2229 dom (proj\u2081 (scriptOuts utxo))\n\n  refScripts : Tx txLevel \u2192 UTxO \u2192 List Script\n  refScripts tx utxo =\n    mapMaybe (proj\u2082 \u2218 proj\u2082 \u2218 proj\u2082) $ setToList (range (utxo \u2223 (txIns \u222a refInputs)))\n    where open Tx; open TxBody (TxBodyOf tx)\n\n  txscripts : Tx txLevel \u2192 UTxO \u2192 \u2119 Script\n  txscripts tx utxo = scripts (tx .txWitnesses) \u222a fromList (refScripts tx utxo)\n    where open Tx; open TxWitnesses\n\n  lookupScriptHash : ScriptHash \u2192 Tx txLevel \u2192 UTxO \u2192 Maybe Script\n  lookupScriptHash sh tx utxo =\n    if sh \u2208 map\u02e2 proj\u2081 (m \u02e2) then\n      just (lookup\u1d50 m sh)\n    else\n      nothing\n    where m = setToMap (map\u02e2 &lt; hash , id &gt; (txscripts tx utxo))\n\n  getSubTxScripts : SubLevelTx \u2192 \u2119 (TxId \u00d7 ScriptHash)\n  getSubTxScripts subtx = map\u02e2 (\u03bb hash \u2192 (TxIdOf subtx , hash)) (ScriptHashes subtx)\n    where\n    ScriptHashes : Tx TxLevelSub \u2192 \u2119 ScriptHash\n    ScriptHashes = dom \u2218 TxBody.txRequiredTopLevelGuards \u2218 TxBodyOf\n\n  getTxScripts : {\u2113 : TxLevel} \u2192 Tx \u2113 \u2192 \u2119 (TxId \u00d7 ScriptHash)\n  getTxScripts {TxLevelSub} = getSubTxScripts\n  getTxScripts {TxLevelTop} =\n    concatMap\u02e2 getSubTxScripts \u2218 fromList \u2218 TxBody.txSubTransactions \u2218 TxBodyOf\n</pre>"},{"location":"Ledger.Dijkstra.Specification.Transaction.html#changes-to-transaction-validity","title":"Changes to Transaction Validity","text":"<p>As discussed in [Ledger.Conway.Specification.Properties][], transaction validity is tricky, and this is as true in the Dijkstra era as it was in Conway, if not moreso.</p> <p>Here are some key points about transaction validity in the Dijkstra era.</p> <ol> <li> <p>Sub-transactions are not allowed to contain sub-transactions themselves.</p> </li> <li> <p>Sub-transactions are not allowed to contain collateral inputs.  Only a top-level     transaction is allowed to (furthermore, obligated to) provide sufficient     collateral for all scripts that are run as part of validating all transactions in     that batch.  If any script in a batch fails, none of the transactions in the batch     is applied; only the collateral is collected.</p> </li> <li> <p>Transactions using the new features of the Dijkstra era are not allowed to run     PlutusV3 scripts (nor earlier Plutus version scripts).</p> </li> <li> <p>All scripts are shared across all transactions within a single batch, so     attaching one script to either a sub- or a top-level-transaction allows other     transactions to run it without also including it in its own scripts.  This     includes references scripts that are sourced from the outputs to which reference     inputs point in the UTxO.  These referenced UTxO entries could be outputs of     preceding transactions in the batch.</p> <p>Datums (from reference inputs and from other transactions) are also shared in this way.  As before, only the datums fixed by the executing transaction are included in the <code>TxInfo</code> constructed for its scripts, however, now they don't necessarily have to be attached to that transaction.</p> </li> <li> <p>All inputs of all transactions in a single batch must be contained in the UTxO     set before any of the batch transactions are applied.  This ensures that     operation of scripts is not disrupted, for example, by temporarily duplicating     thread tokens, or falsifying access to assets via flash loans.  In the future,     this may be up for reconsideration.</p> </li> <li> <p>The batch must be balanced; i.e., preservation of value (POV) must hold.  The     updated <code>produced</code> and <code>consumed</code> calculations sum up the appropriate quantities     not for individual transactions, but for the entire batch, which includes the     top-level transaction and all its sub-transactions.</p> </li> <li> <p>All transactions (sub- and top-level) may specify a non-zero fee.  The total fee     summed up across all transactions in a batch is required to cover the minimum     fees of all transactions.  The fees specified in all transactions are always     collected.  Individual transactions in a batch do not need to meet the min-fee     requirement.</p> </li> <li> <p>The total size of the top-level transaction (including all its sub-transactions)     must be less than the <code>maxTxSize</code>.  This constraint is necessary to     ensure efficient network operation since batches will be transmitted wholesale     across the Cardano network.</p> </li> </ol> <ol> <li> <p>See CIP 0118; once finalized and merged, CIP 0118 will appear in the    main branch of the CIP repository; until then, it can be found    at https://github.com/polinavino/CIPs/tree/polina/CIP0118/CIP-0118.\u00a0\u21a9</p> </li> </ol>"},{"location":"Ledger.Dijkstra.Specification.html","title":"Introduction","text":"<p>This is the formal specification of the Cardano ledger for the Dijkstra era. The Agda source code which formalizes the ledger specification in the Conway era consists of the modules listed below.</p> <pre>{-# OPTIONS --safe #-}\nmodule Ledger.Dijkstra.Specification where\n</pre>"},{"location":"Ledger.Dijkstra.Specification.html#addresses","title":"Addresses","text":"<pre>import Ledger.Core.Specification.Address renaming (RwdAddr to RewardAddress)\n</pre>"},{"location":"Ledger.Dijkstra.Specification.html#epoch","title":"Epoch","text":"<pre>import Ledger.Core.Specification.Epoch\n</pre>"},{"location":"Ledger.Dijkstra.Specification.html#certificates","title":"Certificates","text":"<pre>import Ledger.Dijkstra.Specification.Certs\n</pre>"},{"location":"Ledger.Dijkstra.Specification.html#governance","title":"Governance","text":"<pre>import Ledger.Dijkstra.Specification.Gov.Base\nimport Ledger.Dijkstra.Specification.Gov.Actions\n</pre>"},{"location":"Ledger.Dijkstra.Specification.html#protocol-parameters","title":"Protocol Parameters","text":"<pre>import Ledger.Dijkstra.Specification.PParams\n</pre>"},{"location":"Ledger.Dijkstra.Specification.html#scripts","title":"Scripts","text":"<pre>import Ledger.Dijkstra.Specification.Script\nimport Ledger.Dijkstra.Specification.Script.Validation\n</pre>"},{"location":"Ledger.Dijkstra.Specification.html#token-algebras","title":"Token Algebras","text":"<pre>import Ledger.Dijkstra.Specification.TokenAlgebra.Base\n</pre>"},{"location":"Ledger.Dijkstra.Specification.html#transactions","title":"Transactions","text":"<pre>import Ledger.Dijkstra.Specification.Transaction\n</pre>"},{"location":"Ledger.Dijkstra.html","title":"Ledger.Dijkstra","text":"<pre>module Ledger.Dijkstra where\n\n--- Cardano ledger in the Dijkstra era\nimport Ledger.Dijkstra.Specification\n\n-- TODO:\n-- import Ledger.Dijkstra.Conformance       -- Conformance test reconciliation\n-- import Ledger.Dijkstra.Foreign.HSLedger  -- Haskell code extraction\n</pre>"},{"location":"Ledger.Introduction.html","title":"Introduction","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Axiom.Set using (Theory)\n\nmodule Ledger.Introduction (th : Theory) where\n\nopen import Prelude\n\nimport Data.Maybe as Maybe\nopen import Data.Maybe.Properties\nopen import Interface.STS hiding (_\u22a2_\u21c0\u27e6_\u27e7*_)\nopen import Relation.Binary.PropositionalEquality\n\nprivate variable\n  C S Sig : Type\n  \u0393 : C\n  s s' s'' : S\n  b sig : Sig\n  sigs : List Sig\n</pre> <p>This is the formal specification of the Cardano ledger.  The Agda source code with which we formalize the ledger specification and which generates this web site is open source and resides at the following</p> <p>repository url: https://github.com/IntersectMBO/formal-ledger-specifications</p> <p>The current status of each individual era is described in the table below.</p> <p> <p>Table 1. Specification Progress</p> Era Figures Prose Cleanup Shelley\u00a0 Partial Partial Not started Shelley-MA\u00a0 Partial Partial Not started Alonzo\u00a0 Partial Partial Not started Babbage\u00a0 Not started Not started Not started Conway\u00a0 Complete Partial Partial <p></p>"},{"location":"Ledger.Introduction.html#sec:overview","title":"Overview","text":"<p>The formal ledger specification Agda source code (and the documentation on this site that it generates), describes, in a precise and executable way, the behavior of the Cardano ledger as it is updated in response to a series of events.  Because of the precise nature of the documententation, it can be dense and difficult to read at times, and it can be helpful to have a high-level understanding of what it is trying to describe, which we present in this introduction.  Keep in mind that this section focuses on intuition, using terms (set in italics) that may be unfamiliar to some readers, but rest assured that later sections of the document will make the intuition and italicized terms precise.</p>"},{"location":"Ledger.Introduction.html#a-note-on-agda","title":"A Note on Agda","text":"<p>This specification is written using the Agda proof assistant and programming language.  We have made a considerable effort to ensure that this documentation is readable by people unfamiliar with Agda or other proof assistants.  However, by the nature of working in a formal language we have to play by its rules, meaning that some instances of uncommon notation are very difficult or impossible to avoid.  Some are explained in the Notation and Essential Agda sections, but there is no guarantee that those sections are complete.  If the meaning of an expression is confusing or unclear, please open an issue in the formal ledger repository with the \"notation\" label.</p> <p>Viewing the Complete Agda Source Code</p> <p>Throughout the documentation, source code snippets are presented in literate Agda but some of the more technical and less essential bits of code are hidden from view in order to improve flow and make the formalization easier to digest. However, if you wish to see the complete Agda source code, you can click on the \"Show more Agda\" button at the top of each page, which will reveal the complete Agda source code for the module presented on that page.  Alterantively, you can always find the source code in its entirety in the formal ledger repository.</p>"},{"location":"Ledger.Introduction.html#separation-of-concerns","title":"Separation of Concerns","text":"<p>The Cardano Node consists of three pieces,</p> <ul> <li> <p>a networking layer responsible for sending messages across the   internet,</p> </li> <li> <p>a consensus layer establishing a common order of valid blocks, and</p> </li> <li> <p>a ledger layer which determines whether a sequence of blocks is   valid.</p> </li> </ul> <p>Because of this separation, the ledger can be modeled as a state machine,</p> \\[s \\xrightarrow[X]{b} s'.\\] <p>More generally, we will consider state machines with an environment,</p> \\[\u0393 \u22a2 s \\xrightarrow[X]{b} s'.\\] <p>These are modelled as 4-ary relations between the environment \\(\u0393\\), an initial state \\(s\\), a signal \\(b\\) and a final state \\(s'\\). The ledger consists of roughly 25 (depending on the version) such relations that depend on each other, forming a directed graph that is almost a tree. STS diagram. Thus each such relation represents the transition rule of the state machine; \\(X\\) is simply a placeholder for the name of the transition rule.</p>"},{"location":"Ledger.Introduction.html#sec:ledger-state-transition-rules","title":"Ledger State Transition Rules","text":"<p>By a ledger we mean a structure that contains information about how funds in the system are distributed accross accounts\u2014that is, account balances, how such balances should be adjusted when transactions and proposals are processed, the ADA currently held in the treasury reserve, a list of stake pools operating the network, and so on.</p> <p>The ledger can be updated in response to certain events, such as receiving a new transaction, time passing and crossing an epoch boundary, enacting a governance proposal, to name a few. This document defines, as part of the behaior of the ledger, a set of rules that determine which events are valid and exactly how the state of the ledger should be updated in response to those events. The primary aim of this document is to provide a precise description of this system\u2014the ledger state, valid events and the rules for processing them.</p> <p>We model this via a number of state transition systems (STS), sometimes called \u201ctransition rules\u201d or just \u201crules.\u201d  These rules describe the different behaviors that determine how the whole system evolves and, taken together, they comprise a full description of the ledger protocol.  Each transition rule consists of the following components:</p> <ul> <li> <p>an environment consisting of data, read from the ledger state or the    outside world, which should be considered constant for the purposes of    the rule;</p> </li> <li> <p>an initial state, consisting of the subset of the full ledger state    that is relevant to the rule and which the rule can update;</p> </li> <li> <p>a signal or event, with associated data, that the rule can receive    or observe;</p> </li> <li> <p>a set of preconditions that must be met in order for the transition    to be valid;</p> </li> <li> <p>a new state that results from the transition rule.</p> </li> </ul> <p>For example, the UTXOW transition rule\u2014defined in the section called The UTXOW Transition System of the Utxow module\u2014checks that, among other things, a given transaction is signed by the appropriate parties.</p> <p>The transition rules can be composed in the sense that they may require other transition rules to hold as part of their preconditions. For example, the UTXOW rule mentioned above requires the UTXO rule, which checks that the inputs to the transaction exist, that the transaction is balanced, and several other conditions.</p> <p>Figure: STS Diagram</p> <p>State transition rules of the ledger specification, presented as a directed graph; each node represents a transition rule; an arrow from rule A to rule B indicates that B appears among the premises of A; a dotted arrow represents a dependency in the sense that the output of the target node is an input to the source node, either as part of the source state, the environment or the event.</p> <p> Rules added in Conway;  Rules modified in Conway</p> <p> </p> <p>A brief description of each transition rule is provided below, with a link to an Agda module and reference to a section where the rule is formally defined.</p> <ul> <li> <p>CHAIN is the top level transition in response to a new block that applies    the NEWEPOCH transition when crossing an epoch boundary, and the    LEDGERS transition on the list of transactions in the body.</p> </li> <li> <p>NEWEPOCH computes the new state as of the start of a new epoch; includes the    previous EPOCH transition.</p> </li> <li> <p>EPOCH computes the new state as of the end of an epoch; includes the ENACT,    RATIFY, and SNAP transition rules.</p> </li> <li> <p>RATIFY decides whether a pending governance action has reached the thresholds    it needs to be ratified.</p> </li> <li> <p>ENACT applies the result of a previously ratified governance action, such as    triggering a hard fork or updating the protocol parameters.</p> </li> <li> <p>SNAP computes new stake distribution snapshots.</p> </li> <li> <p>LEDGERS applies LEDGER repeatedly as needed, for each transaction in a list of    transactions.</p> </li> <li> <p>LEDGER is the full state update in response to a single transaction; it    includes the UTXOW, GOV, and CERTS rules.</p> </li> <li> <p>CERTS applies CERT repeatedly for each certificate in the transaction.</p> </li> <li> <p>CERT combines DELEG, POOL, GOVCERT transition rules, as well as some    additional rules shared by all three.</p> </li> <li> <p>DELEG handles registering stake addresses and delegating to a stake pool.</p> </li> <li> <p>GOVCERT handles registering and delegating to <code>DReps</code>.</p> </li> <li> <p>POOL handles registering and retiring stake pools.</p> </li> <li> <p>GOV handles voting and submitting governance proposals.</p> </li> <li> <p>UTXOW checks that a transaction is witnessed correctly with the appropriate    signatures, datums, and scripts; includes the UTXO transition rule.</p> </li> <li> <p>UTXO checks core invariants for an individual transaction to be valid, such    as the transaction being balanced, fees being paid, etc; include the    UTXOS transition rule.</p> </li> <li> <p>UTXOS checks that any relevant scripts needed by the transaction evaluate to true.</p> </li> </ul>"},{"location":"Ledger.Introduction.html#reflexive-transitive-closure","title":"Reflexive-transitive Closure","text":"<p>Some state transition rules need to be applied as many times as possible to arrive at a final state. Since we use this pattern multiple times, we define a closure operation which takes a transition rule and applies it as many times as possible.</p> <p>The closure <code>RTCI</code> of a relation <code>RTCB</code> is defined in Reflexive transitive closure. In the remainder of the text, the closure operation is called <code>RTC</code>.</p>"},{"location":"Ledger.Introduction.html#reflexive-transitive-closure_1","title":"Reflexive transitive closure","text":"<pre>\nmodule _ (_\u22a2_\u21c0\u27e6_\u27e7_ : C \u2192 S \u2192 Sig \u2192 S \u2192 Type) where\n</pre> <p>Closure type</p> <pre>\n  data _\u22a2_\u21c0\u27e6_\u27e7*_ : C \u2192 S \u2192 List Sig \u2192 S \u2192 Type where\n</pre> <p>Closure rules</p> <pre>\n    RTC-base :\n      \u0393 \u22a2 s \u21c0\u27e6 [] \u27e7* s\n\n    RTC-ind :\n      \u2219 \u0393 \u22a2 s  \u21c0\u27e6 sig  \u27e7  s'\n      \u2219 \u0393 \u22a2 s' \u21c0\u27e6 sigs \u27e7* s''\n      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      \u0393 \u22a2 s \u21c0\u27e6 sig \u2237 sigs \u27e7* s''\n</pre>"},{"location":"Ledger.Introduction.html#computational","title":"Computational","text":"<p>Since all such state machines need to be evaluated by the nodes and all nodes should compute the same states, the relations specified by them should be computable by functions. This can be captured by the definition in Computational relations which is parametrized over the state transition relation.</p>"},{"location":"Ledger.Introduction.html#computational-relations","title":"Computational relations","text":"<pre>\nrecord Computational (_\u22a2_\u21c0\u2987_,X\u2988_ : C \u2192 S \u2192 Sig \u2192 S \u2192 Type) : Type where\n  field\n    compute     : C \u2192 S \u2192 Sig \u2192 Maybe S\n    \u2261-just\u21d4STS  : compute \u0393 s b \u2261 just s' \u21d4 \u0393 \u22a2 s \u21c0\u2987 b ,X\u2988 s'\n\n  nothing\u21d2\u2200\u00acSTS : compute \u0393 s b \u2261 nothing \u2192 \u2200 s' \u2192 \u00ac \u0393 \u22a2 s \u21c0\u2987 b ,X\u2988 s'\n</pre> <pre>\n  nothing\u21d2\u2200\u00acSTS comp\u2261nothing s' h rewrite \u2261-just\u21d4STS .Equivalence.from h =\n    case comp\u2261nothing of \u03bb ()\n</pre> <p>Unpacking this, we have a <code>compute</code> function that computes a final state from a given environment, state and signal. The second piece is correctness: <code>compute</code> succeeds with some final state if and only if that final state is in relation to the inputs.</p> <p>This has two further implications:</p> <ul> <li> <p>Since <code>compute</code> is a function, the state transition   relation is necessarily a (partial) function; i.e., there is at most   one possible final state for each input data. Otherwise, we could   prove that <code>compute</code> could evaluates to two different   states on the same inputs, which is impossible since it is a function.</p> </li> <li> <p>The actual definition of <code>compute</code> is irrelevant\u2014any two   implementations of <code>compute</code> have to produce the same   result on any input. This is because we can simply chain the   equivalences for two different <code>compute</code> functions   together.</p> </li> </ul> <p>What this all means in the end is that if we give a <code>Computational</code> instance for every relation defined in the ledger, we also have an executable version of the rules which is guaranteed to be correct. This is indeed something we have done, and the same source code that generates this document also generates a Haskell library that lets anyone run this code.</p>"},{"location":"Ledger.Introduction.html#sec:sets-maps","title":"Sets &amp; Maps","text":"<p>The ledger heavily uses set theory. For various reasons it was necessary to implement our own set theory (there will be a paper on this some time in the future). Crucially, the set theory is completely abstract (in a technical sense\u2014Agda has an abstract keyword) meaning that implementation details of the set theory are irrelevant. Additionally, all sets in this specification are finite.</p> <p>We use this set theory to define maps as seen below, which are used in many places. We usually think of maps as partial functions (i.e., functions not necessarily defined everywhere\u2014equivalently, \"left-unique\" relations) and we use the harpoon arrow to distinguish such maps from standard Agda functions which use . The code below also gives notation for the powerset operation, <code>PowerSet</code>, used to form a type of sets with elements in a given type, as well as the subset relation and the equality relation for sets.</p> <p>When we need to convert a list to its set of elements, we write <code>fromList</code>\u00a0.</p> <pre>\nopen Theory th using (_\u2208_) renaming (Set to \u2119)\nprivate variable\n  a c : Level\n  A : Type a\n\u03a3-syntax' : (A : Type a) \u2192 (A \u2192 Type c) \u2192 Type _\n\u03a3-syntax' = \u03a3\nsyntax \u03a3-syntax' A (\u03bb x \u2192 B) = x \u2208 A \ufe50 B\n</pre> <pre>\n_\u2286_ : {A : Type} \u2192 \u2119 A \u2192 \u2119 A \u2192 Type\nX \u2286 Y = \u2200 {x} \u2192 x \u2208 X \u2192 x \u2208 Y\n\n_\u2261\u1d49_ : {A : Type} \u2192 \u2119 A \u2192 \u2119 A \u2192 Type\nX \u2261\u1d49 Y = X \u2286 Y \u00d7 Y \u2286 X\n\nRel : Type \u2192 Type \u2192 Type\nRel A B = \u2119 (A \u00d7 B)\n\nleft-unique : {A B : Type} \u2192 Rel A B \u2192 Type\nleft-unique R = \u2200 {a b b'} \u2192 (a , b) \u2208 R \u2192 (a , b') \u2208 R \u2192 b \u2261 b'\n\n_\u21c0_ : Type \u2192 Type \u2192 Type\nA \u21c0 B = r \u2208 Rel A B \ufe50 left-unique r\n</pre>"},{"location":"Ledger.Introduction.html#sec:prop-as-types","title":"Propositions as Types, Properties and Relations","text":"<p>In type theory we represent propositions as types and proofs of a proposition as elements of the corresponding type. A unary predicate is a function that takes each <code>x</code> (of some type <code>A</code>) and returns a proposition <code>P</code>(<code>x</code>). Thus, a predicate is a function of type <code>A</code> \u2192 <code>Type</code>. A binary relation <code>R</code> between <code>A</code> and <code>B</code> is a function that takes a pair of values <code>x</code> and <code>y</code> and returns a proposition asserting that the relation <code>R</code> holds between <code>x</code> and <code>y</code>. Thus, such a relation is a function of type <code>A</code> <code>\u00d7</code> <code>B</code> \u2192 <code>Type</code> or <code>A</code> \u2192 <code>B</code> \u2192 <code>Type</code>.</p> <p>These relations are typically required to be decidable, which means that there is a boolean-valued function that computes whether the predicate holds or not. This means that it is generally safe to think of predicates simply returning a boolean value instead.</p>"},{"location":"Ledger.PreConway.Conformance.NewPP.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Relation.Nullary.Decidable\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.Conformance.NewPP.Properties (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.PreConway.Conformance.PPUp txs\nopen import Ledger.PreConway.Conformance.NewPP txs\n\ninstance\n  Computational-NEWPP : Computational _\u22a2_\u21c0\u2987_,NEWPP\u2988_ String\n  Computational-NEWPP = record {M} where module M \u0393 s (open NewPParamState s) where\n    computeProof = \u03bb where\n      nothing \u2192 success (_ , NEWPP-Reject)\n      (just upd) \u2192 let newpp = applyUpdate pparams upd in\n        case \u00bf viablePParams newpp \u00bf of \u03bb where\n          (yes p) \u2192 success (_ , NEWPP-Accept p)\n          (no _)  \u2192 failure \"Failed in NEWPP\"\n\n    completeness : _\n    completeness sig s' h with sig | h\n    ... | nothing  | NEWPP-Reject   = refl\n    ... | just upd | NEWPP-Accept p = refl\n</pre>"},{"location":"Ledger.PreConway.Conformance.NewPP.html","title":"NewPP","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Relation.Nullary.Decidable\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.Conformance.NewPP (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.PreConway.Conformance.PPUp txs\n\nrecord NewPParamEnv : Type where\n--  field\n\nrecord NewPParamState : Type where\n  field\n    pparams  : PParams\n    ppup     : PPUpdateState\n\ninstance\n  unquoteDecl HasCast-NewPParamState = derive-HasCast\n    [ (quote NewPParamState , HasCast-NewPParamState) ]\n\nupdatePPUp : PParams \u2192 PPUpdateState \u2192 PPUpdateState\nupdatePPUp pparams record { fpup = fpup }\n  with all\u1d47 \u00bf isViableUpdate pparams \u00bf\u00b9 (range fpup)\n... | false  = record { pup = \u2205\u1d50    ; fpup = \u2205\u1d50 }\n... | true   = record { pup = fpup  ; fpup = \u2205\u1d50 }\n\nvotedValue : ProposedPPUpdates \u2192 PParams \u2192 \u2115 \u2192 Maybe PParamsUpdate\nvotedValue pup pparams quorum =\n  case any? (\u03bb u \u2192 length\u02e2 (pup \u2223^ fromList [ u ]) \u2265? quorum) (range pup) of\n    \u03bb  where\n       (no  _)        \u2192 nothing\n       (yes (u , _))  \u2192 just u\n\nprivate variable\n  \u0393 : NewPParamEnv\n  s s' : NewPParamState\n  upd : PParamsUpdate\n\ndata _\u22a2_\u21c0\u2987_,NEWPP\u2988_ : NewPParamEnv \u2192 NewPParamState \u2192 Maybe PParamsUpdate \u2192 NewPParamState \u2192 Type where\n\n  NEWPP-Accept : \u2200 {\u0393} \u2192 let open NewPParamState s; newpp = applyUpdate pparams upd in\n    viablePParams newpp\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u0393 \u22a2 s \u21c0\u2987 just upd ,NEWPP\u2988 $\\begin{pmatrix} \\,\\href{Ledger.PreConway.Conformance.NewPP.html#1386}{\\htmlId{1514}{\\htmlClass{Bound}{\\text{newpp}}}}\\, \\\\ \\,\\href{Ledger.PreConway.Conformance.NewPP.html#644}{\\htmlId{1522}{\\htmlClass{Function}{\\text{updatePPUp}}}}\\, \\,\\href{Ledger.PreConway.Conformance.NewPP.html#1386}{\\htmlId{1533}{\\htmlClass{Bound}{\\text{newpp}}}}\\, \\,\\href{Ledger.PreConway.Conformance.NewPP.html#498}{\\htmlId{1539}{\\htmlClass{Function}{\\text{ppup}}}}\\, \\end{pmatrix}$\n\n  NEWPP-Reject : \u2200 {\u0393} \u2192\n    \u0393 \u22a2 s \u21c0\u2987 nothing ,NEWPP\u2988 s\n\n</pre>"},{"location":"Ledger.PreConway.Conformance.PPUp.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (_*_)\nopen Computational \u2983...\u2984; open HasDecPartialOrder \u2983...\u2984\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.Conformance.PPUp.Properties (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.PreConway.Conformance.PPUp txs\n\nprivate\n  -- Ring literals\n  open import Agda.Builtin.FromNat\n  open import Algebra; open Semiring Slot\u02b3 using (_*_)\n  open import stdlib.Algebra.Literals; open Semiring-Lit Slot\u02b3\n\n  Current-Property : PPUpdateEnv \u2192 Update \u2192 Type\n  Current-Property \u0393 (pup , e) = let open PPUpdateEnv \u0393 in\n      dom pup \u2286 dom genDelegs\n      \u00d7 All (isViableUpdate pparams) (range pup)\n      \u00d7 slot + 2 * StabilityWindow &lt; firstSlot (epoch slot + 1)\n      \u00d7 epoch slot \u2261 e\n\n  Future-Property : PPUpdateEnv \u2192 Update \u2192 Type\n  Future-Property \u0393 (pup , e) = let open PPUpdateEnv \u0393 in\n      dom pup \u2286 dom genDelegs\n      \u00d7 All (isViableUpdate pparams) (range pup)\n      \u00d7 firstSlot (epoch slot + 1) \u2264 slot + 2 * StabilityWindow\n      \u00d7 epoch slot + 1 \u2261 e\n\ninstance\n  Computational-PPUP : Computational _\u22a2_\u21c0\u2987_,PPUP\u2988_ String\n  Computational-PPUP .computeProof \u0393 s = \u03bb where\n    (just (pup , e)) \u2192\n      case \u00bf Current-Property \u0393 (pup , e) \u00bf\n        ,\u2032 \u00bf Future-Property \u0393 (pup , e) \u00bf of \u03bb where\n        (yes (p\u2081 , p\u2082 , p\u2083 , p\u2084) , _) \u2192 success (-, PPUpdateCurrent p\u2081 p\u2082 p\u2083 p\u2084)\n        (_ , yes (p\u2081 , p\u2082 , p\u2083 , p\u2084)) \u2192 success (-, PPUpdateFuture p\u2081 p\u2082 p\u2083 p\u2084)\n        (no _ , no _)                 \u2192 failure \"Failed in PPUP\"\n    nothing \u2192 success (-, PPUpdateEmpty)\n\n  Computational-PPUP .completeness \u0393 _ .nothing  _     PPUpdateEmpty = refl\n  Computational-PPUP .completeness \u0393 _ (just up) _ p   with p\n  Computational-PPUP .completeness \u0393 _ (just up) _ _ | PPUpdateCurrent p\u2081 p\u2082 p\u2083 p\u2084\n    rewrite dec-yes \u00bf Current-Property \u0393 up \u00bf (p\u2081 , p\u2082 , p\u2083 , p\u2084) .proj\u2082 = refl\n  Computational-PPUP .completeness \u0393 _ (just up) _ _ | PPUpdateFuture p\u2081 p\u2082 p\u2083 p\u2084\n    with \u00bf Current-Property \u0393 up \u00bf | \u00bf Future-Property \u0393 up \u00bf\n  ... | yes (_ , _ , \u00acp\u2083 , _) | _ = \u22a5-elim\n                                  $ &lt;\u21d2\u00ac&gt;\u228e\u2248 {A = Slot} \u00acp\u2083 (\u2264\u21d4&lt;\u2228\u2248 .Equivalence.to p\u2083)\n  ... | no _ | yes p = refl\n  ... | no _ | no \u00acp = \u22a5-elim (\u00acp (p\u2081 , p\u2082 , p\u2083 , p\u2084))\n</pre>"},{"location":"Ledger.PreConway.Conformance.PPUp.html","title":"PPUp","text":"<pre>\n{-# OPTIONS --safe #-}\n\nopen import Agda.Builtin.FromNat\nopen import Algebra; open import stdlib.Algebra.Literals\nimport Data.Product.Properties as \u00d7\nimport Data.Nat as \u2115; import Data.Nat.Properties as \u2115\n\nopen import Ledger.Prelude hiding (_*_)\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.Conformance.PPUp (txs : _) (open TransactionStructure txs) where\n\nopen Semiring Slot\u02b3 using (_*_)\nopen Semiring-Lit Slot\u02b3\n\nprivate variable m n : \u2115\n\nGenesisDelegation = KeyHash \u21c0 (KeyHash \u00d7 KeyHash)\n\nrecord PPUpdateState : Type where\n\n  field\n\n    pup   : ProposedPPUpdates\n    fpup  : ProposedPPUpdates\n\nrecord PPUpdateEnv : Type where\n\n  field\n\n    slot       : Slot\n    pparams    : PParams\n    genDelegs  : GenesisDelegation\n\nviablePParams : PParams \u2192 Type\nviablePParams pp = \u22a4 -- TODO: block size check\n\nisViableUpdate : PParams \u2192 PParamsUpdate \u2192 Type\nisViableUpdate pp pup with applyUpdate pp pup\n... | pp' = pvCanFollow (PParams.pv pp) (PParams.pv pp') \u00d7 viablePParams pp'\n\nprivate variable\n  \u0393 : PPUpdateEnv\n  s : PPUpdateState\n  e : Epoch\n  pup pup\u02e2 fpup\u02e2 : ProposedPPUpdates\n\ninstance\n  Dec-pvCanFollow : pvCanFollow \u2047\u00b2\n  Dec-pvCanFollow {(m , n)} {pv} .dec with pv \u225f (m + 1 , 0) | pv \u225f (m , n + 1)\n  ... | no \u00acp    | no \u00acp\u2081   = no $ \u03bb where canFollowMajor \u2192 \u00acp  refl\n                                           canFollowMinor \u2192 \u00acp\u2081 refl\n  ... | no \u00acp    | yes refl = yes canFollowMinor\n  ... | yes refl | no \u00acp    = yes canFollowMajor\n  ... | yes refl | yes p    = \u22a5-elim $ \u2115.m+1+n\u2262m m $ \u00d7.\u00d7-\u2261,\u2261\u2190\u2261 p .proj\u2081\n\ndata _\u22a2_\u21c0\u2987_,PPUP\u2988_ : PPUpdateEnv \u2192 PPUpdateState \u2192 Maybe Update \u2192 PPUpdateState \u2192 Type where\n\n  PPUpdateEmpty : \u0393 \u22a2 s \u21c0\u2987 nothing ,PPUP\u2988 s\n\n  PPUpdateCurrent : let open PPUpdateEnv \u0393 in\n    dom pup \u2286 dom genDelegs\n    \u2192 All (isViableUpdate pparams) (range pup)\n    \u2192 slot + 2 * StabilityWindow &lt; firstSlot (epoch slot + 1)\n    \u2192 epoch slot \u2261 e\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u0393 \u22a2 record { pup = pup\u02e2 ; fpup = fpup\u02e2 } \u21c0\u2987 just (pup , e) ,PPUP\u2988\n        record { pup = pup \u222a\u02e1 pup\u02e2 ; fpup = fpup\u02e2 }\n\n  PPUpdateFuture : let open PPUpdateEnv \u0393 in\n    dom pup \u2286 dom genDelegs\n    \u2192 All (isViableUpdate pparams) (range pup)\n    \u2192 firstSlot (epoch slot + 1) \u2264 slot + 2 * StabilityWindow\n    \u2192 epoch slot + 1 \u2261 e\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u0393 \u22a2 record { pup = pup\u02e2 ; fpup = fpup\u02e2 } \u21c0\u2987 just (pup , e) ,PPUP\u2988\n        record { pup = pup\u02e2 ; fpup = pup \u222a\u02e1 fpup\u02e2 }\n\n</pre>"},{"location":"Ledger.PreConway.NewPP.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Relation.Nullary.Decidable\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.NewPP.Properties (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.PreConway.PPUp txs\nopen import Ledger.PreConway.NewPP txs\n\ninstance\n  Computational-NEWPP : Computational _\u22a2_\u21c0\u2987_,NEWPP\u2988_ String\n  Computational-NEWPP = record {M} where module M \u0393 s (open NewPParamState s) where\n    computeProof = \u03bb where\n      nothing \u2192 success (_ , NEWPP-Reject)\n      (just upd) \u2192 let newpp = applyUpdate pparams upd in\n        case \u00bf viablePParams newpp \u00bf of \u03bb where\n          (yes p) \u2192 success (_ , NEWPP-Accept p)\n          (no _)  \u2192 failure \"Failed in NEWPP\"\n\n    completeness : _\n    completeness sig s' h with sig | h\n    ... | nothing  | NEWPP-Reject   = refl\n    ... | just upd | NEWPP-Accept p = refl\n</pre>"},{"location":"Ledger.PreConway.NewPP.html","title":"Protocol Parameters Update","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Relation.Nullary.Decidable\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.NewPP (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.PreConway.PPUp txs\n\nrecord NewPParamEnv : Type where\n--  field\n</pre>"},{"location":"Ledger.PreConway.NewPP.html#sec:types-and-functions-for-the-newpp-transition-system","title":"Types and Functions for the NEWPP Transition System","text":"<pre>record NewPParamState : Type where\n  field\n    pparams  : PParams\n    ppup     : PPUpdateState\n\nupdatePPUp : PParams \u2192 PPUpdateState \u2192 PPUpdateState\nupdatePPUp pparams record { fpup = fpup }\n  with all\u1d47 \u00bf isViableUpdate pparams \u00bf\u00b9 (range fpup)\n... | false  = record { pup = \u2205\u1d50    ; fpup = \u2205\u1d50 }\n... | true   = record { pup = fpup  ; fpup = \u2205\u1d50 }\n\nvotedValue : ProposedPPUpdates \u2192 PParams \u2192 \u2115 \u2192 Maybe PParamsUpdate\nvotedValue pup pparams quorum =\n  case any? (\u03bb u \u2192 length\u02e2 (pup \u2223^ fromList [ u ]) \u2265? quorum) (range pup) of \u03bb where\n    (no  _)        \u2192 nothing\n    (yes (u , _))  \u2192 just u\n</pre> <pre>instance\n  unquoteDecl HasCast-NewPParamState = derive-HasCast\n    [ (quote NewPParamState , HasCast-NewPParamState) ]\n\nprivate variable\n  \u0393 : NewPParamEnv\n  s s' : NewPParamState\n  upd : PParamsUpdate\n</pre>"},{"location":"Ledger.PreConway.NewPP.html#sec:the-newpp-transition-system","title":"The NEWPP Transition System","text":"<pre>data _\u22a2_\u21c0\u2987_,NEWPP\u2988_ : NewPParamEnv \u2192 NewPParamState \u2192 Maybe PParamsUpdate \u2192 NewPParamState \u2192 Type where\n\n  NEWPP-Accept : \u2200 {\u0393} \u2192 let open NewPParamState s; newpp = applyUpdate pparams upd in\n    viablePParams newpp\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u0393 \u22a2 s \u21c0\u2987 just upd ,NEWPP\u2988 $\\begin{pmatrix} \\,\\href{Ledger.PreConway.NewPP.html#1710}{\\htmlId{1838}{\\htmlClass{Bound}{\\text{newpp}}}}\\, \\\\ \\,\\href{Ledger.PreConway.NewPP.html#725}{\\htmlId{1846}{\\htmlClass{Function}{\\text{updatePPUp}}}}\\, \\,\\href{Ledger.PreConway.NewPP.html#1710}{\\htmlId{1857}{\\htmlClass{Bound}{\\text{newpp}}}}\\, \\,\\href{Ledger.PreConway.NewPP.html#699}{\\htmlId{1863}{\\htmlClass{Function}{\\text{ppup}}}}\\, \\end{pmatrix}$\n\n  NEWPP-Reject : \u2200 {\u0393} \u2192\n    \u0393 \u22a2 s \u21c0\u2987 nothing ,NEWPP\u2988 s\n</pre>"},{"location":"Ledger.PreConway.PPUp.Properties.html","title":"Properties","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (_*_)\nopen Computational \u2983...\u2984; open HasDecPartialOrder \u2983...\u2984\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.PPUp.Properties (txs : _) (open TransactionStructure txs) where\n\nopen import Ledger.PreConway.PPUp txs\n\nprivate\n  -- Ring literals\n  open import Agda.Builtin.FromNat\n  open import Algebra; open Semiring Slot\u02b3 using (_*_)\n  open import stdlib.Algebra.Literals; open Semiring-Lit Slot\u02b3\n\n  Current-Property : PPUpdateEnv \u2192 Update \u2192 Type\n  Current-Property \u0393 (pup , e) = let open PPUpdateEnv \u0393 in\n      dom pup \u2286 dom genDelegs\n      \u00d7 All (isViableUpdate pparams) (range pup)\n      \u00d7 slot + 2 * StabilityWindow &lt; firstSlot (epoch slot + 1)\n      \u00d7 epoch slot \u2261 e\n\n  Future-Property : PPUpdateEnv \u2192 Update \u2192 Type\n  Future-Property \u0393 (pup , e) = let open PPUpdateEnv \u0393 in\n      dom pup \u2286 dom genDelegs\n      \u00d7 All (isViableUpdate pparams) (range pup)\n      \u00d7 firstSlot (epoch slot + 1) \u2264 slot + 2 * StabilityWindow\n      \u00d7 epoch slot + 1 \u2261 e\n\ninstance\n  Computational-PPUP : Computational _\u22a2_\u21c0\u2987_,PPUP\u2988_ String\n  Computational-PPUP .computeProof \u0393 s = \u03bb where\n    (just (pup , e)) \u2192\n      case \u00bf Current-Property \u0393 (pup , e) \u00bf\n        ,\u2032 \u00bf Future-Property \u0393 (pup , e) \u00bf of \u03bb where\n        (yes (p\u2081 , p\u2082 , p\u2083 , p\u2084) , _) \u2192 success (-, PPUpdateCurrent p\u2081 p\u2082 p\u2083 p\u2084)\n        (_ , yes (p\u2081 , p\u2082 , p\u2083 , p\u2084)) \u2192 success (-, PPUpdateFuture p\u2081 p\u2082 p\u2083 p\u2084)\n        (no _ , no _)                 \u2192 failure \"Failed in PPUP\"\n    nothing \u2192 success (-, PPUpdateEmpty)\n\n  Computational-PPUP .completeness \u0393 _ .nothing  _     PPUpdateEmpty = refl\n  Computational-PPUP .completeness \u0393 _ (just up) _ p   with p\n  Computational-PPUP .completeness \u0393 _ (just up) _ _ | PPUpdateCurrent p\u2081 p\u2082 p\u2083 p\u2084\n    rewrite dec-yes \u00bf Current-Property \u0393 up \u00bf (p\u2081 , p\u2082 , p\u2083 , p\u2084) .proj\u2082 = refl\n  Computational-PPUP .completeness \u0393 _ (just up) _ _ | PPUpdateFuture p\u2081 p\u2082 p\u2083 p\u2084\n    with \u00bf Current-Property \u0393 up \u00bf | \u00bf Future-Property \u0393 up \u00bf\n  ... | yes (_ , _ , \u00acp\u2083 , _) | _ = \u22a5-elim\n                                  $ &lt;\u21d2\u00ac&gt;\u228e\u2248 {A = Slot} \u00acp\u2083 (\u2264\u21d4&lt;\u2228\u2248 .Equivalence.to p\u2083)\n  ... | no _ | yes p = refl\n  ... | no _ | no \u00acp = \u22a5-elim (\u00acp (p\u2081 , p\u2082 , p\u2083 , p\u2084))\n</pre>"},{"location":"Ledger.PreConway.PPUp.html","title":"Protocol Parameter Update Proposal Mechanism","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Agda.Builtin.FromNat\nopen import Algebra; open import stdlib.Algebra.Literals\nimport Data.Product.Properties as \u00d7\nimport Data.Nat as \u2115; import Data.Nat.Properties as \u2115\n\nopen import Ledger.Prelude hiding (_*_)\nopen import Ledger.Conway.Specification.Transaction\n\nmodule Ledger.PreConway.PPUp (txs : _) (open TransactionStructure txs) where\n\nopen Semiring Slot\u02b3 using (_*_)\nopen Semiring-Lit Slot\u02b3\n\nprivate variable m n : \u2115\n</pre>"},{"location":"Ledger.PreConway.PPUp.html#sec:protocol-parameter-update-types","title":"Protocol Parameter Update Types","text":"<pre>GenesisDelegation = KeyHash \u21c0 (KeyHash \u00d7 KeyHash)\n\nrecord PPUpdateState : Type where\n  field\n    pup   : ProposedPPUpdates\n    fpup  : ProposedPPUpdates\n\nrecord PPUpdateEnv : Type where\n  field\n    slot       : Slot\n    pparams    : PParams\n    genDelegs  : GenesisDelegation\n</pre>"},{"location":"Ledger.PreConway.PPUp.html#sec:protocol-parameter-update-definitions","title":"Protocol Parameter Update Definitions","text":"<pre>viablePParams : PParams \u2192 Type\nviablePParams pp = \u22a4 -- TODO: block size check\n\nisViableUpdate : PParams \u2192 PParamsUpdate \u2192 Type\nisViableUpdate pp pup with applyUpdate pp pup\n... | pp' = pvCanFollow (PParams.pv pp) (PParams.pv pp') \u00d7 viablePParams pp'\n</pre> <pre>private variable\n  \u0393 : PPUpdateEnv\n  s : PPUpdateState\n  e : Epoch\n  pup pup\u02e2 fpup\u02e2 : ProposedPPUpdates\n\ninstance\n  Dec-pvCanFollow : pvCanFollow \u2047\u00b2\n  Dec-pvCanFollow {(m , n)} {pv} .dec with pv \u225f (m + 1 , 0) | pv \u225f (m , n + 1)\n  ... | no \u00acp    | no \u00acp\u2081   = no $ \u03bb where canFollowMajor \u2192 \u00acp  refl\n                                           canFollowMinor \u2192 \u00acp\u2081 refl\n  ... | no \u00acp    | yes refl = yes canFollowMinor\n  ... | yes refl | no \u00acp    = yes canFollowMajor\n  ... | yes refl | yes p    = \u22a5-elim $ \u2115.m+1+n\u2262m m $ \u00d7.\u00d7-\u2261,\u2261\u2190\u2261 p .proj\u2081\n\n</pre>"},{"location":"Ledger.PreConway.PPUp.html#sec:the-ppup-transition-system","title":"The PPUP Transition System","text":"<pre>data _\u22a2_\u21c0\u2987_,PPUP\u2988_ : PPUpdateEnv \u2192 PPUpdateState \u2192 Maybe Update \u2192 PPUpdateState \u2192 Type where\n\n  PPUpdateEmpty : \u0393 \u22a2 s \u21c0\u2987 nothing ,PPUP\u2988 s\n\n  PPUpdateCurrent : let open PPUpdateEnv \u0393 in\n    dom pup \u2286 dom genDelegs\n    \u2192 All (isViableUpdate pparams) (range pup)\n    \u2192 slot + 2 * StabilityWindow &lt; firstSlot (epoch slot + 1)\n    \u2192 epoch slot \u2261 e\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u0393 \u22a2 record { pup = pup\u02e2 ; fpup = fpup\u02e2 } \u21c0\u2987 just (pup , e) ,PPUP\u2988\n        record { pup = pup \u222a\u02e1 pup\u02e2 ; fpup = fpup\u02e2 }\n\n  PPUpdateFuture : let open PPUpdateEnv \u0393 in\n    dom pup \u2286 dom genDelegs\n    \u2192 All (isViableUpdate pparams) (range pup)\n    \u2192 firstSlot (epoch slot + 1) \u2264 slot + 2 * StabilityWindow\n    \u2192 epoch slot + 1 \u2261 e\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u0393 \u22a2 record { pup = pup\u02e2 ; fpup = fpup\u02e2 } \u21c0\u2987 just (pup , e) ,PPUP\u2988\n        record { pup = pup\u02e2 ; fpup = pup \u222a\u02e1 fpup\u02e2 }\n</pre>"},{"location":"Ledger.PreConway.html","title":"Ledger.PreConway","text":"<pre>{-# OPTIONS --safe #-}\nmodule Ledger.PreConway where\n\nimport Ledger.PreConway.NewPP\nimport Ledger.PreConway.NewPP.Properties\nimport Ledger.PreConway.PPUp\nimport Ledger.PreConway.PPUp.Properties\nimport Ledger.PreConway.Conformance.NewPP\nimport Ledger.PreConway.Conformance.NewPP.Properties\nimport Ledger.PreConway.Conformance.PPUp\nimport Ledger.PreConway.Conformance.PPUp.Properties\n</pre>"},{"location":"Ledger.Prelude.Base.html","title":"Base Types of the Cardano Ledger","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Prelude.Base where\n\nopen import Agda.Primitive using (lzero) renaming (Set to Type) public\nopen import Data.Nat\n</pre>"},{"location":"Ledger.Prelude.Base.html#basic-types","title":"Basic Types","text":"<pre>Coin : Type\nCoin = \u2115\n\nDonations Fees Reserves Treasury : Type\nDonations         = Coin\nFees              = Coin\nReserves          = Coin\nTreasury          = Coin\n</pre> <pre>{- Type classes\n   These provide a handy mechanism for associating a Coin value with a type and\n   provide a consistent way to access that value via a type class instance.\n-}\n\nrecord HasDonations {a} (A : Type a) : Type a where\n  field DonationsOf : A \u2192 Donations\nopen HasDonations \u2983...\u2984 public\n\nrecord HasFees {a} (A : Type a) : Type a where\n  field FeesOf : A \u2192 Fees\nopen HasFees \u2983...\u2984 public\n\nrecord HasReserves {a} (A : Type a) : Type a where\n  field ReservesOf : A \u2192 Reserves\nopen HasReserves \u2983...\u2984 public\n\nrecord HasTreasury {a} (A : Type a) : Type a where\n  field TreasuryOf : A \u2192 Treasury\nopen HasTreasury \u2983...\u2984 public\n\n{- For instance, we have record types representing entities that have fees or\n   donations associated with them.  If `A` is such a type with a field called `fees`,\n   then we would define the following instance of the `HasFees` type class:\n\n       HasFees-A : HasFees A\n       HasFees-A .FeesOf = A.fees\n\n   then, if `a : A`, we can access the fees of `a` via `FeesOf a`.  From this\n   contrived example, it may seem like this is overkill, but it can be quite useful\n   in practice when we have many different types that have fees or donations\n   associated with them, and we want to be able to access those values in a\n   consistent way.  Moreover, we have many examples of nested records that\n   contain fees or donations, and this allows us to access those values without\n   having to remember the specific paths to the field names of those record types.\n-}\n</pre>"},{"location":"Ledger.Prelude.Foreign.HSTypes.html","title":"HSTypes","text":"<pre>module Ledger.Prelude.Foreign.HSTypes where\n\n{-# FOREIGN GHC\n  {-# LANGUAGE DeriveGeneric #-}\n  {-# LANGUAGE DeriveFunctor #-}\n#-}\n\nopen import Prelude\n\nopen import Foreign.Haskell\nopen import stdlib.Foreign.Haskell.Empty public\nopen import Foreign.Haskell.Coerce\nopen import Data.Rational.Base\n\n{-# FOREIGN GHC\n  import GHC.Generics (Generic)\n  import Prelude hiding (Rational)\n  import GHC.Real (Ratio(..))\n#-}\n\n-- * Rational\n\ndata Rational : Type where\n  _,_ : \u2124 \u2192 \u2115 \u2192 Rational\n{-# COMPILE GHC Rational = data Rational ((:%)) #-}\n\n-- We'll generate code with qualified references to Rational in this\n-- module, so make sure to define it.\n{-# FOREIGN GHC type Rational = Ratio Integer #-}\n\n-- * Maps and Sets\n\nrecord HSMap K V : Type where\n  constructor MkHSMap\n  field assocList : List (Pair K V)\n\nrecord HSSet A : Type where\n  constructor MkHSSet\n  field elems : List A\n\n{-# FOREIGN GHC\n  newtype HSMap k v = MkHSMap [(k, v)]\n    deriving (Generic, Show, Eq, Ord)\n  newtype HSSet a = MkHSSet [a]\n    deriving (Generic, Show, Eq, Ord)\n#-}\n{-# COMPILE GHC HSMap = data HSMap (MkHSMap) #-}\n{-# COMPILE GHC HSSet = data HSSet (MkHSSet) #-}\n\n-- * ComputationResult\n\ndata ComputationResult E A : Type where\n  Success : A \u2192 ComputationResult E A\n  Failure : E \u2192 ComputationResult E A\n\n{-# FOREIGN GHC\n  data ComputationResult e a = Success a | Failure e\n    deriving (Functor, Eq, Show, Generic)\n\n  instance Applicative (ComputationResult e) where\n    pure = Success\n    (Success f) &lt;*&gt; x = f &lt;$&gt; x\n    (Failure e) &lt;*&gt; _ = Failure e\n\n  instance Monad (ComputationResult e) where\n    return = pure\n    (Success a) &gt;&gt;= m = m a\n    (Failure e) &gt;&gt;= _ = Failure e\n#-}\n{-# COMPILE GHC ComputationResult = data ComputationResult (Success | Failure) #-}\n</pre>"},{"location":"Ledger.Prelude.Foreign.Util.html","title":"Util","text":"<pre>module Ledger.Prelude.Foreign.Util where\n\nopen import Ledger.Prelude\n\npostulate\n  error : {A : Set} \u2192 String \u2192 A\n{-# FOREIGN GHC import Data.Text #-}\n{-# COMPILE GHC error = \\ _ s -&gt; error (unpack s) #-}\n</pre>"},{"location":"Ledger.Prelude.HasCoin.html","title":"HasCoin","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Prelude.HasCoin where\n\nopen import Prelude\nopen import Ledger.Prelude.Base\n\nrecord HasCoin {a} (A : Type a) : Type a where\n  field getCoin : A \u2192 Coin\n\nopen HasCoin \u2983...\u2984 public\n</pre>"},{"location":"Ledger.Prelude.Instances.html","title":"Instances","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Ledger.Prelude.Instances where\n\nopen import Prelude\nopen import Ledger.Prelude.Base\nopen import Ledger.Prelude.HasCoin\nopen import Interface.TypeClasses.HasSubtract\nopen import Interface.TypeClasses.HasSubset\n\nopen import abstract-set-theory.FiniteSetTheory\n  renaming (_\u2286_ to _\u2286\u02e2_)\n\ninstance\n  CommMonoid-\u2115-+ = NonUniqueInstances.CommMonoid-\u2115-+\n\n  HasCoin-Map : \u2200 {A} \u2192 \u2983 DecEq A \u2984 \u2192 HasCoin (A \u21c0 Coin)\n  HasCoin-Map .getCoin s = \u2211[ x \u2190 s ] x\n\n  HasCoin-Set : \u2200 {A} \u2192 \u2983 DecEq A \u2984 \u2192 HasCoin (\u2119 (A \u00d7 Coin))\n  HasCoin-Set .getCoin s = \u2211\u02e2[ (a , c) \u2190 s ] c\n\n  HasSubset-Set : \u2200 {A} \u2192 HasSubset (\u2119 A)\n  HasSubset-Set ._\u2286_ = _\u2286\u02e2_\n\n  HasSubtract-\u2119 : \u2200 {A} \u2192 \u2983 DecEq A \u2984 \u2192 HasSubtract (\u2119 A) (\u2119 A)\n  HasSubtract-\u2119 {A} ._-_ = _\uff3c_\n\n  HasSubset-Map : {A B : Set} \u2192 HasSubset (A \u21c0 B)\n  HasSubset-Map {A} {B} ._\u2286_ m\u2081 m\u2082 = {k : A} {v : B} \u2192 (k , v) \u2208 (m\u2081 \u02e2) \u2192 (k , v) \u2208 (m\u2082 \u02e2)\n\n\n</pre>"},{"location":"Ledger.Prelude.Numeric.PositiveNat.html","title":"PositiveNat","text":"<pre>{-# OPTIONS --safe #-}\nmodule Ledger.Prelude.Numeric.PositiveNat where\n\nopen import Prelude\n  hiding ([_,_]; [_]; _*_)\n\nopen import Class.Show using (Show; show)\n\nopen import Agda.Builtin.FromNat\nopen import Data.Nat using (\u2115; NonZero; _&gt;_)\nopen import Data.Refinement using (Refinement-syntax; value; _,_)\nopen import Data.Irrelevant\n\n-- PosNat: Non zero natural number.\nPosNat : Type\nPosNat = [ x \u2208 \u2115 \u2223 NonZero x ]\n\ninstance\n  Show-PosNat : Show PosNat\n  Show-PosNat .show (n , _) = show n\n\nfromPosNat : PosNat \u2192 \u2115\nfromPosNat = value\n\ntoPosNat : \u2115 \u2192 Maybe PosNat\ntoPosNat n with nonZero? n\n... | yes p = just (n , [ p ])\n... | no \u00acp = nothing\n\nmkPosNat : \u2200 (n : \u2115) \u2192 {T (does (nonZero? n))} \u2192 PosNat\nmkPosNat n {evidence}\n  with nonZero? n in eq\n... | no  _ = \u22a5-elim evidence\n... | yes p = n , [ p ]\n\nPosNat-IsNonZero : (n : PosNat) \u2192 NonZero (fromPosNat n)\nPosNat-IsNonZero (suc n , n&gt;0) .NonZero.nonZero = tt\n\nPosNat-Is&gt;0 : (n : PosNat) \u2192 fromPosNat n &gt; 0\nPosNat-Is&gt;0 (suc n , n&gt;0) = s\u2264s z\u2264n\n\nNumber-PosNat : Number PosNat\nNumber-PosNat = record\n  { Constraint = NonZero\n  ; fromNat = \u03bb n \u2983 p \u2984 \u2192 n , [ p ]\n  }\n</pre>"},{"location":"Ledger.Prelude.Numeric.UnitInterval.html","title":"UnitInterval","text":"<pre>{-# OPTIONS --safe #-}\n\n-- Rational number in the unit interval.\nmodule Ledger.Prelude.Numeric.UnitInterval where\n\nopen import Prelude\n  hiding ([_,_]; [_]; _*_)\n\nopen import Agda.Builtin.FromNat\nopen import Class.Show using (Show; show)\nopen import Data.Irrelevant using ([_])\nopen import Data.Rational using (\u211a; _\u2264_; _\u2264?_; _*_; nonNegative)\nopen import Data.Rational.Properties\nopen import Data.Rational.Show using () renaming (show to \u211ashow)\nopen import Data.Refinement using (Refinement-syntax; value; _,_)\n\nopen \u2264-Reasoning\n\n-- inUnitInterval predicate\ninUnitInterval : (x : \u211a) \u2192 Type\ninUnitInterval x = (0 \u2264 x) \u00d7 (x \u2264 1)\n\n-- Decide whether a rational number is in the unit interval.\nisInUnitInterval : (x : \u211a) \u2192 Dec (inUnitInterval x)\nisInUnitInterval x = (0 \u2264? x) \u00d7-dec (x \u2264? 1)\n\n-- Multiplying with a number from the unit interval only decreases.\ninUnitInterval-*-\u2264y : \u2200 (x y : \u211a) \u2192 inUnitInterval x \u2192 0 \u2264 y \u2192 x * y \u2264 y\ninUnitInterval-*-\u2264y x y (0\u2264x , x\u22641) 0\u2264y =\n  begin\n    x * y  \u2264\u27e8 *-mono\u02b3-\u2264-nonNeg y \u2983 nonNegative 0\u2264y \u2984 x\u22641 \u27e9\n    1 * y  \u2261\u27e8 *-identity\u02e1 _ \u27e9\n    y      \u220e\n\n-- Left multiplication by unit interval element preserves non-negativity.\ninUnitInterval-*-0\u2264 : \u2200 (x y : \u211a) \u2192 inUnitInterval y \u2192 0 \u2264 x \u2192 0 \u2264 x * y\ninUnitInterval-*-0\u2264 x y (0\u2264y , _) 0\u2264x =\n  begin\n    0      \u2261\u27e8 sym (*-zero\u02b3 x) \u27e9\n    x * 0  \u2264\u27e8 *-mono\u02e1-\u2264-nonNeg x \u2983 nonNegative 0\u2264x \u2984 0\u2264y \u27e9\n    x * y  \u220e\n\n-- Left multiplication by unit interval element preserves being upper boundeded by 1.\ninUnitInterval-*-\u22641 : \u2200 (x y : \u211a) \u2192 inUnitInterval x \u2192 y \u2264 1 \u2192 x * y \u2264 1\ninUnitInterval-*-\u22641 x y (0\u2264x , x\u22641) y\u22641 =\n  begin\n    x * y  \u2264\u27e8 *-mono\u02e1-\u2264-nonNeg x \u2983 nonNegative 0\u2264x \u2984 y\u22641 \u27e9\n    x * 1  \u2261\u27e8 *-identity\u02b3 _ \u27e9\n    x      \u2264\u27e8 x\u22641 \u27e9\n    1      \u220e\n\n-- UnitInterval: rational number in the unit interval [0, 1].\nUnitInterval : Type\nUnitInterval = [ x \u2208 \u211a \u2223 inUnitInterval x ]\n\ninstance\n  Show-UnitInterval : Show UnitInterval\n  Show-UnitInterval .show = \u211ashow \u2218 value\n\n-- In the cardano-ledger codebase:\n--  unboundRational\nfromUnitInterval : UnitInterval \u2192 \u211a\nfromUnitInterval = value\n\n-- In the cardano-ledger codebase:\n--  unboundRational\ntoUnitInterval : \u211a \u2192 Maybe UnitInterval\ntoUnitInterval x with isInUnitInterval x\n... | no \u00acp = nothing\n... | yes p = just (x , [ p ])\n\n-- Helper function to make an element of the Refinement type\n-- that is useful in the case where Agda can infer the evidence\n-- automatically by computation.\n-- Usage example:  mkUnitInterval (+ 2 / 10)\nmkUnitInterval : \u2200 (x : \u211a) \u2192 {T (does (isInUnitInterval x))} \u2192 UnitInterval\nmkUnitInterval x {evidence} with isInUnitInterval x in eq\n... | no  _ rewrite cong does eq = \u22a5-elim evidence\n... | yes p = x , [ p ]\n\n-- Clamp a rational number to the unit interval.\n-- Values below 0 or above 1 are set to 0 or 1, respectively.\nclamp : \u211a \u2192 UnitInterval\nclamp x with 0 \u2264? x\n... | no  _ = mkUnitInterval 0\n... | yes 0\u2264x with x \u2264? 1\n...     | no  _   = mkUnitInterval 1\n...     | yes x\u22641 = (x , [ 0\u2264x , x\u22641 ])\n\n-- UnitInterval Properties\n\n-- The predicate for 'UnitInterval' also holds in a proof-relevant context.\nfromUnitInterval-inUnitInterval\n  : \u2200 (x : UnitInterval) \u2192 inUnitInterval (fromUnitInterval x)\nfromUnitInterval-inUnitInterval (x , [ p0 ]) with isInUnitInterval x\n... | no \u00acp = \u22a5-elim-irr (\u00acp p0)\n... | yes p = p\n\n-- Left multiplication by unit interval element preserves non-negativity.\nUnitInterval-*-0\u2264\n  : \u2200 (x : \u211a) (y : UnitInterval) \u2192 0 \u2264 x \u2192 0 \u2264 x * fromUnitInterval y\nUnitInterval-*-0\u2264 x y 0\u2264x =\n  inUnitInterval-*-0\u2264 x (value y) (fromUnitInterval-inUnitInterval y) 0\u2264x\n\n-- to/from is the identity\nprop-toUnitInterval-fromUnitInterval : \u2200 (x : UnitInterval)\n  \u2192 toUnitInterval (fromUnitInterval x) \u2261 just x\nprop-toUnitInterval-fromUnitInterval (x , [ p0 ]) with isInUnitInterval x\n... | no \u00acp = \u22a5-elim-irr (\u00acp p0)\n... | yes p = refl\n</pre>"},{"location":"Ledger.Prelude.Numeric.html","title":"Numeric","text":"<pre>{-# OPTIONS --safe #-}\n\n-- Subsets of number types useful for the ledger specification.\nmodule Ledger.Prelude.Numeric where\n\nopen import Ledger.Prelude.Numeric.PositiveNat public\n  renaming (PosNat to \u2115\u207a; fromPosNat to from\u2115\u207a; mkPosNat to mk\u2115\u207a\n           ; PosNat-Is&gt;0 to \u2115\u207a-&gt;0)\nopen import Ledger.Prelude.Numeric.UnitInterval public\n</pre>"},{"location":"Ledger.Prelude.html","title":"Ledger.Prelude","text":"<pre>{-# OPTIONS --safe #-}\n\n--------------------------------------------------------------------------------\n-- Ledger prelude\n--\n-- Re-exports modules relating to STS, set theory and other\n-- miscellaneous things used to write the ledger rules. If something\n-- is used in more than two Ledger.* modules, it should probably go\n-- here.\n--------------------------------------------------------------------------------\n\nmodule Ledger.Prelude where\n\nopen import Prelude public\n  hiding (\u2203\u2047)\nopen import Prelude.Init public\n  using (\u2203\u2047)\n\nopen import Ledger.Prelude.Base public\nimport Data.List\n\nopen import Class.HasAdd public\nopen import stdlib-classes.Class.HasCast public\nopen import Class.HasOrder public\nopen import Class.ToBool public\nopen import Interface.ComputationalRelation public\nopen import Interface.TypeClasses.Hashable public\nopen import Interface.TypeClasses.HasSubset public\nopen import Interface.TypeClasses.HasSubtract public\nopen import Interface.TypeClasses.HasSubtract.Instances public\nopen import Ledger.Prelude.Instances public\nopen import Ledger.Prelude.HasCoin public\nopen import Tactic.Defaults public\nopen import Tactic.Derive.DecEq public\nopen import Tactic.Inline public\nopen import MyDebugOptions public\nopen import Prelude.STS.GenPremises public\n\nopen import abstract-set-theory.FiniteSetTheory public\n  renaming (_\u2286_ to _\u2286\u02e2_)\n\nimport Data.Integer as \u2124\nimport Data.Rational as \u211a\nopen import Data.Rational using (\u211a)\n\ndec-de-morgan : \u2200{P Q : Type} \u2192 \u2983 P \u2047 \u2984 \u2192 \u00ac (P \u00d7 Q) \u2192 \u00ac P \u228e \u00ac Q\ndec-de-morgan \u2983 \u2047 no \u00acp \u2984 \u00acpq = inj\u2081 \u00acp\ndec-de-morgan \u2983 \u2047 yes p \u2984 \u00acpq = inj\u2082 \u03bb q \u2192 \u00acpq (p , q)\n\n\u2261\u1d49-getCoin : \u2200 {A} \u2192 \u2983 _ : DecEq A \u2984 \u2192 (s s' : A \u21c0 Coin) \u2192 s \u02e2 \u2261\u1d49 s' \u02e2 \u2192 getCoin s \u2261 getCoin s'\n\u2261\u1d49-getCoin {A} \u2983 decEqA \u2984 s s' s\u2261s' = indexedSum\u1d5b'-cong {C = Coin} {x = s} {y = s'} s\u2261s'\n\nsetToMap : \u2200 {A B : Type} \u2192 \u2983 DecEq A \u2984 \u2192 \u2119 (A \u00d7 B) \u2192 A \u21c0 B\nsetToMap = fromList\u1d50 \u2218 setToList\n\n-- division of natural numbers with completion by 0.\nopaque\n  _/\u2080_ : \u2115 \u2192 \u2115 \u2192 \u211a\n  x /\u2080 0 = \u211a.0\u211a\n  x /\u2080 y@(suc _) = \u2124.+ x \u211a./ y\n\n-- Division of rational numbers with completion by 0.\n_\u00f7\u2080_ : \u211a \u2192 \u211a \u2192 \u211a\n_\u00f7\u2080_ x y = case y \u225f \u211a.0\u211a of \u03bb where\n  (yes _) \u2192 \u211a.0\u211a\n  (no y\u22620) \u2192 let instance nonZero-y = \u211a.\u2262-nonZero y\u22620 in x \u211a.\u00f7 y\n\n\u27e6_\u27e7 : \u2200 {A B : Type} \u2983 f : HasCast A B \u2984 \u2192 A \u2192 B\n\u27e6_\u27e7 \u2983 f = f \u2984 = f.cast\n  where module f = HasCast f\n\n\u2223_\u2223 : \u2200 {A B : Type} \u2983 f : HasCast A B \u2984 \u2192 A \u2192 B\n\u2223_\u2223 \u2983 f = f \u2984 = f.cast\n  where module f = HasCast f\n\ninfix 5 \u27e6_\u27e7\ninfix 6 \u2223_\u2223\n\nmodule Filter where\n  filter : \u2200 {a} {p} {A : Type a} \u2192 (P : Pred A p) \u2192 \u2983 P \u2047\u00b9 \u2984 \u2192 List A \u2192 List A\n  filter P = Data.List.filter \u00bf P \u00bf\u00b9\n\n</pre>"},{"location":"Ledger.html","title":"Ledger","text":"<pre>module Ledger where\n\nimport Ledger.Introduction\nimport Ledger.PreConway\nimport Ledger.Core\nimport Ledger.Conway\nimport Ledger.Dijkstra\n\nimport Test.Examples\n\nimport EssentialAgda\n</pre>"},{"location":"MyDebugOptions.html","title":"MyDebugOptions","text":"<pre>{-# OPTIONS --safe --without-K #-}\nmodule MyDebugOptions where\n\nopen import Meta.Init\n\ninstance\n  defaultDebugOptionsI : DebugOptions\n  defaultDebugOptionsI = record defaultDebugOptions\n    { selection = All\n    ; filter = Filter.\u22a5 }\n</pre>"},{"location":"Notation.html","title":"Notation","text":"<p>This section introduces some of the notation we use in this document and in our Agda formalization.</p>"},{"location":"Notation.html#propositions-sets-and-types","title":"Propositions, Sets and Types","text":"<p>See Sets &amp; Maps. Note that Agda denotes the primitive notion of type by <code>Set</code>. To avoid confusion, throughout this document and in our Agda code we call this primitive <code>Type</code> and use <code>\u2119</code> for our set type.</p>"},{"location":"Notation.html#lists","title":"Lists","text":"<p>We use the notation <code>a</code> <code>\u2237</code> <code>as</code> for the list with head <code>a</code> and tail <code>as</code>; <code>[]</code> denotes the empty list, and <code>l</code> <code>\u2237\u02b3</code> <code>x</code> appends the element <code>x</code> to the end of the list <code>l</code>.</p>"},{"location":"Notation.html#sums-and-products","title":"Sums and Products","text":"<p>The sum (or disjoint union, coproduct, etc.) of <code>A</code> and <code>B</code> is denoted by <code>A</code> <code>\u228e</code> <code>B</code>, and their product is denoted by <code>A</code> <code>\u00d7</code> <code>B</code>. The projection functions from products are denoted <code>proj\u2081</code> and <code>proj\u2082</code> and the injections are denoted <code>inj\u2081</code> and <code>inj\u2082</code>, respectively. The property of being an element of a coproduct in the left (resp., right) component is called <code>isInj\u2081</code> (resp., <code>isInj\u2082</code>).</p>"},{"location":"Notation.html#addition-of-map-values","title":"Addition of Map Values","text":"<p>The expression <code>\u2211[</code> <code>x</code> <code>\u2190</code> <code>m</code> <code>]</code> <code>f</code> <code>x</code> denotes the sum of the values obtained by applying the function <code>f</code> to the values of the map <code>m</code>.</p>"},{"location":"Notation.html#record-types","title":"Record types","text":"<p>See the official documentation on Agda record types.</p>"},{"location":"Notation.html#postfix-projections","title":"Postfix Projections","text":"<p>Projections can be written using postfix notation. For example, we may write <code>x</code> <code>.</code> <code>proj\u2081</code> instead of</p> <p><code>proj\u2081</code> <code>x</code></p>"},{"location":"Notation.html#restriction-corestriction-and-complements","title":"Restriction, Corestriction and Complements","text":"<p>The restriction of a function or map <code>f</code> to some domain <code>A</code> is denoted by <code>f</code> <code>|</code> <code>A</code>, and the restriction to the complement of <code>A</code> is written <code>f</code> <code>|</code> <code>A</code> <code>\u1d9c</code>.</p> <p>Corestriction or range restriction is denoted similarly, except that <code>|</code> is replaced by <code>\u2223^</code>.</p>"},{"location":"Notation.html#inverse-image","title":"Inverse Image","text":"<p>The expression <code>m</code> <code>\u207b\u00b9</code> <code>B</code> denotes the inverse image of the set <code>B</code> under the map <code>m</code>.</p>"},{"location":"Notation.html#left-biased-union","title":"Left-biased Union","text":"<p>For maps <code>m</code> and <code>m'</code>, we write <code>m</code> <code>\u222a\u02e1</code> <code>m'</code> for their left-biased union. This means that key-value pairs in <code>m</code> are guaranteed to be in the union, while a key-value pair in <code>m'</code> is in the union if and only if the key is not in <code>m</code>.</p>"},{"location":"Notation.html#map-addition","title":"Map Addition","text":"<p>For maps <code>m</code> and <code>m'</code>, we write <code>m</code> <code>\u222a\u207a</code> <code>m'</code> for their union, where keys that appear in both maps have their corresponding values added.</p>"},{"location":"Notation.html#mapping-a-partial-function","title":"Mapping a Partial Function.","text":"<p>A partial function is a function on <code>A</code> which may not be defined for all elements of <code>A</code>.  We denote such a function by <code>f</code> : <code>A</code> \u21c0 <code>B</code>.</p> <p>If we happen to know that the function is total (defined for all elements of <code>A</code>), then we write <code>f</code> : <code>A</code> \u2192 <code>B</code>.</p> <p>The <code>mapPartial</code> operation takes such a function <code>f</code> and a set <code>S</code> of elements of <code>A</code> and applies <code>f</code> to the elements of <code>S</code> at which it is defined; the result is the set</p> <p>{ <code>f</code> <code>x</code> \u2223 <code>x</code> \u2208 <code>S</code> and <code>f</code> is defined at  <code>x</code>.} </p>"},{"location":"Notation.html#the-maybe-type","title":"The Maybe Type","text":"<p>This type represents an optional value and can either be <code>just</code> <code>x</code> (indicating the presence of a value, <code>x</code>) or <code>nothing</code> (indicating the absence of a value).</p> <p>If <code>x</code> has type <code>X</code>, then <code>just</code> <code>x</code> has type <code>Maybe</code> <code>X</code>.</p> <p>The symbol <code>~</code> denotes (pseudo)equality of two values <code>x</code> and <code>y</code> of type <code>Maybe</code> <code>X</code> : if <code>x</code> is of the form <code>just</code> <code>x'</code> and <code>y</code> is of the form <code>just</code> <code>y'</code>, then <code>x'</code> and  <code>y'</code> have to be equal. Otherwise, they are considered \"equal.\"</p>"},{"location":"Notation.html#the-unit-type","title":"The Unit Type","text":"<p><code>\u22a4</code> has a single inhabitant <code>tt</code> and may be thought of as a type that carries no information; it is useful for signifying the completion of an action, the presence of a trivial value, a trivially satisfied requirement, etc.</p>"},{"location":"Notation.html#sec:superscripts-other-special-notation","title":"Superscripts and Other Special Notations","text":"<p>In the current version of this specification, superscript letters are sometimes used for things such as disambiguations or type conversions. These are essentially meaningless, only present for technical reasons and can safely be ignored. However there are the two exceptions:</p> <ul> <li> <p><code>\u222a\u02e1</code> for left-biased union</p> </li> <li> <p><code>\u1d9c</code> in the context of set restrictions, where it indicates the complement</p> </li> </ul> <p>Also, non-letter superscripts do carry meaning.</p> <p>(At some point in the future we hope to be able to remove all those non-essential superscripts. Since we prefer doing this by changing the Agda source code instead of via hiding them in this document, this is a non-trivial problem that will take some time to address.)</p>"},{"location":"Notation.html#tables-of-variable-names-and-name-changes","title":"Tables of Variable Names and Name Changes","text":""},{"location":"Notation.html#renamed-fields-of-txbody","title":"Renamed Fields of <code>TxBody</code>","text":"Old Name New Name Old Type New Type <code>txins</code> <code>txIns</code> (no change) <code>txouts</code> <code>txOuts</code> (no change) <code>txfee</code> <code>txFee</code> <code>Coin</code> <code>Fees</code> <code>txwdrls</code> <code>txWithdrawals</code> <code>Wdrl</code> <code>Withdrawals</code> <code>txvldt</code> <code>txVldt</code> (no change) <code>txcerts</code> <code>txCerts</code> (no change) <code>txvote</code> <code>txGovVotes</code> (no change) <code>txprop</code> <code>txGovProposals</code> (no change) <code>txdonation</code> <code>txDonation</code> <code>Coin</code> <code>Donations</code> <code>curTreasury</code> <code>currentTreasury</code> <code>Maybe Coin</code> <code>Maybe Treasury</code> <code>txid</code> <code>txId</code> (no change) <code>collateral</code> <code>collateralInputs</code> (no change) <code>reqSigHash</code> <code>reqSignerHashes</code> (no change) <code>scriptIntHash</code> <code>scriptIntegrityHash</code> (no change)"},{"location":"Notation.html#renamed-contructors-of-govactiontype","title":"Renamed Contructors of <code>GovActionType</code>","text":"Old Name New Name <code>TriggerHF</code> <code>TriggerHardFork</code> <code>TreasuryWdrl</code> <code>TreasuryWithdrawal</code>"},{"location":"Prelude.html","title":"Prelude","text":"<pre>{-# OPTIONS --safe --without-K #-}\n\nmodule Prelude where\n\nopen import Agda.Primitive using (lzero) renaming (Set to Type) public\n\nopen import Level public\n  hiding (lower)\n  renaming (_\u2294_ to _\u2294\u02e1_; suc to suc\u02e1; zero to zero\u02e1)\nopen import Function public\n\nopen import Data.Bool public\n  hiding (_\u225f_; _\u2264_; _\u2264?_; _&lt;_; _&lt;?_; if_then_else_)\nopen import Data.Bool.ListAction public\nopen import Data.Empty public\nopen import Data.List public\n  hiding (all; and; any; align; alignWith; filter; fromMaybe; map; or; product; sum; zip; zipWith)\nopen import Data.List.Membership.Propositional public\n  using () renaming (_\u2208_ to _\u2208\u02e1_; _\u2209_ to _\u2209\u02e1_)\nopen import Data.Maybe public\n  hiding (_&gt;&gt;=_; align; alignWith; ap; fromMaybe; map; zip; zipWith)\nopen import Data.Unit public\n  using (\u22a4; tt)\nopen import Data.Unit.Polymorphic public\n  using ()\n  renaming (\u22a4 to \u22a4\u2191; tt to tt\u2191)\ninstance Poly-tt = tt\u2191\nopen import Data.Sum public\n  hiding (assoc\u02b3; assoc\u02e1; map; map\u2081; map\u2082; reduce; swap)\nopen import Data.Product public\n  hiding (assoc\u02b3; assoc\u02e1; map; map\u2081; map\u2082; map\u2082\u2032; swap; _&lt;*&gt;_)\nopen import Data.Nat public\n  hiding (_\u225f_; _\u2264_; _\u2264?_; _&lt;_; _&lt;?_; _\u2264\u1d47_; _\u2261\u1d47_; _\u2265_; _&gt;_; less-than-or-equal)\n  renaming (_+_ to _+\u2115_)\nopen import Data.Nat.ListAction public\nopen import Data.Integer as \u2124 public\n  using (\u2124)\n  renaming (_+_ to _+\u2124_)\nopen import Data.String public\n  using (String; _&lt;+&gt;_)\n\nopen import Relation.Nullary public\nopen import Relation.Nullary.Negation public\nopen import Relation.Nullary.Decidable public\n  using (Dec; yes; no; dec-yes; dec-no; \u230a_\u230b; \u00ac?; toWitness; fromWitness)\n  renaming (map\u2032 to mapDec)\nopen import Relation.Unary public\n  using (Pred) renaming (Decidable to Decidable\u00b9)\nopen import Relation.Binary public\n  using () renaming (Decidable to Decidable\u00b2)\nopen import Relation.Binary.PropositionalEquality public\n  hiding (preorder; isPreorder; setoid; [_])\n\nopen import Class.Core public\n  using (Type\u2191)\nopen import Class.Functor public\n  renaming (fmap to map)\nopen import Class.Bifunctor public\nopen import Class.Semigroup public\nopen import Class.Monoid public\nopen import Class.CommutativeMonoid public\nopen import Class.Applicative public\nopen import Class.Monad public\nopen import Class.DecEq public; instance DecEq-\u00d7\u2032 = DecEq-\u00d7\nopen import Class.Decidable public\n\u2203\u2047 : \u2200 {\u2113} \u2192 Set (suc\u02e1 \u2113)\n\u2203\u2047 {\u2113} = \u03a3 (Set \u2113) _\u2047\nopen import Class.Show public\n\n\u2203\u2082-syntax : \u2200 {a b c} {A : Set a} {B : Set b}\n     (C : A \u2192 B \u2192 Set c) \u2192 Set _\n\u2203\u2082-syntax C = \u2203 \u03bb a \u2192 \u2203 \u03bb b \u2192 C a b\n\ninfix 2 \u2203\u2082-syntax\nsyntax \u2203\u2082-syntax (\u03bb x y \u2192 C) = \u2203\u2082[ x , y ] C\n\n-- Instance for number literals, not enabled by default\nimport Data.Nat.Literals as \u2115\nimport Data.Integer.Literals as \u2124\nimport Data.Rational.Literals as \u211a\n\ninstance Number-\u2115 = \u2115.number\ninstance Number-\u2124 = \u2124.number\ninstance Number-\u211a = \u211a.number\n\n-- (Pseudo)equality (for Maybe)\nopen import Data.Maybe.Relation.Binary.Connected\n  using (Connected; connected?)\n\n_~_ : {A : Type} \u2192 Maybe A \u2192 Maybe A \u2192 Type\n_~_ = Connected _\u2261_\n\ninstance\n  ~? : {A : Type} {x y : Maybe A} \u2192 \u2983 DecEq A \u2984 \u2192 (x ~ y) \u2047\n  ~? {A} {x} {y} \u2983 deqEq \u2984 = \u2047 (connected? (DecEq._\u225f_ deqEq) x y)\n\n-- Positive and negative part of integers\nopen import Data.Integer using (sign; \u2223_\u2223; _\u2296_)\nopen import Data.Integer.Properties using ([1+m]\u2296[1+n]\u2261m\u2296n)\nopen import Data.Sign using (Sign)\n\nposPart : \u2124 \u2192 \u2115\nposPart x with sign x\n... | Sign.+ = \u2223 x \u2223\n... | Sign.- = 0\n\nnegPart : \u2124 \u2192 \u2115\nnegPart x with sign x\n... | Sign.- = \u2223 x \u2223\n... | Sign.+ = 0\n\n\u2238\u2261posPart\u2296 : {m n : \u2115} \u2192 (m \u2238 n) \u2261 posPart (m \u2296 n)\n\u2238\u2261posPart\u2296 {zero} {zero} = _\u2261_.refl\n\u2238\u2261posPart\u2296 {zero} {\u2115.suc n} = _\u2261_.refl\n\u2238\u2261posPart\u2296 {\u2115.suc m} {zero} = _\u2261_.refl\n\u2238\u2261posPart\u2296 {\u2115.suc m} {\u2115.suc n} = trans (\u2238\u2261posPart\u2296{m}{n}) (sym (cong posPart (([1+m]\u2296[1+n]\u2261m\u2296n m n))))\n</pre>"},{"location":"Properties.html","title":"Properties","text":""},{"location":"Properties.html#properties","title":"Properties","text":"<p>This section presents the properties of the ledger that we have formally proved in Agda or plan to do so in the near future.  We indicate in which Agda module each property is formally stated and (possibly) proved. A \"Claim\" is a property that is not yet proved, while a \"Theorem\" is one for which we have a formal proof.</p>"},{"location":"Properties.html#preservation-of-value","title":"Preservation of Value","text":"<p>There are several \"preservation of value\" proofs throughout this formal specificaition.  These can be found in the following modules:</p> <ul> <li>Ledger.Properties.PoV</li> <li>Utxo.Properties.PoV</li> <li>Certs.Properties.PoV</li> <li>Certs.Properties.PoVLemmas</li> </ul>"},{"location":"Properties.html#invariance-properties","title":"Invariance Properties","text":"<p>To say that a predicate <code>P</code> is an invariant of a transition rule <code>R</code> means the following: if the rule <code>R</code> relates states <code>s</code> and <code>s'</code> and if <code>P</code> holds at state <code>s</code>, then <code>P</code> holds at state <code>s'</code>.</p> <p>Examples of invariance properties are found in</p> <ul> <li>Chain.Properties.CredDepsEqualDomRwds</li> <li>Chain.Properties.PParamsWellFormed</li> </ul>"},{"location":"Properties.html#matching-governance-action-deposits","title":"Matching Governance Action Deposits","text":"<p>ChainGovDepsMatch, LedgerGovDepsMatch, and EpochGovDepsMatch assert that a certain predicate is an invariant of the <code>CHAIN</code>, <code>LEDGER</code>, and <code>EPOCH</code> rules, respectively.</p> <p>Given a ledger state <code>s</code>, we focus on deposits in the <code>UTxOState</code> of <code>s</code> that are <code>GovActionDeposit</code>s and we compare that set of deposits with the <code>GovActionDeposit</code>s of the <code>GovState</code> of <code>s</code>. When these two sets are the same, we write <code>govDepsMatch</code> <code>s</code> and say the <code>govDepsMatch</code> relation holds for <code>s</code>. The formal definition of <code>govDepsMatch</code> is given in Ledger.Properties.</p> <p>The assertion, \"the <code>govDepsMatch</code> relation is an invariant of the <code>LEDGER</code> rule,\" means the following: if <code>govDepsMatch</code> <code>s</code> and <code>s</code> <code>\u21c0\u2987</code> <code>tx</code> <code>,LEDGER\u2988</code> <code>s'</code>, then <code>govDepsMatch</code> <code>s'</code>.</p> <p>The following are examples of this assertion:</p> <ul> <li>Chain.Properties.GovDepsMatch</li> <li>Ledger.Properties.GovDepsMatch</li> <li>Epoch.Properties.GovDepsMatch</li> </ul>"},{"location":"Properties.html#minimum-spending-conditions","title":"Minimum Spending Conditions","text":"<p>A minimum spending condition is proved in Utxo.Properties.MinSpend.</p>"},{"location":"Properties.html#other-miscellaneous-properties","title":"Other Miscellaneous Properties","text":"<ul> <li> <p>Certs.Properties.VoteDelegsVDeleg: The set of <code>VDeleg</code>s    resulting from the application of    <code>credVoter</code> <code>DRep</code> to the    domain of the <code>voteDelegs</code> of a <code>DState</code> contains the    range of the <code>voteDelegs</code> of that <code>DState</code>.</p> </li> <li> <p>Chain.Properties.EpochStep:    If <code>cs</code> <code>\u21c0\u2987</code> <code>b</code> <code>,CHAIN\u2988</code> <code>cs'</code> and    if the enact states of <code>cs</code> and <code>cs'</code> differ, then the    epoch of the slot of <code>b</code> is the successor of the last epoch of <code>cs</code>.</p> </li> <li> <p>Epoch.Properties.ConstRwds: The <code>NEWEPOCH</code> rule leaves rewards unchanged.</p> </li> <li> <p>Epoch.Properties.NoPropSameDReps:    If <code>es</code> is a <code>NewEpochState</code>, and if the    <code>GovState</code> of <code>es</code> contains no governance proposals,    then the set of <code>activeDReps</code> of <code>es</code> in    <code>Epoch</code> <code>e</code> is equal to the set of    <code>activeDReps</code> of <code>es</code> in the next epoch.</p> </li> <li> <p>Gov.Properties.ChangePPGroup: <code>PParam</code> updates have non-empty groups.</p> </li> </ul>"},{"location":"Test.AbstractImplementation.html","title":"AbstractImplementation","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude using (DecEq; Show)\nimport Ledger.Conway.Specification.Script.ScriptPurpose as SP\nopen import Test.LedgerImplementation using (SVTransactionStructure)\n\nmodule Test.AbstractImplementation\n  {T D : Set} {{DecEq-Data : DecEq D}} {{Show-Data : Show D}}\n  (open SP (SVTransactionStructure T D) using (TxInfo; ScriptPurpose))\n  (valContext' : TxInfo \u2192 ScriptPurpose \u2192 D)\n  where\n\nopen import Ledger.Prelude using (nothing; _,_)\n\nopen import Test.LedgerImplementation T D\n  renaming (SVTransactionStructure to SVTransactionStructure')\nopen import Ledger.Conway.Specification.Abstract SVTransactionStructure'\n\nopen Implementation\n\nSVAbstractFunctions : AbstractFunctions\nSVAbstractFunctions = record\n  { Implementation\n  ; txscriptfee = \u03bb tt y \u2192 0\n  ; serSize     = \u03bb v \u2192 0 -- changed to 0\n  ; indexOfImp  = record\n    { indexOfDCert    = \u03bb _ _ \u2192 nothing\n    ; indexOfRwdAddr  = \u03bb _ _ \u2192 nothing\n    ; indexOfTxIn     = indexOfTxInImp\n    ; indexOfPolicyId = \u03bb _ _ \u2192 nothing\n    ; indexOfVote     = \u03bb _ _ \u2192 nothing\n    ; indexOfProposal = \u03bb _ _ \u2192 nothing\n    }\n  ; runPLCScript = \u03bb { x (sh , script) x\u2082 x\u2083 \u2192 script x\u2083 }\n  ; scriptSize = \u03bb _ \u2192 0\n  ; valContext = valContext'\n  }\n</pre>"},{"location":"Test.Examples.AccountSim.Datum.html","title":"Datum","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\n\nmodule Test.Examples.AccountSim.Datum where\n\nopen import Tactic.Derive.DecEq\nopen import Data.Vec as Vec\n  hiding (fromList)\nimport stdlib.Data.Vec.Instances as Vec\nimport Data.Vec.Relation.Binary.Pointwise.Inductive as Vec\n\ndata Label : Set where\n  Always : List (\u2115 \u00d7 \u2115) -&gt; Label\ninstance\n  unquoteDecl DecEq-Label = derive-DecEq\n    ((quote Label , DecEq-Label) \u2237 [])\n\ndata Input : Set where\n  Open     : \u2115 -&gt; Input\n  Close    : \u2115 -&gt; Input\n  Withdraw : \u2115 -&gt; \u2115 -&gt; Input\n  Deposit  : \u2115 -&gt; \u2115 -&gt; Input\n  Transfer : \u2115 -&gt; \u2115 -&gt; \u2115 -&gt; Input\n  Cleanup  : Input\ninstance\n  unquoteDecl DecEq-Input = derive-DecEq\n    ((quote Input , DecEq-Input) \u2237 [])\n\nAccountSimData = Label \u228e Input\n</pre>"},{"location":"Test.Examples.AccountSim.OffChain.Cleanup.html","title":"Cleanup","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.AccountSim.OffChain.Cleanup where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.AccountSim.Datum\nopen import Test.Examples.AccountSim.OffChain.Lib\nopen import Test.Examples.AccountSim.Validator\nopen import Test.Prelude AccountSimData\nopen import Test.SymbolicData AccountSimData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nmakeCleanupTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 Maybe Tx\nmakeCleanupTx id state script@(sh , _) w = \n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , (fst , txValue , snd)) \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeUnPaymentTxOut wutxo txValue)\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addNat}} (getTxId wutxo) w) ) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; \n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 Cleanup) ,\n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                )\n            })\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n\n</pre>"},{"location":"Test.Examples.AccountSim.OffChain.Close.html","title":"Close","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.AccountSim.OffChain.Close where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.AccountSim.Datum\nopen import Test.Examples.AccountSim.Validator\nopen import Test.Examples.AccountSim.OffChain.Lib\nopen import Test.Prelude AccountSimData\nopen import Test.SymbolicData AccountSimData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n\nmakeCloseTxOut : Label \u2192 (scriptIx w : \u2115) \u2192 TxOut \u2192 List (\u2115 \u00d7 TxOut)\nmakeCloseTxOut (Always l) ix w (fst , fst' , snd) =\n  (ix , (fst , fst' ,  just (inj\u2081 (inj\u2081 (inj\u2081 (Always (delete' w l))))) , nothing)) \u2237 []\n\nmakeCloseTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 Maybe Tx\nmakeCloseTx id state script@(sh , _) w =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeTxOut wutxo ++ makeCloseTxOut label (proj\u2082 scIn) w scOut )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addNat}} (getTxId wutxo) w) ) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ;\n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 (Close w)) ,\n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n\n</pre>"},{"location":"Test.Examples.AccountSim.OffChain.Deposit.html","title":"Deposit","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.AccountSim.OffChain.Deposit where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.AccountSim.Datum\nopen import Test.Examples.AccountSim.OffChain.Lib\nopen import Test.Examples.AccountSim.Validator\nopen import Test.Prelude AccountSimData\nopen import Test.SymbolicData AccountSimData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nscriptDTxOut : Label \u2192 TxOut \u2192 (w : \u2115) \u2192 (v : Value) \u2192 TxOut\nscriptDTxOut (Always l) (fst , txValue , snd) w v = (fst , (_+_ {{addValue}} txValue v) , (just (inj\u2081 (inj\u2081 (inj\u2081 (Always (insert' w (_+_ {{addValue}} val v) l)))))) , nothing)\n  where\n    val = getVal (Always l) w\n\n\n\nmakeDepositTxOut : Label \u2192 (scriptIx : \u2115) \u2192 TxOut \u2192 (w : \u2115) \u2192 (v : Value) \u2192 List (\u2115 \u00d7 TxOut)\nmakeDepositTxOut (Always l) ix txo w v =\n            (ix , scriptDTxOut (Always l) txo w v)\n            \u2237 []\n\n\n\nmakeDepositTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 (v : Value) \u2192 Maybe Tx\nmakeDepositTx id state script@(sh , _) w v =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeePaymentTxOut wutxo v ++ makeDepositTxOut label (proj\u2082 scIn) scOut w v )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addNat}} (getTxId wutxo) w)) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ;\n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 (Deposit w v)) ,\n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n</pre>"},{"location":"Test.Examples.AccountSim.OffChain.Lib.html","title":"Lib","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.AccountSim.OffChain.Lib where\n\nopen import Data.List using (filter)\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Test.Examples.AccountSim.Datum\nopen import Test.Examples.AccountSim.Validator\nopen import Test.Prelude AccountSimData\nopen import Test.SymbolicData AccountSimData\nopen import Test.LedgerImplementation SData SData\n\nopen TransactionStructure SVTransactionStructure\n\ndefaultTxBody : TxBody\ndefaultTxBody = record\n                  { txIns = \u2205\n                  ; refInputs = \u2205\n                  ; collateralInputs = \u2205\n                  ; txOuts =  \u2205\n                  ; txFee = 10000000000\n                  ; mint = 0\n                  ; txVldt = nothing , nothing\n                  ; txCerts = []\n                  ; txWithdrawals = \u2205\n                  ; txGovVotes = []\n                  ; txGovProposals = []\n                  ; txDonation = 0\n                  ; txADhash = nothing\n                  ; txNetworkId = just 0\n                  ; currentTreasury = nothing\n                  ; txId = 0\n                  ; reqSignerHashes = \u2205\n                  ; scriptIntegrityHash = nothing\n                  }\n\nmatchScriptAddress : (scriptHash : \u2115) \u2192 Credential \u2192 Set\nmatchScriptAddress sh (KeyHashObj x) = \u22a5\nmatchScriptAddress sh (ScriptObj y) = True (sh \u225f y)\n\nmatchScriptAddress? : (sh : \u2115) \u2192 (c : Credential) \u2192 Dec (matchScriptAddress sh c)\nmatchScriptAddress? sh (KeyHashObj x) = no (\u03bb x\u2081 \u2192 x\u2081)\nmatchScriptAddress? sh (ScriptObj y) = T? \u230a (sh \u225f y) \u230b\n\ngetScriptUTxO : (scriptHash : \u2115) \u2192 UTxO \u2192 Maybe (TxIn \u00d7 TxOut)\ngetScriptUTxO sh (utxo , prf) = head $ filter (\u03bb { (_ , addr , _) \u2192 matchScriptAddress? sh (payCred addr)}) (setToList utxo)\n\nmatchWalletHash : (keyHash : \u2115) \u2192 Credential \u2192 Set\nmatchWalletHash kh (KeyHashObj x) = True (kh \u225f x)\nmatchWalletHash kh (ScriptObj y) = \u22a5\n\nmatchWalletHash? : (sh : \u2115) \u2192 (c : Credential) \u2192 Dec (matchWalletHash sh c)\nmatchWalletHash? kh (KeyHashObj x) = T? \u230a (kh \u225f x) \u230b\nmatchWalletHash? kh (ScriptObj y) = no (\u03bb x\u2081 \u2192 x\u2081)\n\ngetWalletUTxO : (scriptHash : \u2115) \u2192 UTxO \u2192 List (TxIn \u00d7 TxOut)\ngetWalletUTxO sh (utxo , prf) = filter (\u03bb { (_ , addr , _) \u2192 matchWalletHash? sh (payCred addr)}) (setToList utxo)\n\n\n\ngetLabel : TxOut \u2192 Maybe Label\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2081 (inj\u2081 x))) , snd) = just x\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2081 (inj\u2082 y))) , snd) = nothing\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2082 y)) , snd) = nothing\ngetLabel (fst , fst\u2081 , just (inj\u2082 y) , snd) = nothing\ngetLabel (fst , fst\u2081 , nothing , snd) = nothing\n\n\n\n-- Assumes a list of filtered waller txins and subtracts a default fee from the head of the list\nmakeFeeTxOut : List (TxIn \u00d7 TxOut) \u2192 List (\u2115 \u00d7 TxOut)\nmakeFeeTxOut [] = []\nmakeFeeTxOut ((txin , (fst , txValue , snd)) \u2237 utxos) = (proj\u2082 txin , fst , txValue - feeValue , snd) \u2237 []\n\nmakeFeeUnPaymentTxOut : List (TxIn \u00d7 TxOut) \u2192 Value \u2192 List (\u2115 \u00d7 TxOut)\nmakeFeeUnPaymentTxOut [] v = []\nmakeFeeUnPaymentTxOut ((txin , (fst , txValue , snd)) \u2237 utxos) v = (proj\u2082 txin , fst , _+_ {{addValue}} (txValue - feeValue) v , snd) \u2237 []\n\nmakeFeePaymentTxOut : List (TxIn \u00d7 TxOut) \u2192 Value \u2192 List (\u2115 \u00d7 TxOut)\nmakeFeePaymentTxOut [] v = []\nmakeFeePaymentTxOut ((txin , (fst , txValue , snd)) \u2237 utxos) v = (proj\u2082 txin , fst , (txValue - feeValue ) - v , snd) \u2237 []\n\n-- return id of 0 if no txins\ngetTxId : List (TxIn \u00d7 TxOut) \u2192 \u2115\ngetTxId xs = maybe (\u03bb x \u2192 proj\u2081 (proj\u2081 x)) 0 (head xs)\n\ngetVal : Label -&gt; \u2115 -&gt; Value\ngetVal (Always l) w with lookup' w l\n...| nothing = emptyValue\n...| just v = v\n\n\n\n\n</pre>"},{"location":"Test.Examples.AccountSim.OffChain.OffChain.html","title":"OffChain","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.AccountSim.OffChain.OffChain where\n\nopen import Test.Examples.AccountSim.OffChain.Start public\nopen import Test.Examples.AccountSim.OffChain.Close public\nopen import Test.Examples.AccountSim.OffChain.Open public\nopen import Test.Examples.AccountSim.OffChain.Deposit public\nopen import Test.Examples.AccountSim.OffChain.Withdraw public\nopen import Test.Examples.AccountSim.OffChain.Transfer public\nopen import Test.Examples.AccountSim.OffChain.Cleanup public\n</pre>"},{"location":"Test.Examples.AccountSim.OffChain.Open.html","title":"Open","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.AccountSim.OffChain.Open where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.AccountSim.Datum\nopen import Test.Examples.AccountSim.OffChain.Lib\nopen import Test.Examples.AccountSim.Validator\nopen import Test.Prelude AccountSimData\nopen import Test.SymbolicData AccountSimData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nmakeOpenTxOut : Label \u2192 (scriptIx w : \u2115) \u2192 TxOut \u2192 List (\u2115 \u00d7 TxOut)\nmakeOpenTxOut (Always l) ix w (fst , fst' , snd) =\n  (ix , (fst , fst' ,  just (inj\u2081 (inj\u2081 (inj\u2081 (Always (insert' w emptyValue l))))) , nothing)) \u2237 []\n\nmakeOpenTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 Maybe Tx\nmakeOpenTx id state script@(sh , _) w =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeTxOut wutxo ++ makeOpenTxOut label (proj\u2082 scIn) w scOut )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addNat}} (getTxId wutxo) w)) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ;\n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 (Open w)) , --(Add w)\n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n\n</pre>"},{"location":"Test.Examples.AccountSim.OffChain.Start.html","title":"Start","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.AccountSim.OffChain.Start where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Test.Examples.AccountSim.Datum\nopen import Test.Examples.AccountSim.OffChain.Lib\nopen import Test.Examples.AccountSim.Validator\nopen import Test.Prelude AccountSimData\nopen import Test.SymbolicData AccountSimData\nopen import Test.LedgerImplementation SData SData\nopen import Test.Lib valContext\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nstartTxOut : Value \u2192 PlutusScript \u2192 TxOut\nstartTxOut v script = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj (proj\u2081 script) ;\n                           stake = just (ScriptObj (proj\u2081 script)) })\n                           , v\n                           , just (inj\u2081 (inj\u2081 (inj\u2081 (Always [])))) , nothing\n\n-- txid, wallet, value at script, script index\nstartTx : (id w tw : \u2115) \u2192 (v : Value) \u2192 PlutusScript \u2192 Tx\nstartTx id w tw v script = record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((w , w) \u2237 [])\n                         ; txOuts = fromListIx ((tw , startTxOut v script)\n                                               \u2237 (w\n                                                 , ((inj\u2081 (record { net = 0 ;\n                                                                    pay = KeyHashObj w ;\n                                                                    stake = just (KeyHashObj w) }))\n                                               , ((startValue - feeValue) - v) , nothing , nothing))\n                                               \u2237 [])\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList ((w , w) \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addNat}} w id)) \u2237 []) ;\n                                scripts = \u2205 ;\n                                txdats = \u2205 ;\n                                txrdmrs = \u2205 } ;\n\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n</pre>"},{"location":"Test.Examples.AccountSim.OffChain.Transfer.html","title":"Transfer","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.AccountSim.OffChain.Transfer where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.AccountSim.Datum\nopen import Test.Examples.AccountSim.OffChain.Lib\nopen import Test.Examples.AccountSim.Validator\nopen import Test.Prelude AccountSimData\nopen import Test.SymbolicData AccountSimData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n\nmakeTransferTxOut : Label \u2192 (scriptIx from to : \u2115) \u2192 (v : Value) \u2192 TxOut \u2192 List (\u2115 \u00d7 TxOut)\nmakeTransferTxOut (Always l) ix from to v (fst , fst' , snd) =\n  (ix , (fst , fst' ,  just (inj\u2081 (inj\u2081 (inj\u2081 (Always (insert' from (vF - v) (insert' to (_+_ {{addValue}} vT v) l)))))) , nothing)) \u2237 []\n  where\n    vF = getVal (Always l) from\n    vT = getVal (Always l) to\n\nmakeTransferTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (from to : \u2115) \u2192 (v : Value) \u2192 Maybe Tx\nmakeTransferTx id state script@(sh , _) from to v =\n  let\n    wutxo = getWalletUTxO from (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeTxOut wutxo ++ makeTransferTxOut label (proj\u2082 scIn) from to v scOut )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (from \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((from , (_+_ {{addNat}} (getTxId wutxo) from)) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; \n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 (Transfer from to v)) , --(Add w) \n                                                      ((getTxId wutxo) , from)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n\n</pre>"},{"location":"Test.Examples.AccountSim.OffChain.Withdraw.html","title":"Withdraw","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.AccountSim.OffChain.Withdraw where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.AccountSim.Datum\nopen import Test.Examples.AccountSim.OffChain.Lib\nopen import Test.Examples.AccountSim.Validator\nopen import Test.Prelude AccountSimData\nopen import Test.SymbolicData AccountSimData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n\nscriptTxOut : Label \u2192 TxOut \u2192 (w : \u2115) \u2192 (v : Value) \u2192 TxOut\nscriptTxOut (Always l) (fst , txValue , snd) w v = (fst , txValue - v , (just (inj\u2081 (inj\u2081 (inj\u2081 (Always (insert' w (val - v) l)))))) , nothing)\n  where\n    val = getVal (Always l) w\n\n\nmakeWithdrawTxOut : Label \u2192 (scriptIx : \u2115) \u2192 TxOut \u2192 (w : \u2115) \u2192 (v : Value) \u2192 List (\u2115 \u00d7 TxOut)\nmakeWithdrawTxOut (Always l) ix txo w v =\n            (ix , scriptTxOut (Always l) txo w v) \u2237 []\n\n\nmakeWithdrawTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 (v : Value) \u2192 Maybe Tx\nmakeWithdrawTx id state script@(sh , _) w v  =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeUnPaymentTxOut wutxo v ++ makeWithdrawTxOut label (proj\u2082 scIn) scOut w v )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addNat}} (getTxId wutxo) w)) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; \n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 (Withdraw w v)) , \n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n</pre>"},{"location":"Test.Examples.AccountSim.Test.Trace.html","title":"Trace","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.AccountSim.Test.Trace where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Test.Examples.AccountSim.Datum\nopen import Test.Examples.AccountSim.OffChain.OffChain\nopen import Test.Examples.AccountSim.Validator\nopen import Test.Prelude AccountSimData\nopen import Test.SymbolicData AccountSimData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxow.Properties.Computational SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nmultiSigScript : PlutusScript\nmultiSigScript = 777 , applyScriptWithContext (accSimValidator)\n\ninitEnv : UTxOEnv\ninitEnv = createEnv 0\n\ninitTxOut : TxOut\ninitTxOut = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 777 ;\n                           stake = just (ScriptObj 777) })\n                           , scriptValue , just (inj\u2082 (inj\u2081 (inj\u2081 (Always [])))) , nothing\n\nscript : TxIn \u00d7 TxOut\nscript = (6 , 6) , initTxOut\n\n\n\ninitState' : UTxO\ninitState' = fromList' (createInitUtxoState 5 startValue)\n\ndata Tx' : Set where\n    start      : \u2115 \u2192 Value \u2192 Tx'\n    openn      : \u2115 \u2192 Tx'\n    close      : \u2115 \u2192 Tx'\n    withdraw   : \u2115 \u2192 Value \u2192 Tx'\n    deposit    : \u2115 \u2192 Value \u2192 Tx'\n    transfer   : \u2115 \u2192 \u2115 \u2192 Value \u2192 Tx'\n    cleanup    : \u2115 \u2192 Tx'\n\n\nmakeTx : UTxOState \u2192 PlutusScript \u2192 Tx' \u2192 (id : \u2115) \u2192 Maybe Tx\nmakeTx s script (start w v) id = just (startTx id w 999 v script)\nmakeTx s script (openn w) id = makeOpenTx id s script w\nmakeTx s script (close w) id = makeCloseTx id s script w\nmakeTx s script (withdraw w v) id = makeWithdrawTx id s script w v\nmakeTx s script (deposit w v) id = makeDepositTx id s script w v\nmakeTx s script (transfer from to v) id = makeTransferTx id s script from to v\nmakeTx s script (cleanup w) id = makeCleanupTx id s script w\n\n\nevalTransanctions : UTxOEnv \u2192 ComputationResult String UTxOState \u2192 List Tx' \u2192 \u2115 \u2192 ComputationResult String UTxOState\nevalTransanctions env s [] id = s\nevalTransanctions env state@(failure s) (x \u2237 xs) id = state\nevalTransanctions env (success s) (tx' \u2237 txs') id =\n  maybe\n    (\u03bb tx \u2192 evalTransanctions\n              initEnv\n              (UTXO-step initEnv s tx)\n              txs'\n              (suc id))\n    (failure \"failed to generate tx\")\n    (makeTx s multiSigScript tx' id)\n\nevalTransanctionsW : UTxOEnv \u2192 ComputationResult String UTxOState \u2192 List Tx' \u2192 \u2115 \u2192 ComputationResult String UTxOState\nevalTransanctionsW env s [] id = s\nevalTransanctionsW env state@(failure s) (x \u2237 xs) id = state\nevalTransanctionsW env (success s) (tx' \u2237 txs') id =\n  maybe\n    (\u03bb tx \u2192 evalTransanctions\n              initEnv\n              (UTXO-step initEnv s tx)\n              txs'\n              (suc id))\n    (failure \"failed to generate tx\")\n    (makeTx s multiSigScript tx' id)\n\nvalidTrace : List Tx'\nvalidTrace = start 5 (adaValueOf 80000000)\n              \u2237 openn 1\n              \u2237 openn 2\n              \u2237 close 2\n              \u2237 deposit 1 (adaValueOf 2000000000)\n              \u2237 withdraw 1 (adaValueOf 1000000000)\n              \u2237 deposit 1 (adaValueOf 10000000)\n              \u2237 openn 3\n              \u2237 deposit 3 (adaValueOf 30000000)\n              \u2237 transfer 3 1 (adaValueOf 5000000)\n              \u2237 []\n\n\nvalidTrace2 : List Tx'\nvalidTrace2 = start 5 (adaValueOf 8000000000)\n              \u2237 openn 1\n              \u2237 openn 2\n              \u2237 close 2\n              \u2237 deposit 1 (adaValueOf 20000000000)\n              \u2237 withdraw 1 (adaValueOf 10000000000)\n              \u2237 deposit 1 (adaValueOf 10000000)\n              \u2237 deposit 1 (adaValueOf 10000000)\n              \u2237 openn 3\n              \u2237 deposit 3 (adaValueOf 30000000)\n              \u2237 transfer 1 3 (adaValueOf 5000000)\n              \u2237 []\n\n\nvalidTrace3 : List Tx'\nvalidTrace3 = start 5 (adaValueOf 8000000000)\n              \u2237 openn 2\n              \u2237 close 2\n              \u2237 cleanup 5\n              \u2237 []\n\n\n\nfailingTrace : List Tx'\nfailingTrace = start 5 (adaValueOf 8000000000)\n              \u2237 openn 1\n              \u2237 openn 2\n              \u2237 deposit 1 (adaValueOf 20000000)\n              \u2237 withdraw 2 (adaValueOf 10000000)\n              \u2237 []\n\nopaque\n  unfolding collectP2ScriptsWithContext\n  unfolding setToList\n  unfolding Computational-UTXO\n  unfolding outs\n\n  evalValidTrace : ComputationResult String UTxOState\n  evalValidTrace = evalTransanctions initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.AccountSim.Test.Trace.html#1577}{\\htmlId{4910}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{4923}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{4927}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{4931}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) validTrace 6\n\n  evalValidTrace2 : ComputationResult String UTxOState\n  evalValidTrace2 = evalTransanctionsW initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.AccountSim.Test.Trace.html#1577}{\\htmlId{5066}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{5079}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{5083}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{5087}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) validTrace2 6\n\n  evalValidTrace3 : ComputationResult String UTxOState\n  evalValidTrace3 = evalTransanctionsW initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.AccountSim.Test.Trace.html#1577}{\\htmlId{5223}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{5236}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{5240}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{5244}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) validTrace3 6\n\n  evalFailingTrace : ComputationResult String UTxOState\n  evalFailingTrace = evalTransanctionsW initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.AccountSim.Test.Trace.html#1577}{\\htmlId{5380}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{5393}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{5397}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{5401}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) failingTrace 6\n\n  _ : isSuccess evalValidTrace \u2261 true\n  _ = refl \n\n  _ : isSuccess evalValidTrace2 \u2261 true\n  _ = refl\n\n  _ : isSuccess evalValidTrace3 \u2261 true\n  _ = refl \n\n  _ : isSuccess evalFailingTrace \u2261 false\n  _ = refl\n</pre>"},{"location":"Test.Examples.AccountSim.Validator.html","title":"Validator","text":"<pre>{-# OPTIONS --safe #-}\n\n-- Validator Simulating Accounts on Cardano based on Agda2hs work\n\nmodule Test.Examples.AccountSim.Validator where\n\nopen import Data.Bool.Base renaming (_\u2227_ to _&amp;&amp;_) hiding (if_then_else_)\nopen import Data.List using (filter)\nopen import Data.Maybe renaming (map to maybeMap)\n\nopen import Ledger.Prelude\nopen import Test.Examples.AccountSim.Datum\nopen import Test.Prelude AccountSimData\nopen import Test.SymbolicData AccountSimData\n\nimport Agda.Builtin.Nat as N\n\nPubKeyHash : Type\nPubKeyHash = \u2115\n\ninstance\n  ShowAccountSimData : Show AccountSimData\n  ShowAccountSimData = mkShow (\u03bb x \u2192 \"\")\n\nopen import Test.LedgerImplementation SData SData\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen TransactionStructure SVTransactionStructure\n\nemptyValue : Value\nemptyValue = 0\n\nfeeValue : Value\nfeeValue = 10000000000\n\nstartValue : Value\nstartValue = 1000000000000\n\nscriptValue : Value\nscriptValue = 30000000000\n\nadaValueOf : \u2115 -&gt; Value\nadaValueOf n = n\n\n\ngeq : Value -&gt; Value -&gt; Bool\ngeq v1 v2 =  \u230a v1 \u2265? v2 \u230b\n\nsubVal : Value -&gt; Value -&gt; Value\nsubVal v1 v2 = v1 - v2\n\ninstance ValueSub : HasSubtract Value Value\n         ValueSub = record { _-_ = \u03bb x y \u2192 subVal x y } --subVal\n\n\ngetInlineOutputDatum : STxOut \u2192 List AccountSimData \u2192 Maybe Datum\ngetInlineOutputDatum (a , b , just (inj\u2081 (inj\u2081 x))) dats = just (inj\u2081 (inj\u2081 x))\ngetInlineOutputDatum (a , b , just (inj\u2081 (inj\u2082 y))) dats = nothing\ngetInlineOutputDatum (a , b , just (inj\u2082 y)) dats = nothing\ngetInlineOutputDatum (a , b , nothing) dats = nothing\n\nnewLabel : ScriptContext -&gt; Maybe Label\nnewLabel (record { realizedInputs = realizedInputs ; txouts = txouts ; fee = fee ; mint = mint ; txwdrls = txwdrls ; txvldt = txvldt ; vkey = vkey ; txdats = txdats ; txid = txid } , snd) with\n  mapMaybe (\u03bb x \u2192 getInlineOutputDatum x txdats) (map proj\u2082 txouts)\n... | [] = nothing\n... | inj\u2081 (inj\u2081 x) \u2237 [] = just x\n... | _ = nothing\n\ncontinuing : ScriptContext -&gt; Bool\ncontinuing (record { realizedInputs = realizedInputs ; txouts = txouts ; fee = fee ; mint = mint ; txwdrls = txwdrls ; txvldt = txvldt ; vkey = vkey ; txdats = txdats ; txid = txid } , snd) with\n  mapMaybe (\u03bb x \u2192 getInlineOutputDatum x txdats) (map proj\u2082 txouts)\n... | [] = false\n... | _ = true\n\n\ngetPaymentCredential : STxOut \u2192 \u2115\ngetPaymentCredential (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake } , snd) = x\ngetPaymentCredential (inj\u2081 record { net = net ; pay = (ScriptObj x) ; stake = stake } , snd) = x\ngetPaymentCredential (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize } , snd) = x\ngetPaymentCredential (inj\u2082 record { net = net ; pay = (ScriptObj x) ; attrsSize = attrsSize } , snd) = x\n\n\ngetScriptCredential' : \u2115 \u2192 SUTxO \u2192 Maybe \u2115\ngetScriptCredential' ix [] = nothing\ngetScriptCredential' ix (((txid' , ix') , txout) \u2237 utxos) with ix \u225f ix'\n... | no \u00aca = getScriptCredential' ix utxos\n... | yes a = just (getPaymentCredential txout)\n\n\ngetScriptCredential : ScriptContext \u2192 Maybe \u2115\ngetScriptCredential (fst , Rwrd x) = nothing\ngetScriptCredential (fst , Mint x) = nothing\ngetScriptCredential (txinfo , Spend (txid , ix)) = getScriptCredential' ix (STxInfo.realizedInputs txinfo)\ngetScriptCredential (fst , Empty) = nothing\n\nbalanceSTxOut : List STxOut \u2192 Value\nbalanceSTxOut txout = foldr (_+_ {{addValue}}) emptyValue (map (\u03bb {(_ , v , _) \u2192 v}) txout)\n\nmatchIx : \u2115 \u2192 SAddr \u2192 Set\nmatchIx n (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake }) = n \u2261 x\nmatchIx n (inj\u2081 record { net = net ; pay = (ScriptObj y) ; stake = stake }) = n \u2261 y\nmatchIx n (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize }) = n \u2261 x\nmatchIx n (inj\u2082 record { net = net ; pay = (ScriptObj y) ; attrsSize = attrsSize }) = n \u2261 y\n\nmatchIx? : (n : \u2115) \u2192 (a : SAddr) \u2192 Dec (matchIx n a)\nmatchIx? n (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake }) = n \u225f x\nmatchIx? n (inj\u2081 record { net = net ; pay = (ScriptObj y) ; stake = stake }) = n \u225f y\nmatchIx? n (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize }) = n \u225f x\nmatchIx? n (inj\u2082 record { net = net ; pay = (ScriptObj y) ; attrsSize = attrsSize }) = n \u225f y\n\n\ntotalOuts : ScriptContext \u2192 PubKeyHash \u2192 Value\ntotalOuts (txinfo , _) ph  = balanceSTxOut (filter (\u03bb { (fst , snd) \u2192 matchIx? ph fst}) (map proj\u2082 (STxInfo.txouts txinfo)))\n\ntotalIns : ScriptContext \u2192 PubKeyHash \u2192 Value\ntotalIns (txinfo , _) ph  = balanceSTxOut (filter (\u03bb { (fst , snd) \u2192 matchIx? ph fst}) (map proj\u2082 (STxInfo.realizedInputs txinfo)))\n\n-- Get the value of txouts for own script\nnewValue : ScriptContext \u2192 Maybe Value\nnewValue sc@(txinfo , sp) with getScriptCredential sc\n... | nothing = nothing\n... | just sh = just (totalOuts sc sh)\n\noldValue : ScriptContext \u2192 Maybe Value\noldValue sc@(txinfo , sp) with getScriptCredential sc\n... | nothing = nothing\n... | just sh = just (totalIns sc sh)\n\n\nopen import Relation.Nullary.Decidable\n\ncheckSigned : PubKeyHash \u2192 ScriptContext \u2192 Bool\ncheckSigned ph (txinfo , _) = \u230a (ph \u2208? (STxInfo.vkey txinfo)) \u230b\n\nquery : PubKeyHash \u2192 List PubKeyHash \u2192 Bool\nquery ph xs = any (\u03bb k \u2192  \u230a ph \u225f k \u230b) xs\n\ncheckPayment : PubKeyHash -&gt; Value -&gt; ScriptContext -&gt; Bool\ncheckPayment pkh v ctx = \u230a totalOuts ctx pkh \u225f (_+_ {{addValue}} (totalIns ctx pkh) v) \u230b\n\nexpired : \u2115 -&gt; ScriptContext -&gt; Bool\nexpired slot (txinfo , _) = maybe (\u03bb deadline \u2192  \u230a slot &gt;? deadline \u230b)\n                                     false\n                                     (proj\u2082 (STxInfo.txvldt txinfo))\n\n\n\ncheckMembership : Maybe Value -&gt; Bool\ncheckMembership (just x) = true\ncheckMembership nothing = false\n\ncheckEmpty : Maybe Value -&gt; Bool\ncheckEmpty (just x) = x == emptyValue\ncheckEmpty nothing = false\n\ninsert' : PubKeyHash -&gt; Value -&gt; List (\u2115 \u00d7 Value) -&gt; List (\u2115 \u00d7 Value)\ninsert' pkh val [] = ((pkh , val) \u2237 [])\ninsert' pkh val ((x , y) \u2237 xs) = if (pkh == x) then ((pkh , val) \u2237 xs) else ((x , y) \u2237 (insert' pkh val xs))\n\ndelete' : PubKeyHash -&gt; List (\u2115 \u00d7 Value) -&gt; List (\u2115 \u00d7 Value)\ndelete' pkh [] = []\ndelete' pkh ((x , y) \u2237 xs) = if (pkh == x)\n  then xs\n  else ((x , y) \u2237 (delete' pkh xs))\n\nlookup' : \u2115 \u2192 List (\u2115 \u00d7 Value) \u2192 Maybe Value\nlookup' x []              = nothing \nlookup' x ((x\u2081 , y) \u2237 xs) = if x == x\u2081 then just y else lookup' x xs\n\n\n\ncheckWithdraw : Maybe Value -&gt; \u2115 -&gt; Value -&gt; Label -&gt; ScriptContext -&gt; Bool\ncheckWithdraw nothing _ _ _ _ = false\ncheckWithdraw (just v) pkh val (Always lab) ctx = geq val emptyValue &amp;&amp; geq v val &amp;&amp; (newLabel ctx == just (Always (insert' pkh (v - val) lab))) \n\ncheckDeposit : Maybe  Value -&gt; \u2115 -&gt; Value -&gt;  Label -&gt; ScriptContext -&gt; Bool\ncheckDeposit nothing _ _ _ _ = false\ncheckDeposit (just v) pkh val (Always lab) ctx = geq val emptyValue &amp;&amp; (newLabel ctx == just ( Always (insert' pkh (_+_ {{addValue}} v val) lab)))\n\ncheckTransfer : Maybe Value -&gt; Maybe Value -&gt; \u2115 -&gt; \u2115 -&gt; Value -&gt; Label -&gt; ScriptContext -&gt; Bool\ncheckTransfer nothing _ _ _ _ _ _ = false\ncheckTransfer (just vF) nothing _ _ _ _ _ = false\ncheckTransfer (just vF) (just vT) from to val (Always lab) ctx = geq val emptyValue &amp;&amp; geq vF val &amp;&amp; (from \u2260 to) &amp;&amp; (newLabel ctx == just (Always (insert' from (vF - val) (insert' to (_+_ {{addValue}} vT val) lab))))\n\nagdaValidator : Label -&gt; Input -&gt; ScriptContext -&gt; Bool\nagdaValidator (Always lab) inp ctx = case inp of \u03bb where\n\n    (Open pkh) -&gt; continuing ctx &amp;&amp; (checkSigned pkh ctx) &amp;&amp; (not (checkMembership (lookup' pkh lab))) &amp;&amp;\n                  (newLabel ctx == just (Always (insert' pkh emptyValue lab))) &amp;&amp; (newValue ctx == oldValue ctx)\n\n    (Close pkh) -&gt; continuing ctx &amp;&amp; (checkSigned pkh ctx) &amp;&amp; (checkEmpty (lookup' pkh lab)) &amp;&amp;\n                   (newLabel ctx == just (Always (delete' pkh lab))) &amp;&amp; (newValue ctx == oldValue ctx)\n\n    (Withdraw pkh val) -&gt; continuing ctx &amp;&amp; (checkSigned pkh ctx) &amp;&amp; (checkWithdraw (lookup' pkh lab) pkh val (Always lab) ctx) &amp;&amp;\n                          ((maybeMap (_+_ {{addValue}} val) (newValue ctx)) == oldValue ctx )\n\n    (Deposit pkh val) -&gt; continuing ctx &amp;&amp; checkSigned pkh ctx &amp;&amp; checkDeposit (lookup' pkh lab) pkh val (Always lab) ctx &amp;&amp;\n                         (newValue ctx == (maybeMap (_+_ {{addValue}} val) (oldValue ctx))) \n\n    (Transfer from to val) -&gt; continuing ctx &amp;&amp; checkSigned from ctx &amp;&amp;\n                              checkTransfer (lookup' from lab) (lookup' to lab) from to val (Always lab) ctx &amp;&amp;\n                              (newValue ctx == oldValue ctx) \n\n    Cleanup -&gt; not (continuing ctx) &amp;&amp; (lab == [])\n\n\naccSimValidator : Maybe SData \u2192 Maybe SData \u2192 List SData \u2192 Bool\naccSimValidator (just (inj\u2081 (inj\u2081 x))) (just (inj\u2081 (inj\u2082 y))) (inj\u2082 y\u2081 \u2237 []) =\n  agdaValidator x y y\u2081\naccSimValidator _ _ _ = false\n\n</pre>"},{"location":"Test.Examples.DEx.Datum.html","title":"Datum","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\n\nmodule Test.Examples.DEx.Datum where\n\nopen import Tactic.Derive.DecEq\nopen import Data.Vec as Vec\n  hiding (fromList)\nimport stdlib.Data.Vec.Instances as Vec\nimport Data.Vec.Relation.Binary.Pointwise.Inductive as Vec\n\nopen import Data.Rational.Base\n\ndata Label : Set where\n -- Holding : Label\n  Always : \u211a -&gt; \u2115 -&gt; Label \ninstance\n  unquoteDecl DecEq-Label = derive-DecEq\n    ((quote Label , DecEq-Label) \u2237 [])\n\ndata Input : Set where\n  Update   : \u2115 -&gt; \u211a -&gt; Input\n  Exchange : \u2115 -&gt; \u2115 -&gt; Input\n  Close    : Input\ninstance\n  unquoteDecl DecEq-Input = derive-DecEq\n    ((quote Input , DecEq-Input) \u2237 [])\n\nDExData = Label \u228e Input\n</pre>"},{"location":"Test.Examples.DEx.OffChain.Close.html","title":"Close","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.DEx.OffChain.Close where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.DEx.Datum\nopen import Test.Examples.DEx.Validator\nopen import Test.Examples.DEx.OffChain.Lib\nopen import Test.Prelude DExData\nopen import Test.SymbolicData DExData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nmakeCloseTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 Maybe Tx\nmakeCloseTx id state script@(sh , _) w =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , (fst , txValue , snd)) \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeUnPaymentTxOut wutxo txValue)\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 []) \n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addNat}} (getTxId wutxo) w) ) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; \n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 Close) , \n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                )\n            })\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n\n</pre>"},{"location":"Test.Examples.DEx.OffChain.Exchange.html","title":"Exchange","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.DEx.OffChain.Exchange where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.DEx.Datum\nopen import Test.Examples.DEx.Validator\nopen import Test.Examples.DEx.OffChain.Lib\nopen import Test.Prelude DExData\nopen import Test.SymbolicData DExData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nimport Data.Rational.Base as Q\n\nscriptETxOut : Label \u2192 TxOut \u2192 (w : \u2115) \u2192 (v : Value) \u2192 TxOut\nscriptETxOut (Always q o) (fst , txValue , snd) w v = (fst , (txValue - v) , (just (inj\u2081 (inj\u2081 (inj\u2081 (Always q o))))) , nothing)\n\n\nmakeExchangeTxOut : Label \u2192 (scriptIx : \u2115) \u2192 TxOut \u2192 (w : \u2115) \u2192 (v : Value) \u2192 List (\u2115 \u00d7 TxOut)\nmakeExchangeTxOut (Always r o) ix txo w v =\n            (ix , scriptETxOut (Always r o) txo w v) \u2237\n            (2 , ((inj\u2081 (record { net = 0 ; pay = KeyHashObj o ; stake = just (KeyHashObj o) })) ,\n              (ratioValue v r , nothing , nothing)))\u2237 []\n\n\n\nmakeExchangeTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 (v : Value) \u2192 Maybe Tx\nmakeExchangeTx id state script@(sh , _) w v = \n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb {(Always r o) \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeSwapTxOut wutxo v (ratioValue v r) ++ makeExchangeTxOut (Always r o) (proj\u2082 scIn) scOut w v )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addNat}} (getTxId wutxo) w)) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; \n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 (Exchange w v)) , \n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                )}) \n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n</pre>"},{"location":"Test.Examples.DEx.OffChain.Lib.html","title":"Lib","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.DEx.OffChain.Lib where\n\nopen import Data.List using (filter)\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Test.Examples.DEx.Datum\nopen import Test.Examples.DEx.Validator\nopen import Test.Prelude DExData\nopen import Test.SymbolicData DExData\nopen import Test.LedgerImplementation SData SData\n\nopen TransactionStructure SVTransactionStructure\n\ndefaultTxBody : TxBody\ndefaultTxBody = record\n                  { txIns = \u2205\n                  ; refInputs = \u2205\n                  ; collateralInputs = \u2205\n                  ; txOuts =  \u2205\n                  ; txFee = 10000000000\n                  ; mint = 0\n                  ; txVldt = nothing , nothing\n                  ; txCerts = []\n                  ; txWithdrawals = \u2205\n                  ; txGovVotes = []\n                  ; txGovProposals = []\n                  ; txDonation = 0\n                  ; txADhash = nothing\n                  ; txNetworkId = just 0\n                  ; currentTreasury = nothing\n                  ; txId = 0\n                  ; reqSignerHashes = \u2205\n                  ; scriptIntegrityHash = nothing\n                  }\n\nmatchScriptAddress : (scriptHash : \u2115) \u2192 Credential \u2192 Set\nmatchScriptAddress sh (KeyHashObj x) = \u22a5\nmatchScriptAddress sh (ScriptObj y) = True (sh \u225f y)\n\nmatchScriptAddress? : (sh : \u2115) \u2192 (c : Credential) \u2192 Dec (matchScriptAddress sh c)\nmatchScriptAddress? sh (KeyHashObj x) = no (\u03bb x\u2081 \u2192 x\u2081)\nmatchScriptAddress? sh (ScriptObj y) = T? \u230a (sh \u225f y) \u230b\n\ngetScriptUTxO : (scriptHash : \u2115) \u2192 UTxO \u2192 Maybe (TxIn \u00d7 TxOut)\ngetScriptUTxO sh (utxo , prf) = head $ filter (\u03bb { (_ , addr , _) \u2192 matchScriptAddress? sh (payCred addr)}) (setToList utxo)\n\nmatchWalletHash : (keyHash : \u2115) \u2192 Credential \u2192 Set\nmatchWalletHash kh (KeyHashObj x) = True (kh \u225f x)\nmatchWalletHash kh (ScriptObj y) = \u22a5\n\nmatchWalletHash? : (sh : \u2115) \u2192 (c : Credential) \u2192 Dec (matchWalletHash sh c)\nmatchWalletHash? kh (KeyHashObj x) = T? \u230a (kh \u225f x) \u230b\nmatchWalletHash? kh (ScriptObj y) = no (\u03bb x\u2081 \u2192 x\u2081)\n\ngetWalletUTxO : (scriptHash : \u2115) \u2192 UTxO \u2192 List (TxIn \u00d7 TxOut)\ngetWalletUTxO sh (utxo , prf) = filter (\u03bb { (_ , addr , _) \u2192 matchWalletHash? sh (payCred addr)}) (setToList utxo)\n\n{-\nsucceedTxOut' : TxOut\nsucceedTxOut' = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 777 ;\n                           stake = just (ScriptObj 777) })\n                           , {!!} , just (inj\u2081 (inj\u2081 (inj\u2081 (Always [])))) , nothing\n-- 700000000000 -}\n\ngetLabel : TxOut \u2192 Maybe Label\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2081 (inj\u2081 x))) , snd) = just x\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2081 (inj\u2082 y))) , snd) = nothing\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2082 y)) , snd) = nothing\ngetLabel (fst , fst\u2081 , just (inj\u2082 y) , snd) = nothing\ngetLabel (fst , fst\u2081 , nothing , snd) = nothing\n\n\n\n-- Assumes a list of filtered waller txins and subtracts a default fee from the head of the list\nmakeFeeTxOut : List (TxIn \u00d7 TxOut) \u2192 List (\u2115 \u00d7 TxOut)\nmakeFeeTxOut [] = []\nmakeFeeTxOut ((txin , (fst , txValue , snd)) \u2237 utxos) = (proj\u2082 txin , fst , txValue - feeValue , snd) \u2237 []\n--10000000000\n\nmakeFeeUnPaymentTxOut : List (TxIn \u00d7 TxOut) \u2192 Value \u2192 List (\u2115 \u00d7 TxOut)\nmakeFeeUnPaymentTxOut [] v = []\nmakeFeeUnPaymentTxOut ((txin , (fst , txValue , snd)) \u2237 utxos) v = (proj\u2082 txin , fst , _+_ {{addValue}} (txValue - feeValue) v , snd) \u2237 []\n-- 10000000000\n\nmakeFeePaymentTxOut : List (TxIn \u00d7 TxOut) \u2192 Value \u2192 List (\u2115 \u00d7 TxOut)\nmakeFeePaymentTxOut [] v = []\nmakeFeePaymentTxOut ((txin , (fst , txValue , snd)) \u2237 utxos) v = (proj\u2082 txin , fst , (txValue - feeValue ) - v , snd) \u2237 []\n--10000000000\n\nmakeFeeSwapTxOut : List (TxIn \u00d7 TxOut) \u2192 Value \u2192 Value \u2192 List (\u2115 \u00d7 TxOut)\nmakeFeeSwapTxOut [] v1 v2 = []\nmakeFeeSwapTxOut ((txin , (fst , txValue , snd)) \u2237 utxos) refund new = (proj\u2082 txin , fst , _+_ {{addValue}} ((txValue - feeValue ) - new) refund , snd) \u2237 []\n\n-- return id of 0 if no txins\ngetTxId : List (TxIn \u00d7 TxOut) \u2192 \u2115\ngetTxId xs = maybe (\u03bb x \u2192 proj\u2081 (proj\u2081 x)) 0 (head xs)\n\n{-\ngetVal : Label -&gt; \u2115 -&gt; Value\ngetVal (Always l) w with lookup' w l\n...| nothing = emptyValue\n...| just v = v\n-}\n\n\n\n</pre>"},{"location":"Test.Examples.DEx.OffChain.OffChain.html","title":"OffChain","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.DEx.OffChain.OffChain where\n\nopen import Test.Examples.DEx.OffChain.Start public\nopen import Test.Examples.DEx.OffChain.Close public\nopen import Test.Examples.DEx.OffChain.Update public\nopen import Test.Examples.DEx.OffChain.Exchange public\n</pre>"},{"location":"Test.Examples.DEx.OffChain.Start.html","title":"Start","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.DEx.OffChain.Start where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Test.Examples.DEx.Datum\nopen import Test.Examples.DEx.OffChain.Lib\nopen import Test.Examples.DEx.Validator\nopen import Test.Prelude DExData\nopen import Test.SymbolicData DExData\nopen import Test.LedgerImplementation SData SData\nopen import Test.Lib valContext\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nimport Data.Rational.Base as Q\n\nstartTxOut : Value \u2192 Q.\u211a \u2192 \u2115 \u2192 PlutusScript \u2192 TxOut\nstartTxOut v r o script = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj (proj\u2081 script) ;\n                           stake = just (ScriptObj (proj\u2081 script)) })\n                           , v\n                           , just (inj\u2081 (inj\u2081 (inj\u2081 (Always r o)))) , nothing\n\n\nstartTx : (id w tw : \u2115) \u2192 (v : Value) \u2192 Q.\u211a \u2192 PlutusScript \u2192 Tx\nstartTx id w tw v r script = record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((w , w) \u2237 [])\n                         ; txOuts = fromListIx ((tw , startTxOut v r w script)\n                                               \u2237 (w\n                                                 , ((inj\u2081 (record { net = 0 ;\n                                                                    pay = KeyHashObj w ;\n                                                                    stake = just (KeyHashObj w) }))\n                                               , ((startValue - feeValue) - v) , nothing , nothing))\n                                               \u2237 [])\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList ((w , w) \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addNat}} w id)) \u2237 []) ;\n                                scripts = \u2205 ; \n                                txdats = \u2205 ; \n                                txrdmrs = \u2205 } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n</pre>"},{"location":"Test.Examples.DEx.OffChain.Update.html","title":"Update","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.DEx.OffChain.Update where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.DEx.Datum\nopen import Test.Examples.DEx.Validator\nopen import Test.Examples.DEx.OffChain.Lib\nopen import Test.Prelude DExData\nopen import Test.SymbolicData DExData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nimport Data.Rational.Base as Q\n\n\n\nmakeUpdateTxOut : Label \u2192 (scriptIx w : \u2115) \u2192 Value \u2192 Q.\u211a \u2192 TxOut \u2192 List (\u2115 \u00d7 TxOut)\nmakeUpdateTxOut (Always q o) ix w v r (fst , txValue , snd) =\n  (ix , (fst , v ,  just (inj\u2081 (inj\u2081 (inj\u2081 (Always r o)))) , nothing)) \u2237 [] \n\nmakeUpdateTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 Value \u2192 Q.\u211a \u2192 Maybe Tx\nmakeUpdateTx id state script@(sh , _) w v r =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , (fst , txValue , snd)) \u2192 maybe (\u03bb label \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeSwapTxOut wutxo txValue v ++ makeUpdateTxOut label (proj\u2082 scIn) w v r (fst , txValue , snd) )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 []) \n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addNat}} (getTxId wutxo) w)) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; \n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 (Input.Update v r)) , \n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                ))\n            nothing\n            (getLabel (fst , txValue , snd))})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n\n</pre>"},{"location":"Test.Examples.DEx.Test.Trace.html","title":"Trace","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.DEx.Test.Trace where\n\nimport Data.Rational.Base as Q\nopen import Data.Nat.Divisibility.Core\nopen import Data.Nat.Properties\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Test.Examples.DEx.Datum\nopen import Test.Examples.DEx.Validator\nopen import Test.Prelude DExData\nopen import Test.SymbolicData DExData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxow.Properties.Computational SVTransactionStructure SVAbstractFunctions\n\n\nopen import Test.Examples.DEx.OffChain.OffChain\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n\npar : Params\npar = record { sellC = 0 ; buyC = 0 }\n\nmultiSigScript : PlutusScript\nmultiSigScript = 777 , applyScriptWithContext (dexValidator par)\n\ninitEnv : UTxOEnv\ninitEnv = createEnv 0\n\n\ninitState' : UTxO\ninitState' = fromList' (createInitUtxoState 5 startValue)\n\n\ndata Tx' : Set where\n    start      : \u2115 \u2192 Value \u2192 Q.\u211a \u2192 Tx'\n    close      : \u2115 \u2192 Tx'\n    updatetx   : \u2115 \u2192 Value \u2192 Q.\u211a \u2192 Tx'\n    exchange   : \u2115 \u2192 Value \u2192 Tx'\n\n\nmakeTx : UTxOState \u2192 PlutusScript \u2192 Tx' \u2192 (id : \u2115) \u2192 Maybe Tx\nmakeTx s script (start w v r) id = just (startTx id w 999 v r script)\nmakeTx s script (close w) id = makeCloseTx id s script w\nmakeTx s script (updatetx w v r) id = makeUpdateTx id s script w v r\nmakeTx s script (exchange w v) id = makeExchangeTx id s script w v\n\nevalTransanctions : UTxOEnv \u2192 ComputationResult String UTxOState \u2192 List Tx' \u2192 \u2115 \u2192 ComputationResult String UTxOState\nevalTransanctions env s [] id = s\nevalTransanctions env state@(failure s) (x \u2237 xs) id = state\nevalTransanctions env (success s) (tx' \u2237 txs') id =\n  maybe\n    (\u03bb tx \u2192 evalTransanctions\n              initEnv\n              (UTXO-step initEnv s tx)\n              txs'\n              (suc id))\n    (failure \"failed to generate tx\")\n    (makeTx s multiSigScript tx' id)\n\nevalTransanctionsW : UTxOEnv \u2192 ComputationResult String UTxOState \u2192 List Tx' \u2192 \u2115 \u2192 ComputationResult String UTxOState\nevalTransanctionsW env s [] id = s\nevalTransanctionsW env state@(failure s) (x \u2237 xs) id = state\nevalTransanctionsW env (success s) (tx' \u2237 txs') id =\n  maybe\n    (\u03bb tx \u2192 evalTransanctions\n              initEnv\n              (UTXO-step initEnv s tx)\n              txs'\n              (suc id))\n    (failure \"failed to generate tx\")\n    (makeTx s multiSigScript tx' id)\n\npf : \u2200 {d} -&gt; (d Data.Nat.Divisibility.Core.\u2223 1) -&gt; d \u2261 1\npf {zero} (divides quotient equality) rewrite *-comm quotient zero = sym equality\npf {suc d} (divides (suc zero) eq) rewrite +-comm d 0 = sym eq\npf {suc zero} (divides (2+ q) ())\npf {2+ d} (divides (2+ q) ())\n\nrate : Q.\u211a\nrate = (Q.mk\u211a (\u2124.pos (suc zero)) zero (\u03bb { (fst , snd) \u2192 pf fst }) )\n\nrate2 : Q.\u211a\nrate2 = (Q.mk\u211a (\u2124.pos (suc zero)) (suc zero) (\u03bb { (fst , snd) \u2192 pf fst }) )\n\nrate3 : Q.\u211a\nrate3 = (Q.mk\u211a (\u2124.pos (suc (suc (suc zero)))) (zero) (\u03bb { (fst , snd) \u2192 pf snd }) )\n\nvalidTrace : List Tx'\nvalidTrace = start 5 (adaValueOf 80000000) rate\n             \u2237 updatetx 5 (adaValueOf 70000000) rate\n             \u2237 close 5\n             \u2237 []\n\n\nvalidTrace2 : List Tx'\nvalidTrace2 = start 5 (adaValueOf 8000000000) rate\n              \u2237 exchange 1 (adaValueOf 70000000)\n              \u2237 []\n\n\n\nfailingTrace : List Tx'\nfailingTrace = start 5 (adaValueOf 8000000000) rate\n               \u2237 updatetx 1 (adaValueOf 40000000) rate3\n              \u2237 []\n\nopaque\n  unfolding collectP2ScriptsWithContext\n  unfolding setToList\n  unfolding Computational-UTXO\n  unfolding outs\n\n  evalValidTrace : ComputationResult String UTxOState\n  evalValidTrace = evalTransanctionsW initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.DEx.Test.Trace.html#1378}{\\htmlId{4134}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{4147}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{4151}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{4155}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) validTrace 6\n\n  evalValidTrace2 : ComputationResult String UTxOState\n  evalValidTrace2 = evalTransanctionsW initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.DEx.Test.Trace.html#1378}{\\htmlId{4288}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{4301}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{4305}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{4309}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) validTrace2 6\n\n  evalFailingTrace : ComputationResult String UTxOState\n  evalFailingTrace = evalTransanctionsW initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.DEx.Test.Trace.html#1378}{\\htmlId{4445}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{4458}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{4462}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{4466}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) failingTrace 6\n\n  _ : isSuccess evalValidTrace \u2261 true\n  _ = refl\n\n  _ : isSuccess evalValidTrace2 \u2261 true\n  _ = refl\n\n  _ : isSuccess evalFailingTrace \u2261 false\n  _ = refl\n</pre>"},{"location":"Test.Examples.DEx.Validator.html","title":"Validator","text":"<pre>{-# OPTIONS --safe #-}\n\n-- Validator for the MultiSig contract from the EUTxO paper adapted from Agda2hs version\n\nmodule Test.Examples.DEx.Validator where\n\nopen import Data.Maybe renaming (map to maybeMap)\nopen import Data.List using (filter)\nopen import Data.Bool.Base renaming (_\u2227_ to _&amp;&amp;_) hiding (if_then_else_)\n\nimport Agda.Builtin.Nat as N\nimport Data.Rational.Base as Q\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Test.Examples.DEx.Datum\nopen import Test.Prelude DExData\nopen import Test.SymbolicData DExData\n\nPubKeyHash : Type\nPubKeyHash = \u2115\n\n--TODO: Implement show properly\ninstance\n  ShowAccountSimData : Show DExData\n  ShowAccountSimData = mkShow (\u03bb x \u2192 \"\")\n\nopen import Test.LedgerImplementation SData SData\n\nopen TransactionStructure SVTransactionStructure\n\nemptyValue : Value\nemptyValue = 0\n\nfeeValue : Value\nfeeValue = 10000000000\n\nstartValue : Value\nstartValue = 1000000000000\n\nscriptValue : Value\nscriptValue = 30000000000\n\nminValue : Value\nminValue = 3000000\n\nadaValueOf : \u2115 -&gt; Value\nadaValueOf n = n \n\n\ngeq : Value -&gt; Value -&gt; Bool\ngeq v1 v2 =  \u230a v1 \u2265? v2 \u230b\n\nsubVal : Value -&gt; Value -&gt; Value\nsubVal v1 v2 = v1 - v2\n\ninstance ValueSub : HasSubtract Value Value\n         ValueSub = record { _-_ = \u03bb x y \u2192 subVal x y } --subVal\n\n\n\nrecord Params : Set where\n  field\n    sellC : \u2115\n    buyC : \u2115\n\n\ngetInlineOutputDatum : STxOut \u2192 List DExData \u2192 Maybe Datum\ngetInlineOutputDatum (a , b , just (inj\u2081 (inj\u2081 x))) dats = just (inj\u2081 (inj\u2081 x))\ngetInlineOutputDatum (a , b , just (inj\u2081 (inj\u2082 y))) dats = nothing\ngetInlineOutputDatum (a , b , just (inj\u2082 y)) dats = nothing\ngetInlineOutputDatum (a , b , nothing) dats = nothing\n\nnewLabel : ScriptContext -&gt; Maybe Label\nnewLabel (record { realizedInputs = realizedInputs ; txouts = txouts ; fee = fee ; mint = mint ; txwdrls = txwdrls ; txvldt = txvldt ; vkey = vkey ; txdats = txdats ; txid = txid } , snd) with\n  mapMaybe (\u03bb x \u2192 getInlineOutputDatum x txdats) (map proj\u2082 txouts)\n... | [] = nothing\n... | inj\u2081 (inj\u2081 x) \u2237 [] = just x\n... | _ = nothing\n\ncontinuing : ScriptContext -&gt; Bool\ncontinuing (record { realizedInputs = realizedInputs ; txouts = txouts ; fee = fee ; mint = mint ; txwdrls = txwdrls ; txvldt = txvldt ; vkey = vkey ; txdats = txdats ; txid = txid } , snd) with\n  mapMaybe (\u03bb x \u2192 getInlineOutputDatum x txdats) (map proj\u2082 txouts)\n... | [] = false\n... | _ = true\n\ngetPaymentCredential : STxOut \u2192 \u2115\ngetPaymentCredential (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake } , snd) = x\ngetPaymentCredential (inj\u2081 record { net = net ; pay = (ScriptObj x) ; stake = stake } , snd) = x\ngetPaymentCredential (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize } , snd) = x\ngetPaymentCredential (inj\u2082 record { net = net ; pay = (ScriptObj x) ; attrsSize = attrsSize } , snd) = x\n\ngetScriptCredential' : \u2115 \u2192 SUTxO \u2192 Maybe \u2115\ngetScriptCredential' ix [] = nothing\ngetScriptCredential' ix (((txid' , ix') , txout) \u2237 utxos) with ix \u225f ix'\n... | no \u00aca = getScriptCredential' ix utxos\n... | yes a = just (getPaymentCredential txout)\n\ngetScriptCredential : ScriptContext \u2192 Maybe \u2115\ngetScriptCredential (fst , Rwrd x) = nothing\ngetScriptCredential (fst , Mint x) = nothing\ngetScriptCredential (txinfo , Spend (txid , ix)) = getScriptCredential' ix (STxInfo.realizedInputs txinfo)\ngetScriptCredential (fst , Empty) = nothing\n\nbalanceSTxOut : List STxOut \u2192 Value\nbalanceSTxOut txout = foldr (_+_ {{addValue}}) emptyValue (map (\u03bb {(_ , v , _) \u2192 v}) txout)\n\nmatchIx : \u2115 \u2192 SAddr \u2192 Set\nmatchIx n (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake }) = n \u2261 x\nmatchIx n (inj\u2081 record { net = net ; pay = (ScriptObj y) ; stake = stake }) = n \u2261 y\nmatchIx n (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize }) = n \u2261 x\nmatchIx n (inj\u2082 record { net = net ; pay = (ScriptObj y) ; attrsSize = attrsSize }) = n \u2261 y\n\nmatchIx? : (n : \u2115) \u2192 (a : SAddr) \u2192 Dec (matchIx n a)\nmatchIx? n (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake }) = n \u225f x\nmatchIx? n (inj\u2081 record { net = net ; pay = (ScriptObj y) ; stake = stake }) = n \u225f y\nmatchIx? n (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize }) = n \u225f x\nmatchIx? n (inj\u2082 record { net = net ; pay = (ScriptObj y) ; attrsSize = attrsSize }) = n \u225f y\n\n\ntotalOuts : ScriptContext \u2192 PubKeyHash \u2192 Value\ntotalOuts (txinfo , _) ph  = balanceSTxOut (filter (\u03bb { (fst , snd) \u2192 matchIx? ph fst}) (map proj\u2082 (STxInfo.txouts txinfo)))\n\ntotalIns : ScriptContext \u2192 PubKeyHash \u2192 Value\ntotalIns (txinfo , _) ph  = balanceSTxOut (filter (\u03bb { (fst , snd) \u2192 matchIx? ph fst}) (map proj\u2082 (STxInfo.realizedInputs txinfo)))\n\nnewValue : ScriptContext \u2192 Maybe Value\nnewValue sc@(txinfo , sp) with getScriptCredential sc\n... | nothing = nothing\n... | just sh = just (totalOuts sc sh)\n\noldValue : ScriptContext \u2192 Maybe Value\noldValue sc@(txinfo , sp) with getScriptCredential sc\n... | nothing = nothing\n... | just sh = just (totalIns sc sh)\n\n\nopen import Relation.Nullary.Decidable\n\ncheckSigned : PubKeyHash \u2192 ScriptContext \u2192 Bool\ncheckSigned ph (txinfo , _) = \u230a (ph \u2208? (STxInfo.vkey txinfo)) \u230b\n\n\ncheckRational : Q.\u211a -&gt; Bool\ncheckRational (Q.mk\u211a (\u2124.pos n) denominator-1 isCoprime) = \u230a n \u2265? 0 \u230b\ncheckRational (Q.mk\u211a (\u2124.negsuc n) denominator-1 isCoprime) = false\n\n\ncheckMinValue : Value -&gt; Bool\ncheckMinValue v = geq v minValue\n\n\nratioValue : Value -&gt; Q.\u211a -&gt; Value\nratioValue v (Q.mk\u211a (\u2124.pos n) denominator-1 isCoprime) = N.suc ((v * n) / (N.suc denominator-1))\nratioValue v (Q.mk\u211a (\u2124.negsuc n) denominator-1 isCoprime) = N.suc ((v * n) / (N.suc denominator-1))\n\ncheckBuyerPayment : PubKeyHash -&gt; Value -&gt; Q.\u211a -&gt; ScriptContext -&gt; Bool\ncheckBuyerPayment pkh v r ctx = \u230a totalOuts ctx pkh \u225f (_+_ {{addValue}} (((totalIns ctx pkh) - feeValue) - ratioValue v r) v) \u230b\n\ncheckOwnerPayment : PubKeyHash -&gt; Value -&gt; Q.\u211a -&gt; ScriptContext -&gt; Bool\ncheckOwnerPayment pkh v (Q.mk\u211a (\u2124.pos n) denominator-1 isCoprime) ctx =\n  \u230a totalOuts ctx pkh \u2265? (_+_ {{addValue}} (totalIns ctx pkh) ((v * n) / (N.suc denominator-1)))  \u230b\ncheckOwnerPayment pkh v (Q.mk\u211a (\u2124.negsuc n) denominator-1 isCoprime) ctx = false\n\nagdaValidator : Params -&gt; Label -&gt; Input -&gt; ScriptContext -&gt; Bool\nagdaValidator par (Always q o) inp ctx = (case inp of \u03bb where\n  (Update v r) -&gt; checkSigned o ctx &amp;&amp; checkRational r &amp;&amp;\n                  checkMinValue v &amp;&amp; (newValue ctx == just v) &amp;&amp;\n                  (newLabel ctx == just (Always r o)) &amp;&amp; continuing ctx\n  (Exchange pkh amt) -&gt; ((oldValue ctx) == (maybeMap (_+_ {{addValue}} amt) (newValue ctx))) &amp;&amp;\n                        (newLabel ctx == just (Always q o)) &amp;&amp;\n                        checkOwnerPayment o amt q ctx &amp;&amp; checkBuyerPayment pkh amt q ctx &amp;&amp;\n                        checkMinValue amt &amp;&amp; continuing ctx \n  Close -&gt; checkSigned o ctx &amp;&amp; not (continuing ctx) ) \n\n\ndexValidator : Params \u2192 Maybe SData \u2192 Maybe SData \u2192 List SData \u2192 Bool\ndexValidator par (just (inj\u2081 (inj\u2081 x))) (just (inj\u2081 (inj\u2082 y))) (inj\u2082 y\u2081 \u2237 []) =\n  agdaValidator par x y y\u2081\ndexValidator _ _ _ _ = false\n\n</pre>"},{"location":"Test.Examples.HelloWorld.html","title":"HelloWorld","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.HelloWorld where\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\n\nopen import Test.LedgerImplementation String String\nopen import Ledger.Conway.Specification.Script.ScriptPurpose SVTransactionStructure\n\nopen import Ledger.Conway.Specification.Transaction\nopen TransactionStructure SVTransactionStructure using (Data)\n\nvalContext : TxInfo \u2192 ScriptPurpose \u2192 Data\nvalContext x x\u2081 = \"\"\n\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n-- true if redeemer is \"Hello World\"\nhelloWorld' : Maybe String \u2192 Maybe String \u2192 Bool\nhelloWorld' _ (just s) = \u230a (s \u225f \"Hello World\") \u230b\nhelloWorld' _ _ = false\n\nhelloWorld : PlutusScript\nhelloWorld = 777 , applyScript helloWorld'\n\ninitEnv : UTxOEnv\ninitEnv = createEnv 0\n\ninitTxOut : TxOut\ninitTxOut = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 777 ;\n                           stake = just (ScriptObj 777) })\n                           , 10 , nothing , nothing\n\nscript : TxIn \u00d7 TxOut\nscript = (6 , 6) , initTxOut\n\ninitState : UTxO\ninitState = fromList' (script \u2237 (createInitUtxoState 5 1000000000000))\n\nsucceedTx : Tx\nsucceedTx = record { body = record\n                         { txIns = Ledger.Prelude.fromList ((6 , 6) \u2237 (5 , 5) \u2237 [])\n                         ; refInputs = \u2205\n                         ; txOuts = fromListIx ((6 , initTxOut)\n                                               \u2237 (5\n                                                 , ((inj\u2081 (record { net = 0 ;\n                                                                    pay = KeyHashObj 5 ;\n                                                                    stake = just (KeyHashObj 5) }))\n                                                 , (1000000000000 - 10000000000) , nothing , nothing))\n                                               \u2237 [])\n                         ; txFee = 10000000000\n                         ; mint = 0\n                         ; txVldt = nothing , nothing\n                         ; txCerts = []\n                         ; txWithdrawals = \u2205\n                         ; txGovVotes = []\n                         ; txGovProposals = []\n                         ; txDonation = 0\n                         ; txADhash = nothing\n                         ; txNetworkId = just 0\n                         ; currentTreasury = nothing\n                         ; txId = 7\n                         ; collateralInputs = Ledger.Prelude.fromList ((5 , 5) \u2237 [])\n                         ; reqSignerHashes = \u2205\n                         ; scriptIntegrityHash = nothing\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((5 , 12) \u2237 []) ;\n                                -- signature now is first number + txId \u2261 second number\n                                -- first number is needs to be the id for the script\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 helloWorld) \u2237 []) ;\n                                txdats = \u2205 ;\n                                txrdmrs = fromList\u1d50 (((Spend , 6) , \"Hello World\" , (5 , 5)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n\nfailTx : Tx\nfailTx = record { body = record\n                         { txIns = Ledger.Prelude.fromList ((6 , 6) \u2237 [])\n                         ; refInputs = \u2205\n                         ; txOuts = \u2205\n                         ; txFee = 10\n                         ; mint = 0\n                         ; txVldt = nothing , nothing\n                         ; txCerts = []\n                         ; txWithdrawals = \u2205\n                         ; txGovVotes = []\n                         ; txGovProposals = []\n                         ; txDonation = 0\n                         ; txADhash = nothing\n                         ; txNetworkId = just 0\n                         ; currentTreasury = nothing\n                         ; txId = 7\n                         ; collateralInputs = \u2205\n                         ; reqSignerHashes = \u2205\n                         ; scriptIntegrityHash = nothing\n                         } ;\n                wits = record { vkSigs = \u2205 ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 helloWorld) \u2237 []) ;\n                                txdats = \u2205 ;\n                                txrdmrs = fromList\u1d50 (((Spend , 6) , \"Hello World!\" , (5 , 5)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n\nsucceedState : List (P2Script \u00d7 List Implementation.Data \u00d7 Implementation.ExUnits \u00d7 Implementation.CostModel)\nsucceedState = (collectP2ScriptsWithContext (UTxOEnv.pparams initEnv) succeedTx initState)\n\nevalSucceedScript : Bool\nevalSucceedScript = evalP2Scripts succeedState\n\nfailState : List (P2Script \u00d7 List Implementation.Data \u00d7 Implementation.ExUnits \u00d7 Implementation.CostModel)\nfailState = (collectP2ScriptsWithContext (UTxOEnv.pparams initEnv) failTx initState)\n\nevalFailScript : Bool\nevalFailScript = evalP2Scripts failState\n\nopaque\n  unfolding Computational-UTXO\n  unfolding collectP2ScriptsWithContext\n  unfolding setToList\n  unfolding outs\n\n  _ : notEmpty succeedState \u2261 \u22a4\n  _ = refl\n\n  -- need to check that the state is non-empty otherwise evalP2Scripts will always return true\n  _ : notEmpty succeedState \u2261 \u22a4\n  _ = refl\n\n  _ : evalSucceedScript \u2261 true\n  _ = refl\n\n  _ : notEmpty failState \u2261 \u22a4\n  _ = refl\n\n  _ : evalFailScript \u2261 false\n  _ = refl\n\n  -- Compute the result of running the UTXO rules on the succeedTx transaction\n  succeedExample : ComputationResult String UTxOState\n  succeedExample = UTXO-step initEnv $\\begin{pmatrix} \\,\\href{Test.Examples.HelloWorld.html#1536}{\\htmlId{6094}{\\htmlClass{Function}{\\text{initState}}}}\\, \\\\ \\,\\htmlId{6106}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{6110}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{6114}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$  succeedTx\n\n  _ : isSuccess succeedExample \u2261 true\n  _  = refl\n\n  -- Compute the result of running the UTXO rules on the failTx transaction\n  failExample : ComputationResult String UTxOState\n  failExample = UTXO-step initEnv $\\begin{pmatrix} \\,\\href{Test.Examples.HelloWorld.html#1536}{\\htmlId{6344}{\\htmlClass{Function}{\\text{initState}}}}\\, \\\\ \\,\\htmlId{6356}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{6360}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{6364}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$  failTx\n\n  _ : isFailure failExample\n  _ = _ , refl\n</pre>"},{"location":"Test.Examples.MultiSig.Datum.html","title":"Datum","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\n\nmodule Test.Examples.MultiSig.Datum where\n\nopen import Tactic.Derive.DecEq\n\ndata Label : Set where\n  Holding : Label\n  Collecting : \u2115 -&gt; \u2115 -&gt; \u2115 -&gt; List \u2115 -&gt; Label\ninstance\n  unquoteDecl DecEq-Label = derive-DecEq\n    ((quote Label , DecEq-Label) \u2237 [])\n\ndata Input : Set where\n  -- Propose: Ada amount, Target Wallet, Slot Deadline\n  Propose : \u2115 -&gt; \u2115 -&gt; \u2115 -&gt; Input\n  --  Add: Wallet signature to add\n  Add     : \u2115 -&gt; Input\n  Pay     : Input\n  Cancel  : Input\ninstance\n  unquoteDecl DecEq-Input = derive-DecEq\n    ((quote Input , DecEq-Input) \u2237 [])\n\nMultiSigData = Label \u228e Input\n</pre>"},{"location":"Test.Examples.MultiSig.OffChain.AddSig.html","title":"AddSig","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSig.OffChain.AddSig where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.MultiSig.Datum\nopen import Test.Examples.MultiSig.Validator\nopen import Test.Examples.MultiSig.OffChain.Lib\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n-- TODO: Invesitgate what is going on with vkSigs vs reqSigHash in terms of\n-- transaction not failing vkSigs\n-- txinfo only gets reqSigHash\n\nmakeAddSigTxOut : Label \u2192 (scriptIx w : \u2115) \u2192 TxOut \u2192 List (\u2115 \u00d7 TxOut)\nmakeAddSigTxOut Holding ix w txo = []\nmakeAddSigTxOut (Collecting vl pkh d sigs) ix w (fst , fst\u2081 , snd) =\n  (ix , (fst , fst\u2081 ,  just (inj\u2081 (inj\u2081 (inj\u2081 (Collecting vl pkh d (w \u2237 sigs))))) , nothing)) \u2237 []\n\nmakeAddSigTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 Maybe Tx\nmakeAddSigTx id state script@(sh , _) w =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeTxOut wutxo ++ makeAddSigTxOut label (proj\u2082 scIn) w scOut )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 []) \n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addValue}} (getTxId wutxo) w)) \u2237 []) ;\n                                -- signature now is first number + txId \u2261 second number\n                                -- first number is needs to be the id for the script\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; -- fromList\u1d50 ((inj\u2081 (inj\u2081 Holding) , inj\u2081 (inj\u2081 Holding)) \u2237 []) ;\n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 (Add w)) , \n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n\n</pre>"},{"location":"Test.Examples.MultiSig.OffChain.Lib.html","title":"Lib","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSig.OffChain.Lib where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Test.Examples.MultiSig.Datum\nopen import Test.Examples.MultiSig.Validator\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\nopen import Data.List using (filter)\nopen import Relation.Nullary\n\ndefaultTxBody : TxBody\ndefaultTxBody = record\n                  { txIns = \u2205\n                  ; refInputs = \u2205\n                  ; collateralInputs = \u2205\n                  ; txOuts =  \u2205\n                  ; txFee = 10000000000\n                  ; mint = 0\n                  ; txVldt = nothing , nothing\n                  ; txCerts = []\n                  ; txWithdrawals = \u2205\n                  ; txGovVotes = []\n                  ; txGovProposals = []\n                  ; txDonation = 0\n                  ; txADhash = nothing\n                  ; txNetworkId = just 0\n                  ; currentTreasury = nothing\n                  ; txId = 0\n                  ; reqSignerHashes = \u2205\n                  ; scriptIntegrityHash = nothing\n                  }\n\nmatchScriptAddress : (scriptHash : \u2115) \u2192 Credential \u2192 Set\nmatchScriptAddress sh (KeyHashObj x) = \u22a5\nmatchScriptAddress sh (ScriptObj y) = True (sh \u225f y)\n\nmatchScriptAddress? : (sh : \u2115) \u2192 (c : Credential) \u2192 Dec (matchScriptAddress sh c)\nmatchScriptAddress? sh (KeyHashObj x) = no (\u03bb x\u2081 \u2192 x\u2081)\nmatchScriptAddress? sh (ScriptObj y) = T? \u230a (sh \u225f y) \u230b\n\ngetScriptUTxO : (scriptHash : \u2115) \u2192 UTxO \u2192 Maybe (TxIn \u00d7 TxOut)\ngetScriptUTxO sh (utxo , prf) = head $ filter (\u03bb { (_ , addr , _) \u2192 matchScriptAddress? sh (payCred addr)}) (setToList utxo)\n\nmatchWalletHash : (keyHash : \u2115) \u2192 Credential \u2192 Set\nmatchWalletHash kh (KeyHashObj x) = True (kh \u225f x)\nmatchWalletHash kh (ScriptObj y) = \u22a5\n\nmatchWalletHash? : (sh : \u2115) \u2192 (c : Credential) \u2192 Dec (matchWalletHash sh c)\nmatchWalletHash? kh (KeyHashObj x) = T? \u230a (kh \u225f x) \u230b\nmatchWalletHash? kh (ScriptObj y) = no (\u03bb x\u2081 \u2192 x\u2081)\n\ngetWalletUTxO : (scriptHash : \u2115) \u2192 UTxO \u2192 List (TxIn \u00d7 TxOut)\ngetWalletUTxO sh (utxo , prf) = filter (\u03bb { (_ , addr , _) \u2192 matchWalletHash? sh (payCred addr)}) (setToList utxo)\n\nsucceedTxOut' : TxOut\nsucceedTxOut' = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 777 ;\n                           stake = just (ScriptObj 777) })\n                           , 700000000000 , just (inj\u2081 (inj\u2081 (inj\u2081 Holding))) , nothing\n\ngetLabel : TxOut \u2192 Maybe Label\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2081 (inj\u2081 x))) , snd) = just x\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2081 (inj\u2082 y))) , snd) = nothing\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2082 y)) , snd) = nothing\ngetLabel (fst , fst\u2081 , just (inj\u2082 y) , snd) = nothing\ngetLabel (fst , fst\u2081 , nothing , snd) = nothing\n\n-- Assumes a list of filtered waller txins and subtracts a default fee from the head of the list\nmakeFeeTxOut : List (TxIn \u00d7 TxOut) \u2192 List (\u2115 \u00d7 TxOut)\nmakeFeeTxOut [] = []\nmakeFeeTxOut ((txin , (fst , txValue , snd)) \u2237 utxos) = (proj\u2082 txin , fst , txValue - 10000000000 , snd) \u2237 []\n\n-- return id of 0 if no txins\ngetTxId : List (TxIn \u00d7 TxOut) \u2192 \u2115\ngetTxId xs = maybe (\u03bb x \u2192 proj\u2081 (proj\u2081 x)) 0 (head xs)\n\n</pre>"},{"location":"Test.Examples.MultiSig.OffChain.OffChain.html","title":"OffChain","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSig.OffChain.OffChain where\n\nopen import Test.Examples.MultiSig.OffChain.Pay public\nopen import Test.Examples.MultiSig.OffChain.Propose public\nopen import Test.Examples.MultiSig.OffChain.Open public\nopen import Test.Examples.MultiSig.OffChain.AddSig public\n</pre>"},{"location":"Test.Examples.MultiSig.OffChain.Open.html","title":"Open","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSig.OffChain.Open where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.MultiSig.Datum\nopen import Test.Examples.MultiSig.Validator\nopen import Test.Examples.MultiSig.OffChain.Lib\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.Lib valContext\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nopenTxOut : Value \u2192 PlutusScript \u2192 TxOut\nopenTxOut v script = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj (proj\u2081 script) ;\n                           stake = just (ScriptObj (proj\u2081 script)) })\n                           , v\n                           , just (inj\u2081 (inj\u2081 (inj\u2081 Holding))) , nothing\n\n-- txid, wallet, value at script, script index\nopenTx : (id w v tw : \u2115) \u2192 PlutusScript \u2192 Tx\nopenTx id w v tw script = record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((w , w) \u2237 [])\n                         ; txOuts = fromListIx ((tw , openTxOut v script)\n                                               \u2237 (w\n                                                 , ((inj\u2081 (record { net = 0 ;\n                                                                    pay = KeyHashObj w ;\n                                                                    stake = just (KeyHashObj w) }))\n                                               -- , 10000000000 , nothing , nothing))\n                                               , ((1000000000000 - 10000000000) - v) , nothing , nothing))\n                                               \u2237 [])\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList ((w , w) \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addValue}} w id)) \u2237 []) ;\n                                -- signature now is first number + txId \u2261 second number\n                                -- first number is needs to be the id for the script\n                                scripts = \u2205 ; -- Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; -- fromList\u1d50 ((inj\u2081 (inj\u2081 Holding) , (inj\u2081 (inj\u2081 Holding))) \u2237 []) ;\n                                txrdmrs = \u2205 } ;\n                                {-\n                                  ; --  fromList\u1d50 (((Propose , (proj\u2081 script)) ,\n                                                 --                inj\u2081 (inj\u2082 Pay) ,\n                                                    --            (5 , w)) \u2237 []) } ; -}\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n</pre>"},{"location":"Test.Examples.MultiSig.OffChain.Pay.html","title":"Pay","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSig.OffChain.Pay where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.MultiSig.Datum\nopen import Test.Examples.MultiSig.Validator\nopen import Test.Examples.MultiSig.OffChain.Lib\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\npayScriptTxOut : TxOut \u2192 (value : \u2115) \u2192 TxOut\npayScriptTxOut (fst , txValue , snd) v = fst , txValue - v , just (inj\u2081 (inj\u2081 (inj\u2081 Holding))) , nothing\n\n-- TODO: Throw error here\n-- -- (Ix \u00d7 TxOut)\nmakePayTxOut : Label \u2192 (scriptIx : \u2115) \u2192 TxOut \u2192 List (\u2115 \u00d7 TxOut)\nmakePayTxOut Holding ix txo = []\nmakePayTxOut (Collecting vl pkh x\u2082 x\u2083) ix txo =\n            (ix , payScriptTxOut txo vl)\n            \u2237\n             (777 , ((inj\u2081 (record { net = 0 ; pay = KeyHashObj pkh ; stake = just (KeyHashObj pkh) })) ,\n              (vl , nothing , nothing))) \u2237 []\n\nmakePayTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 Maybe Tx\nmakePayTx id state script@(sh , _) w =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n            record { body = record defaultTxBody\n                                  { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                                  ; txOuts = fromListIx (makeFeeTxOut wutxo  ++ makePayTxOut label (proj\u2082 scIn) scOut)\n                                  ; txId = id\n                                  ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                                  } ;\n                          wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addValue}} (getTxId wutxo) w)) \u2237 []) ;\n                                          -- signature now is first number + txId \u2261 second number\n                                          -- first number is needs to be the id for the script\n                                          scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                          txdats = \u2205 ; -- fromList\u1d50 ((inj\u2081 (inj\u2081 Holding) , inj\u2081 (inj\u2081 Holding)) \u2237 []) ;\n                                          txrdmrs = fromList\u1d50 (((Spend , proj\u2082 scIn) ,\n                                                                inj\u2081 (inj\u2082 Pay) ,\n                                                                ((getTxId wutxo) , w)) \u2237 []) } ;\n                          txsize = 10 ;\n                          isValid = true ;\n                          txAD = nothing }\n                          ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n</pre>"},{"location":"Test.Examples.MultiSig.OffChain.Propose.html","title":"Propose","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSig.OffChain.Propose where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.MultiSig.Datum\nopen import Test.Examples.MultiSig.Validator\nopen import Test.Examples.MultiSig.OffChain.Lib\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n-- TODO: Add error handling\nmakeProposeTxOut : Label \u2192 (scriptIx : \u2115) \u2192 TxOut \u2192 (v tw d : \u2115) \u2192 List (\u2115 \u00d7 TxOut)\nmakeProposeTxOut Holding ix (fst , txValue , snd) v tw d = (ix , (fst , txValue , (just (inj\u2081 (inj\u2081 (inj\u2081 (Collecting v tw d []))))) , nothing)) \u2237 []\nmakeProposeTxOut _ _ _ _ _ _ = []\n\nmakeProposeTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w v tw d : \u2115) \u2192 Maybe Tx\nmakeProposeTx id state script@(sh , _) w v tw d =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeTxOut wutxo ++ makeProposeTxOut label (proj\u2082 scIn) scOut v tw d )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addValue}} (getTxId wutxo) w)) \u2237 []) ;\n                                -- signature now is first number + txId \u2261 second number\n                                -- first number is needs to be the id for the script\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; -- fromList\u1d50 ((inj\u2081 (inj\u2081 Holding) , inj\u2081 (inj\u2081 Holding)) \u2237 []) ;\n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 (Propose v -- amount\n                                                                          tw -- wallet pkh\n                                                                          d)) , -- End Slot\n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n</pre>"},{"location":"Test.Examples.MultiSig.Test.Trace.html","title":"Trace","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSig.Test.Trace where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Test.Examples.MultiSig.Datum\nopen import Test.Examples.MultiSig.OffChain.OffChain\nopen import Test.Examples.MultiSig.Validator\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxow.Properties.Computational SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nimpMultiSig : MultiSig\nimpMultiSig = record { signatories = 3 \u2237 2 \u2237 5 \u2237 [] ; minNumSignatures = 2 }\n\nmultiSigScript : PlutusScript\nmultiSigScript = 777 , applyScriptWithContext (multiSigValidator impMultiSig)\n\ninitEnv : UTxOEnv\ninitEnv = createEnv 0\n\ninitTxOut : TxOut\ninitTxOut = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 777 ;\n                           stake = just (ScriptObj 777) })\n                           , 800000000000 , just (inj\u2082 (inj\u2081 (inj\u2081 Holding))) , nothing\n\nscript : TxIn \u00d7 TxOut\nscript = (6 , 6) , initTxOut\n\ninitState : UTxO\ninitState = fromList' (script \u2237 (createInitUtxoState 5 1000000000000))\n\ninitState' : UTxO\ninitState' = fromList' (createInitUtxoState 5 1000000000000)\n\n-- Hack to have partial Transactions\ndata Tx' : Set where\n    openContract : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 Tx'\n    addSig       : \u2115 \u2192 \u2115 \u2192 Tx'\n    pay          : \u2115 \u2192 \u2115 \u2192 Tx'\n    propose      : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 Tx'\n\nmakeTx : UTxOState \u2192 PlutusScript \u2192 Tx' \u2192 Maybe Tx\nmakeTx s script (openContract id w v tw) = just (openTx id w v tw script)\nmakeTx s script (addSig id w) = makeAddSigTx id s script w\nmakeTx s script (pay id w) = makePayTx id s script w\nmakeTx s script (propose id w v tw d) = makeProposeTx id s script w v tw d\n\nevalTransanctions : UTxOEnv \u2192 ComputationResult String UTxOState \u2192 List Tx' \u2192 ComputationResult String UTxOState\nevalTransanctions env s [] = s\nevalTransanctions env state@(failure s) (x \u2237 xs) = state\nevalTransanctions env (success s) (tx' \u2237 txs') =\n  maybe\n    (\u03bb tx \u2192 evalTransanctions\n              initEnv\n              (UTXO-step initEnv s tx)\n              txs')\n    (failure \"failed to generate tx\")\n    (makeTx s multiSigScript tx')\n\nevalTransanctionsW : UTxOEnv \u2192 ComputationResult String UTxOState \u2192 List Tx' \u2192 ComputationResult String UTxOState\nevalTransanctionsW env s [] = s\nevalTransanctionsW env state@(failure s) (x \u2237 xs) = state\nevalTransanctionsW env (success s) (tx' \u2237 txs') =\n  maybe\n    (\u03bb tx \u2192 evalTransanctions\n              initEnv\n              (UTXO-step initEnv s tx)\n              txs')\n    (failure \"failed to generate tx\")\n    (makeTx s multiSigScript tx')\n\n-- Add Sig trace\naddSigTrace : List Tx'\naddSigTrace = openContract 6 5 800000000000 6\n              \u2237 propose 7 5 100000000000 2 4\n              \u2237 addSig 8 5\n              \u2237 addSig 9 2\n              \u2237 pay 10 2 \n              \u2237 []\n\nfailingTrace : List Tx'\nfailingTrace =\n   openContract 6 2 800000000000 5\n   \u2237 propose 7 1 500000000000 5 13\n   \u2237 addSig 8 2\n   \u2237 addSig 9 3\n   \u2237 pay 10 4\n   \u2237 propose 11 2 300000000001 5 13\n   \u2237 []\n\nutxowTrace : List Tx'\nutxowTrace = openContract 6 5 800000000000 6\n             \u2237 propose 7 5 100000000000 2 3\n             \u2237 addSig 8 5\n             \u2237 addSig 9 2\n             \u2237 pay 10 5\n             \u2237 []\n\nopaque\n  unfolding collectP2ScriptsWithContext\n  unfolding setToList\n  unfolding Computational-UTXO\n  unfolding outs\n\n  t0 : ComputationResult String UTxOState\n  t0 = evalTransanctions initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.MultiSig.Test.Trace.html#1762}{\\htmlId{4101}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{4114}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{4118}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{4122}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) addSigTrace\n\n  _ : isSuccess t0 \u2261 true\n  _ = refl\n\n  t1 : ComputationResult String UTxOState\n  t1 = evalTransanctions initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.MultiSig.Test.Trace.html#1762}{\\htmlId{4265}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{4278}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{4282}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{4286}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) failingTrace\n\n  _ : isSuccess t1 \u2261 false\n  _ = refl \n\n  t2 : ComputationResult String UTxOState\n  t2 = evalTransanctionsW initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.MultiSig.Test.Trace.html#1762}{\\htmlId{4433}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{4446}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{4450}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{4454}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) utxowTrace\n\n  _ : isSuccess t2 \u2261 true\n  _ = refl\n</pre>"},{"location":"Test.Examples.MultiSig.Validator.html","title":"Validator","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSig.Validator where\n\nopen import Ledger.Prelude\n\nopen import Test.Examples.MultiSig.Datum\nopen import Test.Prelude MultiSigData\nopen import Ledger.Conway.Specification.Transaction\nopen import Test.SymbolicData MultiSigData\n\nopen import Data.List using (filter)\nopen import Data.Maybe renaming (map to maybeMap)\nopen import Relation.Binary using (REL; Decidable)\n\nPubKeyHash : Type\nPubKeyHash = \u2115\n\nrecord MultiSig : Set where\n  field\n    signatories : List PubKeyHash\n    minNumSignatures : \u2115\n\n--TODO: Implement show properly\ninstance\n  ShowMultiSigData : Show MultiSigData\n  ShowMultiSigData = mkShow (\u03bb x \u2192 \"\")\n\nopen import Test.LedgerImplementation SData SData\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n-- Make this get all output datums\ngetInlineOutputDatum : STxOut \u2192 List MultiSigData \u2192 Maybe Datum\ngetInlineOutputDatum (a , b , just (inj\u2081 (inj\u2081 x))) dats = just (inj\u2081 (inj\u2081 x))\ngetInlineOutputDatum (a , b , just (inj\u2081 (inj\u2082 y))) dats = nothing\ngetInlineOutputDatum (a , b , just (inj\u2082 y)) dats = nothing\ngetInlineOutputDatum (a , b , nothing) dats = nothing\n\nnewLabel : ScriptContext -&gt; Maybe Label\nnewLabel (record { realizedInputs = realizedInputs ; txouts = txouts ; fee = fee ; mint = mint ; txwdrls = txwdrls ; txvldt = txvldt ; vkey = vkey ; txdats = txdats ; txid = txid } , snd) with\n  mapMaybe (\u03bb x \u2192 getInlineOutputDatum x txdats) (map proj\u2082 txouts)\n... | [] = nothing\n... | inj\u2081 (inj\u2081 x) \u2237 [] = just x\n... | _ = nothing\n\n-- TODO: Look into this\ngetPaymentCredential : STxOut \u2192 \u2115\ngetPaymentCredential (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake } , snd) = x\ngetPaymentCredential (inj\u2081 record { net = net ; pay = (ScriptObj x) ; stake = stake } , snd) = x\ngetPaymentCredential (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize } , snd) = x\ngetPaymentCredential (inj\u2082 record { net = net ; pay = (ScriptObj x) ; attrsSize = attrsSize } , snd) = x\n\n-- TODO: look into Ledger.address version of getscripthash\ngetScriptCredential' : \u2115 \u2192 SUTxO \u2192 Maybe \u2115\ngetScriptCredential' ix [] = nothing\ngetScriptCredential' ix (((txid' , ix') , txout) \u2237 utxos) with ix \u225f ix'\n... | no \u00aca = getScriptCredential' ix utxos\n... | yes a = just (getPaymentCredential txout)\n\n--TODO: Handle cases other than spend\ngetScriptCredential : ScriptContext \u2192 Maybe \u2115\ngetScriptCredential (fst , Rwrd x) = nothing\ngetScriptCredential (fst , Mint x) = nothing\ngetScriptCredential (txinfo , Spend (txid , ix)) = getScriptCredential' ix (STxInfo.realizedInputs txinfo)\ngetScriptCredential (fst , Empty) = nothing\n\nbalanceSTxOut : List STxOut \u2192 Value\nbalanceSTxOut txout = foldr (_+_ {{addValue}}) 0 (map (\u03bb {(_ , v , _) \u2192 v}) txout)\n\nmatchIx : \u2115 \u2192 SAddr \u2192 Set\nmatchIx n (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake }) = n \u2261 x\nmatchIx n (inj\u2081 record { net = net ; pay = (ScriptObj y) ; stake = stake }) = n \u2261 y\nmatchIx n (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize }) = n \u2261 x\nmatchIx n (inj\u2082 record { net = net ; pay = (ScriptObj y) ; attrsSize = attrsSize }) = n \u2261 y\n\nmatchIx? : (n : \u2115) \u2192 (a : SAddr) \u2192 Dec (matchIx n a)\nmatchIx? n (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake }) = n \u225f x\nmatchIx? n (inj\u2081 record { net = net ; pay = (ScriptObj y) ; stake = stake }) = n \u225f y\nmatchIx? n (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize }) = n \u225f x\nmatchIx? n (inj\u2082 record { net = net ; pay = (ScriptObj y) ; attrsSize = attrsSize }) = n \u225f y\n\ntotalOuts : ScriptContext \u2192 PubKeyHash \u2192 Value\ntotalOuts (txinfo , _) ph  = balanceSTxOut (filter (\u03bb { (fst , snd) \u2192 matchIx? ph fst}) (map proj\u2082 (STxInfo.txouts txinfo)))\n\ntotalIns : ScriptContext \u2192 PubKeyHash \u2192 Value\ntotalIns (txinfo , _) ph  = balanceSTxOut (filter (\u03bb { (fst , snd) \u2192 matchIx? ph fst}) (map proj\u2082 (STxInfo.realizedInputs txinfo)))\n\n-- Get the value of txouts for own script\nnewValue : ScriptContext \u2192 Maybe Value\nnewValue sc@(txinfo , sp) with getScriptCredential sc\n... | nothing = nothing\n... | just sh = just (totalOuts sc sh)\n\noldValue : ScriptContext \u2192 Maybe Value\noldValue sc@(txinfo , sp) with getScriptCredential sc\n... | nothing = nothing\n... | just sh = just (totalIns sc sh)\n\ncompareScriptValues : {\u2113 : Level}{r : REL \u2115 \u2115 \u2113} \u2192 Decidable r \u2192 Maybe Value \u2192 Maybe Value \u2192 Bool\ncompareScriptValues r (just ov) (just nv) = \u230a r ov nv \u230b\ncompareScriptValues r _ _ = false\n\n\ncheckPayment : PubKeyHash -&gt; Value -&gt; ScriptContext -&gt; Bool\ncheckPayment pkh v (txinfo , _) = any (\u03bb { (fst , val , snd) \u2192 v == val}) ((filter (\u03bb { (fst , snd) \u2192 matchIx? pkh fst}) (map proj\u2082 (STxInfo.txouts txinfo))))\n\n\nopen import Relation.Nullary.Decidable\n\n-- I think the signatories should just contain the signature\n-- The agda implementation has  sig == signature ctx\ncheckSigned : PubKeyHash \u2192 ScriptContext \u2192 Bool\ncheckSigned ph (txinfo , _) = \u230a (ph \u2208? (STxInfo.vkey txinfo)) \u230b\n\nquery : PubKeyHash \u2192 List PubKeyHash \u2192 Bool\nquery ph xs = any (\u03bb k \u2192  \u230a ph \u225f k \u230b) xs\n\n--checkPayment : PubKeyHash -&gt; Value -&gt; ScriptContext -&gt; Bool\n--checkPayment pkh v ctx = \u230a totalOuts ctx pkh \u225f (_+_ {{addValue}} ((totalIns ctx pkh)) v) \u230b\n\n\n{-\nbalanceSTxOut : List STxOut \u2192 Value\nbalanceSTxOut txout = foldr (_+_ {{addValue}}) 0 (map (\u03bb {(_ , v , _) \u2192 v}) txout)\ntotalOuts : ScriptContext \u2192 PubKeyHash \u2192 Value\ntotalOuts (txinfo , _) ph  = balanceSTxOut (filter (\u03bb { (fst , snd) \u2192 matchIx? ph fst}) (map proj\u2082 (STxInfo.txouts txinfo)))\n\ncheckPayment :: PaymentPubKeyHash -&gt; Value -&gt; ScriptContext -&gt; Bool\ncheckPayment pkh v ctx = case filter\n  (\\i -&gt; (txOutAddress i == (pubKeyHashAddress (unPaymentPubKeyHash pkh))))\n  (txInfoOutputs (scriptContextTxInfo ctx)) of\n  os -&gt; any (\\o -&gt; txOutValue o == v) os\n-}\nexpired : \u2115 -&gt; ScriptContext -&gt; Bool\nexpired slot (txinfo , _) = maybe (\u03bb deadline \u2192  \u230a slot &gt;? deadline \u230b)\n                                     false\n                                     (proj\u2082 (STxInfo.txvldt txinfo))\n\nmultiSigValidator' : MultiSig \u2192 Label \u2192 Input \u2192 ScriptContext \u2192 Bool\n\nmultiSigValidator' param Holding (Propose v pkh slot) ctx =\n  (oldValue ctx == newValue ctx) \u2227\n  compareScriptValues _\u225f_ (oldValue ctx) (newValue ctx)\n  \u2227 compareScriptValues _\u2265?_ (oldValue ctx) (just v)\n  \u2227 \u230a v \u2265? 0 \u230b\n  \u2227 (case (newLabel ctx) of \u03bb where\n      nothing \u2192 false\n      (just Holding) \u2192 false\n      (just (Collecting v' pkh' slot' sigs')) \u2192\n                                      (v == v')\n                                      \u2227 (pkh == pkh')\n                                      \u2227 (slot == slot')\n                                      \u2227 (sigs' == []) )\n\nmultiSigValidator' param Holding _ ctx = false\n\nmultiSigValidator' param (Collecting _ _ _ _) (Propose _ _ _) ctx = false\n\nmultiSigValidator' param (Collecting v pkh slot sigs) (Add sig) ctx = \n compareScriptValues _\u225f_ (oldValue ctx) (newValue ctx) -- should this be equal or _\u2264_\n  \u2227 checkSigned sig ctx\n  \u2227 query sig (MultiSig.signatories param)\n  \u2227 (case (newLabel ctx) of \u03bb where\n      nothing \u2192 false\n      (just Holding) \u2192 false\n      (just (Collecting v' pkh' slot' sigs')) \u2192\n        (v == v')\n        \u2227 (pkh == pkh')\n        \u2227 (slot == slot')\n        \u2227 (sigs' == sig \u2237 sigs)) -- Make this an order agnostic comparison?\n\nmultiSigValidator' param (Collecting v pkh slot sigs) Pay ctx =\n \u230a (length sigs) \u2265? MultiSig.minNumSignatures param \u230b\n   \u2227 (case (newLabel ctx) of \u03bb where\n      nothing \u2192 false\n      (just Holding) \u2192 checkPayment pkh v ctx\n                       \u2227 compareScriptValues _\u225f_ (oldValue ctx) (maybeMap (_+_ {{addValue}} v) (newValue ctx))\n\n      (just (Collecting _ _ _ _)) \u2192 false) \n\nmultiSigValidator' param (Collecting v pkh slot sigs) Cancel ctx =\n  compareScriptValues _\u225f_ (oldValue ctx) (newValue ctx)\n  \u2227 (case (newLabel ctx) of \u03bb where\n      nothing \u2192 false\n      (just Holding) \u2192 expired slot ctx\n      (just (Collecting _ _ _ _)) \u2192 false)\n\n\nmultiSigValidator : MultiSig \u2192 Maybe SData \u2192 Maybe SData \u2192 List SData \u2192 Bool\nmultiSigValidator m (just (inj\u2081 (inj\u2081 x))) (just (inj\u2081 (inj\u2082 y))) (inj\u2082 y\u2081 \u2237 []) =\n  multiSigValidator' m x y y\u2081\nmultiSigValidator _ _ _ _ = false\n\n\n</pre>"},{"location":"Test.Examples.MultiSigV2.Datum.html","title":"Datum","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\n\nmodule Test.Examples.MultiSigV2.Datum where\n\nopen import Tactic.Derive.DecEq\n\ndata Label : Set where\n  Holding : Label\n  Collecting : \u2115 -&gt; \u2115 -&gt; \u2115 -&gt; List \u2115 -&gt; Label\ninstance\n  unquoteDecl DecEq-Label = derive-DecEq\n    ((quote Label , DecEq-Label) \u2237 [])\n\ndata Input : Set where\n  Propose : \u2115 -&gt; \u2115 -&gt; \u2115 -&gt; Input\n  Add     : \u2115 -&gt; Input\n  Pay     : Input\n  Cancel  : Input\n  Cleanup : Input\ninstance\n  unquoteDecl DecEq-Input = derive-DecEq\n    ((quote Input , DecEq-Input) \u2237 [])\n\nMultiSigData = Label \u228e Input\n</pre>"},{"location":"Test.Examples.MultiSigV2.OffChain.AddSig.html","title":"AddSig","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSigV2.OffChain.AddSig where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.MultiSigV2.Datum\nopen import Test.Examples.MultiSigV2.OffChain.Lib\nopen import Test.Examples.MultiSigV2.Validator\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n\nmakeAddSigTxOut : Label \u2192 (scriptIx w : \u2115) \u2192 TxOut \u2192 List (\u2115 \u00d7 TxOut)\nmakeAddSigTxOut Holding ix w txo = []\nmakeAddSigTxOut (Collecting vl pkh d sigs) ix w (fst , fst\u2081 , snd) =\n  (ix , (fst , fst\u2081 ,  just (inj\u2081 (inj\u2081 (inj\u2081 (Collecting vl pkh d (insert' w sigs))))) , nothing)) \u2237 []\n\nmakeAddSigTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 Maybe Tx\nmakeAddSigTx id state script@(sh , _) w =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeTxOut wutxo ++ makeAddSigTxOut label (proj\u2082 scIn) w scOut )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 []) \n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addValue}} (getTxId wutxo) w)) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; \n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 (Add w)) , \n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n\n</pre>"},{"location":"Test.Examples.MultiSigV2.OffChain.Cancel.html","title":"Cancel","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSigV2.OffChain.Cancel where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.MultiSigV2.Datum\nopen import Test.Examples.MultiSigV2.OffChain.Lib\nopen import Test.Examples.MultiSigV2.Validator\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nmakeCancelTxOut : Label \u2192 (scriptIx w : \u2115) \u2192 TxOut \u2192 List (\u2115 \u00d7 TxOut)\nmakeCancelTxOut Holding ix w txo = []\nmakeCancelTxOut (Collecting vl pkh d sigs) ix w (fst , fst\u2081 , snd) =\n  (ix , (fst , fst\u2081 ,  just (inj\u2081 (inj\u2081 (inj\u2081 Holding))) , nothing)) \u2237 []\n\nmakeCancelTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 Maybe Tx\nmakeCancelTx id state script@(sh , _) w =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeTxOut wutxo ++ makeCancelTxOut label (proj\u2082 scIn) w scOut )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 []) \n                         ; txVldt = just 0 , just 11\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addValue}} (getTxId wutxo) w)) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; \n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 Cancel) , \n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n\n</pre>"},{"location":"Test.Examples.MultiSigV2.OffChain.Cleanup.html","title":"Cleanup","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSigV2.OffChain.Cleanup where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.MultiSigV2.Datum\nopen import Test.Examples.MultiSigV2.OffChain.Lib\nopen import Test.Examples.MultiSigV2.Validator\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nmakeCleanupTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 Maybe Tx\nmakeCleanupTx id state script@(sh , _) w = \n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , (fst , txValue , snd)) \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeUnPaymentTxOut wutxo txValue)\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; reqSignerHashes = Ledger.Prelude.fromList (w \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addNat}} (getTxId wutxo) w) ) \u2237 []) ; \n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ;\n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 Cleanup) , \n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                )\n            })\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n\n</pre>"},{"location":"Test.Examples.MultiSigV2.OffChain.Lib.html","title":"Lib","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSigV2.OffChain.Lib where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\n\nopen import Test.Examples.MultiSigV2.Datum\nopen import Test.Examples.MultiSigV2.Validator\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nopen import Data.List using (filter)\n\ndefaultTxBody : TxBody\ndefaultTxBody = record\n                  { txIns = \u2205\n                  ; refInputs = \u2205\n                  ; collateralInputs = \u2205\n                  ; txOuts =  \u2205\n                  ; txFee = 10000000000\n                  ; mint = 0\n                  ; txVldt = nothing , nothing\n                  ; txCerts = []\n                  ; txWithdrawals = \u2205\n                  ; txGovVotes = []\n                  ; txGovProposals = []\n                  ; txDonation = 0\n                  ; txADhash = nothing\n                  ; txNetworkId = just 0\n                  ; currentTreasury = nothing\n                  ; txId = 0\n                  ; reqSignerHashes = \u2205\n                  ; scriptIntegrityHash = nothing\n                  }\n\nmatchScriptAddress : (scriptHash : \u2115) \u2192 Credential \u2192 Set\nmatchScriptAddress sh (KeyHashObj x) = \u22a5\nmatchScriptAddress sh (ScriptObj y) = True (sh \u225f y)\n\nmatchScriptAddress? : (sh : \u2115) \u2192 (c : Credential) \u2192 Dec (matchScriptAddress sh c)\nmatchScriptAddress? sh (KeyHashObj x) = no (\u03bb x\u2081 \u2192 x\u2081)\nmatchScriptAddress? sh (ScriptObj y) = T? \u230a (sh \u225f y) \u230b\n\ngetScriptUTxO : (scriptHash : \u2115) \u2192 UTxO \u2192 Maybe (TxIn \u00d7 TxOut)\ngetScriptUTxO sh (utxo , prf) = head $ filter (\u03bb { (_ , addr , _) \u2192 matchScriptAddress? sh (payCred addr)}) (setToList utxo)\n\nmatchWalletHash : (keyHash : \u2115) \u2192 Credential \u2192 Set\nmatchWalletHash kh (KeyHashObj x) = True (kh \u225f x)\nmatchWalletHash kh (ScriptObj y) = \u22a5\n\nmatchWalletHash? : (sh : \u2115) \u2192 (c : Credential) \u2192 Dec (matchWalletHash sh c)\nmatchWalletHash? kh (KeyHashObj x) = T? \u230a (kh \u225f x) \u230b\nmatchWalletHash? kh (ScriptObj y) = no (\u03bb x\u2081 \u2192 x\u2081)\n\ngetWalletUTxO : (scriptHash : \u2115) \u2192 UTxO \u2192 List (TxIn \u00d7 TxOut)\ngetWalletUTxO sh (utxo , prf) = filter (\u03bb { (_ , addr , _) \u2192 matchWalletHash? sh (payCred addr)}) (setToList utxo)\n\nsucceedTxOut' : TxOut\nsucceedTxOut' = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 777 ;\n                           stake = just (ScriptObj 777) })\n                           , 700000000000 , just (inj\u2081 (inj\u2081 (inj\u2081 Holding))) , nothing\n\ngetLabel : TxOut \u2192 Maybe Label\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2081 (inj\u2081 x))) , snd) = just x\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2081 (inj\u2082 y))) , snd) = nothing\ngetLabel (fst , fst\u2081 , just (inj\u2081 (inj\u2082 y)) , snd) = nothing\ngetLabel (fst , fst\u2081 , just (inj\u2082 y) , snd) = nothing\ngetLabel (fst , fst\u2081 , nothing , snd) = nothing\n\n-- Assumes a list of filtered waller txins and subtracts a default fee from the head of the list\nmakeFeeTxOut : List (TxIn \u00d7 TxOut) \u2192 List (\u2115 \u00d7 TxOut)\nmakeFeeTxOut [] = []\nmakeFeeTxOut ((txin , (fst , txValue , snd)) \u2237 utxos) = (proj\u2082 txin , fst , txValue - 10000000000 , snd) \u2237 []\n\nmakeFeeUnPaymentTxOut : List (TxIn \u00d7 TxOut) \u2192 Value \u2192 List (\u2115 \u00d7 TxOut)\nmakeFeeUnPaymentTxOut [] v = []\nmakeFeeUnPaymentTxOut ((txin , (fst , txValue , snd)) \u2237 utxos) v = (proj\u2082 txin , fst , _+_ {{addValue}} (txValue - feeValue) v , snd) \u2237 []\n\nmakeFeePaymentTxOut : List (TxIn \u00d7 TxOut) \u2192 Value \u2192 List (\u2115 \u00d7 TxOut)\nmakeFeePaymentTxOut [] v = []\nmakeFeePaymentTxOut ((txin , (fst , txValue , snd)) \u2237 utxos) v = (proj\u2082 txin , fst , (txValue - feeValue ) - v , snd) \u2237 []\n\n-- return id of 0 if no txins\ngetTxId : List (TxIn \u00d7 TxOut) \u2192 \u2115\ngetTxId xs = maybe (\u03bb x \u2192 proj\u2081 (proj\u2081 x)) 0 (head xs)\n\n</pre>"},{"location":"Test.Examples.MultiSigV2.OffChain.OffChain.html","title":"OffChain","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSigV2.OffChain.OffChain where\n\nopen import Test.Examples.MultiSigV2.OffChain.Pay public\nopen import Test.Examples.MultiSigV2.OffChain.Propose public\nopen import Test.Examples.MultiSigV2.OffChain.Open public\nopen import Test.Examples.MultiSigV2.OffChain.AddSig public\nopen import Test.Examples.MultiSigV2.OffChain.Cancel public\nopen import Test.Examples.MultiSigV2.OffChain.Cleanup public\n</pre>"},{"location":"Test.Examples.MultiSigV2.OffChain.Open.html","title":"Open","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSigV2.OffChain.Open where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.MultiSigV2.Datum\nopen import Test.Examples.MultiSigV2.OffChain.Lib\nopen import Test.Examples.MultiSigV2.Validator\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\nopenTxOut : Value \u2192 PlutusScript \u2192 TxOut\nopenTxOut v script = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj (proj\u2081 script) ;\n                           stake = just (ScriptObj (proj\u2081 script)) })\n                           , v\n                           , just (inj\u2081 (inj\u2081 (inj\u2081 Holding))) , nothing\n\n-- txid, wallet, value at script, script index\nopenTx : (id w v tw : \u2115) \u2192 PlutusScript \u2192 Tx\nopenTx id w v tw script = record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((w , w) \u2237 [])\n                         ; txOuts = fromListIx ((tw , openTxOut v script)\n                                               \u2237 (w\n                                                 , ((inj\u2081 (record { net = 0 ;\n                                                                    pay = KeyHashObj w ;\n                                                                    stake = just (KeyHashObj w) }))\n                                               , ((1000000000000 - 10000000000) - v) , nothing , nothing))\n                                               \u2237 [])\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList ((w , w) \u2237 [])\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addValue}} w id)) \u2237 []) ;\n                                scripts = \u2205 ;\n                                txdats = \u2205 ;\n                                txrdmrs = \u2205 } ;\n\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n</pre>"},{"location":"Test.Examples.MultiSigV2.OffChain.Pay.html","title":"Pay","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSigV2.OffChain.Pay where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.MultiSigV2.Datum\nopen import Test.Examples.MultiSigV2.OffChain.Lib\nopen import Test.Examples.MultiSigV2.Validator\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n\npayScriptTxOut : TxOut \u2192 (value : \u2115) \u2192 TxOut\npayScriptTxOut (fst , txValue , snd) v = fst , txValue - v , just (inj\u2081 (inj\u2081 (inj\u2081 Holding))) , nothing\n\n\nmakePayTxOut : Label \u2192 (scriptIx : \u2115) \u2192 TxOut \u2192 List (\u2115 \u00d7 TxOut)\nmakePayTxOut Holding ix txo = []\nmakePayTxOut (Collecting vl pkh x\u2082 x\u2083) ix txo =\n            (ix , payScriptTxOut txo vl)\n            \u2237\n             (777 , ((inj\u2081 (record { net = 0 ; pay = KeyHashObj pkh ; stake = just (KeyHashObj pkh) })) ,\n              (vl , nothing , nothing))) \u2237 []\n\nmakePayTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w : \u2115) \u2192 Maybe Tx\nmakePayTx id state script@(sh , _) w =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n            record { body = record defaultTxBody\n                                  { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                                  ; txOuts = fromListIx (makeFeeTxOut wutxo  ++ makePayTxOut label (proj\u2082 scIn) scOut)\n                                  ; txId = id\n                                  ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                                  } ;\n                          wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addValue}} (getTxId wutxo) w)) \u2237 []) ;\n                                          scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                          txdats = \u2205 ; \n                                          txrdmrs = fromList\u1d50 (((Spend , proj\u2082 scIn) ,\n                                                                inj\u2081 (inj\u2082 Pay) ,\n                                                                ((getTxId wutxo) , w)) \u2237 []) } ;\n                          txsize = 10 ;\n                          isValid = true ;\n                          txAD = nothing }\n                          ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n</pre>"},{"location":"Test.Examples.MultiSigV2.OffChain.Propose.html","title":"Propose","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSigV2.OffChain.Propose where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.MultiSigV2.Datum\nopen import Test.Examples.MultiSigV2.OffChain.Lib\nopen import Test.Examples.MultiSigV2.Validator\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n\n-- TODO: Add error handling\nmakeProposeTxOut : Label \u2192 (scriptIx : \u2115) \u2192 TxOut \u2192 (v tw d : \u2115) \u2192 List (\u2115 \u00d7 TxOut)\nmakeProposeTxOut Holding ix (fst , txValue , snd) v tw d = (ix , (fst , txValue , (just (inj\u2081 (inj\u2081 (inj\u2081 (Collecting v tw d []))))) , nothing)) \u2237 []\nmakeProposeTxOut _ _ _ _ _ _ = []\n\nmakeProposeTx : (id : \u2115) \u2192 UTxOState \u2192 PlutusScript \u2192 (w v tw d : \u2115) \u2192 Maybe Tx\nmakeProposeTx id state script@(sh , _) w v tw d =\n  let\n    wutxo = getWalletUTxO w (UTxOState.utxo state)\n  in\n    maybe (\u03bb { (scIn , scOut) \u2192 maybe (\u03bb label \u2192\n    just (\n          record { body = record defaultTxBody\n                         { txIns = Ledger.Prelude.fromList ((scIn \u2237 []) ++ (map proj\u2081 wutxo))\n                         ; txOuts = fromListIx (makeFeeTxOut wutxo ++ makeProposeTxOut label (proj\u2082 scIn) scOut v tw d )\n                         ; txId = id\n                         ; collateralInputs = Ledger.Prelude.fromList (map proj\u2081 wutxo)\n                         ; txVldt = just 0 , just 10\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((w , (_+_ {{addValue}} (getTxId wutxo) w)) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 script) \u2237 []) ;\n                                txdats = \u2205 ; \n                                txrdmrs = fromList\u1d50 (((Spend , (proj\u2082 scIn)) ,\n                                                      inj\u2081 (inj\u2082 (Propose v \n                                                                          tw \n                                                                          d)) , \n                                                      ((getTxId wutxo) , w)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n                ))\n            nothing\n            (getLabel scOut)})\n          nothing\n          (getScriptUTxO sh (UTxOState.utxo state))\n</pre>"},{"location":"Test.Examples.MultiSigV2.Test.Trace.html","title":"Trace","text":"<pre>{-# OPTIONS --safe #-}\n\nmodule Test.Examples.MultiSigV2.Test.Trace where\n\nopen import Ledger.Prelude\nopen import Ledger.Conway.Specification.Transaction\n\nopen import Test.Examples.MultiSigV2.Datum\nopen import Test.Examples.MultiSigV2.OffChain.Lib\nopen import Test.Examples.MultiSigV2.Validator\nopen import Test.Prelude MultiSigData\nopen import Test.SymbolicData MultiSigData\nopen import Test.LedgerImplementation SData SData\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\n\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxow.Properties.Computational SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n\n\nopen import Test.Examples.MultiSigV2.OffChain.OffChain\n\nimpMultiSig : Params\nimpMultiSig = record { authSigs = 3 \u2237 2 \u2237 5 \u2237 [] ; minNumSignatures = 2 ; maxWait = 10 }\n\nmultiSigScript : PlutusScript\nmultiSigScript = 777 , applyScriptWithContext (multiSigValidator impMultiSig)\n\ninitEnv : UTxOEnv\ninitEnv = createEnv 0\n\ninitTxOut : TxOut\ninitTxOut = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 777 ;\n                           stake = just (ScriptObj 777) })\n                           , 800000000000 , just (inj\u2082 (inj\u2081 (inj\u2081 Holding))) , nothing\n\nscript : TxIn \u00d7 TxOut\nscript = (6 , 6) , initTxOut\n\ninitState : UTxO\ninitState = fromList' (script \u2237 (createInitUtxoState 5 1000000000000))\n\ninitState' : UTxO\ninitState' = fromList' (createInitUtxoState 5 1000000000000)\n\n-- Hack to have partial Transactions\ndata Tx' : Set where\n    openContract : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 Tx'\n    addSig       : \u2115 \u2192 \u2115 \u2192 Tx'\n    pay          : \u2115 \u2192 \u2115 \u2192 Tx'\n    propose      : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 Tx'\n    cancel       : \u2115 \u2192 \u2115 \u2192 Tx'\n    cleanup      : \u2115 \u2192 \u2115 \u2192 Tx'\n\nmakeTx : UTxOState \u2192 PlutusScript \u2192 Tx' \u2192 Maybe Tx\nmakeTx s script (openContract id w v tw) = just (openTx id w v tw script)\nmakeTx s script (addSig id w) = makeAddSigTx id s script w\nmakeTx s script (pay id w) = makePayTx id s script w\nmakeTx s script (propose id w v tw d) = makeProposeTx id s script w v tw d\nmakeTx s script (cancel id w) = makeCancelTx id s script w\nmakeTx s script (cleanup id w) = makeCleanupTx id s script w\n\nevalTransanctions : UTxOEnv \u2192 ComputationResult String UTxOState \u2192 List Tx' \u2192 ComputationResult String UTxOState\nevalTransanctions env s [] = s\nevalTransanctions env state@(failure s) (x \u2237 xs) = state\nevalTransanctions env (success s) (tx' \u2237 txs') =\n  maybe\n    (\u03bb tx \u2192 evalTransanctions\n              initEnv\n              (UTXO-step initEnv s tx)\n              txs')\n    (failure \"failed to generate tx\")\n    (makeTx s multiSigScript tx')\n\nevalTransanctionsW : UTxOEnv \u2192 ComputationResult String UTxOState \u2192 List Tx' \u2192 ComputationResult String UTxOState\nevalTransanctionsW env s [] = s\nevalTransanctionsW env state@(failure s) (x \u2237 xs) = state\nevalTransanctionsW env (success s) (tx' \u2237 txs') =\n  maybe\n    (\u03bb tx \u2192 evalTransanctions\n              initEnv\n              (UTXO-step initEnv s tx)\n              txs')\n    (failure \"failed to generate tx\")\n    (makeTx s multiSigScript tx')\n\n-- Add Sig trace\naddSigTrace : List Tx'\naddSigTrace = openContract 6 5 800000000000 6\n              \u2237 propose 7 5 100000000000 2 4\n              \u2237 addSig 8 5\n              \u2237 addSig 9 2\n              \u2237 pay 10 4 \n              \u2237 []\n\nfailingTrace : List Tx'\nfailingTrace =\n   openContract 6 2 800000000000 5\n   \u2237 propose 7 1 500000000000 5 13\n   \u2237 addSig 8 2\n   \u2237 addSig 9 3\n   \u2237 pay 10 4\n   \u2237 propose 11 2 300000000001 5 13\n   \u2237 []\n\nutxowTrace : List Tx'\nutxowTrace = openContract 6 5 800000000000 6\n             \u2237 propose 7 5 100000000000 2 3\n             \u2237 addSig 8 5\n             \u2237 addSig 9 2\n             \u2237 pay 10 5\n             \u2237 []\n\nutxowTrace2 : List Tx'\nutxowTrace2 = openContract 6 5 800000000000 6\n             \u2237 propose 7 5 100000000000 2 0\n             \u2237 addSig 8 5\n             \u2237 addSig 9 2           \n             \u2237 addSig 10 5\n             \u2237 addSig 11 2         \n             \u2237 addSig 12 5\n             \u2237 addSig 13 2           \n             \u2237 addSig 14 5\n             \u2237 addSig 15 2           \n             \u2237 cancel 16 1\n             \u2237 []\n\n\nutxowTrace3 : List Tx'\nutxowTrace3 = openContract 6 5 800000000000 6\n             \u2237 propose 7 5 799999999900 2 5\n             \u2237 addSig 8 5\n             \u2237 addSig 9 2    \n             \u2237 pay 10 5\n             \u2237 cleanup 11 1\n             \u2237 []\n\nopaque\n  unfolding collectP2ScriptsWithContext\n  unfolding setToList\n  unfolding Computational-UTXO\n  unfolding outs\n\n  t0 : ComputationResult String UTxOState\n  t0 = evalTransanctions initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.MultiSigV2.Test.Trace.html#1805}{\\htmlId{4995}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{5008}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{5012}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{5016}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) addSigTrace\n\n  _ : isSuccess t0 \u2261 true\n  _ = refl \n\n  t1 : ComputationResult String UTxOState\n  t1 = evalTransanctions initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.MultiSigV2.Test.Trace.html#1805}{\\htmlId{5160}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{5173}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{5177}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{5181}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) failingTrace\n\n  _ : isSuccess t1 \u2261 false\n  _ = refl \n\n  t2 : ComputationResult String UTxOState\n  t2 = evalTransanctionsW initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.MultiSigV2.Test.Trace.html#1805}{\\htmlId{5328}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{5341}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{5345}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{5349}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) utxowTrace\n\n  _ : isSuccess t2 \u2261 true\n  _ = refl\n\n  t3 : ComputationResult String UTxOState\n  t3 = evalTransanctionsW initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.MultiSigV2.Test.Trace.html#1805}{\\htmlId{5492}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{5505}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{5509}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{5513}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) utxowTrace2\n\n  _ : isSuccess t3 \u2261 true\n  _ = refl\n\n  t4 : ComputationResult String UTxOState\n  t4 = evalTransanctionsW initEnv (success $\\begin{pmatrix} \\,\\href{Test.Examples.MultiSigV2.Test.Trace.html#1805}{\\htmlId{5659}{\\htmlClass{Function}{\\text{initState'}}}}\\, \\\\ \\,\\htmlId{5672}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{5676}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{5680}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$) utxowTrace3\n\n  _ : isSuccess t4 \u2261 true\n  _ = refl\n\n\n</pre>"},{"location":"Test.Examples.MultiSigV2.Validator.html","title":"Validator","text":"<pre>{-# OPTIONS --safe #-}\n\n-- Version 2 of MultiSig contract adapted from updated Agda2hs code\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\nopen import Test.Examples.MultiSigV2.Datum\nopen import Relation.Binary using (REL; Decidable)\nopen import Level using (Level; _\u2294_; suc)\nopen import Data.Maybe renaming (map to maybeMap)\nopen import Data.List using (filter)\n\nopen import Data.Bool.Base renaming (_\u2227_ to _&amp;&amp;_) hiding (if_then_else_)\nimport Agda.Builtin.Nat as N\nopen import Test.Prelude MultiSigData\n\nmodule Test.Examples.MultiSigV2.Validator where\n\nPubKeyHash = \u2115\n\nrecord Params : Set where\n  field\n    authSigs         : List PubKeyHash\n    minNumSignatures : \u2115\n    maxWait          : \u2115\nopen Params\n\nopen import Test.SymbolicData MultiSigData\n\n\ninstance\n  ShowMultiSigData : Show MultiSigData\n  ShowMultiSigData = mkShow (\u03bb x \u2192 \"\")\n\nopen import Test.LedgerImplementation SData SData\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\nopen TransactionStructure SVTransactionStructure\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\nopen import Data.Empty\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Core.Specification.Epoch\nopen EpochStructure SVEpochStructure\nopen Implementation\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxow.Properties.Computational SVTransactionStructure SVAbstractFunctions\n\nemptyValue : Value\nemptyValue = 0\n\nfeeValue : Value\nfeeValue = 10000000000\n\nstartValue : Value\nstartValue = 1000000000000\n\nscriptValue : Value\nscriptValue = 30000000000\n\nminValue : Value\nminValue = 5000000\n\nadaValueOf : \u2115 -&gt; Value\nadaValueOf n = n \n\n\ngeq : Value -&gt; Value -&gt; Bool\ngeq v1 v2 =  \u230a v1 \u2265? v2 \u230b\n\ngt : Value -&gt; Value -&gt; Bool\ngt v1 v2 =  \u230a v1 &gt;? v2 \u230b\n\nsubVal : Value -&gt; Value -&gt; Value\nsubVal v1 v2 = v1 - v2\n\ninstance ValueSub : HasSubtract Value Value\n         ValueSub = record { _-_ = \u03bb x y \u2192 subVal x y } \n\n\ngetInlineOutputDatum : STxOut \u2192 List MultiSigData \u2192 Maybe Datum\ngetInlineOutputDatum (a , b , just (inj\u2081 (inj\u2081 x))) dats = just (inj\u2081 (inj\u2081 x))\ngetInlineOutputDatum (a , b , just (inj\u2081 (inj\u2082 y))) dats = nothing\ngetInlineOutputDatum (a , b , just (inj\u2082 y)) dats = nothing\ngetInlineOutputDatum (a , b , nothing) dats = nothing\n\nnewLabel : ScriptContext -&gt; Maybe Label\nnewLabel (record { realizedInputs = realizedInputs ; txouts = txouts ; fee = fee ; mint = mint ; txwdrls = txwdrls ; txvldt = txvldt ; vkey = vkey ; txdats = txdats ; txid = txid } , snd) with\n  mapMaybe (\u03bb x \u2192 getInlineOutputDatum x txdats) (map proj\u2082 txouts)\n... | [] = nothing\n... | inj\u2081 (inj\u2081 x) \u2237 [] = just x\n... | _ = nothing\n\ncontinuing : ScriptContext -&gt; Bool\ncontinuing (record { realizedInputs = realizedInputs ; txouts = txouts ; fee = fee ; mint = mint ; txwdrls = txwdrls ; txvldt = txvldt ; vkey = vkey ; txdats = txdats ; txid = txid } , snd) with\n  mapMaybe (\u03bb x \u2192 getInlineOutputDatum x txdats) (map proj\u2082 txouts)\n... | [] = false\n... | _ = true\n\n\ngetPaymentCredential : STxOut \u2192 \u2115\ngetPaymentCredential (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake } , snd) = x\ngetPaymentCredential (inj\u2081 record { net = net ; pay = (ScriptObj x) ; stake = stake } , snd) = x\ngetPaymentCredential (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize } , snd) = x\ngetPaymentCredential (inj\u2082 record { net = net ; pay = (ScriptObj x) ; attrsSize = attrsSize } , snd) = x\n\ngetScriptCredential' : \u2115 \u2192 SUTxO \u2192 Maybe \u2115\ngetScriptCredential' ix [] = nothing\ngetScriptCredential' ix (((txid' , ix') , txout) \u2237 utxos) with ix \u225f ix'\n... | no \u00aca = getScriptCredential' ix utxos\n... | yes a = just (getPaymentCredential txout)\n\ngetScriptCredential : ScriptContext \u2192 Maybe \u2115\ngetScriptCredential (fst , Rwrd x) = nothing\ngetScriptCredential (fst , Mint x) = nothing\ngetScriptCredential (txinfo , Spend (txid , ix)) = getScriptCredential' ix (STxInfo.realizedInputs txinfo)\ngetScriptCredential (fst , Empty) = nothing\n\nbalanceSTxOut : List STxOut \u2192 Value\nbalanceSTxOut txout = foldr (_+_ {{addValue}}) emptyValue (map (\u03bb {(_ , v , _) \u2192 v}) txout)\n\nmatchIx : \u2115 \u2192 SAddr \u2192 Set\nmatchIx n (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake }) = n \u2261 x\nmatchIx n (inj\u2081 record { net = net ; pay = (ScriptObj y) ; stake = stake }) = n \u2261 y\nmatchIx n (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize }) = n \u2261 x\nmatchIx n (inj\u2082 record { net = net ; pay = (ScriptObj y) ; attrsSize = attrsSize }) = n \u2261 y\n\nmatchIx? : (n : \u2115) \u2192 (a : SAddr) \u2192 Dec (matchIx n a)\nmatchIx? n (inj\u2081 record { net = net ; pay = (KeyHashObj x) ; stake = stake }) = n \u225f x\nmatchIx? n (inj\u2081 record { net = net ; pay = (ScriptObj y) ; stake = stake }) = n \u225f y\nmatchIx? n (inj\u2082 record { net = net ; pay = (KeyHashObj x) ; attrsSize = attrsSize }) = n \u225f x\nmatchIx? n (inj\u2082 record { net = net ; pay = (ScriptObj y) ; attrsSize = attrsSize }) = n \u225f y\n\n\ntotalOuts : ScriptContext \u2192 PubKeyHash \u2192 Value\ntotalOuts (txinfo , _) ph  = balanceSTxOut (filter (\u03bb { (fst , snd) \u2192 matchIx? ph fst}) (map proj\u2082 (STxInfo.txouts txinfo)))\n\ntotalIns : ScriptContext \u2192 PubKeyHash \u2192 Value\ntotalIns (txinfo , _) ph  = balanceSTxOut (filter (\u03bb { (fst , snd) \u2192 matchIx? ph fst}) (map proj\u2082 (STxInfo.realizedInputs txinfo)))\n\n\nnewValue : ScriptContext \u2192 Maybe Value\nnewValue sc@(txinfo , sp) with getScriptCredential sc\n... | nothing = nothing\n... | just sh = just (totalOuts sc sh)\n\noldValue : ScriptContext \u2192 Maybe Value\noldValue sc@(txinfo , sp) with getScriptCredential sc\n... | nothing = nothing\n... | just sh = just (totalIns sc sh)\n\ninsert' : PubKeyHash -&gt; List PubKeyHash -&gt; List PubKeyHash\ninsert' pkh [] = (pkh \u2237 [])\ninsert' pkh (x \u2237 l') = if (pkh == x)\n  then (x \u2237 l')\n  else (x \u2237 (insert' pkh l'))\n\nopen import Relation.Nullary.Decidable\n\ncheckSigned : PubKeyHash \u2192 ScriptContext \u2192 Bool\ncheckSigned ph (txinfo , _) = \u230a (ph \u2208? (STxInfo.vkey txinfo)) \u230b\n\nquery : PubKeyHash \u2192 List PubKeyHash \u2192 Bool\nquery ph xs = any (\u03bb k \u2192  \u230a ph \u225f k \u230b) xs\n\ncheckPayment : PubKeyHash -&gt; Value -&gt; ScriptContext -&gt; Bool\ncheckPayment pkh v ctx = if checkSigned pkh ctx\n                            then \u230a totalOuts ctx pkh \u225f ((_+_ {{addValue}} (totalIns ctx pkh) v) - feeValue) \u230b\n                            else \u230a totalOuts ctx pkh \u225f (_+_ {{addValue}} (totalIns ctx pkh) v) \u230b\n\n\nexpired : \u2115 -&gt; ScriptContext -&gt; Bool\nexpired deadline (txinfo , _) = maybe (\u03bb slot \u2192 \u230a slot \u2265? deadline \u230b)\n                                     false\n                                     (proj\u2081 (STxInfo.txvldt txinfo))\n\n\nnotTooLate : Params -&gt; \u2115 -&gt; ScriptContext -&gt; Bool\nnotTooLate par deadline (txinfo , _) = maybe (\u03bb now \u2192  \u230a (_+_ {{addNat}} now (maxWait par))  &gt;? deadline \u230b)\n                                     false\n                                     (proj\u2082 (STxInfo.txvldt txinfo))\n\n\n\nagdaValidator : Params -&gt; Label -&gt; Input -&gt; ScriptContext -&gt; Bool\nagdaValidator param lab red ctx = case (lab , red) of \u03bb where\n    (Holding , (Propose v pkh d)) -&gt;  \n      (newValue ctx == oldValue ctx) &amp;&amp; geq (fromMaybe 0 (oldValue ctx)) v &amp;&amp;\n      geq v minValue &amp;&amp; notTooLate param d ctx &amp;&amp; continuing ctx &amp;&amp;\n      (case (newLabel ctx) of \u03bb where\n        (just (Collecting v' pkh' d' sigs')) -&gt; (v == v') &amp;&amp; (pkh == pkh') &amp;&amp; (d == d') &amp;&amp; (sigs' == [])\n        _ -&gt; false )\n    ((Collecting v pkh d sigs) , (Add sig)) -&gt;\n      (newValue ctx == oldValue ctx) &amp;&amp; checkSigned sig ctx &amp;&amp; query sig (authSigs param) &amp;&amp;\n      continuing ctx &amp;&amp; (case (newLabel ctx) of \u03bb where\n        (just (Collecting v' pkh' d' sigs')) -&gt; (v == v') &amp;&amp; (pkh == pkh') &amp;&amp; (d == d') &amp;&amp; (sigs' == insert' sig sigs)\n        _ -&gt; false)\n    ((Collecting v pkh d sigs) , Pay) -&gt;\n      geq (length sigs) (minNumSignatures param) &amp;&amp; continuing ctx &amp;&amp; (case (newLabel ctx) of \u03bb where\n        (just Holding) -&gt; (checkPayment pkh v ctx) &amp;&amp; (oldValue ctx == (maybeMap (_+_ {{addValue}} v) (newValue ctx)))\n        _ -&gt; false)\n    ((Collecting v pkh d sigs) , Cancel) -&gt;\n      (newValue ctx == oldValue ctx) &amp;&amp; continuing ctx &amp;&amp;\n      (case (newLabel ctx) of \u03bb where\n        (just Holding) -&gt; expired d ctx \n        _ -&gt; false) \n    (Holding , Cleanup) -&gt; gt minValue (fromMaybe 0 (oldValue ctx)) &amp;&amp; not (continuing ctx)\n    _ -&gt; false \n\n\nmultiSigValidator : Params \u2192 Maybe SData \u2192 Maybe SData \u2192 List SData \u2192 Bool\nmultiSigValidator m (just (inj\u2081 (inj\u2081 x))) (just (inj\u2081 (inj\u2082 y))) (inj\u2082 y\u2081 \u2237 []) =\n  agdaValidator m x y y\u2081\nmultiSigValidator _ _ _ _ = false\n\n\n</pre>"},{"location":"Test.Examples.SucceedIfNumber.html","title":"SucceedIfNumber","text":"<pre>{-# OPTIONS --safe #-}\nmodule Test.Examples.SucceedIfNumber where\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\n\nopen import Test.LedgerImplementation \u2115 \u2115\nopen import Ledger.Conway.Specification.Script.ScriptPurpose SVTransactionStructure\n\nopen import Ledger.Conway.Specification.Transaction\nopen TransactionStructure SVTransactionStructure using (Data)\n\nvalContext : TxInfo \u2192 ScriptPurpose \u2192 Data\nvalContext x x\u2081 = 0\n\nopen import Test.AbstractImplementation valContext\nopen import Test.Lib valContext\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure SVAbstractFunctions\n\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure SVAbstractFunctions\nopen import Ledger.Conway.Specification.Utxo.Properties.Computational SVTransactionStructure SVAbstractFunctions\n\nopen TransactionStructure SVTransactionStructure\nopen Implementation\n</pre> <p>\u2192</p> <pre>-- succeed if the datum is 1\nsucceedIf1Datum' : Maybe \u2115 \u2192 Maybe \u2115 \u2192 Bool\nsucceedIf1Datum' (just (suc zero)) _ = true\nsucceedIf1Datum' _ _ = false\n\nsucceedIf1Datum : PlutusScript\nsucceedIf1Datum = 777 , applyScript succeedIf1Datum'\n\n--succeed if the redeemer is 1\nsucceedIf1Redeemer' : Maybe \u2115 \u2192 Maybe \u2115 \u2192 Bool\nsucceedIf1Redeemer' _ (just (suc zero)) = true\nsucceedIf1Redeemer' _ _ = false\n\nsucceedIf1Redeemer : PlutusScript\nsucceedIf1Redeemer = 888 , applyScript succeedIf1Redeemer'\n\ninitEnv : UTxOEnv\ninitEnv = createEnv 0\n\n-- initTxOut for script with datum reference\ninitTxOut : TxOut\ninitTxOut = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 777 ;\n                           stake = just (ScriptObj 777) })\n                           , 10 , just (inj\u2082 1) , nothing\n\n-- initTxOut for script without datum reference\ninitTxOut' : TxOut\ninitTxOut' = inj\u2081 (record { net = 0 ;\n                           pay = ScriptObj 888 ;\n                           stake = just (ScriptObj 888) })\n                           , 10 , nothing , nothing\n\nscriptDatum : TxIn \u00d7 TxOut\nscriptDatum = (6 , 6) , initTxOut\n\nscriptRedeemer : TxIn \u00d7 TxOut\nscriptRedeemer = (6 , 6) , initTxOut'\n\ninitStateDatum : UTxO\ninitStateDatum = fromList' (scriptDatum \u2237 (createInitUtxoState 5 1000000000000))\n\ninitStateRedeemer : UTxO\ninitStateRedeemer = fromList' (scriptRedeemer \u2237 (createInitUtxoState 5 1000000000000))\n\nsucceedTx : Tx\nsucceedTx = record { body = record\n                         { txIns = Ledger.Prelude.fromList ((6 , 6) \u2237 (5 , 5) \u2237 [])\n                         ; refInputs = \u2205\n                         ; txOuts = fromListIx ((6 , initTxOut)\n                                                \u2237 (5\n                                                  , ((inj\u2081 (record { net = 0 ;\n                                                                     pay = KeyHashObj 5 ;\n                                                                     stake = just (KeyHashObj 5) }))\n                                                  , (1000000000000 - 10000000000) , nothing , nothing))\n                                                \u2237 [])\n                         ; txFee = 10000000000\n                         ; mint = 0\n                         ; txVldt = nothing , nothing\n                         ; txCerts = []\n                         ; txWithdrawals = \u2205\n                         ; txGovVotes = []\n                         ; txGovProposals = []\n                         ; txDonation = 0\n                         ; txADhash = nothing\n                         ; txNetworkId = just 0\n                         ; currentTreasury = nothing\n                         ; txId = 7\n                         ; collateralInputs = Ledger.Prelude.fromList ((5 , 5) \u2237 [])\n                         ; reqSignerHashes = \u2205\n                         ; scriptIntegrityHash = nothing\n                         } ;\n                wits = record { vkSigs = fromList\u1d50 ((5 , 12) \u2237 []) ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 succeedIf1Datum) \u2237 []) ;\n                                txdats = Ledger.Prelude.fromList (1 \u2237 []) ;\n                                txrdmrs = fromList\u1d50 (((Spend , 6) , 5 , (5 , 5)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n\nevalScriptDatum : Bool\nevalScriptDatum = evalP2Scripts (collectP2ScriptsWithContext (UTxOEnv.pparams initEnv) succeedTx initStateDatum)\n\nexampleDatum : Maybe Datum\nexampleDatum = getDatum succeedTx initStateDatum (Spend (6 , 6))\n\nfailTx : Tx\nfailTx = record { body = record\n                         { txIns = Ledger.Prelude.fromList ((6 , 6) \u2237 [])\n                         ; refInputs = \u2205\n                         ; txOuts = \u2205\n                         ; txFee = 10\n                         ; mint = 0\n                         ; txVldt = nothing , nothing\n                         ; txCerts = []\n                         ; txWithdrawals = \u2205\n                         ; txGovVotes = []\n                         ; txGovProposals = []\n                         ; txDonation = 0\n                         ; txADhash = nothing\n                         ; txNetworkId = just 0\n                         ; currentTreasury = nothing\n                         ; txId = 7\n                         ; collateralInputs = \u2205\n                         ; reqSignerHashes = \u2205\n                         ; scriptIntegrityHash = nothing\n                         } ;\n                wits = record { vkSigs = \u2205 ;\n                                scripts = Ledger.Prelude.fromList ((inj\u2082 succeedIf1Redeemer) \u2237 []) ;\n                                txdats = \u2205 ;\n                                txrdmrs = fromList\u1d50 (((Spend , 6) , 1 , (5 , 5)) \u2237 []) } ;\n                txsize = 10 ;\n                isValid = true ;\n                txAD = nothing }\n\n\nevalScriptRedeemer : Bool\nevalScriptRedeemer = evalP2Scripts (collectP2ScriptsWithContext (UTxOEnv.pparams initEnv) failTx initStateRedeemer)\n\nexampleDatum' : Maybe Datum\nexampleDatum' = getDatum failTx initStateRedeemer (Spend (6 , 6))\n</pre> <pre>opaque\n  unfolding Computational-UTXO\n  unfolding collectP2ScriptsWithContext\n  unfolding setToList\n  unfolding outs\n\n  gotScript : lookupScriptHash 777 succeedTx initStateDatum \u2261 just (inj\u2082 succeedIf1Datum)\n  gotScript = refl\n\n  _ : exampleDatum \u2261 just 1\n  _ = refl\n\n  _ : exampleDatum' \u2261 nothing\n  _ = refl\n\n  _ : evalScriptDatum \u2261 true\n  _ = refl\n\n  _ : evalScriptRedeemer \u2261 true\n  _ = refl\n\n  -- Compute the result of running the UTXO rules on the succeedTx transaction\n  succeedExample : ComputationResult String UTxOState\n  succeedExample = UTXO-step initEnv $\\begin{pmatrix} \\,\\href{Test.Examples.SucceedIfNumber.html#2199}{\\htmlId{6659}{\\htmlClass{Function}{\\text{initStateDatum}}}}\\, \\\\ \\,\\htmlId{6676}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{6680}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{6684}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$  succeedTx\n\n  _ : isSuccess succeedExample \u2261 true\n  _  = refl\n\n  -- Compute the result of running the UTXO rules on the failTx transaction\n  failExample : ComputationResult String UTxOState\n  failExample = UTXO-step initEnv $\\begin{pmatrix} \\,\\href{Test.Examples.SucceedIfNumber.html#2303}{\\htmlId{6914}{\\htmlClass{Function}{\\text{initStateRedeemer}}}}\\, \\\\ \\,\\htmlId{6934}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{6938}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{6942}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$  failTx\n\n  _ : isFailure failExample\n  _ = _ , refl\n\n  -- Note that the UTXOS rule succeeds but the UTXO rule fails for failTx\n  failExampleS : Bool\n  failExampleS = case compute Computational-UTXOS initEnv $\\begin{pmatrix} \\,\\href{Test.Examples.SucceedIfNumber.html#2303}{\\htmlId{7155}{\\htmlClass{Function}{\\text{initStateRedeemer}}}}\\, \\\\ \\,\\htmlId{7175}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{7179}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{7183}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$ failTx of \u03bb where\n    (success x) \u2192 true\n    (failure x) \u2192 false\n\n  _ : failExampleS \u2261 true\n  _ = refl\n\n  failExampleU : Bool\n  failExampleU = case compute Computational-UTXO initEnv $\\begin{pmatrix} \\,\\href{Test.Examples.SucceedIfNumber.html#2303}{\\htmlId{7372}{\\htmlClass{Function}{\\text{initStateRedeemer}}}}\\, \\\\ \\,\\htmlId{7392}{\\htmlClass{Number}{\\text{0}}}\\, \\\\ \\,\\href{Class.HasEmptySet.html#287}{\\htmlId{7396}{\\htmlClass{Field}{\\text{\u2205}}}}\\, \\\\ \\,\\htmlId{7400}{\\htmlClass{Number}{\\text{0}}}\\, \\end{pmatrix}$ failTx of \u03bb where\n    (success x) \u2192 true\n    (failure x) \u2192 false\n\n  _ : failExampleU \u2261 false\n  _ = refl\n</pre>"},{"location":"Test.Examples.html","title":"Examples","text":"<p>The \"Examples\" module aims to add a couple of example smart contract validators written as part of the Cardano Formal Ledger Specification. These validator scripts are functions that examine a transaction and decide if the UTxO locked by their script can be spent as part of the current transaction.</p> <pre>{-# OPTIONS --safe #-}\nmodule Test.Examples where\n\nimport Test.Examples.SucceedIfNumber\nimport Test.Examples.HelloWorld\n</pre> <p>The first two examples, \"SucceedIfNumber\" and \"HelloWorld\" are very simple scripts that allow their UTxO to be spent if the input is a number or the string \"Hello World\", respectively. In each file are also defined example transactions that are expected to succeed or fail, respectively. These transactions are passed through the UTxO-step rule, which uses the formal ledger specification to simulate an actual transaction on the blockchain and tells us if said transaction succeeds or not. As part of the UTxO rule, we also run the scripts locking any consumed outputs, which in our case are the validator scripts.</p> <p>The other examples are more in-depth and are separated across multiple modules.</p> <pre>import Test.Examples.MultiSig.Datum\nimport Test.Examples.MultiSig.Validator\nimport Test.Examples.MultiSig.Test.Trace\n</pre> <p>The \"MultiSig\" example is based on the Multi-Signature wallet smart contract proposed in the seminal EUTxO paper by Chakravarty et. al. It aims to simulate a wallet that has a certain number of authorized signatories, of which a certain subset must sign before a payment can be approved. Payments can also be cancelled if a deadline passes before enough signatories can be gathered.</p> <p>All examples after and including this one use the same structure:</p> <p>A \"Datum\" file that defines the types of the Input and Redeemer for our validator script. The Datum stores most of the stateful information in our smart contract. In the case of MultiSig, that would include if a payment is trying to be made, who the payment is for, and who has already signed off on said payment. The Inputs, on the other hand, are the \"actions\" that the script is allowed to take. This would include proposing a payment, signing on a payment, cancelling the payment after the deadline is passed, etc.</p> <p>A \"Validator\" file where the actual script is defined, alongside any helper functions needed. Generally, the validator script is a combination of checks that depend on what the contract is trying to accomplish, such as making sure we only allow authorized wallets to sign, or executing payments only after enough signatories are gathered. The validators use Symbolic Data in order to avoid cyclical definitions. The Symbolic data is described in more detail in a separate module in this folder, but translates almost directly into the same data types used by the Formal Ledger Rules.</p> <p>An \"OffChain\" folder, which defines the \"endpoints\" used to interact with our account. Essentially, this defines a way to easily create a transaction where we are attempting to execute one of the actions our validator might allow. This includes various aspects, such as making sure the transaction is signed by the right person, that the correct fees are paid, that payments are sent to the correct recipients, that the smart contract self-perpetuates, etc.</p> <p>Finally, the \"Trace\" file in the \"Test\" folder contains some definitions that allow us to systematically apply multiple transactions in sequence, as well as a couple of example traces of such sequences being run. By making use of the previously defined \"OffChain\" endpoints, we can create transactions which can be similarly verified using the UTxO or UTxOw rules defined by the ledger specification. To do this for a sequence of transactions, we define an \"evalTransactions\" function which takes a list of transactions and applies them sequentially, letting us know if they all succeed or if there is an error along the way. Finally, we put together some example traces by defining lists of transactions that are expected to either succeed or fail, running our \"evalTransactions\" function on that list and checking that we get the expected result.</p> <p>We have a trace that puts the smart contract on the simulated ledger, proposes a payment, adds the two required signatures, and then executes a payment. This trace succeeds and is tested with both the UTxO and UTxOw rules. We also have a failing trace, where after the first payment, we try to propose another payment of a larger amount than is contained in the wallet, which naturally fails.</p> <pre>import Test.Examples.AccountSim.Datum\nimport Test.Examples.AccountSim.Validator\nimport Test.Examples.AccountSim.Test.Trace\n</pre> <p>The \"AccountSim\" contract attempts to simulate an account-based system on UTxO. It is a naive implementation which holds all accounts represented as a list of pairs linking a Public Key Hash to its associated Value.</p> <p>It is meant to have the generic abilities required of such a simulation: opening/closing an account, depositing/withdrawing value from/to your account, transferring value to some other account, and a cleanup function when there are no accounts left to remove the UTxO from the blockchain.</p> <p>The example traces attempt to test every individual endpoint at least once, as well as a simple failing trace where we try to withdraw more than an account has in it.</p> <pre>import Test.Examples.DEx.Datum\nimport Test.Examples.DEx.Validator\nimport Test.Examples.DEx.Test.Trace\n</pre> <p>The \"DEx\" contract is meant to implement a Limit Order Book Distributed Exchange. It is primarily designed for exchanging one currency for another at various rates, but the Token Algebra for native tokens is currently incomplete. As such, the example currently exchanges Ada for Ada. When multiple assets can be used, the code can be easily modified to fulfill its full purpose.</p> <pre>import Test.Examples.MultiSigV2.Datum\nimport Test.Examples.MultiSigV2.Validator\nimport Test.Examples.MultiSigV2.Test.Trace\n</pre> <p>The second implementation of \"MultiSig\" is, at its core, the same contract, but with some modifications made to aid the effort of proving properties of the validator. Many of these changes were primarily made in order to better integrate with the Thread Token mechanism necessary for certain properties of UTxO-based smart contracts. Due to similar problems to the distributed exchange, tokens are not currently fully functional, so for now, it can be viewed as an alternative implementation of the same specification.</p>"},{"location":"Test.LedgerImplementation.html","title":"LedgerImplementation","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\n\nmodule Test.LedgerImplementation\n  (T D : Set) {{DecEq-Data : DecEq D}} {{Show-Data : Show D}} where\n\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\nimport      Data.Integer as \u2124\nopen import Data.Rational using (0\u211a; \u00bd)\nimport      Data.Rational as \u211a\nopen import Algebra.Morphism    using (module MonoidMorphisms)\nopen import Data.Nat.Properties using (+-0-commutativeMonoid)\nopen import Relation.Binary.Morphism.Structures\nopen import Algebra.Construct.DirectProduct\nopen import Ledger.Core.Specification.Crypto\nopen import Ledger.Conway.Specification.Transaction\nopen import Ledger.Core.Specification.Epoch\nopen import Ledger.Conway.Specification.Gov.Base\n\nmodule _ {A : Set} \u2983 _ : DecEq A \u2984 \u2983 _ : Show A \u2984 where instance\n  \u2200Hashable : Hashable A A\n  \u2200Hashable = \u03bb where .hash \u2192 id\n\n  \u2200isHashableSet : isHashableSet A\n  \u2200isHashableSet = mkIsHashableSet A\n\ninstance\n  Hashable-\u22a4 : Hashable \u22a4 \u2115\n  Hashable-\u22a4 = \u03bb where .hash tt \u2192 0\n</pre> <pre>module Implementation where\n  Network          = \u2115\n  SlotsPerEpoch\u1d9c   = 100\n  ActiveSlotCoeff  = \u2124.1\u2124 \u211a./ 20  \n  StabilityWindow\u1d9c = 10\n  RandomnessStabilisationWindow\u1d9c = 2\n  MaxLovelaceSupply\u1d9c = 1000000000000000000\n  Quorum           = 1\n  NetworkId        = 0\n\n  SKey = \u2115\n  VKey = \u2115\n  Sig  = \u2115\n  Ser  = \u2115\n\n  isKeyPair  = _\u2261_\n  sign       = _+_\n\n  Data         = D\n  Data\u02b0        = mkHashableSet D\n\n  PlutusScript = \u2115 \u00d7 (List Data \u2192 Bool)\n  ScriptHash = \u2115\n\n  ExUnits      = \u2115 \u00d7 \u2115\n  ExUnit-CommutativeMonoid =\n    Conversion.fromBundle (commutativeMonoid +-0-commutativeMonoid +-0-commutativeMonoid)\n  _\u2265\u1d49_ : ExUnits \u2192 ExUnits \u2192 Type\n  _\u2265\u1d49_ = _\u2261_\n  instance\n    Show-ExUnits : Show ExUnits\n    Show-ExUnits = Show-\u00d7\n\n  CostModel    = \u22a4 -- changed from \u22a5\n  Language     = \u22a4\n  LangDepView  = \u22a4\n  Prices       = \u22a4\n\n  TxId            = \u2115\n  Ix              = \u2115\n  AuxiliaryData   = \u2115\n  DocHash         = \u2115\n  tokenAlgebra    = Coin-TokenAlgebra\n    where open import Ledger.Conway.Specification.TokenAlgebra.Coin ScriptHash\n            using (Coin-TokenAlgebra)\n\nSVGlobalConstants = GlobalConstants \u220b record {Implementation}\nSVEpochStructure  = EpochStructure  \u220b \u2115EpochStructure SVGlobalConstants\ninstance _ = SVEpochStructure\n\nSVCrypto : CryptoStructure\nSVCrypto = record\n  { Implementation\n  ; pkk = SVPKKScheme\n  }\n  where\n  -- Dummy private key crypto scheme\n  SVPKKScheme : PKKScheme\n  SVPKKScheme = record\n    { Implementation\n    ; isSigned         = \u03bb a b m \u2192 a + b \u2261 m\n    ; sign             = _+_\n    ; isSigned-correct = \u03bb where (sk , sk , refl) _ _ h \u2192 h\n    }\n</pre> <pre>instance _ = SVCrypto\n\nopen import Ledger.Conway.Specification.Script it it\nopen import Ledger.Conway.Conformance.Script it it public using (P1ScriptStructure-HTL)\n</pre> <pre>SVScriptStructure : ScriptStructure\nSVScriptStructure = record\n  { p1s = P1ScriptStructure-HTL\n  ; hashRespectsUnion = hashRespectsUnion\n  ; ps = SVP2ScriptStructure\n  }\n  where\n\n    instance Hashable-PlutusScript : Hashable Implementation.PlutusScript \u2115\n             Hashable-PlutusScript = record { hash = \u03bb x \u2192 proj\u2081 x }\n\n    hashRespectsUnion : \u2200 {A B \u210d}\n      \u2192 Hashable A \u210d \u2192 Hashable B \u210d\n      \u2192 Hashable (A \u228e B) \u210d\n    hashRespectsUnion ha hb = record { hash = \u03bb { (inj\u2081 x) \u2192 Hashable.hash ha x ; (inj\u2082 y) \u2192 Hashable.hash hb y }}\n\n    SVP2ScriptStructure : PlutusStructure\n    SVP2ScriptStructure =  record\n      { Implementation\n      ; validPlutusScript = \u03bb _ _ _ _ \u2192 \u22a4\n      }\n</pre> <pre>instance _ = SVScriptStructure\n\nopen import Ledger.Conway.Specification.PParams it it it hiding (PParams)\n</pre> <pre>SVGovParams : GovParams\nSVGovParams = record\n  { Implementation\n  ; ppUpd = let open PParamsDiff in \u03bb where\n      .UpdateT                \u2192 \u22a4\n      .updateGroups           \u2192 \u03bb _ \u2192 \u2205\n      .applyUpdate            \u2192 \u03bb p _ \u2192 p\n      .ppWF?                  \u2192 \u2047 yes \u03bb _ \u2192 id\n  }\n\nSVGovStructure : GovStructure\nSVGovStructure = record\n  { Implementation\n  ; epochStructure  = SVEpochStructure\n  ; govParams       = SVGovParams\n  ; cryptoStructure = SVCrypto\n  ; globalConstants = SVGlobalConstants\n  }\ninstance _ = SVGovStructure\n\nopen import Ledger.Conway.Specification.Gov.Actions it hiding (Vote; GovRole; VDeleg; Anchor)\nopen import Ledger.Conway.Conformance.Certs it hiding (StakePoolParams; DCert)\n\nSVTransactionStructure : TransactionStructure\nSVTransactionStructure = record\n  { Implementation\n  ; epochStructure  = SVEpochStructure\n  ; globalConstants = SVGlobalConstants\n  ; adHashingScheme = it\n  ; cryptoStructure = SVCrypto\n  ; govParams       = SVGovParams\n  ; txidBytes       = id\n  ; scriptStructure = SVScriptStructure\n  }\n</pre> <pre>instance _ = SVTransactionStructure\n\nopen import Ledger.Conway.Specification.Abstract it\nopen import Ledger.Conway.Conformance.Gov it\n\nopen TransactionStructure it\n</pre> <pre>indexOfTxInImp : TxIn \u2192 \u2119 TxIn \u2192 Maybe Ix\nindexOfTxInImp x y = lookup\u1d50? (fromList\u1d50 (setToList y)) (proj\u2081 x)\n</pre>"},{"location":"Test.Lib.html","title":"Lib","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude hiding (fromList; \u03b5; _/_)\nopen import Test.LedgerImplementation using (SVTransactionStructure)\nimport Ledger.Conway.Specification.Script.ScriptPurpose as SP\n\nmodule Test.Lib\n  {T D : Set}{{DecEq-Data : DecEq D}}{{Show-Data : Show D}}\n  (open SP (SVTransactionStructure T D) using (TxInfo; ScriptPurpose))\n  (valContext' : TxInfo \u2192 ScriptPurpose \u2192 D)\n  where\n\nopen import Test.AbstractImplementation valContext'\nopen import Test.LedgerImplementation T D\n  renaming (SVTransactionStructure to SVTransactionStructure')\nopen import Ledger.Conway.Specification.Utxo SVTransactionStructure' SVAbstractFunctions\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\nopen TransactionStructure SVTransactionStructure'\nopen import Ledger.Prelude.Numeric using (mkUnitInterval; mk\u2115\u207a)\nopen import Data.Integer using (\u2124; +_)\nopen import Data.Rational using (\u00bd; 1\u211a ; mk\u211a+ ; _/_)\nopen import Data.Nat.Coprimality using (Coprime; gcd\u22611\u21d2coprime)\n\ncreateEnv : \u2115 \u2192 UTxOEnv\ncreateEnv s = record { slot = s ; treasury = 0 ;\n                   pparams = record\n                               { maxBlockSize = 90112\n                               ; maxTxSize = 16384\n                               ; maxHeaderSize = 1100\n                               ; maxValSize = 5000\n                               ; maxCollateralInputs = 3\n                               ; pv = 8 , 0\n                               ; maxTxExUnits = 10000000000 , 14000000\n                               ; maxBlockExUnits = 40000000000 , 62000000\n                               ; a = 44\n                               ; b = 155381\n                               ; minUTxOValue = 0\n                               ; poolDeposit = 500000000 -- lovelace\n                               ; keyDeposit = 500000000 -- lovelace\n                               ; monetaryExpansion = mkUnitInterval (+ 3 / 1000)\n                               ; treasuryCut = mkUnitInterval (+ 2 / 10)\n                               ; coinsPerUTxOByte = 0  --lovelace\n                               -- ^^^ was 4310, but that value resulted in failed tests once\n                               -- we replaced `minUTxOValue` with `coinsPerUTxOByte`; see `HelloWorld.agda`\n                               -- line 153: `isSuccess succeedExample \u2261 true`\n                               ; minFeeRefScriptCoinsPerByte = mk\u211a+ 15 1 (gcd\u22611\u21d2coprime refl) -- see [1]\n                               ; prices = tt -- fix this\n                               ; maxRefScriptSizePerTx = 200 * 1024 -- 200KiB\n                               ; maxRefScriptSizePerBlock = 1024 * 1024 -- 1MiB\n                               ; refScriptCostStride  = mk\u2115\u207a 25\n                               ; refScriptCostMultiplier = mk\u211a+ 6 5 (gcd\u22611\u21d2coprime refl) -- see [1]\n                               ; a0 = 1\u211a -- don't know\n                               ; Emax = 18\n                               ; nopt = 0 -- don't know\n                               ; collateralPercentage = 150\n                               ; costmdls = tt -- fix this\n                               ; drepThresholds = record -- unknown so setting all to 50%\n                                                    { P1 = \u00bd\n                                                    ; P2a = \u00bd\n                                                    ; P2b = \u00bd\n                                                    ; P3 = \u00bd\n                                                    ; P4 = \u00bd\n                                                    ; P5a = \u00bd\n                                                    ; P5b = \u00bd\n                                                    ; P5c = \u00bd\n                                                    ; P5d = \u00bd\n                                                    ; P6 = \u00bd\n                                                    }\n                               ; poolThresholds = record\n                                                    { Q1 = \u00bd\n                                                    ; Q2a = \u00bd\n                                                    ; Q2b = \u00bd\n                                                    ; Q4 = \u00bd\n                                                    ; Q5 = \u00bd\n                                                    }\n                               ; govActionLifetime = 10 -- unknown\n                               ; govActionDeposit = 1000000 -- unknown (set to 1 ada)\n                               ; drepDeposit = 1000000 -- unknown (set to 1 ada)\n                               ; drepActivity = 13 -- unknown\n                               ; ccMinSize = 10 -- unknown\n                               ; ccMaxTermLength = 73 -- unknown set to 1 year (73 epochs)\n                               } }\n\ncreateUTxO : (index : \u2115)\n           \u2192 (wallet : \u2115)\n           \u2192 (value : Value)\n           \u2192 Maybe (D \u228e DataHash)\n           \u2192 TxIn \u00d7 TxOut\ncreateUTxO index wallet value d = (index , index)\n                                , (inj\u2081 (record { net = 0 ; pay = KeyHashObj wallet ; stake = just (KeyHashObj wallet) })\n                                  , value , d , nothing)\n\ncreateInitUtxoState : (wallets : \u2115)\n                    \u2192 (value : Value)\n                    \u2192 List (TxIn \u00d7 TxOut)\ncreateInitUtxoState zero value = []\ncreateInitUtxoState (suc wallet) value = createUTxO (suc wallet) (suc wallet) value nothing\n                                         \u2237 createInitUtxoState wallet value\n\nfromList' : List (TxIn \u00d7 TxOut) \u2192 UTxO\nfromList' = fromList\u1d50\n\nfromListIx : List (Implementation.Ix \u00d7 TxOut) \u2192 Implementation.Ix \u21c0 TxOut\nfromListIx = fromList\u1d50\n\napplyScript : (Maybe D \u2192 Maybe D \u2192 Bool) \u2192 List D \u2192 Bool\napplyScript f [] = f nothing nothing\napplyScript f (_ \u2237 []) = f nothing nothing\napplyScript f (redeemer \u2237 valcontext \u2237 []) = f nothing (just redeemer)\napplyScript f (datum \u2237 redeemer \u2237 valcontext \u2237 _) = f (just datum) (just redeemer)\n\nnotEmpty : \u2200 {A : Type} \u2192 List A \u2192 Type\nnotEmpty [] = \u22a5\nnotEmpty (x \u2237 xs) = \u22a4\n\nisSuccess : ComputationResult String UTxOState \u2192 Bool\nisSuccess (success x) = true\nisSuccess (failure x) = false\n\napplyScriptWithContext : (Maybe D \u2192 Maybe D \u2192 List D \u2192 Bool) \u2192 List D \u2192 Bool\napplyScriptWithContext f [] = f nothing nothing []\napplyScriptWithContext f (_ \u2237 []) = f nothing nothing []\napplyScriptWithContext f (redeemer \u2237 valcontext \u2237 []) = f nothing (just redeemer) []\napplyScriptWithContext f (datum \u2237 redeemer \u2237 valcontext \u2237 vs) = f (just datum) (just redeemer) (valcontext \u2237 vs)\n\n-- [1] https://github.com/IntersectMBO/cardano-ledger/blob/master/docs/adr/2024-08-14_009-refscripts-fee-change.md\n</pre>"},{"location":"Test.Prelude.html","title":"Prelude","text":"<pre>{-# OPTIONS --safe #-}\nopen import Ledger.Prelude hiding (fromList; \u03b5); open Computational\n\nmodule Test.Prelude (D : Set) {{DecEq-Data : DecEq D}} where\n\nopen import Tactic.Derive.DecEq\nopen import Data.Vec \n\n-- Only implementing Rwd, Mint and Spend\n-- TODO: Implement Cert, Propose and Vote\n-- All maps become lists of pairs to ensure decidable equality\n</pre> <pre>SDatum = D\nSValue = \u2115 -- \u00d7 Vec \u2115 3\nSTxId = \u2115\nSIx = \u2115\nSTxIn  = STxId \u00d7 SIx\nSNetwork = \u2115\nSSlot = \u2115\nSKeyHash = \u2115\n\n-- SCredential = \u2115 \u228e \u2115\ndata SCredential : Type where\n  KeyHashObj : \u2115 \u2192 SCredential\n  ScriptObj  : \u2115 \u2192 SCredential\ninstance\n  unquoteDecl DecEq-SCredential = derive-DecEq\n    ((quote SCredential , DecEq-SCredential) \u2237 [])\n\nrecord SBaseAddr : Set where\n  field net    : SNetwork\n        pay    : SCredential\n        stake  : Maybe SCredential\ninstance\n  unquoteDecl DecEq-SBaseAddr = derive-DecEq\n    ((quote SBaseAddr , DecEq-SBaseAddr) \u2237 [])\n\nrecord SBootstrapAddr : Set where\n  field net        : SNetwork\n        pay        : SCredential\n        attrsSize  : \u2115\ninstance\n  unquoteDecl DecEq-SBootstrapAddr = derive-DecEq\n    ((quote SBootstrapAddr , DecEq-SBootstrapAddr) \u2237 [])\n\nSAddr = SBaseAddr \u228e SBootstrapAddr\n\n-- ScriptHash\nSTxOut = SAddr \u00d7 SValue \u00d7 Maybe (D \u228e D) -- Assumes hash is identity for datums, dropping Maybe Script for now\nSUTxO  = List (STxIn \u00d7 STxOut)\n\nrecord SRwdAddr : Set where\n  field net    : SNetwork\n        stake  : SCredential\ninstance\n  unquoteDecl DecEq-SRwdAddr = derive-DecEq\n    ((quote SRwdAddr , DecEq-SRwdAddr) \u2237 [])\n\ndata SScriptPurpose : Set where\n  -- network is tt so we can ignore it here\n  Rwrd     : SRwdAddr \u2192 SScriptPurpose\n  Mint     : SValue \u2192 SScriptPurpose\n  Spend    : STxIn \u2192 SScriptPurpose\n  Empty    : SScriptPurpose\ninstance\n  unquoteDecl DecEq-SScriptPurpose = derive-DecEq\n    ((quote SScriptPurpose , DecEq-SScriptPurpose) \u2237 [])\n\n\nrecord STxInfo : Set where\n  field realizedInputs : SUTxO\n        txouts         : List (SIx \u00d7 STxOut)\n        fee            : SValue\n        mint           : SValue\n        -- not adding txcerts as rarely used\n        txwdrls        : List (SRwdAddr  \u00d7 Coin)\n        txvldt         : Maybe SSlot \u00d7 Maybe SSlot\n        vkey           : \u2119 SKeyHash\n        txdats         : List D -- Hash is id for datums therfore List D can replicate: DataHash \u21c0 Datum\n        txid           : STxId\n</pre> <pre>instance\n  unquoteDecl DecEq-STxInfo = derive-DecEq\n    ((quote STxInfo , DecEq-STxInfo) \u2237 [])\n\n-- open import ScriptVerification.LedgerImplementation SScriptPurpose SScriptPurpose\n</pre>"},{"location":"Test.SymbolicData.html","title":"SymbolicData","text":"<pre>{-# OPTIONS --safe #-}\n\nopen import Ledger.Prelude\n\nmodule Test.SymbolicData\n  (SD : Set) {{DecEq-Data : DecEq SD}} {{Show-Data : Show SD}} where\n\nopen import Test.Prelude SD\n\nScriptContext : Type\nScriptContext = STxInfo \u00d7 SScriptPurpose\n\nSData : Type\nSData = SDatum \u228e ScriptContext\n\ninstance ShowSData : Show SData\n         ShowSData = mkShow (\u03bb x \u2192 \"\")\n\nopen import Test.LedgerImplementation SData SData\nopen import Ledger.Conway.Specification.Script.ScriptPurpose SVTransactionStructure\n\nopen import Ledger.Conway.Specification.Transaction using (TransactionStructure)\nopen TransactionStructure SVTransactionStructure\n\nopen import Ledger.Conway.Specification.Script.Validation SVTransactionStructure\n\nTxInToSymbolic : TxIn \u2192 STxIn\nTxInToSymbolic x = x\n\ncredToSymbolic : Credential \u2192 SCredential\ncredToSymbolic (KeyHashObj x) = KeyHashObj x\ncredToSymbolic (ScriptObj x) = ScriptObj x\n\nAddrToSymbolic : Addr \u2192 SAddr\nAddrToSymbolic (inj\u2081 record { net = net ; pay = pay ; stake = stake })\n  = inj\u2081 (record { net = net ; pay = credToSymbolic pay ; stake = maybe (\u03bb x \u2192 just (credToSymbolic x)) nothing stake })\nAddrToSymbolic (inj\u2082 record { net = net ; pay = pay ; attrsSize = attrsSize })\n  = inj\u2082 (record { net = net ; pay = credToSymbolic pay ; attrsSize = attrsSize })\n\nRwdAddrToSymbolic : RwdAddr \u2192 SRwdAddr\nRwdAddrToSymbolic record { net = net ; stake = stake } = record { net = net ; stake = credToSymbolic stake }\n\nDatumToSymbolic : Datum \u2192 Maybe SDatum\nDatumToSymbolic (inj\u2081 x) = just x\nDatumToSymbolic (inj\u2082 y) = nothing\n\nDatumPairToSymbolic : Datum \u228e DataHash \u2192 Maybe (SDatum \u228e SDatum)\nDatumPairToSymbolic (inj\u2081 (inj\u2081 x)) = just (inj\u2081 x)\nDatumPairToSymbolic (inj\u2081 (inj\u2082 y)) = nothing\nDatumPairToSymbolic (inj\u2082 (inj\u2081 x)) = just (inj\u2082 x)\nDatumPairToSymbolic (inj\u2082 (inj\u2082 y)) = nothing\n\nTxOutToSymbolic : TxOut \u2192 STxOut\nTxOutToSymbolic (a , v , d , s) = AddrToSymbolic a , v , maybe DatumPairToSymbolic nothing d\n\nUTxOToSymbolic : UTxO \u2192 SUTxO\nUTxOToSymbolic x = map (\\ x \u2192 (proj\u2081 x , TxOutToSymbolic (proj\u2082 x))) (setToList (x \u02e2))\n\ntxInfoToSymbolic : TxInfo \u2192 STxInfo\ntxInfoToSymbolic txinfo =\n  let open TxInfo txinfo\n  in\n    record\n      { realizedInputs = UTxOToSymbolic realizedInputs\n      ; txouts = map (\\ x \u2192 (proj\u2081 x , TxOutToSymbolic (proj\u2082 x))) (setToList (txOuts \u02e2))\n      ; fee = fee\n      ; mint = mint\n      ; txwdrls = map (\\ x \u2192 (RwdAddrToSymbolic (proj\u2081 x) , proj\u2082 x)) (setToList (txWithdrawals \u02e2))\n      ; txvldt = txVldt\n      ; vkey = vkKey\n      ; txdats = mapMaybe DatumToSymbolic (setToList txdats) \n      ; txid = txId\n      }\n\nScriptPurposeToSymbolic : ScriptPurpose \u2192 SScriptPurpose\nScriptPurposeToSymbolic (Cert x) = Empty\nScriptPurposeToSymbolic (Rwrd x) = Rwrd (RwdAddrToSymbolic x)\nScriptPurposeToSymbolic (Mint x) = Mint x\nScriptPurposeToSymbolic (Spend x) = Spend x\nScriptPurposeToSymbolic (Vote x) = Empty\nScriptPurposeToSymbolic (Propose x) = Empty\n\nvalContext : TxInfo \u2192 ScriptPurpose \u2192 Data\nvalContext txinfo sp = inj\u2082 ((txInfoToSymbolic txinfo) , (ScriptPurposeToSymbolic sp)) \n</pre>"},{"location":"guide.html","title":"Contributing to the Formal Ledger Specifications","text":"<p>Brief Contents</p> <p>\ud83d\udd8a\ufe0f\ufe0f Style Guidelines \ud83d\uddfa\ufe0f Project Overview \ud83d\udcbb Development Environment Setup \ud83c\udfd7\ufe0f Building Project Artifacts \ud83d\udcd6 HTML Documentation \ud83d\udda5\ufe0f IDE Integration \ud83e\uddd1\u200d\ud83d\udd27 Working on the Agda source code \ud83d\udd01 CI/CD Workflow \ud83c\udf9b\ufe0f\ufe0f Setup Without Nix \ud83d\udd75\ufe0f\u200d\u2640\ufe0f Conformance Testing \ud83d\uddc3\ufe0f Miscellanea \ud83d\udc77 Maintainers</p> <p></p>"},{"location":"guide.html#style-guidelines","title":"\ud83d\udd8a\ufe0f\ufe0f Style Guidelines","text":"<p>We adhere to the Agda standard library style guide where practical. However, because we use literate Agda to produce html documentation, readability of the latter takes precedence over code formatting.</p>"},{"location":"guide.html#miscellaneous-conventions","title":"Miscellaneous conventions","text":"<ol> <li> <p>Type classes for accessing fields of records should be named after the type of     the field and not the name of the field.  For example, suppose     <pre><code>Fees : Type\nFees = \u2115\n</code></pre>     and suppose we have a record type <code>A</code> with a field called <code>fee</code>:     <pre><code>record A : Type where\n  field\n    fee : Fees\n    ...\n</code></pre>     Then we would make a type class called <code>HasFees</code> (since the type is called <code>Fees</code>)     <pre><code>record HasFees {a} (A : Type a) : Type a where\n  field FeesOf : A \u2192 Fees\nopen HasFees \u2983...\u2984 public\n</code></pre>     and define the following instance of the <code>HasFees</code> type class for the type <code>A</code>:     <pre><code>  instance\n    HasFees-A : HasFees A\n    HasFees-A .FeesOf = A.fee\n</code></pre>     then, if <code>a : A</code>, we can access the <code>fee</code> field of <code>a</code> via <code>FeesOf a</code>.  From this     contrived example, you might think type classes are overkill here, and you're not     all wrong.  However, they can come in handy in practice, expecially when we have     many different types that have, say, fees or donations associated with them, and     we want to be able to access those values in a consistent way.  Moreover, we have     many examples of nested records that contain fees or donations, and the \"getter type     class\" instances allow us to access those values without having to remember the     specific paths to the field names of those record types.  Another example of the     getter type class pattern is given in the     \ud83d\uddc3\ufe0f Miscellanea section below.</p> </li> <li> <p>Use camel case for field names (e.g., <code>txNetworkId</code> instead of <code>txnetworkid</code>).</p> </li> </ol> <p></p>"},{"location":"guide.html#project-overview","title":"\ud83d\uddfa\ufe0f Project Overview","text":"<p>This repository uses Nix and Shake to provide a reproducible, declarative, and portable development environment.</p>"},{"location":"guide.html#nix-flakes","title":"Nix Flakes","text":"<p>We use Nix Flakes to manage dependencies, build processes, and development shells.</p>"},{"location":"guide.html#dependency-management","title":"Dependency Management","text":"<p>All external Nix dependencies (like <code>nixpkgs</code>) and Agda libraries are pinned to specific versions (e.g., Git commits).</p> <p>The core Agda dependencies include:</p> <ul> <li>agda-stdlib: standard library;</li> <li>agda-stdlib-classes: type-class extensions for the standard library;</li> <li>agda-stdlib-meta: meta-programming utilities;</li> <li>agda-sets: abstract set theory library;</li> <li>iog-agda-prelude: supplementary prelude.</li> </ul>"},{"location":"guide.html#directory-structure","title":"Directory Structure","text":"<p>The main directories and files involved in the build process are as follows. (A more detailed version of this annotated tree can be found at the bottom of this page.)</p> <pre><code>\u251c\u2500\u2500 flake.nix                  # The main Nix flake file.\n\u2502\n\u2514\u2500\u2500 build-tools\n    \u251c\u2500\u2500 agda/\n    \u2502   \u251c\u2500\u2500 data/\n    \u2502   \u2502   \u251c\u2500\u2500 Agda.css       # For styling Agda HTML output.\n    \u2502   \u2502   \u2514\u2500\u2500 AgdaKaTeX.js   # For integrating Agda's HTML with KaTeX.\n    \u2502   \u251c\u2500\u2500 flake.nix          # Auxiliary Nix flake file.\n    \u2502   \u251c\u2500\u2500 fls-agda.cabal     # For building fls-agda Haskell package.\n    \u2502   \u251c\u2500\u2500 nix/\n    \u2502   \u2502   \u2514\u2500\u2500 fls-agda.nix   # Nix derivation for fls-agda package.\n    \u2502   \u2514\u2500\u2500 src/\n    \u2502       \u2514\u2500\u2500 Main.hs        # Main entry point for fls-agda executable.\n    \u2502\n    \u251c\u2500\u2500 nix/                   # Nix derivations for exported packages.\n    \u2502   \u251c\u2500\u2500 formal-ledger.nix\n    \u2502   \u251c\u2500\u2500 hs-src.nix\n    \u2502   \u251c\u2500\u2500 html.nix\n    \u2502   \u2514\u2500\u2500 mkdocs.nix\n    \u2502\n    \u2514\u2500\u2500 shake/\n        \u251c\u2500\u2500 flake.nix          # Auxiliary Nix flake file.\n        \u251c\u2500\u2500 fls-shake.cabal    # For building fls-shake Haskell package.\n        \u251c\u2500\u2500 nix/\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 fls-shake.nix  # Nix derivation for fls-shake package.\n        \u2514\u2500\u2500 src/\n            \u2514\u2500\u2500 Main.hs        # Main entry point for fls-shake build system.\n</code></pre> <p></p>"},{"location":"guide.html#development-environment-setup","title":"\ud83d\udcbb Development Environment Setup","text":"<p>We provide several development shells tailored for different tasks. You can enter them using <code>nix develop</code>.</p> <ul> <li> <p>\ud83d\udc1a Default Shell</p> <p>This is the primary environment for Agda development. It includes Agda, all required libraries, and the <code>fls-shake</code> build tool.</p> <pre><code># Enter the default development shell\nnix develop\n</code></pre> <p>\u2692\ufe0f Available Tools</p> <ul> <li><code>agda</code> (with all project libraries)</li> <li><code>fls-shake</code> (our custom build tool)</li> <li><code>python311</code> (Python version 3.11)</li> <li><code>hpack</code> (the Haskell package helper)</li> </ul> </li> <li> <p>\ud83d\udc1a CI Shell</p> <p>A minimal environment designed for automated builds, containing only the <code>fls-shake</code> build tool and its runtime dependencies.</p> <pre><code># Enter the CI shell\nnix develop .#ci\n</code></pre> </li> <li> <p>\ud83d\udc1a Documentation Shell</p> <p>A comprehensive environment for working on documentation, including the full documentation generation pipeline.</p> <pre><code># Enter the documentation shell\nnix develop .#mkdocs\n</code></pre> <p>\u2692\ufe0f Available Tools</p> <p>Everything from the default shell plus</p> <ul> <li><code>pandoc</code> (the document conversion tool)</li> <li><code>latex</code> (the typesetting language)</li> <li><code>mkdocs</code> (with Python dependencies)</li> </ul> </li> </ul> <p></p>"},{"location":"guide.html#building-project-artifacts","title":"\ud83c\udfd7\ufe0f Building Project Artifacts","text":"<p>You can build project artifacts in several ways. The recommended method is using <code>nix build</code>.</p> <p>The <code>flake.nix</code> file exposes all buildable artifacts as packages.</p> <p>(How to view or use what these commands build is explained below; see Building and viewing the formal specification and Browsing the source code.)</p> <pre><code># Type-check the Agda specification (default package)\nnix build .#formal-ledger\n# or simply:\nnix build\n\n# Generate the (HTML version of the) formal specification\nnix build .#mkdocs\n\n# Generate browseable HTML version of Agda code\nnix build .#html\n\n# Generate Haskell source code for conformance testing\nnix build .#hs-src\n</code></pre> <p>Build outputs are symlinked in the <code>result/</code> directory.</p>"},{"location":"guide.html#using-the-fls-shake-build-tool","title":"Using the <code>fls-shake</code> Build Tool","text":"<p>For more granular control, you can use our Shake-based build tool, <code>fls-shake</code>, from within a development shell.</p> <pre><code># Enter the default development shell\nnix develop\n\n# Build specific artifacts using fls-shake\nfls-shake html                # Build HTML docs\nrm -rf _build dist/hs; fls-shake hs   # Build Haskell source\n\n# See all available targets\nfls-shake --help\n</code></pre> <p></p>"},{"location":"guide.html#html-documentation","title":"\ud83d\udcd6 HTML Documentation","text":""},{"location":"guide.html#building-and-viewing-the-formal-specification","title":"Building and viewing the formal specification","text":"<p>There are two ways to do this.</p> <ol> <li> <p>With Nix</p> <p>Enter the command <code>nix build .#mkdocs</code> then open the file <code>result/site/index.html</code> in a browser. This type-checks the Agda code, and generates the HTML documentation from scratch.</p> <p>Note. This currently works in Chrome but may not work in Brave or Firefox.  If you want to use one of those browsers to view the generated documentation, you can run a local server on the result, <code>cd result/site; python3 -m http.server</code>, and then point your browser to http://127.0.0.1:8000/.</p> </li> <li> <p>Manually</p> <p>This method only type-checks the Agda code that has changed since last time and then generates the HTML documentation.</p> <pre><code>nix develop .#mkdocs\npython build-tools/scripts/md/build.py --run-agda\ncd _build/md/mkdocs\nmkdocs serve\n</code></pre> <p>Then point your browser to  http://127.0.0.1:8000/.</p> </li> </ol>"},{"location":"guide.html#generating-images","title":"Generating images","text":"<p>The diagrams in our documentation come from legacy tikz source code files that live in the <code>build-tools/static/latex/Diagrams</code> directory.  To generate svg images from a tikz source code file, we create a standalone LaTeX document for it (e.g., <code>build-tools/static/latex/STS-Diagram.tex</code>) and</p> <ol> <li> <p>run the following commands:</p> <pre><code>lualatex -halt-on-error -interaction=batchmode STS-Diagram.tex\ndvisvgm --pdf --page=1 -n -a -o STS-Diagram.svg STS-Diagram.pdf\n</code></pre> </li> <li> <p>copy the resulting <code>.svg</code> file into the <code>build-tools/static/md/common/src/img/</code> directory.</p> </li> </ol> <p>To include the diagram in the markdown documentation, we add it to a <code>.lagda.md</code> file as follows: <code>![STS-Diagram](img/STS-Diagram.svg)</code>.</p> <p>(The Python pipeline for markdown migration and mkdocs site generation can now handle steps 1 and 2 above.  Specifically, when you build the html documentation site using the second (\"manual\") method above, the program looks in the <code>build-tools/static/latex/</code> directory for LaTeX files with names matching the pattern <code>*-Diagram.tex</code>; it processes each such file with the <code>lualatex</code> and <code>dvisvgm</code> commands shown above and then copies the resulting <code>.svg</code> image file into the <code>build-tools/static/md/common/src/img</code> directory.)</p> <p>Important Notes</p> <ul> <li> <p>For each tikz source file in <code>build-tools/static/latex/Diagrams</code>, to generate the    corresponding svg image file, we must create a standalone LaTeX file    <code>*-Diagram.tex</code> file that <code>\\include</code>s the tikz source file.  Also, we need to    include the svg image in the appropriate <code>.lagda.md</code> file by hand, either</p> <ul> <li> <p>using the standard Markdown syntax for including images, that is, <code>![...](...)</code>; e.g.,</p> <p><code>![Rewards flowchart](img/Rewards-Diagram.svg \"Rewards flowchart\")</code></p> <p>OR</p> </li> <li> <p>using our custom <code>svg-card</code> css class; e.g.,</p> <pre><code>&lt;figure class=\"svg-card\"&gt;\n  &lt;img src=\"img/RewardsTiming-Diagram.svg\" alt=\"Rewards timeline\"&gt;\n&lt;/figure&gt;\n</code></pre> </li> </ul> </li> <li> <p>Each <code>.tex</code> file in the <code>build-tools/static/latex/</code> directory that should not be    converted to Markdown by the pipeline must be added to the <code>excluded_prefixes</code>    list in the <code>convert_all_static_tex</code> function of the Python script    <code>build-tools/scripts/md/modules/static_tex_processor.py</code>.</p> </li> </ul>"},{"location":"guide.html#browsing-the-source-code","title":"Browsing the source code","text":"<p>After generating the HTML version of the source code with <code>nix build .#html</code>, you can view the result by pointing your browser to <code>result/html/index.html</code>.  If this fails, then you may have to run a local server, as follows:</p> <pre><code>cd result/html\npython3 -m http.server\n</code></pre> <p>Then point your browser to http://127.0.0.1:8000.</p> <p></p>"},{"location":"guide.html#ide-integration","title":"\ud83d\udda5\ufe0f IDE Integration","text":"<p>For the best development experience, you should configure your IDE to use the Agda executable provided by this project's Nix environment.</p> <p>First, build <code>fls-agdaWithPackages</code> and create a stable symlink to it in your home directory. This prevents you from having to update your IDE settings every time the project's dependencies change.</p> <pre><code>nix build ./#fls-agdaWithPackages -o ~/ledger-agda\n</code></pre> <p>Then make sure that the <code>~/ledger-agda/bin</code> directory is in your <code>PATH</code> when starting your editor.</p>"},{"location":"guide.html#setting-up-multiple-versions-with-update-alternatives-optional","title":"Setting up multiple versions with <code>update-alternatives</code> (OPTIONAL)","text":"<p>For Linux users.</p> <p>If you have <code>update-alternatives</code> installed, then, instead of creating a symlink from your home directory (or some other directory that's in your <code>PATH</code>) to our version of agda in <code>~/ledger-agda/bin/agda</code>, you can configure multiple versions of <code>agda</code> and <code>agda-mode</code> as follows:</p> <pre><code>sudo update-alternatives --install /usr/bin/agda agda ~/ledger-agda/bin/agda 1\n</code></pre> <p>Do the same for any other versions of Agda that you have installed, and want to make available, on your system.</p> <p>For example,</p> <pre><code>sudo update-alternatives --install /usr/bin/agda agda ~/.cabal/bin/agda-2.8.0 10\n</code></pre> <p>Now, install the associated version of <code>agda-mode</code>, which is required for using Agda (versions &lt; 2.8.0) in Emacs:</p> <pre><code>sudo update-alternatives --install /usr/bin/agda-mode agda-mode ~/ledger-agda/bin/agda-mode 1\n</code></pre> <p>Finally, choose which Agda version you want to use:</p> <pre><code>sudo update-alternatives --config agda\n</code></pre> <p>and, if you choose a version below 2.8.0, be sure to select the appropriate <code>agda-mode</code> version to accompany it!</p> <pre><code>sudo update-alternatives --config agda-mode\n</code></pre>"},{"location":"guide.html#emacs","title":"Emacs","text":"<p>(This section does not assume you followed the optional <code>update-alternative</code> setup instructions above.  However, even if you did, you can still carry out the customization instructions in the present section, which do not conflict with the <code>update-alternatives</code> approach.)</p> <ol> <li> <p>Configure Emacs for version switching.</p> <p>Add the following to your Emacs init file (highlight and <code>M-x eval-region</code> to load without restarting):</p> <pre><code>;; Defines a function `my/switch-agda' that switches between different\n;; `agda' executables defined in `my/agda-versions'. The first entry of\n;; `my/agda-versions' is assumed to be the default Agda.\n;;\n;; If there are two entries in `my/agda-versions', `my/switch-agda' toggles\n;; between the two. If there are more entries, it will ask which one\n;; to choose.\n(setq my/agda-versions `((\"System Agda\"  \"2.8.0\" \"agda\")  ; Adjust version as needed\n                         (\"Ledger Agda\"  \"2.7.0.1\" \"~/ledger-agda/bin/agda\")))\n(setq my/selected-agda (caar my/agda-versions))\n\n(defun my/switch-agda (name version path)\n  (interactive\n   (cond ((&gt; (length my/agda-versions) 2)\n          (assoc (completing-read \"Agda: \" my/agda-versions '(lambda (x) 't) 't) my/agda-versions))\n         ((= (length my/agda-versions) 2)\n          (car (seq-filter '(lambda (x) (not (string= my/selected-agda (car x)))) my/agda-versions)))\n         (t (error \"my/agda-versions needs to have at least two elements!\"))))\n  (message \"Selecting %s, version %s\" name version)\n  (setq my/selected-agda   name\n        agda2-version      version\n        agda2-program-name path)\n  (agda2-restart))\n\n;; Bind the switch function to C-c C-x C-t in agda2-mode\n(with-eval-after-load 'agda2-mode\n  (define-key agda2-mode-map (kbd \"C-c C-x C-t\") 'my/switch-agda))\n</code></pre> <p>Notes</p> <ul> <li>Update the system Agda version in <code>my/agda-versions</code> to match your installation.</li> <li>Check your system Agda with <code>which agda &amp;&amp; agda --version</code>.</li> <li>Once configured, use <code>M-x my/switch-agda</code> (or <code>C-c C-x C-t</code>) to switch between Agda versions.</li> <li>This works with most Emacs distributions (Doom, Spacemacs, vanilla, etc.).</li> </ul> </li> <li> <p>Launch Emacs from within the project's Nix shell to make it aware of the environment:</p> <pre><code>nix develop\nemacs src/Ledger.lagda.md\n</code></pre> </li> <li> <p>Use standard <code>agda-mode</code> commands (e.g., <code>C-c C-l</code> to load a file).</p> </li> </ol>"},{"location":"guide.html#visual-studio-code","title":"Visual Studio Code","text":"<ol> <li> <p>Install the official Agda Language Server extension from the marketplace.</p> </li> <li> <p>Configure the extension to use the project's Agda executable. Open your <code>settings.json</code> (<code>Ctrl+Shift+P</code> &gt; \"Preferences: Open User Settings (JSON)\") and add the path to the symlink:     <pre><code>{\n  \"agdaMode.connection.paths\": [\n    \"~/ledger-agda/bin/agda\",\n    \"agda\"\n  ]\n}\n</code></pre> (Note: VS Code may not expand <code>~</code>, so you might need to use the full path, e.g., <code>/home/user/ledger-agda/bin/agda</code>).</p> </li> <li> <p>Use <code>Ctrl+C Ctrl+R</code> to switch between Agda versions if you have multiple configured.</p> </li> </ol> <p></p>"},{"location":"guide.html#working-on-the-agda-source-code","title":"\ud83e\uddd1\u200d\ud83d\udd27 Working on the Agda source code","text":""},{"location":"guide.html#editing-the-source-files","title":"Editing the source files","text":"<p>You can use either Emacs or VSCode to edit the source code files under the main <code>src</code> directory.  Currently, we have a mixture of plain Agda (<code>.agda</code>), LaTeX-based literate Agda (<code>.lagda</code>), and Markdown-based literate Agda (<code>.lagda.md</code>), but eventually all Agda files under <code>src</code> will be of the Markdown flavor and as such will have the <code>.lagda.md</code> extension.</p> <p>Markdown-flavored literate Agda files contain English prose, formatted using Markdown syntax, along with code blocks each of which is delimited by an Agda code fence. For example,</p> <pre><code>```agda\n-- Agda code goes here\n```\n</code></pre> <p>We also use \"hidden\" code blocks, inside of which is code that is type-checked by Agda but does not (by default) appear on web pages generated by from the <code>.lagda.md</code> source file.<sup>1</sup>  A normal Agda code block is hidden by simply surrounding a normal code block with the standard HTML comment delimiters.  For example,</p> <pre><code>&lt;!--\n```agda\n-- Agda code here will be type-checked but not shown on the web page by default.\n```\n--&gt;\n</code></pre> <p>See also: the Agda documentation section on literate markdown.</p>"},{"location":"guide.html#checking-how-your-code-looks-on-the-site","title":"Checking how your code looks on the site","text":"<p>An important step in contributing any code to the repository is to check how it will appear when run through our custom mkdocs site generator and rendered on our website. This section explains how to use the tools we have created to monitor the effects your changes to the code will have on the appearance of the corresponding web pages.</p> <ol> <li> <p>First, generate the mkdocs site Manually (as described in option 2 of the     Building and viewing the formal specification section):</p> <p><pre><code>nix develop .#mkdocs\npython build-tools/scripts/md/build.py --run-agda\ncd _build/md/mkdocs\nmkdocs serve\n</code></pre> 2.  In another terminal window, enter the default Nix shell with <code>nix develop</code> and then run <code>fls-shake --watch</code>.</p> </li> <li> <p>Now, instead of directly editing a file (or creating a new file) under the main <code>src</code>     directory, make your changes to (or create) <code>.lagda.md</code> files under <code>_build/md/md.in/src</code>.</p> </li> <li> <p>Check your work by viewing the corresponding page at http://127.0.0.1:8000/.</p> </li> <li> <p>Once you are satisfied with your changes.  Replace the corresponding file under     <code>src</code> with your new version from <code>_build/md/md.in/src</code>.</p> </li> </ol> <p>How this works.  The <code>fls-shake --watch</code> command watches for changes to files in <code>_build/md/md.in/src</code> and, whenever a change occurs, generates a new corresponding page in the mkdocs site directory.  Since the mkdocs server is listening for changes to files in the mkdocs site directory, you will see the effect of your changes in the browser.</p> <p></p>"},{"location":"guide.html#cicd-workflow","title":"\ud83d\udd01 CI/CD Workflow","text":"<p>Our CI/CD pipeline, defined in <code>.github/workflows/</code>, automates the building and publishing of artifacts. Here are some key details:</p> <ul> <li>Caching</li> </ul> <p>The initial <code>formal-ledger-agda</code> job type-checks the code and uploads the resulting <code>_build</code> directory as a GitHub artifact. Subsequent jobs download this artifact to avoid re-compiling Agda code.</p> <ul> <li>Artifact Branches</li> </ul> <p>For every push to <code>master</code> or a pull request branch, the CI creates a corresponding <code>&lt;branch-name&gt;-artifacts</code> branch. This branch stores the generated artifacts (PDFs, HTML, Haskell code).</p> <ul> <li>PDF Generation Note</li> </ul> <p>The CI workflow does not build PDFs from the current source. Instead, it checks out the <code>legacy-latex-artifacts</code> branch and copies the PDFs from there. This is a temporary measure to ensure the stability of the published documents. You can still build PDFs locally from source using the commands described above.</p> <p></p>"},{"location":"guide.html#setup-without-nix","title":"\ud83c\udf9b\ufe0f\ufe0f Setup Without Nix","text":"<p>While we recommend using Nix for the best experience, it's possible to work with this repository without Nix. Those making nontrivial contributions are advised to use the Nix-based approach, but these instructions are provided for those who prefer not to use Nix.</p>"},{"location":"guide.html#installing-agda-and-dependencies-manually","title":"Installing Agda and Dependencies Manually","text":"<ol> <li> <p>Install Agda 2.7.0.1.</p> <p>Follow the instructions at https://agda.readthedocs.io/en/v2.7.0/getting-started/installation.html#step-1-install-agda</p> </li> <li> <p>Clone the required Agda libraries.</p> <pre><code>mkdir -p LIB &amp;&amp; cd LIB\n\n# Clone exact versions used by the project\ngit clone --config advice.detachedHead=false --single-branch -b \"v2.2\" \\\n  https://github.com/agda/agda-stdlib.git\ngit clone --config advice.detachedHead=false --single-branch \\\n  https://github.com/agda/agda-stdlib-classes.git\ngit clone --config advice.detachedHead=false --single-branch \\\n  https://github.com/agda/agda-stdlib-meta.git\ngit clone --config advice.detachedHead=false --single-branch -b \"master\" \\\n  https://github.com/input-output-hk/agda-sets.git\ngit clone --config advice.detachedHead=false --single-branch -b \"main\" \\\n  https://github.com/input-output-hk/iog-agda-prelude.git\n\n# Checkout specific commits (check sources.json for exact versions)\ncd agda-stdlib-classes &amp;&amp; git checkout aa62ce6348d39c554ef89487079871d5590e155e &amp;&amp; cd ..\ncd agda-stdlib-meta &amp;&amp; git checkout 5ff853375180ef69f243ce72f2d3f6294bdb6aff &amp;&amp; cd ..\ncd agda-sets &amp;&amp; git checkout f517d0d0c1ff1fd6dbac8b34309dea0e1aea6fc6 &amp;&amp; cd ..\ncd iog-agda-prelude &amp;&amp; git checkout 20e4ab42fd6a980233053c8c3b1b8b2ab42946c9 &amp;&amp; cd ..\n</code></pre> </li> <li> <p>Create library configuration.</p> <p>Create a file <code>LIB/libraries</code> with the following content:</p> <pre><code>LIB/agda-stdlib/standard-library.agda-lib\nLIB/agda-stdlib-classes/agda-stdlib-classes.agda-lib\nLIB/agda-stdlib-meta/agda-stdlib-meta.agda-lib\nLIB/agda-sets/abstract-set-theory.agda-lib\nLIB/iog-agda-prelude/iog-prelude.agda-lib\n</code></pre> </li> <li> <p>Use Agda with the libraries.</p> <pre><code># Type-check the formal specification\nAGDA_DIR=LIB agda src/Everything.agda\n\n# Build artifacts (requires fls-shake, see below)\nAGDA_DIR=LIB fls-shake cardano-ledger.pdf\n</code></pre> </li> </ol>"},{"location":"guide.html#building-fls-shake-without-nix","title":"Building fls-shake Without Nix","text":"<p>The build system <code>fls-shake</code> can be compiled manually by following the steps described in this subsection.</p> <ol> <li> <p>Install GHC and Cabal.</p> <p>Follow the official Haskell instructions.</p> <p>Verify installation and update:</p> <pre><code>ghc --version\ncabal --version\ncabal update\n</code></pre> </li> <li> <p>Compile fls-shake.</p> <pre><code>cd build-tools/shake\ncabal build fls-shake\n</code></pre> </li> <li> <p>Run fls-shake:</p> <pre><code># Build PDF documents\ncabal run fls-shake -- -C '../..' cardano-ledger.pdf\ncabal run fls-shake -- -C '../..' conway-ledger.pdf\n\n# Build HTML and Haskell outputs\ncabal run fls-shake -- -C '../..' html\ncabal run fls-shake -- -C '../..' hs\n</code></pre> <p>Note: The <code>-C '../..'</code> option makes fls-shake run from the repository's main directory.</p> </li> </ol>"},{"location":"guide.html#required-system-dependencies","title":"Required System Dependencies","text":"<p>For non-Nix users, you'll also need to install the following:</p> <ul> <li>LaTeX (for PDF generation)</li> </ul> <pre><code># Ubuntu/Debian\nsudo apt install texlive-full latexmk\n\n# Or minimal installation\nsudo apt install texlive-latex-extra latexmk\n</code></pre> <ul> <li>Python and dependencies (for documentation tools)</li> </ul> <pre><code>pip install mkdocs mkdocs-material pymdown-extensions pyyaml\n</code></pre> <ul> <li>Other tools</li> </ul> <p>pandoc, basic utilities (cp, mkdir, etc.)</p> <p></p>"},{"location":"guide.html#conformance-testing","title":"\ud83d\udd75\ufe0f\u200d\u2640\ufe0f Conformance Testing","text":"<p>After producing the Agda-generated Haskell code with <code>nix build .#hs-src</code>, you can run the conformance tests.</p> <p>See the <code>conformance-example</code> directory.</p> <p></p>"},{"location":"guide.html#miscellanea","title":"\ud83d\uddc3\ufe0f Miscellanea","text":""},{"location":"guide.html#updating-agda-dependencies-in-the-nix-configuration","title":"Updating Agda dependencies in the Nix configuration","text":"<p>The following example ilustrates the procedure</p> <pre><code>nix flake update agda-nix/abstract-set-theory \\\n  --override-input agda-nix/abstract-set-theory \\\n  github:input-output-hk/agda-sets/bbaa00abc4aef061896ae5d3cdec148bfbf5029f\nnix build ./#fls-agdaWithPackages -o ~/ledger-agda\n</code></pre> <p>The first line updates the commit hash to use for a dependency. In the example, it updates the dependency <code>agda-nix/abstract-set-theory</code> to point at the commit <code>bbaa00abc4aef061896ae5d3cdec148bfbf5029f</code> or the repository <code>github:input-output-hk/agda-sets</code>.</p> <p>The second line rebuilds the Agda mode to use with emacs. This step is necessary for emacs to use the new version of the dependency when loading Agda code. This assumes that <code>~/ledger-agda/bin</code> is in your <code>PATH</code>.</p>"},{"location":"guide.html#plotting-typechecking-times","title":"Plotting typechecking times","text":"<p>The script <code>scripts/plot_typecheck_time.py</code> can be used to generate an <code>html</code> file that plots the typechecking times as recorded in the <code>master-artifacts</code> branch.</p> <p>The script uses <code>python</code> and <code>pandas</code>, and the generated <code>html</code> uses <code>chart.js</code> for plotting.</p> <p>Frome the git repository, run, <pre><code>python scripts/plot_typecheck_time.py &gt; index.html\n</code></pre> and open <code>index.html</code> in your browser.</p> <p></p>"},{"location":"guide.html#another-example-of-the-getter-type-class-pattern","title":"Another Example of the Getter Type Class Pattern","text":"<p>Here's a more realistic example of how we use type classes to make accessing fields of records easier and more consistent.</p> <p>Let</p> <pre><code>VoteDelegs : Type\nVoteDelegs = Credential \u21c0 VDeleg\n\nrecord HasVoteDelegs {a} (A : Type a) : Type a where\n  field VoteDelegsOf : A \u2192 VoteDelegs\nopen HasVoteDelegs \u2983...\u2984 public\n\nrecord DState : Type where\n  field\n    voteDelegs   : VoteDelegs\n    ...\n\nrecord HasDState {a} (A : Type a) : Type a where\n  field DStateOf : A \u2192 DState\nopen HasDState \u2983...\u2984 public\n\nrecord CertState : Type where\n  field\n    dState : DState\n    ...\n\ninstance\n  HasVoteDelegs-DState : HasVoteDelegs DState\n  HasVoteDelegs-DState .VoteDelegsOf = DState.voteDelegs\n\n  HasDState-CertState : HasDState CertState\n  HasDState-CertState .DStateOf = CertState.dState\n\n  HasVoteDelegs-CertState : HasVoteDelegs CertState\n  HasVoteDelegs-CertState .VoteDelegsOf = VoteDelegsOf \u2218 DStateOf\n</code></pre> <p>Now, if we have <code>cs : CertState</code>, we can fetch the <code>voteDelegs</code> field of (the <code>dState</code> of) <code>cs</code> as follows: <code>VoteDelegsOf cs</code>.</p> <p>Without type classes we would have to <code>open DState</code> and <code>open CertState</code> and then write <code>cs .dState .voteDelegs</code>, or, if we want to avoid <code>open</code> clutter, <code>DState.voteDelegs CertState.dState cs</code>.</p>"},{"location":"guide.html#build-tools","title":"Build-tools","text":"<p>Here is the complete annotated subtree of the <code>build-tools</code> directory.</p> <pre><code>\u251c\u2500\u2500 build-tools/                                     # All build-related utilities and static assets\n\u2502   \u251c\u2500\u2500 agda/                                        # Source for the custom `fls-agda` Agda backend\n\u2502   \u2502   \u251c\u2500\u2500 data/                                    # Static assets used by the fls-agda backend\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Agda.css                             # Base CSS for styling Agda HTML output\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 AgdaKaTeX.js                         # JS for integrating Agda's HTML with KaTeX\n\u2502   \u2502   \u251c\u2500\u2500 fls-agda.cabal                           # Cabal file for building the fls-agda Haskell package\n\u2502   \u2502   \u251c\u2500\u2500 nix/                                     # Nix-specific build files for fls-agda\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 fls-agda.nix                         # Nix derivation for the fls-agda package\n\u2502   \u2502   \u251c\u2500\u2500 src/                                     # Haskell source code for the fls-agda backend\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Main.hs                              # Main entry point for the fls-agda executable\n\u2502   \u2502   \u2514\u2500\u2500 test/                                    # Test files for the fls-agda backend\n\u2502   \u2502       \u2514\u2500\u2500 Test0.agda                           # Agda file for testing the backend's functionality\n\u2502   \u251c\u2500\u2500 nix/                                         # General Nix configuration for the project\n\u2502   \u2502   \u251c\u2500\u2500 sources.json                             # Niv-managed file pinning exact dependency versions\n\u2502   \u2502   \u2514\u2500\u2500 sources.nix                              # Niv-generated file to load pinned dependencies\n\u2502   \u251c\u2500\u2500 scripts/                                     # Various utility scripts for building and processing\n\u2502   \u2502   \u251c\u2500\u2500 agda2vec.py                              # Python script for post-processing Agda-generated LaTeX\n\u2502   \u2502   \u251c\u2500\u2500 checkTypeChecked.sh                      # Shell script to verify Agda type-checking success\n\u2502   \u2502   \u251c\u2500\u2500 hldiff.py                                # Python script for highlighting differences in LaTeX\n\u2502   \u2502   \u251c\u2500\u2500 md/                                      # Scripts for the Markdown documentation pipeline\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 agda-filter.lua                      # Pandoc Lua filter for processing Agda code blocks\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 build.py                             # Main entry point for the Markdown build script\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 config/                              # Configuration modules for the build script\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 build_config.py                  # Defines dataclasses for build paths and settings\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 modules/                             # Core logic modules for the build script\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 agda_processing.py               # Handles interaction with the Agda compiler\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 bibtex_processor.py              # Processes BibTeX citations\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 content_staging.py               # Manages intermediate build files\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 latex_pipeline.py                # Orchestrates LaTeX-to-Markdown conversion\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 latex_preprocessor.py            # Pre-processes LaTeX files before conversion\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 site_assembly.py                 # Assembles the final MkDocs/MdBook site\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 test/                                # Tests for the Markdown build pipeline\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 test_bibtex_processor.py         # Unit tests for the BibTeX processor\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 utils/                               # Utility functions used by the build script\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 command_runner.py                # Helper for running external commands\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 file_ops.py                      # Helpers for file system operations\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 pipeline_types.py                # Defines custom types used in the pipeline\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 text_processing.py               # Helpers for text manipulation\n\u2502   \u2502   \u251c\u2500\u2500 plot_typecheck_time.py                   # Script to plot Agda type-checking performance\n\u2502   \u2502   \u2514\u2500\u2500 prepare-conf-test.sh                     # Script to prepare for conformance testing\n\u2502   \u251c\u2500\u2500 shake/                                       # Source for the `fls-shake` build tool\n\u2502   \u2502   \u251c\u2500\u2500 fls-shake.cabal                          # Cabal file for building the fls-shake Haskell package\n\u2502   \u2502   \u251c\u2500\u2500 nix/                                     # Nix-specific build files for fls-shake\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 fls-shake.nix                        # Nix derivation for the fls-shake package\n\u2502   \u2502   \u2514\u2500\u2500 src/                                     # Haskell source code for fls-shake\n\u2502   \u2502       \u2514\u2500\u2500 Main.hs                              # Main entry point for the fls-shake build system\n\u2502   \u2514\u2500\u2500 static/                                      # Static assets copied into builds\n\u2502       \u251c\u2500\u2500 hs-src/                                  # Template for the extracted Haskell source code\n\u2502       \u2502   \u251c\u2500\u2500 package.yaml                         # hpack file to generate the .cabal file\n\u2502       \u2502   \u2514\u2500\u2500 src/MAlonzo/Code/Ledger/Foreign/API.hs # Manual Haskell FFI to Agda code\n\u2502       \u251c\u2500\u2500 latex/                                   # Static LaTeX files for (legacy) PDF generation\n\u2502       \u2502   \u251c\u2500\u2500 cardano-ledger.tex                   # Main TeX file for the full specification PDF\n\u2502       \u2502   \u251c\u2500\u2500 ...                                  # Other TeX includes, diagrams, fonts, etc.\n\u2502       \u2502   \u2514\u2500\u2500 references.bib                       # BibTeX file for all citations\n\u2502       \u2514\u2500\u2500 md/                                      # Static assets for Markdown documentation sites\n\u2502           \u251c\u2500\u2500 common/                              # Assets shared between MkDocs and MdBook\n\u2502           \u2502   \u251c\u2500\u2500 nav.yml                          # Template for the MkDocs navigation structure\n\u2502           \u2502   \u2514\u2500\u2500 src/                             # Source assets (CSS, JS, images, etc.)\n\u2502           \u2502       \u251c\u2500\u2500 css/custom.css               # Custom stylesheet for documentation sites\n\u2502           \u2502       \u2514\u2500\u2500 js/custom.js                 # Custom JavaScript for documentation sites\n\u2502           \u2514\u2500\u2500 mkdocs/                              # Configuration and templates for MkDocs\n\u2502               \u251c\u2500\u2500 docs/index.md                    # Homepage/landing page for the MkDocs site\n\u2502               \u251c\u2500\u2500 includes/links.md                # Common Markdown link references\n\u2502               \u2514\u2500\u2500 mkdocs.yml                       # Main configuration file for the MkDocs site\n\u251c\u2500\u2500 TEX2MD_MIGRATION.md                              # Guide for the LaTeX to Markdown migration process\n\u2514\u2500\u2500 TROUBLESHOOTING.md                               # Guide for resolving common build issues\n</code></pre> <p></p>"},{"location":"guide.html#maintainers","title":"\ud83e\uddd1\u200d\ud83d\udd27 Maintainers","text":"<p>This repository is maintained by @carlostome, @WhatisRT, and @williamdemeo.</p> <p>If you encounter any problems, please open a New Issue.</p> <ol> <li> <p>However, our custom mkdocs configuration provides a toggle button that allows the reader to view hidden code blocks if desired.)\u00a0\u21a9</p> </li> </ol>"}]}