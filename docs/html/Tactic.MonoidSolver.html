<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.MonoidSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- Reflection-based solver for monoid equalities</a>
<a id="155" class="Comment">------------------------------------------------------------------------</a>
<a id="228" class="Comment">--</a>
<a id="231" class="Comment">-- This solver automates the construction of proofs of equivalences</a>
<a id="299" class="Comment">-- between monoid expressions.</a>
<a id="330" class="Comment">-- When called like so:</a>
<a id="354" class="Comment">--</a>
<a id="357" class="Comment">--   proof : ∀ x y z → (x ∙ y) ∙ z ≈ x ∙ (y ∙ z) ∙ ε</a>
<a id="410" class="Comment">--   proof x y z = solve mon</a>
<a id="439" class="Comment">--</a>
<a id="442" class="Comment">-- The following diagram describes what happens under the hood:</a>
<a id="506" class="Comment">--</a>
<a id="509" class="Comment">--            ┌▸x ∙ (y ∙ (z ∙ ε)) ════ x ∙ (y ∙ (z ∙ ε))◂┐</a>
<a id="568" class="Comment">--            │         ║                      ║         │</a>
<a id="627" class="Comment">--            │         ║                      ║         │</a>
<a id="686" class="Comment">--          [_⇓]        ║                      ║        [_⇓]</a>
<a id="747" class="Comment">--          ╱           ║                      ║          ╲</a>
<a id="807" class="Comment">--         ╱            ║                      ║           ╲</a>
<a id="868" class="Comment">-- (x ∙′ y) ∙′ z      homo                   homo    x ∙′ (y ∙′ z) ∙′ ε′</a>
<a id="941" class="Comment">--   ▴     ╲            ║                      ║           ╱       ▴</a>
<a id="1010" class="Comment">--   │      ╲           ║                      ║          ╱        │</a>
<a id="1079" class="Comment">--   │       [_↓]       ║                      ║        [_↓]       │</a>
<a id="1148" class="Comment">--   │        │         ║                      ║         │         │</a>
<a id="1217" class="Comment">--   │        │         ║                      ║         │         │</a>
<a id="1286" class="Comment">--   │        └───▸(x ∙ y) ∙ z          x ∙ (y ∙ z) ∙ ε◂─┘         │</a>
<a id="1355" class="Comment">--   │                  │                      │                   │</a>
<a id="1424" class="Comment">--   │                  │                      │                   │</a>
<a id="1493" class="Comment">--   └────reflection────┘                      └───reflection──────┘</a>
<a id="1562" class="Comment">--</a>
<a id="1565" class="Comment">-- The actual output—the proof constructed by the solver—is represented</a>
<a id="1637" class="Comment">-- by the double-lined path (══).</a>
<a id="1671" class="Comment">--</a>
<a id="1674" class="Comment">-- We start at the bottom, with our two expressions.</a>
<a id="1727" class="Comment">-- Through reflection, we convert these two expressions to their AST</a>
<a id="1796" class="Comment">-- representations, in the Expr type.</a>
<a id="1834" class="Comment">-- We then can evaluate the AST in two ways: one simply gives us back</a>
<a id="1904" class="Comment">-- the two expressions we put in ([_↓]), and the other normalises</a>
<a id="1970" class="Comment">-- ([_⇓]).</a>
<a id="1981" class="Comment">-- We use the homo function to prove equivalence between these two</a>
<a id="2048" class="Comment">-- forms: joining up these two proofs gives us the desired overall</a>
<a id="2115" class="Comment">-- proof.</a>

<a id="2126" class="Comment">-- Note: What&#39;s going on with the Monoid parameter?</a>
<a id="2178" class="Comment">--</a>
<a id="2181" class="Comment">-- This module is not parameterised over a monoid, which is contrary</a>
<a id="2250" class="Comment">-- to what you might expect. Instead, we take the monoid record as an</a>
<a id="2320" class="Comment">-- argument to the solve macro, and then pass it around as an</a>
<a id="2382" class="Comment">-- argument wherever we need it.</a>
<a id="2415" class="Comment">--</a>
<a id="2418" class="Comment">-- We need to get the monoid record at the call site, not the import</a>
<a id="2487" class="Comment">-- site, to ensure that it&#39;s consistent with the rest of the context.</a>
<a id="2557" class="Comment">-- For instance, if we wanted to produce `x ∙ y` using the monoid record</a>
<a id="2630" class="Comment">-- as imported, we would run into problems:</a>
<a id="2674" class="Comment">-- * If we tried to just reflect on the expression itself</a>
<a id="2732" class="Comment">--   (quoteTerm (x ∙ y)) we would likely get some de Bruijn indices</a>
<a id="2800" class="Comment">--   wrong (in x and y), and ∙ might not even be in scope where the</a>
<a id="2868" class="Comment">--   user wants us to solve! If they&#39;re solving an expression like</a>
<a id="2935" class="Comment">--   x + (y + z), they can pass in the +-0-monoid, but don&#39;t have to</a>
<a id="3004" class="Comment">--   open it themselves.</a>
<a id="3029" class="Comment">-- * If instead we tried to construct a term which accesses the _∙_</a>
<a id="3097" class="Comment">--   field on the reflection of the record, we&#39;d run into similar</a>
<a id="3163" class="Comment">--   problems again. While the record is a parameter for us, it might</a>
<a id="3233" class="Comment">--   not be for the user.</a>
<a id="3259" class="Comment">-- Basically, we need the Monoid we&#39;re looking at to be exactly the</a>
<a id="3327" class="Comment">-- same as the one the user is looking at, and in order to do that we</a>
<a id="3397" class="Comment">-- quote it at the call site.</a>

<a id="3428" class="Symbol">{-#</a> <a id="3432" class="Keyword">OPTIONS</a> <a id="3440" class="Pragma">--cubical-compatible</a> <a id="3461" class="Pragma">--safe</a> <a id="3468" class="Symbol">#-}</a>

<a id="3473" class="Keyword">module</a> <a id="3480" href="Tactic.MonoidSolver.html" class="Module">Tactic.MonoidSolver</a> <a id="3500" class="Keyword">where</a>

<a id="3507" class="Keyword">open</a> <a id="3512" class="Keyword">import</a> <a id="3519" href="Algebra.html" class="Module">Algebra</a>
<a id="3527" class="Keyword">open</a> <a id="3532" class="Keyword">import</a> <a id="3539" href="Function.Base.html" class="Module">Function.Base</a> <a id="3553" class="Keyword">using</a> <a id="3559" class="Symbol">(</a><a id="3560" href="Function.Base.html#4322" class="Function Operator">_⟨_⟩_</a><a id="3565" class="Symbol">)</a>

<a id="3568" class="Keyword">open</a> <a id="3573" class="Keyword">import</a> <a id="3580" href="Data.Bool.html" class="Module">Data.Bool</a>         <a id="3598" class="Symbol">as</a> <a id="3601" class="Module">Bool</a>    <a id="3609" class="Keyword">using</a> <a id="3615" class="Symbol">(</a><a id="3616" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a><a id="3620" class="Symbol">;</a> <a id="3622" href="Data.Bool.Base.html#1053" class="Function Operator">_∨_</a><a id="3625" class="Symbol">;</a> <a id="3627" href="Data.Bool.Base.html#1505" class="Function Operator">if_then_else_</a><a id="3640" class="Symbol">)</a>
<a id="3642" class="Keyword">open</a> <a id="3647" class="Keyword">import</a> <a id="3654" href="Data.Maybe.html" class="Module">Data.Maybe</a>        <a id="3672" class="Symbol">as</a> <a id="3675" class="Module">Maybe</a>   <a id="3683" class="Keyword">using</a> <a id="3689" class="Symbol">(</a><a id="3690" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a><a id="3695" class="Symbol">;</a> <a id="3697" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a><a id="3701" class="Symbol">;</a> <a id="3703" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a><a id="3710" class="Symbol">;</a> <a id="3712" href="Data.Maybe.Base.html#1391" class="Function">maybe</a><a id="3717" class="Symbol">)</a>
<a id="3719" class="Keyword">open</a> <a id="3724" class="Keyword">import</a> <a id="3731" href="Data.List.Base.html" class="Module">Data.List.Base</a>    <a id="3749" class="Symbol">as</a> <a id="3752" class="Module">List</a>    <a id="3760" class="Keyword">using</a> <a id="3766" class="Symbol">(</a><a id="3767" href="Agda.Builtin.List.html#147" class="Datatype">List</a><a id="3771" class="Symbol">;</a> <a id="3773" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">_∷_</a><a id="3776" class="Symbol">;</a> <a id="3778" href="Data.List.Base.html#7793" class="InductiveConstructor">[]</a><a id="3780" class="Symbol">)</a>
<a id="3782" class="Keyword">open</a> <a id="3787" class="Keyword">import</a> <a id="3794" href="Data.Nat.html" class="Module">Data.Nat</a>          <a id="3812" class="Symbol">as</a> <a id="3815" class="Module">ℕ</a>       <a id="3823" class="Keyword">using</a> <a id="3829" class="Symbol">(</a><a id="3830" href="Agda.Builtin.Nat.html#203" class="Datatype">ℕ</a><a id="3831" class="Symbol">;</a> <a id="3833" href="Agda.Builtin.Nat.html#234" class="InductiveConstructor">suc</a><a id="3836" class="Symbol">;</a> <a id="3838" href="Agda.Builtin.Nat.html#221" class="InductiveConstructor">zero</a><a id="3842" class="Symbol">)</a>
<a id="3844" class="Keyword">open</a> <a id="3849" class="Keyword">import</a> <a id="3856" href="Data.Product.Base.html" class="Module">Data.Product.Base</a> <a id="3874" class="Symbol">as</a> <a id="3877" class="Module">Product</a> <a id="3885" class="Keyword">using</a> <a id="3891" class="Symbol">(</a><a id="3892" href="Data.Product.Base.html#1618" class="Function Operator">_×_</a><a id="3895" class="Symbol">;</a> <a id="3897" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">_,_</a><a id="3900" class="Symbol">)</a>

<a id="3903" class="Keyword">open</a> <a id="3908" class="Keyword">import</a> <a id="3915" href="Reflection.AST.html" class="Module">Reflection.AST</a>
<a id="3930" class="Keyword">open</a> <a id="3935" class="Keyword">import</a> <a id="3942" href="Reflection.AST.Term.html" class="Module">Reflection.AST.Term</a>
<a id="3962" class="Keyword">open</a> <a id="3967" class="Keyword">import</a> <a id="3974" href="Reflection.AST.Argument.html" class="Module">Reflection.AST.Argument</a>
<a id="3998" class="Keyword">import</a> <a id="4005" href="Reflection.AST.Name.html" class="Module">Reflection.AST.Name</a> <a id="4025" class="Symbol">as</a> <a id="4028" class="Module">Name</a>
<a id="4033" class="Keyword">open</a> <a id="4038" class="Keyword">import</a> <a id="4045" href="Reflection.TCM.html" class="Module">Reflection.TCM</a>
<a id="4060" class="Keyword">open</a> <a id="4065" class="Keyword">import</a> <a id="4072" href="Reflection.TCM.Syntax.html" class="Module">Reflection.TCM.Syntax</a>

<a id="4095" class="Keyword">import</a> <a id="4102" href="Relation.Binary.Reasoning.Setoid.html" class="Module">Relation.Binary.Reasoning.Setoid</a> <a id="4135" class="Symbol">as</a> <a id="4138" class="Module">SetoidReasoning</a>

<a id="4155" class="Comment">------------------------------------------------------------------------</a>
<a id="4228" class="Comment">-- The Expr type with homomorphism proofs</a>
<a id="4270" class="Comment">------------------------------------------------------------------------</a>

<a id="4344" class="Keyword">infixl</a> <a id="4351" class="Number">7</a> <a id="4353" href="Tactic.MonoidSolver.html#4400" class="InductiveConstructor Operator">_∙′_</a>
<a id="4358" class="Keyword">data</a> <a id="Expr"></a><a id="4363" href="Tactic.MonoidSolver.html#4363" class="Datatype">Expr</a> <a id="4368" class="Symbol">{</a><a id="4369" href="Tactic.MonoidSolver.html#4369" class="Bound">a</a><a id="4370" class="Symbol">}</a> <a id="4372" class="Symbol">(</a><a id="4373" href="Tactic.MonoidSolver.html#4373" class="Bound">A</a> <a id="4375" class="Symbol">:</a> <a id="4377" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="4381" href="Tactic.MonoidSolver.html#4369" class="Bound">a</a><a id="4382" class="Symbol">)</a> <a id="4384" class="Symbol">:</a> <a id="4386" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="4390" href="Tactic.MonoidSolver.html#4369" class="Bound">a</a> <a id="4392" class="Keyword">where</a>
  <a id="Expr._∙′_"></a><a id="4400" href="Tactic.MonoidSolver.html#4400" class="InductiveConstructor Operator">_∙′_</a>  <a id="4406" class="Symbol">:</a> <a id="4408" href="Tactic.MonoidSolver.html#4363" class="Datatype">Expr</a> <a id="4413" href="Tactic.MonoidSolver.html#4373" class="Bound">A</a> <a id="4415" class="Symbol">→</a> <a id="4417" href="Tactic.MonoidSolver.html#4363" class="Datatype">Expr</a> <a id="4422" href="Tactic.MonoidSolver.html#4373" class="Bound">A</a> <a id="4424" class="Symbol">→</a> <a id="4426" href="Tactic.MonoidSolver.html#4363" class="Datatype">Expr</a> <a id="4431" href="Tactic.MonoidSolver.html#4373" class="Bound">A</a>
  <a id="Expr.ε′"></a><a id="4435" href="Tactic.MonoidSolver.html#4435" class="InductiveConstructor">ε′</a>    <a id="4441" class="Symbol">:</a> <a id="4443" href="Tactic.MonoidSolver.html#4363" class="Datatype">Expr</a> <a id="4448" href="Tactic.MonoidSolver.html#4373" class="Bound">A</a>
  <a id="Expr.[_↑]"></a><a id="4452" href="Tactic.MonoidSolver.html#4452" class="InductiveConstructor Operator">[_↑]</a>  <a id="4458" class="Symbol">:</a> <a id="4460" href="Tactic.MonoidSolver.html#4373" class="Bound">A</a> <a id="4462" class="Symbol">→</a> <a id="4464" href="Tactic.MonoidSolver.html#4363" class="Datatype">Expr</a> <a id="4469" href="Tactic.MonoidSolver.html#4373" class="Bound">A</a>

<a id="4472" class="Keyword">module</a> <a id="4479" href="Tactic.MonoidSolver.html#4479" class="Module">_</a> <a id="4481" class="Symbol">{</a><a id="4482" href="Tactic.MonoidSolver.html#4482" class="Bound">m₁</a> <a id="4485" href="Tactic.MonoidSolver.html#4485" class="Bound">m₂</a><a id="4487" class="Symbol">}</a> <a id="4489" class="Symbol">(</a><a id="4490" href="Tactic.MonoidSolver.html#4490" class="Bound">monoid</a> <a id="4497" class="Symbol">:</a> <a id="4499" href="Algebra.Bundles.html#6051" class="Record">Monoid</a> <a id="4506" href="Tactic.MonoidSolver.html#4482" class="Bound">m₁</a> <a id="4509" href="Tactic.MonoidSolver.html#4485" class="Bound">m₂</a><a id="4511" class="Symbol">)</a> <a id="4513" class="Keyword">where</a>

  <a id="4522" class="Keyword">open</a> <a id="4527" href="Algebra.Bundles.html#6051" class="Module">Monoid</a> <a id="4534" href="Tactic.MonoidSolver.html#4490" class="Bound">monoid</a>
  <a id="4543" class="Keyword">open</a> <a id="4548" href="Relation.Binary.Reasoning.Setoid.html" class="Module">SetoidReasoning</a> <a id="4564" href="Algebra.Structures.html#1390" class="Function">setoid</a>

  <a id="4574" class="Comment">-- Convert the AST to an expression (i.e. evaluate it) without</a>
  <a id="4639" class="Comment">-- normalising.</a>
  <a id="4657" href="Tactic.MonoidSolver.html#4657" class="Function Operator">[_↓]</a> <a id="4662" class="Symbol">:</a> <a id="4664" href="Tactic.MonoidSolver.html#4363" class="Datatype">Expr</a> <a id="4669" href="Algebra.Bundles.html#6130" class="Field">Carrier</a> <a id="4677" class="Symbol">→</a> <a id="4679" href="Algebra.Bundles.html#6130" class="Field">Carrier</a>
  <a id="4689" href="Tactic.MonoidSolver.html#4657" class="Function Operator">[</a> <a id="4691" href="Tactic.MonoidSolver.html#4691" class="Bound">x</a> <a id="4693" href="Tactic.MonoidSolver.html#4400" class="InductiveConstructor Operator">∙′</a> <a id="4696" href="Tactic.MonoidSolver.html#4696" class="Bound">y</a>  <a id="4699" href="Tactic.MonoidSolver.html#4657" class="Function Operator">↓]</a> <a id="4702" class="Symbol">=</a> <a id="4704" href="Tactic.MonoidSolver.html#4657" class="Function Operator">[</a> <a id="4706" href="Tactic.MonoidSolver.html#4691" class="Bound">x</a> <a id="4708" href="Tactic.MonoidSolver.html#4657" class="Function Operator">↓]</a> <a id="4711" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="4713" href="Tactic.MonoidSolver.html#4657" class="Function Operator">[</a> <a id="4715" href="Tactic.MonoidSolver.html#4696" class="Bound">y</a> <a id="4717" href="Tactic.MonoidSolver.html#4657" class="Function Operator">↓]</a>
  <a id="4722" href="Tactic.MonoidSolver.html#4657" class="Function Operator">[</a> <a id="4724" href="Tactic.MonoidSolver.html#4435" class="InductiveConstructor">ε′</a>      <a id="4732" href="Tactic.MonoidSolver.html#4657" class="Function Operator">↓]</a> <a id="4735" class="Symbol">=</a> <a id="4737" href="Algebra.Bundles.html#6207" class="Field">ε</a>
  <a id="4741" href="Tactic.MonoidSolver.html#4657" class="Function Operator">[</a> <a id="4743" href="Tactic.MonoidSolver.html#4452" class="InductiveConstructor Operator">[</a> <a id="4745" href="Tactic.MonoidSolver.html#4745" class="Bound">x</a> <a id="4747" href="Tactic.MonoidSolver.html#4452" class="InductiveConstructor Operator">↑]</a>  <a id="4751" href="Tactic.MonoidSolver.html#4657" class="Function Operator">↓]</a> <a id="4754" class="Symbol">=</a> <a id="4756" href="Tactic.MonoidSolver.html#4745" class="Bound">x</a>

  <a id="4761" class="Comment">-- Convert an AST to an expression (i.e. evaluate it) while</a>
  <a id="4823" class="Comment">-- normalising.</a>
  <a id="4841" class="Comment">--</a>
  <a id="4846" class="Comment">-- This first function actually converts an AST to the Cayley</a>
  <a id="4910" class="Comment">-- representation of the underlying monoid.</a>
  <a id="4956" class="Comment">-- This obeys the monoid laws up to beta-eta equality, which is the</a>
  <a id="5026" class="Comment">-- property which gives us the &quot;normalising&quot; behaviour we want.</a>
  <a id="5092" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[_⇓]′</a> <a id="5098" class="Symbol">:</a> <a id="5100" href="Tactic.MonoidSolver.html#4363" class="Datatype">Expr</a> <a id="5105" href="Algebra.Bundles.html#6130" class="Field">Carrier</a> <a id="5113" class="Symbol">→</a> <a id="5115" href="Algebra.Bundles.html#6130" class="Field">Carrier</a> <a id="5123" class="Symbol">→</a> <a id="5125" href="Algebra.Bundles.html#6130" class="Field">Carrier</a>
  <a id="5135" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5137" href="Tactic.MonoidSolver.html#5137" class="Bound">x</a> <a id="5139" href="Tactic.MonoidSolver.html#4400" class="InductiveConstructor Operator">∙′</a> <a id="5142" href="Tactic.MonoidSolver.html#5142" class="Bound">y</a>  <a id="5145" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5149" href="Tactic.MonoidSolver.html#5149" class="Bound">z</a> <a id="5151" class="Symbol">=</a> <a id="5153" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5155" href="Tactic.MonoidSolver.html#5137" class="Bound">x</a> <a id="5157" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5161" class="Symbol">(</a><a id="5162" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5164" href="Tactic.MonoidSolver.html#5142" class="Bound">y</a> <a id="5166" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5170" href="Tactic.MonoidSolver.html#5149" class="Bound">z</a><a id="5171" class="Symbol">)</a>
  <a id="5175" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5177" href="Tactic.MonoidSolver.html#4435" class="InductiveConstructor">ε′</a>      <a id="5185" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5189" href="Tactic.MonoidSolver.html#5189" class="Bound">y</a> <a id="5191" class="Symbol">=</a> <a id="5193" href="Tactic.MonoidSolver.html#5189" class="Bound">y</a>
  <a id="5197" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5199" href="Tactic.MonoidSolver.html#4452" class="InductiveConstructor Operator">[</a> <a id="5201" href="Tactic.MonoidSolver.html#5201" class="Bound">x</a> <a id="5203" href="Tactic.MonoidSolver.html#4452" class="InductiveConstructor Operator">↑]</a>  <a id="5207" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5211" href="Tactic.MonoidSolver.html#5211" class="Bound">y</a> <a id="5213" class="Symbol">=</a> <a id="5215" href="Tactic.MonoidSolver.html#5201" class="Bound">x</a> <a id="5217" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="5219" href="Tactic.MonoidSolver.html#5211" class="Bound">y</a>

  <a id="5224" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[_⇓]</a> <a id="5229" class="Symbol">:</a> <a id="5231" href="Tactic.MonoidSolver.html#4363" class="Datatype">Expr</a> <a id="5236" href="Algebra.Bundles.html#6130" class="Field">Carrier</a> <a id="5244" class="Symbol">→</a> <a id="5246" href="Algebra.Bundles.html#6130" class="Field">Carrier</a>
  <a id="5256" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5258" href="Tactic.MonoidSolver.html#5258" class="Bound">x</a> <a id="5260" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5263" class="Symbol">=</a> <a id="5265" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5267" href="Tactic.MonoidSolver.html#5258" class="Bound">x</a> <a id="5269" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5273" href="Algebra.Bundles.html#6207" class="Field">ε</a>

  <a id="5278" href="Tactic.MonoidSolver.html#5278" class="Function">homo′</a> <a id="5284" class="Symbol">:</a> <a id="5286" class="Symbol">∀</a> <a id="5288" href="Tactic.MonoidSolver.html#5288" class="Bound">x</a> <a id="5290" href="Tactic.MonoidSolver.html#5290" class="Bound">y</a> <a id="5292" class="Symbol">→</a> <a id="5294" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5296" href="Tactic.MonoidSolver.html#5288" class="Bound">x</a> <a id="5298" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5301" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="5303" href="Tactic.MonoidSolver.html#5290" class="Bound">y</a> <a id="5305" href="Algebra.Bundles.html#6151" class="Field Operator">≈</a> <a id="5307" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5309" href="Tactic.MonoidSolver.html#5288" class="Bound">x</a> <a id="5311" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5315" href="Tactic.MonoidSolver.html#5290" class="Bound">y</a>
  <a id="5319" href="Tactic.MonoidSolver.html#5278" class="Function">homo′</a> <a id="5325" href="Tactic.MonoidSolver.html#4435" class="InductiveConstructor">ε′</a> <a id="5328" href="Tactic.MonoidSolver.html#5328" class="Bound">y</a>       <a id="5336" class="Symbol">=</a> <a id="5338" href="Algebra.Structures.html#4136" class="Function">identityˡ</a> <a id="5348" href="Tactic.MonoidSolver.html#5328" class="Bound">y</a>
  <a id="5352" href="Tactic.MonoidSolver.html#5278" class="Function">homo′</a> <a id="5358" href="Tactic.MonoidSolver.html#4452" class="InductiveConstructor Operator">[</a> <a id="5360" href="Tactic.MonoidSolver.html#5360" class="Bound">x</a> <a id="5362" href="Tactic.MonoidSolver.html#4452" class="InductiveConstructor Operator">↑]</a> <a id="5365" href="Tactic.MonoidSolver.html#5365" class="Bound">y</a>   <a id="5369" class="Symbol">=</a> <a id="5371" href="Algebra.Structures.html#1526" class="Function">∙-congʳ</a> <a id="5379" class="Symbol">(</a><a id="5380" href="Algebra.Structures.html#4197" class="Function">identityʳ</a> <a id="5390" href="Tactic.MonoidSolver.html#5360" class="Bound">x</a><a id="5391" class="Symbol">)</a>
  <a id="5395" href="Tactic.MonoidSolver.html#5278" class="Function">homo′</a> <a id="5401" class="Symbol">(</a><a id="5402" href="Tactic.MonoidSolver.html#5402" class="Bound">x</a> <a id="5404" href="Tactic.MonoidSolver.html#4400" class="InductiveConstructor Operator">∙′</a> <a id="5407" href="Tactic.MonoidSolver.html#5407" class="Bound">y</a><a id="5408" class="Symbol">)</a> <a id="5410" href="Tactic.MonoidSolver.html#5410" class="Bound">z</a> <a id="5412" class="Symbol">=</a> <a id="5414" href="Relation.Binary.Reasoning.Syntax.html#1510" class="Function Operator">begin</a>
    <a id="5424" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5426" href="Tactic.MonoidSolver.html#5402" class="Bound">x</a> <a id="5428" href="Tactic.MonoidSolver.html#4400" class="InductiveConstructor Operator">∙′</a> <a id="5431" href="Tactic.MonoidSolver.html#5407" class="Bound">y</a> <a id="5433" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5436" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="5438" href="Tactic.MonoidSolver.html#5410" class="Bound">z</a>       <a id="5446" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
    <a id="5454" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5456" href="Tactic.MonoidSolver.html#5402" class="Bound">x</a> <a id="5458" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5462" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5464" href="Tactic.MonoidSolver.html#5407" class="Bound">y</a> <a id="5466" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5469" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="5471" href="Tactic.MonoidSolver.html#5410" class="Bound">z</a>    <a id="5476" href="Relation.Binary.Reasoning.Syntax.html#7074" class="Function">≈⟨</a> <a id="5479" href="Algebra.Structures.html#1526" class="Function">∙-congʳ</a> <a id="5487" class="Symbol">(</a><a id="5488" href="Tactic.MonoidSolver.html#5278" class="Function">homo′</a> <a id="5494" href="Tactic.MonoidSolver.html#5402" class="Bound">x</a> <a id="5496" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5498" href="Tactic.MonoidSolver.html#5407" class="Bound">y</a> <a id="5500" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a><a id="5502" class="Symbol">)</a> <a id="5504" href="Relation.Binary.Reasoning.Syntax.html#7074" class="Function">⟨</a>
    <a id="5510" class="Symbol">(</a><a id="5511" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5513" href="Tactic.MonoidSolver.html#5402" class="Bound">x</a> <a id="5515" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5518" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="5520" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5522" href="Tactic.MonoidSolver.html#5407" class="Bound">y</a> <a id="5524" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a><a id="5526" class="Symbol">)</a> <a id="5528" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="5530" href="Tactic.MonoidSolver.html#5410" class="Bound">z</a> <a id="5532" href="Relation.Binary.Reasoning.Syntax.html#7049" class="Function">≈⟨</a> <a id="5535" href="Algebra.Structures.html#2977" class="Function">assoc</a> <a id="5541" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5543" href="Tactic.MonoidSolver.html#5402" class="Bound">x</a> <a id="5545" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5548" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5550" href="Tactic.MonoidSolver.html#5407" class="Bound">y</a> <a id="5552" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5555" href="Tactic.MonoidSolver.html#5410" class="Bound">z</a> <a id="5557" href="Relation.Binary.Reasoning.Syntax.html#7049" class="Function">⟩</a>
    <a id="5563" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5565" href="Tactic.MonoidSolver.html#5402" class="Bound">x</a> <a id="5567" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5570" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="5572" class="Symbol">(</a><a id="5573" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5575" href="Tactic.MonoidSolver.html#5407" class="Bound">y</a> <a id="5577" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5580" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="5582" href="Tactic.MonoidSolver.html#5410" class="Bound">z</a><a id="5583" class="Symbol">)</a> <a id="5585" href="Relation.Binary.Reasoning.Syntax.html#7049" class="Function">≈⟨</a> <a id="5588" href="Algebra.Structures.html#1465" class="Function">∙-congˡ</a> <a id="5596" class="Symbol">(</a><a id="5597" href="Tactic.MonoidSolver.html#5278" class="Function">homo′</a> <a id="5603" href="Tactic.MonoidSolver.html#5407" class="Bound">y</a> <a id="5605" href="Tactic.MonoidSolver.html#5410" class="Bound">z</a><a id="5606" class="Symbol">)</a> <a id="5608" href="Relation.Binary.Reasoning.Syntax.html#7049" class="Function">⟩</a>
    <a id="5614" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5616" href="Tactic.MonoidSolver.html#5402" class="Bound">x</a> <a id="5618" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5621" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="5623" class="Symbol">(</a><a id="5624" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5626" href="Tactic.MonoidSolver.html#5407" class="Bound">y</a> <a id="5628" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5632" href="Tactic.MonoidSolver.html#5410" class="Bound">z</a><a id="5633" class="Symbol">)</a>  <a id="5636" href="Relation.Binary.Reasoning.Syntax.html#7049" class="Function">≈⟨</a> <a id="5639" href="Tactic.MonoidSolver.html#5278" class="Function">homo′</a> <a id="5645" href="Tactic.MonoidSolver.html#5402" class="Bound">x</a> <a id="5647" class="Symbol">(</a><a id="5648" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5650" href="Tactic.MonoidSolver.html#5407" class="Bound">y</a> <a id="5652" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5656" href="Tactic.MonoidSolver.html#5410" class="Bound">z</a><a id="5657" class="Symbol">)</a> <a id="5659" href="Relation.Binary.Reasoning.Syntax.html#7049" class="Function">⟩</a>
    <a id="5665" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5667" href="Tactic.MonoidSolver.html#5402" class="Bound">x</a> <a id="5669" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5673" class="Symbol">(</a><a id="5674" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5676" href="Tactic.MonoidSolver.html#5407" class="Bound">y</a> <a id="5678" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5682" href="Tactic.MonoidSolver.html#5410" class="Bound">z</a><a id="5683" class="Symbol">)</a>   <a id="5687" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a>

  <a id="5692" href="Tactic.MonoidSolver.html#5692" class="Function">homo</a> <a id="5697" class="Symbol">:</a> <a id="5699" class="Symbol">∀</a> <a id="5701" href="Tactic.MonoidSolver.html#5701" class="Bound">x</a> <a id="5703" class="Symbol">→</a> <a id="5705" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5707" href="Tactic.MonoidSolver.html#5701" class="Bound">x</a> <a id="5709" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5712" href="Algebra.Bundles.html#6151" class="Field Operator">≈</a> <a id="5714" href="Tactic.MonoidSolver.html#4657" class="Function Operator">[</a> <a id="5716" href="Tactic.MonoidSolver.html#5701" class="Bound">x</a> <a id="5718" href="Tactic.MonoidSolver.html#4657" class="Function Operator">↓]</a>
  <a id="5723" href="Tactic.MonoidSolver.html#5692" class="Function">homo</a> <a id="5728" href="Tactic.MonoidSolver.html#4435" class="InductiveConstructor">ε′</a>       <a id="5737" class="Symbol">=</a> <a id="5739" href="Relation.Binary.Structures.html#1596" class="Function">refl</a>
  <a id="5746" href="Tactic.MonoidSolver.html#5692" class="Function">homo</a> <a id="5751" href="Tactic.MonoidSolver.html#4452" class="InductiveConstructor Operator">[</a> <a id="5753" href="Tactic.MonoidSolver.html#5753" class="Bound">x</a> <a id="5755" href="Tactic.MonoidSolver.html#4452" class="InductiveConstructor Operator">↑]</a>   <a id="5760" class="Symbol">=</a> <a id="5762" href="Algebra.Structures.html#4197" class="Function">identityʳ</a> <a id="5772" href="Tactic.MonoidSolver.html#5753" class="Bound">x</a>
  <a id="5776" href="Tactic.MonoidSolver.html#5692" class="Function">homo</a> <a id="5781" class="Symbol">(</a><a id="5782" href="Tactic.MonoidSolver.html#5782" class="Bound">x</a> <a id="5784" href="Tactic.MonoidSolver.html#4400" class="InductiveConstructor Operator">∙′</a> <a id="5787" href="Tactic.MonoidSolver.html#5787" class="Bound">y</a><a id="5788" class="Symbol">)</a> <a id="5790" class="Symbol">=</a> <a id="5792" href="Relation.Binary.Reasoning.Syntax.html#1510" class="Function Operator">begin</a>
    <a id="5802" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5804" href="Tactic.MonoidSolver.html#5782" class="Bound">x</a> <a id="5806" href="Tactic.MonoidSolver.html#4400" class="InductiveConstructor Operator">∙′</a> <a id="5809" href="Tactic.MonoidSolver.html#5787" class="Bound">y</a> <a id="5811" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a>     <a id="5818" href="Relation.Binary.Reasoning.Syntax.html#11017" class="Function">≡⟨⟩</a>
    <a id="5826" href="Tactic.MonoidSolver.html#5092" class="Function Operator">[</a> <a id="5828" href="Tactic.MonoidSolver.html#5782" class="Bound">x</a> <a id="5830" href="Tactic.MonoidSolver.html#5092" class="Function Operator">⇓]′</a> <a id="5834" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5836" href="Tactic.MonoidSolver.html#5787" class="Bound">y</a> <a id="5838" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a>  <a id="5842" href="Relation.Binary.Reasoning.Syntax.html#7074" class="Function">≈⟨</a> <a id="5845" href="Tactic.MonoidSolver.html#5278" class="Function">homo′</a> <a id="5851" href="Tactic.MonoidSolver.html#5782" class="Bound">x</a> <a id="5853" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5855" href="Tactic.MonoidSolver.html#5787" class="Bound">y</a> <a id="5857" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5860" href="Relation.Binary.Reasoning.Syntax.html#7074" class="Function">⟨</a>
    <a id="5866" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5868" href="Tactic.MonoidSolver.html#5782" class="Bound">x</a> <a id="5870" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5873" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="5875" href="Tactic.MonoidSolver.html#5224" class="Function Operator">[</a> <a id="5877" href="Tactic.MonoidSolver.html#5787" class="Bound">y</a> <a id="5879" href="Tactic.MonoidSolver.html#5224" class="Function Operator">⇓]</a> <a id="5882" href="Relation.Binary.Reasoning.Syntax.html#7049" class="Function">≈⟨</a> <a id="5885" href="Algebra.Structures.html#1315" class="Function">∙-cong</a> <a id="5892" class="Symbol">(</a><a id="5893" href="Tactic.MonoidSolver.html#5692" class="Function">homo</a> <a id="5898" href="Tactic.MonoidSolver.html#5782" class="Bound">x</a><a id="5899" class="Symbol">)</a> <a id="5901" class="Symbol">(</a><a id="5902" href="Tactic.MonoidSolver.html#5692" class="Function">homo</a> <a id="5907" href="Tactic.MonoidSolver.html#5787" class="Bound">y</a><a id="5908" class="Symbol">)</a> <a id="5910" href="Relation.Binary.Reasoning.Syntax.html#7049" class="Function">⟩</a>
    <a id="5916" href="Tactic.MonoidSolver.html#4657" class="Function Operator">[</a> <a id="5918" href="Tactic.MonoidSolver.html#5782" class="Bound">x</a> <a id="5920" href="Tactic.MonoidSolver.html#4657" class="Function Operator">↓]</a> <a id="5923" href="Algebra.Bundles.html#6180" class="Field Operator">∙</a> <a id="5925" href="Tactic.MonoidSolver.html#4657" class="Function Operator">[</a> <a id="5927" href="Tactic.MonoidSolver.html#5787" class="Bound">y</a> <a id="5929" href="Tactic.MonoidSolver.html#4657" class="Function Operator">↓]</a> <a id="5932" href="Relation.Binary.Reasoning.Syntax.html#12283" class="Function Operator">∎</a>

<a id="5935" class="Comment">------------------------------------------------------------------------</a>
<a id="6008" class="Comment">-- Helpers for reflection</a>
<a id="6034" class="Comment">------------------------------------------------------------------------</a>

<a id="getArgs"></a><a id="6108" href="Tactic.MonoidSolver.html#6108" class="Function">getArgs</a> <a id="6116" class="Symbol">:</a> <a id="6118" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6123" class="Symbol">→</a> <a id="6125" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="6131" class="Symbol">(</a><a id="6132" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6137" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6139" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="6143" class="Symbol">)</a>
<a id="6145" href="Tactic.MonoidSolver.html#6108" class="Function">getArgs</a> <a id="6153" class="Symbol">(</a><a id="6154" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="6158" class="Symbol">_</a> <a id="6160" href="Tactic.MonoidSolver.html#6160" class="Bound">xs</a><a id="6162" class="Symbol">)</a> <a id="6164" class="Symbol">=</a> <a id="6166" href="Tactic.MonoidSolver.html#6182" class="Function">go</a> <a id="6169" href="Tactic.MonoidSolver.html#6160" class="Bound">xs</a>
  <a id="6174" class="Keyword">where</a>
  <a id="6182" href="Tactic.MonoidSolver.html#6182" class="Function">go</a> <a id="6185" class="Symbol">:</a> <a id="6187" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="6192" class="Symbol">(</a><a id="6193" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="6197" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="6201" class="Symbol">)</a> <a id="6203" class="Symbol">→</a> <a id="6205" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="6211" class="Symbol">(</a><a id="6212" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="6217" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="6219" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="6223" class="Symbol">)</a>
  <a id="6227" href="Tactic.MonoidSolver.html#6182" class="Function">go</a> <a id="6230" class="Symbol">(</a><a id="6231" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="6236" href="Tactic.MonoidSolver.html#6236" class="Bound">x</a> <a id="6238" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6240" href="Reflection.AST.Argument.html#1329" class="InductiveConstructor">vArg</a> <a id="6245" href="Tactic.MonoidSolver.html#6245" class="Bound">y</a> <a id="6247" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="6249" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="6251" class="Symbol">)</a> <a id="6253" class="Symbol">=</a> <a id="6255" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="6260" class="Symbol">(</a><a id="6261" href="Tactic.MonoidSolver.html#6236" class="Bound">x</a> <a id="6263" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="6265" href="Tactic.MonoidSolver.html#6245" class="Bound">y</a><a id="6266" class="Symbol">)</a>
  <a id="6270" href="Tactic.MonoidSolver.html#6182" class="CatchallClause Function">go</a><a id="6272" class="CatchallClause"> </a><a id="6273" class="CatchallClause Symbol">(</a><a id="6274" href="Tactic.MonoidSolver.html#6274" class="CatchallClause Bound">x</a><a id="6275" class="CatchallClause"> </a><a id="6276" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="6277" class="CatchallClause"> </a><a id="6278" href="Tactic.MonoidSolver.html#6278" class="CatchallClause Bound">xs</a><a id="6280" class="CatchallClause Symbol">)</a>               <a id="6296" class="Symbol">=</a> <a id="6298" href="Tactic.MonoidSolver.html#6182" class="Function">go</a> <a id="6301" href="Tactic.MonoidSolver.html#6278" class="Bound">xs</a>
  <a id="6306" href="Tactic.MonoidSolver.html#6182" class="CatchallClause Function">go</a><a id="6308" class="CatchallClause"> </a><a id="6309" class="CatchallClause Symbol">_</a>                      <a id="6332" class="Symbol">=</a> <a id="6334" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>
<a id="6342" href="Tactic.MonoidSolver.html#6108" class="CatchallClause Function">getArgs</a><a id="6349" class="CatchallClause"> </a><a id="6350" class="CatchallClause Symbol">_</a> <a id="6352" class="Symbol">=</a> <a id="6354" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>

<a id="6363" class="Comment">------------------------------------------------------------------------</a>
<a id="6436" class="Comment">-- Getting monoid names</a>
<a id="6460" class="Comment">------------------------------------------------------------------------</a>

<a id="6534" class="Comment">-- We try to be flexible here, by matching two kinds of names.</a>
<a id="6597" class="Comment">-- The first is the field accessor for the monoid record itself.</a>
<a id="6662" class="Comment">-- However, users will likely want to use the solver with</a>
<a id="6720" class="Comment">-- expressions like:</a>
<a id="6741" class="Comment">--</a>
<a id="6744" class="Comment">--   xs ++ (ys ++ zs) ≡ (xs ++ ys) ++ zs</a>
<a id="6785" class="Comment">--</a>
<a id="6788" class="Comment">-- So we also evaluate the field accessor to find functions like ++.</a>

<a id="6858" class="Keyword">record</a> <a id="MonoidNames"></a><a id="6865" href="Tactic.MonoidSolver.html#6865" class="Record">MonoidNames</a> <a id="6877" class="Symbol">:</a> <a id="6879" href="Agda.Primitive.html#388" class="Primitive">Set</a> <a id="6883" class="Keyword">where</a>
  <a id="6891" class="Keyword">field</a>
    <a id="MonoidNames.is-∙"></a><a id="6901" href="Tactic.MonoidSolver.html#6901" class="Field">is-∙</a> <a id="6906" class="Symbol">:</a> <a id="6908" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="6913" class="Symbol">→</a> <a id="6915" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
    <a id="MonoidNames.is-ε"></a><a id="6924" href="Tactic.MonoidSolver.html#6924" class="Field">is-ε</a> <a id="6929" class="Symbol">:</a> <a id="6931" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="6936" class="Symbol">→</a> <a id="6938" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>

<a id="buildMatcher"></a><a id="6944" href="Tactic.MonoidSolver.html#6944" class="Function">buildMatcher</a> <a id="6957" class="Symbol">:</a> <a id="6959" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="6964" class="Symbol">→</a> <a id="6966" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="6972" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="6977" class="Symbol">→</a> <a id="6979" href="Agda.Builtin.Reflection.html#488" class="Postulate">Name</a> <a id="6984" class="Symbol">→</a> <a id="6986" href="Agda.Builtin.Bool.html#173" class="Datatype">Bool</a>
<a id="6991" href="Tactic.MonoidSolver.html#6944" class="Function">buildMatcher</a> <a id="7004" href="Tactic.MonoidSolver.html#7004" class="Bound">n</a> <a id="7006" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a>  <a id="7015" href="Tactic.MonoidSolver.html#7015" class="Bound">x</a> <a id="7017" class="Symbol">=</a> <a id="7019" href="Tactic.MonoidSolver.html#7004" class="Bound">n</a> <a id="7021" href="Agda.Builtin.Reflection.html#539" class="Primitive Operator">Name.≡ᵇ</a> <a id="7029" href="Tactic.MonoidSolver.html#7015" class="Bound">x</a>
<a id="7031" href="Tactic.MonoidSolver.html#6944" class="Function">buildMatcher</a> <a id="7044" href="Tactic.MonoidSolver.html#7044" class="Bound">n</a> <a id="7046" class="Symbol">(</a><a id="7047" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="7052" href="Tactic.MonoidSolver.html#7052" class="Bound">m</a><a id="7053" class="Symbol">)</a> <a id="7055" href="Tactic.MonoidSolver.html#7055" class="Bound">x</a> <a id="7057" class="Symbol">=</a> <a id="7059" href="Tactic.MonoidSolver.html#7044" class="Bound">n</a> <a id="7061" href="Agda.Builtin.Reflection.html#539" class="Primitive Operator">Name.≡ᵇ</a> <a id="7069" href="Tactic.MonoidSolver.html#7055" class="Bound">x</a> <a id="7071" href="Data.Bool.Base.html#1053" class="Function Operator">∨</a> <a id="7073" href="Tactic.MonoidSolver.html#7052" class="Bound">m</a> <a id="7075" href="Agda.Builtin.Reflection.html#539" class="Primitive Operator">Name.≡ᵇ</a> <a id="7083" href="Tactic.MonoidSolver.html#7055" class="Bound">x</a>

<a id="findMonoidNames"></a><a id="7086" href="Tactic.MonoidSolver.html#7086" class="Function">findMonoidNames</a> <a id="7102" class="Symbol">:</a> <a id="7104" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7109" class="Symbol">→</a> <a id="7111" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="7114" href="Tactic.MonoidSolver.html#6865" class="Record">MonoidNames</a>
<a id="7126" href="Tactic.MonoidSolver.html#7086" class="Function">findMonoidNames</a> <a id="7142" href="Tactic.MonoidSolver.html#7142" class="Bound">mon</a> <a id="7146" class="Symbol">=</a> <a id="7148" class="Keyword">do</a>
  <a id="7153" href="Tactic.MonoidSolver.html#7153" class="Bound">∙-altName</a> <a id="7163" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7165" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="7175" class="Symbol">(</a><a id="7176" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="7180" class="Symbol">(</a><a id="7181" class="Keyword">quote</a> <a id="7187" href="Algebra.Bundles.html#6180" class="Field Operator">Monoid._∙_</a><a id="7197" class="Symbol">)</a> <a id="7199" class="Symbol">(</a><a id="7200" class="Number">2</a> <a id="7202" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="7207" href="Tactic.MonoidSolver.html#7142" class="Bound">mon</a> <a id="7211" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7215" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7217" class="Symbol">))</a>
  <a id="7222" href="Tactic.MonoidSolver.html#7222" class="Bound">ε-altName</a> <a id="7232" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7234" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a> <a id="7244" class="Symbol">(</a><a id="7245" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="7249" class="Symbol">(</a><a id="7250" class="Keyword">quote</a> <a id="7256" href="Algebra.Bundles.html#6207" class="Field">Monoid.ε</a><a id="7264" class="Symbol">)</a>   <a id="7268" class="Symbol">(</a><a id="7269" class="Number">2</a> <a id="7271" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="7276" href="Tactic.MonoidSolver.html#7142" class="Bound">mon</a> <a id="7280" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7284" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7286" class="Symbol">))</a>
  <a id="7291" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="7296" class="Keyword">record</a>
    <a id="7307" class="Symbol">{</a> <a id="7309" href="Tactic.MonoidSolver.html#6901" class="Field">is-∙</a> <a id="7314" class="Symbol">=</a> <a id="7316" href="Tactic.MonoidSolver.html#6944" class="Function">buildMatcher</a> <a id="7329" class="Symbol">(</a><a id="7330" class="Keyword">quote</a> <a id="7336" href="Algebra.Bundles.html#6180" class="Field Operator">Monoid._∙_</a><a id="7346" class="Symbol">)</a> <a id="7348" class="Symbol">(</a><a id="7349" href="Reflection.AST.Term.html#2566" class="Function">getName</a> <a id="7357" href="Tactic.MonoidSolver.html#7153" class="Bound">∙-altName</a><a id="7366" class="Symbol">)</a>
    <a id="7372" class="Symbol">;</a> <a id="7374" href="Tactic.MonoidSolver.html#6924" class="Field">is-ε</a> <a id="7379" class="Symbol">=</a> <a id="7381" href="Tactic.MonoidSolver.html#6944" class="Function">buildMatcher</a> <a id="7394" class="Symbol">(</a><a id="7395" class="Keyword">quote</a> <a id="7401" href="Algebra.Bundles.html#6207" class="Field">Monoid.ε</a><a id="7409" class="Symbol">)</a>   <a id="7413" class="Symbol">(</a><a id="7414" href="Reflection.AST.Term.html#2566" class="Function">getName</a> <a id="7422" href="Tactic.MonoidSolver.html#7222" class="Bound">ε-altName</a><a id="7431" class="Symbol">)</a>
    <a id="7437" class="Symbol">}</a>

<a id="7440" class="Comment">------------------------------------------------------------------------</a>
<a id="7513" class="Comment">-- Building Expr</a>
<a id="7530" class="Comment">------------------------------------------------------------------------</a>

<a id="7604" class="Comment">-- We now define a function that takes an AST representing the LHS</a>
<a id="7671" class="Comment">-- or RHS of the equation to solve and converts it into an AST</a>
<a id="7734" class="Comment">-- respresenting the corresponding Expr.</a>

<a id="″ε″"></a><a id="7776" href="Tactic.MonoidSolver.html#7776" class="Function">″ε″</a> <a id="7780" class="Symbol">:</a> <a id="7782" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="7787" href="Tactic.MonoidSolver.html#7776" class="Function">″ε″</a> <a id="7791" class="Symbol">=</a> <a id="7793" class="Keyword">quote</a> <a id="7799" href="Tactic.MonoidSolver.html#4435" class="InductiveConstructor">ε′</a> <a id="7802" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="7804" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="7808" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="7810" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="[_↑]′"></a><a id="7814" href="Tactic.MonoidSolver.html#7814" class="Function Operator">[_↑]′</a> <a id="7820" class="Symbol">:</a> <a id="7822" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="7827" class="Symbol">→</a> <a id="7829" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="7834" href="Tactic.MonoidSolver.html#7814" class="Function Operator">[</a> <a id="7836" href="Tactic.MonoidSolver.html#7836" class="Bound">t</a> <a id="7838" href="Tactic.MonoidSolver.html#7814" class="Function Operator">↑]′</a> <a id="7842" class="Symbol">=</a> <a id="7844" class="Keyword">quote</a> <a id="7850" href="Tactic.MonoidSolver.html#4452" class="InductiveConstructor Operator">[_↑]</a> <a id="7855" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="7857" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="7861" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="7863" class="Symbol">(</a><a id="7864" href="Tactic.MonoidSolver.html#7836" class="Bound">t</a> <a id="7866" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7870" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7872" class="Symbol">)</a>

<a id="7875" class="Keyword">module</a> <a id="7882" href="Tactic.MonoidSolver.html#7882" class="Module">_</a> <a id="7884" class="Symbol">(</a><a id="7885" href="Tactic.MonoidSolver.html#7885" class="Bound">names</a> <a id="7891" class="Symbol">:</a> <a id="7893" href="Tactic.MonoidSolver.html#6865" class="Record">MonoidNames</a><a id="7904" class="Symbol">)</a> <a id="7906" class="Keyword">where</a>

 <a id="7914" class="Keyword">open</a> <a id="7919" href="Tactic.MonoidSolver.html#6865" class="Module">MonoidNames</a> <a id="7931" href="Tactic.MonoidSolver.html#7885" class="Bound">names</a>

 <a id="7939" class="Keyword">mutual</a>
  <a id="7948" href="Tactic.MonoidSolver.html#7948" class="Function">″∙″</a> <a id="7952" class="Symbol">:</a> <a id="7954" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="7959" class="Symbol">(</a><a id="7960" href="Agda.Builtin.Reflection.html#3696" class="Datatype">Arg</a> <a id="7964" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a><a id="7968" class="Symbol">)</a> <a id="7970" class="Symbol">→</a> <a id="7972" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="7979" href="Tactic.MonoidSolver.html#7948" class="Function">″∙″</a> <a id="7983" class="Symbol">(</a><a id="7984" href="Tactic.MonoidSolver.html#7984" class="Bound">x</a> <a id="7986" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7990" href="Tactic.MonoidSolver.html#7990" class="Bound">y</a> <a id="7992" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7996" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="7998" class="Symbol">)</a> <a id="8000" class="Symbol">=</a> <a id="8002" class="Keyword">quote</a> <a id="8008" href="Tactic.MonoidSolver.html#4400" class="InductiveConstructor Operator">_∙′_</a> <a id="8013" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="8015" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="8019" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="8021" href="Tactic.MonoidSolver.html#8124" class="Function">buildExpr</a> <a id="8031" href="Tactic.MonoidSolver.html#7984" class="Bound">x</a> <a id="8033" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8037" href="Tactic.MonoidSolver.html#8124" class="Function">buildExpr</a> <a id="8047" href="Tactic.MonoidSolver.html#7990" class="Bound">y</a> <a id="8049" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8053" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>
  <a id="8058" href="Tactic.MonoidSolver.html#7948" class="CatchallClause Function">″∙″</a><a id="8061" class="CatchallClause"> </a><a id="8062" class="CatchallClause Symbol">(</a><a id="8063" href="Tactic.MonoidSolver.html#8063" class="CatchallClause Bound">x</a><a id="8064" class="CatchallClause"> </a><a id="8065" href="Agda.Builtin.List.html#199" class="CatchallClause InductiveConstructor Operator">∷</a><a id="8066" class="CatchallClause"> </a><a id="8067" href="Tactic.MonoidSolver.html#8067" class="CatchallClause Bound">xs</a><a id="8069" class="CatchallClause Symbol">)</a>         <a id="8079" class="Symbol">=</a> <a id="8081" href="Tactic.MonoidSolver.html#7948" class="Function">″∙″</a> <a id="8085" href="Tactic.MonoidSolver.html#8067" class="Bound">xs</a>
  <a id="8090" href="Tactic.MonoidSolver.html#7948" class="CatchallClause Function">″∙″</a><a id="8093" class="CatchallClause"> </a><a id="8094" class="CatchallClause Symbol">_</a>                <a id="8111" class="Symbol">=</a> <a id="8113" href="Agda.Builtin.Reflection.html#5594" class="InductiveConstructor">unknown</a>

  <a id="8124" href="Tactic.MonoidSolver.html#8124" class="Function">buildExpr</a> <a id="8134" class="Symbol">:</a> <a id="8136" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8141" class="Symbol">→</a> <a id="8143" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
  <a id="8150" href="Tactic.MonoidSolver.html#8124" class="Function">buildExpr</a> <a id="8160" href="Tactic.MonoidSolver.html#8160" class="Bound">t</a><a id="8161" class="Symbol">@(</a><a id="8163" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="8167" href="Tactic.MonoidSolver.html#8167" class="Bound">n</a> <a id="8169" href="Tactic.MonoidSolver.html#8169" class="Bound">xs</a><a id="8171" class="Symbol">)</a> <a id="8173" class="Symbol">=</a>
    <a id="8179" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8182" href="Tactic.MonoidSolver.html#6901" class="Field">is-∙</a> <a id="8187" href="Tactic.MonoidSolver.html#8167" class="Bound">n</a>
      <a id="8195" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8200" href="Tactic.MonoidSolver.html#7948" class="Function">″∙″</a> <a id="8204" href="Tactic.MonoidSolver.html#8169" class="Bound">xs</a>
    <a id="8211" href="Data.Bool.Base.html#1505" class="Function Operator">else</a> <a id="8216" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8219" href="Tactic.MonoidSolver.html#6924" class="Field">is-ε</a> <a id="8224" href="Tactic.MonoidSolver.html#8167" class="Bound">n</a>
      <a id="8232" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8237" href="Tactic.MonoidSolver.html#7776" class="Function">″ε″</a>
    <a id="8245" href="Data.Bool.Base.html#1505" class="Function Operator">else</a>
      <a id="8256" href="Tactic.MonoidSolver.html#7814" class="Function Operator">[</a> <a id="8258" href="Tactic.MonoidSolver.html#8160" class="Bound">t</a> <a id="8260" href="Tactic.MonoidSolver.html#7814" class="Function Operator">↑]′</a>
  <a id="8266" href="Tactic.MonoidSolver.html#8124" class="Function">buildExpr</a> <a id="8276" href="Tactic.MonoidSolver.html#8276" class="Bound">t</a><a id="8277" class="Symbol">@(</a><a id="8279" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="8283" href="Tactic.MonoidSolver.html#8283" class="Bound">n</a> <a id="8285" href="Tactic.MonoidSolver.html#8285" class="Bound">xs</a><a id="8287" class="Symbol">)</a> <a id="8289" class="Symbol">=</a>
    <a id="8295" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8298" href="Tactic.MonoidSolver.html#6901" class="Field">is-∙</a> <a id="8303" href="Tactic.MonoidSolver.html#8283" class="Bound">n</a>
      <a id="8311" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8316" href="Tactic.MonoidSolver.html#7948" class="Function">″∙″</a> <a id="8320" href="Tactic.MonoidSolver.html#8285" class="Bound">xs</a>
    <a id="8327" href="Data.Bool.Base.html#1505" class="Function Operator">else</a> <a id="8332" href="Data.Bool.Base.html#1505" class="Function Operator">if</a> <a id="8335" href="Tactic.MonoidSolver.html#6924" class="Field">is-ε</a> <a id="8340" href="Tactic.MonoidSolver.html#8283" class="Bound">n</a>
      <a id="8348" href="Data.Bool.Base.html#1505" class="Function Operator">then</a> <a id="8353" href="Tactic.MonoidSolver.html#7776" class="Function">″ε″</a>
    <a id="8361" href="Data.Bool.Base.html#1505" class="Function Operator">else</a> <a id="8366" href="Tactic.MonoidSolver.html#7814" class="Function Operator">[</a> <a id="8368" href="Tactic.MonoidSolver.html#8276" class="Bound">t</a> <a id="8370" href="Tactic.MonoidSolver.html#7814" class="Function Operator">↑]′</a>
  <a id="8376" href="Tactic.MonoidSolver.html#8124" class="CatchallClause Function">buildExpr</a><a id="8385" class="CatchallClause"> </a><a id="8386" href="Tactic.MonoidSolver.html#8386" class="CatchallClause Bound">t</a> <a id="8388" class="Symbol">=</a> <a id="8390" class="Keyword">quote</a> <a id="8396" href="Tactic.MonoidSolver.html#4452" class="InductiveConstructor Operator">[_↑]</a> <a id="8401" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="8403" href="Agda.Builtin.Reflection.html#5194" class="InductiveConstructor">con</a> <a id="8407" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="8409" class="Symbol">(</a><a id="8410" href="Tactic.MonoidSolver.html#8386" class="Bound">t</a> <a id="8412" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8416" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="8418" class="Symbol">)</a>

<a id="8421" class="Comment">------------------------------------------------------------------------</a>
<a id="8494" class="Comment">-- Constructing the solution</a>
<a id="8523" class="Comment">------------------------------------------------------------------------</a>

<a id="8597" class="Comment">-- This function joins up the two homomorphism proofs. It constructs</a>
<a id="8666" class="Comment">-- a proof of the following form:</a>
<a id="8700" class="Comment">--</a>
<a id="8703" class="Comment">--   trans (sym (homo x)) (homo y)</a>
<a id="8738" class="Comment">--</a>
<a id="8741" class="Comment">-- where x and y are the Expr representations of each side of the</a>
<a id="8807" class="Comment">-- goal equation.</a>

<a id="constructSoln"></a><a id="8826" href="Tactic.MonoidSolver.html#8826" class="Function">constructSoln</a> <a id="8840" class="Symbol">:</a> <a id="8842" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8847" class="Symbol">→</a> <a id="8849" href="Tactic.MonoidSolver.html#6865" class="Record">MonoidNames</a> <a id="8861" class="Symbol">→</a> <a id="8863" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8868" class="Symbol">→</a> <a id="8870" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="8875" class="Symbol">→</a> <a id="8877" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a>
<a id="8882" href="Tactic.MonoidSolver.html#8826" class="Function">constructSoln</a> <a id="8896" href="Tactic.MonoidSolver.html#8896" class="Bound">mon</a> <a id="8900" href="Tactic.MonoidSolver.html#8900" class="Bound">names</a> <a id="8906" href="Tactic.MonoidSolver.html#8906" class="Bound">lhs</a> <a id="8910" href="Tactic.MonoidSolver.html#8910" class="Bound">rhs</a> <a id="8914" class="Symbol">=</a>
  <a id="8918" class="Keyword">quote</a> <a id="8924" href="Relation.Binary.Structures.html#1648" class="Function">Monoid.trans</a> <a id="8937" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="8939" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="8943" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="8945" class="Number">2</a> <a id="8947" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="8952" href="Tactic.MonoidSolver.html#8896" class="Bound">mon</a> <a id="8956" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="8964" class="Symbol">(</a><a id="8965" class="Keyword">quote</a> <a id="8971" href="Relation.Binary.Structures.html#1622" class="Function">Monoid.sym</a> <a id="8982" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="8984" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="8988" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="8990" class="Number">2</a> <a id="8992" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="8997" href="Tactic.MonoidSolver.html#8896" class="Bound">mon</a> <a id="9001" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
       <a id="9012" class="Symbol">(</a><a id="9013" class="Keyword">quote</a> <a id="9019" href="Tactic.MonoidSolver.html#5692" class="Function">homo</a> <a id="9024" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="9026" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="9030" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="9032" class="Number">2</a> <a id="9034" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="9039" href="Tactic.MonoidSolver.html#8896" class="Bound">mon</a> <a id="9043" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9047" href="Tactic.MonoidSolver.html#8124" class="Function">buildExpr</a> <a id="9057" href="Tactic.MonoidSolver.html#8900" class="Bound">names</a> <a id="9063" href="Tactic.MonoidSolver.html#8906" class="Bound">lhs</a> <a id="9067" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9071" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9073" class="Symbol">)</a> <a id="9075" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9079" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9081" class="Symbol">)</a>
    <a id="9087" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="9095" class="Symbol">(</a><a id="9096" class="Keyword">quote</a> <a id="9102" href="Tactic.MonoidSolver.html#5692" class="Function">homo</a> <a id="9107" href="Function.Base.html#4322" class="Function Operator">⟨</a> <a id="9109" href="Agda.Builtin.Reflection.html#5251" class="InductiveConstructor">def</a> <a id="9113" href="Function.Base.html#4322" class="Function Operator">⟩</a> <a id="9115" class="Number">2</a> <a id="9117" href="Reflection.AST.Term.html#3198" class="Function Operator">⋯⟅∷⟆</a> <a id="9122" href="Tactic.MonoidSolver.html#8896" class="Bound">mon</a> <a id="9126" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9130" href="Tactic.MonoidSolver.html#8124" class="Function">buildExpr</a> <a id="9140" href="Tactic.MonoidSolver.html#8900" class="Bound">names</a> <a id="9146" href="Tactic.MonoidSolver.html#8910" class="Bound">rhs</a> <a id="9150" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="9154" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9156" class="Symbol">)</a> <a id="9158" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a>
    <a id="9166" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a>

<a id="9170" class="Comment">------------------------------------------------------------------------</a>
<a id="9243" class="Comment">-- Macro</a>
<a id="9252" class="Comment">------------------------------------------------------------------------</a>

<a id="solve-macro"></a><a id="9326" href="Tactic.MonoidSolver.html#9326" class="Function">solve-macro</a> <a id="9338" class="Symbol">:</a> <a id="9340" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9345" class="Symbol">→</a> <a id="9347" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9352" class="Symbol">→</a> <a id="9354" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="9357" class="Symbol">_</a>
<a id="9359" href="Tactic.MonoidSolver.html#9326" class="Function">solve-macro</a> <a id="9371" href="Tactic.MonoidSolver.html#9371" class="Bound">mon</a> <a id="9375" href="Tactic.MonoidSolver.html#9375" class="Bound">hole</a> <a id="9380" class="Symbol">=</a> <a id="9382" class="Keyword">do</a>
  <a id="9387" href="Tactic.MonoidSolver.html#9387" class="Bound">hole′</a> <a id="9393" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9395" href="Agda.Builtin.Reflection.html#8878" class="Postulate">inferType</a> <a id="9405" href="Tactic.MonoidSolver.html#9375" class="Bound">hole</a> <a id="9410" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="9414" href="Agda.Builtin.Reflection.html#8957" class="Postulate">normalise</a>
  <a id="9426" href="Tactic.MonoidSolver.html#9426" class="Bound">names</a> <a id="9432" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9434" href="Tactic.MonoidSolver.html#7086" class="Function">findMonoidNames</a> <a id="9450" href="Tactic.MonoidSolver.html#9371" class="Bound">mon</a>
  <a id="9456" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="9461" class="Symbol">(</a><a id="9462" href="Tactic.MonoidSolver.html#9462" class="Bound">lhs</a> <a id="9466" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="9468" href="Tactic.MonoidSolver.html#9468" class="Bound">rhs</a><a id="9471" class="Symbol">)</a> <a id="9473" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9475" href="Reflection.TCM.html#1087" class="Postulate">pure</a> <a id="9480" class="Symbol">(</a><a id="9481" href="Tactic.MonoidSolver.html#6108" class="Function">getArgs</a> <a id="9489" href="Tactic.MonoidSolver.html#9387" class="Bound">hole′</a><a id="9494" class="Symbol">)</a>
    <a id="9500" class="Keyword">where</a> <a id="9506" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="9514" class="Symbol">→</a> <a id="9516" href="Agda.Builtin.Reflection.html#8815" class="Postulate">typeError</a> <a id="9526" class="Symbol">(</a><a id="9527" href="Agda.Builtin.Reflection.html#8254" class="InductiveConstructor">termErr</a> <a id="9535" href="Tactic.MonoidSolver.html#9387" class="Bound">hole′</a> <a id="9541" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="9543" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a><a id="9545" class="Symbol">)</a>
  <a id="9549" class="Keyword">let</a> <a id="9553" href="Tactic.MonoidSolver.html#9553" class="Bound">soln</a> <a id="9558" class="Symbol">=</a> <a id="9560" href="Tactic.MonoidSolver.html#8826" class="Function">constructSoln</a> <a id="9574" href="Tactic.MonoidSolver.html#9371" class="Bound">mon</a> <a id="9578" href="Tactic.MonoidSolver.html#9426" class="Bound">names</a> <a id="9584" href="Tactic.MonoidSolver.html#9462" class="Bound">lhs</a> <a id="9588" href="Tactic.MonoidSolver.html#9468" class="Bound">rhs</a>
  <a id="9594" href="Agda.Builtin.Reflection.html#8775" class="Postulate">unify</a> <a id="9600" href="Tactic.MonoidSolver.html#9375" class="Bound">hole</a> <a id="9605" href="Tactic.MonoidSolver.html#9553" class="Bound">soln</a>

<a id="9611" class="Keyword">macro</a>
  <a id="solve"></a><a id="9619" href="Tactic.MonoidSolver.html#9619" class="Function">solve</a> <a id="9625" class="Symbol">:</a> <a id="9627" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9632" class="Symbol">→</a> <a id="9634" href="Agda.Builtin.Reflection.html#4993" class="Datatype">Term</a> <a id="9639" class="Symbol">→</a> <a id="9641" href="Agda.Builtin.Reflection.html#8602" class="Postulate">TC</a> <a id="9644" class="Symbol">_</a>
  <a id="9648" href="Tactic.MonoidSolver.html#9619" class="Function">solve</a> <a id="9654" class="Symbol">=</a> <a id="9656" href="Tactic.MonoidSolver.html#9326" class="Function">solve-macro</a>
</pre></body></html>