<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Ledger.Certs.Haskell</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--safe</a> <a id="20" class="Symbol">#-}</a>

<a id="25" class="Keyword">open</a> <a id="30" class="Keyword">import</a> <a id="37" href="Ledger.Prelude.html" class="Module">Ledger.Prelude</a>
<a id="52" class="Keyword">open</a> <a id="57" class="Keyword">import</a> <a id="64" href="Ledger.Types.GovStructure.html" class="Module">Ledger.Types.GovStructure</a>

<a id="91" class="Keyword">module</a> <a id="98" href="Ledger.Certs.Haskell.html" class="Module">Ledger.Certs.Haskell</a>
  <a id="121" class="Symbol">(</a><a id="122" href="Ledger.Certs.Haskell.html#122" class="Bound">gs</a> <a id="125" class="Symbol">:</a> <a id="127" class="Symbol">_)</a> <a id="130" class="Symbol">(</a><a id="131" class="Keyword">open</a> <a id="136" href="Ledger.Types.GovStructure.html#235" class="Module">GovStructure</a> <a id="149" href="Ledger.Certs.Haskell.html#122" class="Bound">gs</a><a id="151" class="Symbol">)</a>
  <a id="155" class="Keyword">where</a>

<a id="162" class="Keyword">open</a> <a id="167" class="Keyword">import</a> <a id="174" href="Ledger.Certs.html" class="Module">Ledger.Certs</a> <a id="187" href="Ledger.Certs.Haskell.html#122" class="Bound">gs</a>
  <a id="192" class="Keyword">using</a> <a id="198" class="Symbol">(</a><a id="199" href="Ledger.Certs.html#590" class="Function">Deposits</a><a id="207" class="Symbol">;</a> <a id="209" href="Ledger.Certs.html#2416" class="Record">PState</a><a id="215" class="Symbol">;</a> <a id="217" href="Ledger.Certs.html#898" class="Record">PoolParams</a><a id="227" class="Symbol">;</a> <a id="229" href="Ledger.Certs.html#1056" class="Datatype">DCert</a><a id="234" class="Symbol">;</a> <a id="236" href="Ledger.Certs.html#349" class="Datatype">DepositPurpose</a><a id="250" class="Symbol">;</a> <a id="252" href="Ledger.Certs.html#7790" class="Datatype Operator">_⊢_⇀⦇_,POOL⦈_</a><a id="265" class="Symbol">;</a> <a id="267" href="Ledger.Certs.html#676" class="Function">DecEq-DepositPurpose</a><a id="287" class="Symbol">;</a> <a id="289" href="Ledger.Certs.html#3220" class="Function">PoolEnv</a><a id="296" class="Symbol">)</a>
<a id="298" class="Keyword">open</a> <a id="303" href="Ledger.Certs.html#1056" class="Module">DCert</a>
<a id="309" class="Keyword">open</a> <a id="314" href="Ledger.Certs.html#349" class="Module">DepositPurpose</a>

<a id="330" class="Keyword">open</a> <a id="335" class="Keyword">import</a> <a id="342" href="Tactic.Derive.DecEq.html" class="Module">Tactic.Derive.DecEq</a>

<a id="363" class="Keyword">open</a> <a id="368" class="Keyword">import</a> <a id="375" href="Ledger.GovernanceActions.html" class="Module">Ledger.GovernanceActions</a> <a id="400" href="Ledger.Certs.Haskell.html#122" class="Bound">gs</a>
<a id="403" class="Keyword">open</a> <a id="408" href="Ledger.Address.html#1583" class="Module">RwdAddr</a>

<a id="417" class="Keyword">record</a> <a id="CertEnv"></a><a id="424" href="Ledger.Certs.Haskell.html#424" class="Record">CertEnv</a> <a id="432" class="Symbol">:</a> <a id="434" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="439" class="Keyword">where</a>
  <a id="447" class="Keyword">constructor</a> <a id="⟦_,_,_,_⟧ᶜ"></a><a id="459" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">⟦_,_,_,_⟧ᶜ</a>
  <a id="472" class="Keyword">field</a>
    <a id="CertEnv.epoch"></a><a id="482" href="Ledger.Certs.Haskell.html#482" class="Field">epoch</a>     <a id="492" class="Symbol">:</a> <a id="494" href="Ledger.Types.Epoch.html#335" class="Function">Epoch</a>
    <a id="CertEnv.pp"></a><a id="504" href="Ledger.Certs.Haskell.html#504" class="Field">pp</a>        <a id="514" class="Symbol">:</a> <a id="516" href="Ledger.PParams.html#2073" class="Record">PParams</a>
    <a id="CertEnv.votes"></a><a id="528" href="Ledger.Certs.Haskell.html#528" class="Field">votes</a>     <a id="538" class="Symbol">:</a> <a id="540" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="545" href="Ledger.GovernanceActions.html#8288" class="Record">GovVote</a>
    <a id="CertEnv.wdrls"></a><a id="557" href="Ledger.Certs.Haskell.html#557" class="Field">wdrls</a>     <a id="567" class="Symbol">:</a> <a id="569" href="Ledger.Address.html#1583" class="Record">RwdAddr</a> <a id="577" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="579" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a>

<a id="585" class="Keyword">record</a> <a id="DState"></a><a id="592" href="Ledger.Certs.Haskell.html#592" class="Record">DState</a> <a id="599" class="Symbol">:</a> <a id="601" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="606" class="Keyword">where</a>
  <a id="614" class="Keyword">constructor</a> <a id="⟦_,_,_,_⟧ᵈ"></a><a id="626" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟦_,_,_,_⟧ᵈ</a>
  <a id="639" class="Keyword">field</a>
    <a id="DState.voteDelegs"></a><a id="649" href="Ledger.Certs.Haskell.html#649" class="Field">voteDelegs</a>   <a id="662" class="Symbol">:</a> <a id="664" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="675" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="677" href="Ledger.GovernanceActions.html#1215" class="Datatype">VDeleg</a>
    <a id="DState.stakeDelegs"></a><a id="688" href="Ledger.Certs.Haskell.html#688" class="Field">stakeDelegs</a>  <a id="701" class="Symbol">:</a> <a id="703" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="714" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="716" href="Ledger.Crypto.html#1629" class="Function">KeyHash</a>
    <a id="DState.rewards"></a><a id="728" href="Ledger.Certs.Haskell.html#728" class="Field">rewards</a>      <a id="741" class="Symbol">:</a> <a id="743" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="754" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="756" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a>
    <a id="DState.deposits"></a><a id="765" href="Ledger.Certs.Haskell.html#765" class="Field">deposits</a>     <a id="778" class="Symbol">:</a> <a id="780" href="Ledger.Certs.html#590" class="Function">Deposits</a>

<a id="790" class="Keyword">record</a> <a id="GState"></a><a id="797" href="Ledger.Certs.Haskell.html#797" class="Record">GState</a> <a id="804" class="Symbol">:</a> <a id="806" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="811" class="Keyword">where</a>
  <a id="819" class="Keyword">constructor</a> <a id="⟦_,_,_⟧ᵛ"></a><a id="831" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟦_,_,_⟧ᵛ</a>
  <a id="842" class="Keyword">field</a>
    <a id="GState.dreps"></a><a id="852" href="Ledger.Certs.Haskell.html#852" class="Field">dreps</a>      <a id="863" class="Symbol">:</a> <a id="865" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="876" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="878" href="Ledger.Types.Epoch.html#335" class="Function">Epoch</a>
    <a id="GState.ccHotKeys"></a><a id="888" href="Ledger.Certs.Haskell.html#888" class="Field">ccHotKeys</a>  <a id="899" class="Symbol">:</a> <a id="901" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="912" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="914" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="920" href="Ledger.Address.html#764" class="Datatype">Credential</a>
    <a id="GState.deposits"></a><a id="935" href="Ledger.Certs.Haskell.html#935" class="Field">deposits</a>   <a id="946" class="Symbol">:</a> <a id="948" href="Ledger.Certs.html#590" class="Function">Deposits</a>

<a id="958" class="Keyword">record</a> <a id="CertState"></a><a id="965" href="Ledger.Certs.Haskell.html#965" class="Record">CertState</a> <a id="975" class="Symbol">:</a> <a id="977" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="982" class="Keyword">where</a>
  <a id="990" class="Keyword">constructor</a> <a id="⟦_,_,_⟧ᶜˢ"></a><a id="1002" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟦_,_,_⟧ᶜˢ</a>
  <a id="1014" class="Keyword">field</a>
    <a id="CertState.dState"></a><a id="1024" href="Ledger.Certs.Haskell.html#1024" class="Field">dState</a> <a id="1031" class="Symbol">:</a> <a id="1033" href="Ledger.Certs.Haskell.html#592" class="Record">DState</a>
    <a id="CertState.pState"></a><a id="1044" href="Ledger.Certs.Haskell.html#1044" class="Field">pState</a> <a id="1051" class="Symbol">:</a> <a id="1053" href="Ledger.Certs.html#2416" class="Record">PState</a>
    <a id="CertState.gState"></a><a id="1064" href="Ledger.Certs.Haskell.html#1064" class="Field">gState</a> <a id="1071" class="Symbol">:</a> <a id="1073" href="Ledger.Certs.Haskell.html#797" class="Record">GState</a>

<a id="1081" class="Keyword">record</a> <a id="DelegEnv"></a><a id="1088" href="Ledger.Certs.Haskell.html#1088" class="Record">DelegEnv</a> <a id="1097" class="Symbol">:</a> <a id="1099" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="1104" class="Keyword">where</a>
  <a id="1112" class="Keyword">constructor</a> <a id="⟦_,_⟧ᵈᵉ"></a><a id="1124" href="Ledger.Certs.Haskell.html#1124" class="InductiveConstructor Operator">⟦_,_⟧ᵈᵉ</a>
  <a id="1134" class="Keyword">field</a>
    <a id="DelegEnv.pparams"></a><a id="1144" href="Ledger.Certs.Haskell.html#1144" class="Field">pparams</a>  <a id="1153" class="Symbol">:</a> <a id="1155" href="Ledger.PParams.html#2073" class="Record">PParams</a>
    <a id="DelegEnv.pools"></a><a id="1167" href="Ledger.Certs.Haskell.html#1167" class="Field">pools</a>    <a id="1176" class="Symbol">:</a> <a id="1178" href="Ledger.Crypto.html#1629" class="Function">KeyHash</a> <a id="1186" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="1188" href="Ledger.Certs.html#898" class="Record">PoolParams</a>

<a id="GovCertEnv"></a><a id="1200" href="Ledger.Certs.Haskell.html#1200" class="Function">GovCertEnv</a>  <a id="1212" class="Symbol">=</a> <a id="1214" href="Ledger.Certs.Haskell.html#424" class="Record">CertEnv</a>

<a id="certDeposit"></a><a id="1223" href="Ledger.Certs.Haskell.html#1223" class="Function">certDeposit</a> <a id="1235" class="Symbol">:</a> <a id="1237" href="Ledger.Certs.html#1056" class="Datatype">DCert</a> <a id="1243" class="Symbol">→</a> <a id="1245" href="Ledger.PParams.html#2073" class="Record">PParams</a> <a id="1253" class="Symbol">→</a> <a id="1255" href="Ledger.Certs.html#349" class="Datatype">DepositPurpose</a> <a id="1270" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="1272" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a>
<a id="1277" href="Ledger.Certs.Haskell.html#1223" class="Function">certDeposit</a> <a id="1289" class="Symbol">(</a><a id="1290" href="Ledger.Certs.html#1077" class="InductiveConstructor">delegate</a> <a id="1299" href="Ledger.Certs.Haskell.html#1299" class="Bound">c</a> <a id="1301" class="Symbol">_</a> <a id="1303" class="Symbol">_</a> <a id="1305" href="Ledger.Certs.Haskell.html#1305" class="Bound">v</a><a id="1306" class="Symbol">)</a> <a id="1308" class="Symbol">_</a>   <a id="1312" class="Symbol">=</a> <a id="1314" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="1316" href="Ledger.Certs.html#379" class="InductiveConstructor">CredentialDeposit</a> <a id="1334" href="Ledger.Certs.Haskell.html#1299" class="Bound">c</a> <a id="1336" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1338" href="Ledger.Certs.Haskell.html#1305" class="Bound">v</a> <a id="1340" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a>
<a id="1342" href="Ledger.Certs.Haskell.html#1223" class="Function">certDeposit</a> <a id="1354" class="Symbol">(</a><a id="1355" href="Ledger.Certs.html#1277" class="InductiveConstructor">regdrep</a> <a id="1363" href="Ledger.Certs.Haskell.html#1363" class="Bound">c</a> <a id="1365" href="Ledger.Certs.Haskell.html#1365" class="Bound">v</a> <a id="1367" class="Symbol">_)</a>    <a id="1373" class="Symbol">_</a>   <a id="1377" class="Symbol">=</a> <a id="1379" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="1381" href="Ledger.Certs.html#485" class="InductiveConstructor">DRepDeposit</a> <a id="1393" href="Ledger.Certs.Haskell.html#1363" class="Bound">c</a> <a id="1395" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="1397" href="Ledger.Certs.Haskell.html#1365" class="Bound">v</a> <a id="1399" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a>
<a id="1401" href="Ledger.Certs.Haskell.html#1223" class="CatchallClause Function">certDeposit</a><a id="1412" class="CatchallClause"> </a><a id="1413" class="CatchallClause Symbol">_</a><a id="1414" class="CatchallClause">                  </a><a id="1432" class="CatchallClause Symbol">_</a>   <a id="1436" class="Symbol">=</a> <a id="1438" href="Interface.HasEmptySet.html#150" class="Field">∅</a>
<a id="1440" class="Comment">-- handled in the Utxo module:</a>
<a id="1471" class="Comment">-- certDeposit (regpool kh _)     pp  = ❴ PoolDeposit kh , pp .poolDeposit ❵</a>

<a id="certRefund"></a><a id="1549" href="Ledger.Certs.Haskell.html#1549" class="Function">certRefund</a> <a id="1560" class="Symbol">:</a> <a id="1562" href="Ledger.Certs.html#1056" class="Datatype">DCert</a> <a id="1568" class="Symbol">→</a> <a id="1570" href="Ledger.Set.Theory.html#382" class="Function Operator">ℙ</a> <a id="1572" href="Ledger.Certs.html#349" class="Datatype">DepositPurpose</a>
<a id="1587" href="Ledger.Certs.Haskell.html#1549" class="Function">certRefund</a> <a id="1598" class="Symbol">(</a><a id="1599" href="Ledger.Certs.html#1150" class="InductiveConstructor">dereg</a> <a id="1605" href="Ledger.Certs.Haskell.html#1605" class="Bound">c</a> <a id="1607" class="Symbol">_)</a>    <a id="1613" class="Symbol">=</a> <a id="1615" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="1617" href="Ledger.Certs.html#379" class="InductiveConstructor">CredentialDeposit</a> <a id="1635" href="Ledger.Certs.Haskell.html#1605" class="Bound">c</a> <a id="1637" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a>
<a id="1639" href="Ledger.Certs.Haskell.html#1549" class="Function">certRefund</a> <a id="1650" class="Symbol">(</a><a id="1651" href="Ledger.Certs.html#1328" class="InductiveConstructor">deregdrep</a> <a id="1661" href="Ledger.Certs.Haskell.html#1661" class="Bound">c</a><a id="1662" class="Symbol">)</a>  <a id="1665" class="Symbol">=</a> <a id="1667" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="1669" href="Ledger.Certs.html#485" class="InductiveConstructor">DRepDeposit</a> <a id="1681" href="Ledger.Certs.Haskell.html#1661" class="Bound">c</a> <a id="1683" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a>
<a id="1685" href="Ledger.Certs.Haskell.html#1549" class="CatchallClause Function">certRefund</a><a id="1695" class="CatchallClause"> </a><a id="1696" class="CatchallClause Symbol">_</a>              <a id="1711" class="Symbol">=</a> <a id="1713" href="Interface.HasEmptySet.html#150" class="Field">∅</a>

<a id="updateCertDeposit"></a><a id="1716" href="Ledger.Certs.Haskell.html#1716" class="Function">updateCertDeposit</a>  <a id="1735" class="Symbol">:</a> <a id="1737" href="Ledger.PParams.html#2073" class="Record">PParams</a> <a id="1745" class="Symbol">→</a> <a id="1747" href="Ledger.Certs.html#1056" class="Datatype">DCert</a> <a id="1753" class="Symbol">→</a> <a id="1755" class="Symbol">(</a><a id="1756" href="Ledger.Certs.html#349" class="Datatype">DepositPurpose</a> <a id="1771" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="1773" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a><a id="1777" class="Symbol">)</a>
                   <a id="1798" class="Symbol">→</a> <a id="1800" href="Ledger.Certs.html#349" class="Datatype">DepositPurpose</a> <a id="1815" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="1817" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a>
<a id="1822" href="Ledger.Certs.Haskell.html#1716" class="Function">updateCertDeposit</a> <a id="1840" href="Ledger.Certs.Haskell.html#1840" class="Bound">pp</a> <a id="1843" href="Ledger.Certs.Haskell.html#1843" class="Bound">cert</a> <a id="1848" href="Ledger.Certs.Haskell.html#1848" class="Bound">deposits</a>
  <a id="1859" class="Symbol">=</a> <a id="1861" class="Symbol">(</a><a id="1862" href="Ledger.Certs.Haskell.html#1848" class="Bound">deposits</a> <a id="1871" href="Axiom.Set.Map.Dec.html#1956" class="Function Operator">∪⁺</a> <a id="1874" href="Ledger.Certs.Haskell.html#1223" class="Function">certDeposit</a> <a id="1886" href="Ledger.Certs.Haskell.html#1843" class="Bound">cert</a> <a id="1891" href="Ledger.Certs.Haskell.html#1840" class="Bound">pp</a><a id="1893" class="Symbol">)</a> <a id="1895" href="Axiom.Set.Map.html#10177" class="Function Operator">∣</a> <a id="1897" href="Ledger.Certs.Haskell.html#1549" class="Function">certRefund</a> <a id="1908" href="Ledger.Certs.Haskell.html#1843" class="Bound">cert</a> <a id="1913" href="Axiom.Set.Map.html#10177" class="Function Operator">ᶜ</a>

<a id="1916" class="Keyword">private</a> <a id="1924" class="Keyword">variable</a>
  <a id="1935" href="Ledger.Certs.Haskell.html#1935" class="Generalizable">an</a>                  <a id="1955" class="Symbol">:</a> <a id="1957" href="Ledger.GovernanceActions.html#1399" class="Record">Anchor</a>
  <a id="1966" href="Ledger.Certs.Haskell.html#1966" class="Generalizable">dReps</a>               <a id="1986" class="Symbol">:</a> <a id="1988" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="1999" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="2001" href="Ledger.Types.Epoch.html#335" class="Function">Epoch</a>
  <a id="2009" href="Ledger.Certs.Haskell.html#2009" class="Generalizable">pools</a>               <a id="2029" class="Symbol">:</a> <a id="2031" href="Ledger.Crypto.html#1629" class="Function">KeyHash</a> <a id="2039" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="2041" href="Ledger.Certs.html#898" class="Record">PoolParams</a>
  <a id="2054" href="Ledger.Certs.Haskell.html#2054" class="Generalizable">retiring</a>            <a id="2074" class="Symbol">:</a> <a id="2076" href="Ledger.Crypto.html#1629" class="Function">KeyHash</a> <a id="2084" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="2086" href="Ledger.Types.Epoch.html#335" class="Function">Epoch</a>
  <a id="2094" href="Ledger.Certs.Haskell.html#2094" class="Generalizable">vDelegs</a>             <a id="2114" class="Symbol">:</a> <a id="2116" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="2127" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="2129" href="Ledger.GovernanceActions.html#1215" class="Datatype">VDeleg</a>
  <a id="2138" href="Ledger.Certs.Haskell.html#2138" class="Generalizable">sDelegs</a> <a id="2146" href="Ledger.Certs.Haskell.html#2146" class="Generalizable">stakeDelegs</a> <a id="2158" class="Symbol">:</a> <a id="2160" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="2171" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="2173" href="Ledger.Crypto.html#1629" class="Function">KeyHash</a>
  <a id="2183" href="Ledger.Certs.Haskell.html#2183" class="Generalizable">rewards</a> <a id="2191" href="Ledger.Certs.Haskell.html#2191" class="Generalizable">rwds</a>        <a id="2203" class="Symbol">:</a> <a id="2205" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="2216" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="2218" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a>
  <a id="2225" href="Ledger.Certs.Haskell.html#2225" class="Generalizable">dreps</a>               <a id="2245" class="Symbol">:</a> <a id="2247" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="2258" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="2260" href="Ledger.Types.Epoch.html#335" class="Function">Epoch</a>
  <a id="2268" href="Ledger.Certs.Haskell.html#2268" class="Generalizable">voteDelegs</a>          <a id="2288" class="Symbol">:</a> <a id="2290" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="2301" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="2303" href="Ledger.GovernanceActions.html#1215" class="Datatype">VDeleg</a>
  <a id="2312" href="Ledger.Certs.Haskell.html#2312" class="Generalizable">ccKeys</a> <a id="2319" href="Ledger.Certs.Haskell.html#2319" class="Generalizable">ccHotKeys</a>    <a id="2332" class="Symbol">:</a> <a id="2334" href="Ledger.Address.html#764" class="Datatype">Credential</a> <a id="2345" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="2347" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2353" href="Ledger.Address.html#764" class="Datatype">Credential</a>
  <a id="2366" href="Ledger.Certs.Haskell.html#2366" class="Generalizable">dCert</a>               <a id="2386" class="Symbol">:</a> <a id="2388" href="Ledger.Certs.html#1056" class="Datatype">DCert</a>
  <a id="2396" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a>                   <a id="2416" class="Symbol">:</a> <a id="2418" href="Ledger.Address.html#764" class="Datatype">Credential</a>
  <a id="2431" href="Ledger.Certs.Haskell.html#2431" class="Generalizable">mc</a>                  <a id="2451" class="Symbol">:</a> <a id="2453" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2459" href="Ledger.Address.html#764" class="Datatype">Credential</a>
  <a id="2472" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a>                   <a id="2492" class="Symbol">:</a> <a id="2494" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a>
  <a id="2501" href="Ledger.Certs.Haskell.html#2501" class="Generalizable">e</a>                   <a id="2521" class="Symbol">:</a> <a id="2523" href="Ledger.Types.Epoch.html#335" class="Function">Epoch</a>
  <a id="2531" href="Ledger.Certs.Haskell.html#2531" class="Generalizable">kh</a> <a id="2534" href="Ledger.Certs.Haskell.html#2534" class="Generalizable">kh&#39;</a>              <a id="2551" class="Symbol">:</a> <a id="2553" href="Ledger.Crypto.html#1629" class="Function">KeyHash</a>
  <a id="2563" href="Ledger.Certs.Haskell.html#2563" class="Generalizable">mv</a>                  <a id="2583" class="Symbol">:</a> <a id="2585" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2591" href="Ledger.GovernanceActions.html#1215" class="Datatype">VDeleg</a>
  <a id="2600" href="Ledger.Certs.Haskell.html#2600" class="Generalizable">mkh</a>                 <a id="2620" class="Symbol">:</a> <a id="2622" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="2628" href="Ledger.Crypto.html#1629" class="Function">KeyHash</a>
  <a id="2638" href="Ledger.Certs.Haskell.html#2638" class="Generalizable">stᵍ</a> <a id="2642" href="Ledger.Certs.Haskell.html#2642" class="Generalizable">stᵍ&#39;</a>            <a id="2658" class="Symbol">:</a> <a id="2660" href="Ledger.Certs.Haskell.html#797" class="Record">GState</a>
  <a id="2669" href="Ledger.Certs.Haskell.html#2669" class="Generalizable">stᵈ</a> <a id="2673" href="Ledger.Certs.Haskell.html#2673" class="Generalizable">stᵈ&#39;</a>            <a id="2689" class="Symbol">:</a> <a id="2691" href="Ledger.Certs.Haskell.html#592" class="Record">DState</a>
  <a id="2700" href="Ledger.Certs.Haskell.html#2700" class="Generalizable">stᵖ</a> <a id="2704" href="Ledger.Certs.Haskell.html#2704" class="Generalizable">stᵖ&#39;</a>            <a id="2720" class="Symbol">:</a> <a id="2722" href="Ledger.Certs.html#2416" class="Record">PState</a>
  <a id="2731" href="Ledger.Certs.Haskell.html#2731" class="Generalizable">Γ</a>                   <a id="2751" class="Symbol">:</a> <a id="2753" href="Ledger.Certs.Haskell.html#424" class="Record">CertEnv</a>
  <a id="2763" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a>                  <a id="2783" class="Symbol">:</a> <a id="2785" href="Ledger.PParams.html#2073" class="Record">PParams</a>
  <a id="2795" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a> <a id="2799" href="Ledger.Certs.Haskell.html#2799" class="Generalizable">gdep</a> <a id="2804" href="Ledger.Certs.Haskell.html#2804" class="Generalizable">ddep</a> <a id="2809" href="Ledger.Certs.Haskell.html#2809" class="Generalizable">edeps</a> <a id="2815" class="Symbol">:</a> <a id="2817" href="Ledger.Certs.html#590" class="Function">Deposits</a>
  <a id="2828" href="Ledger.Certs.Haskell.html#2828" class="Generalizable">vs</a>                  <a id="2848" class="Symbol">:</a> <a id="2850" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="2855" href="Ledger.GovernanceActions.html#8288" class="Record">GovVote</a>
  <a id="2865" href="Ledger.Certs.Haskell.html#2865" class="Generalizable">poolParams</a>          <a id="2885" class="Symbol">:</a> <a id="2887" href="Ledger.Certs.html#898" class="Record">PoolParams</a>
  <a id="2900" href="Ledger.Certs.Haskell.html#2900" class="Generalizable">wdrls</a>               <a id="2920" class="Symbol">:</a> <a id="2922" href="Ledger.Address.html#1583" class="Record">RwdAddr</a> <a id="2930" href="Ledger.Set.Theory.html#1515" class="Function Operator">⇀</a> <a id="2932" href="Ledger.Prelude.Base.html#81" class="Function">Coin</a>

<a id="2938" class="Keyword">data</a> <a id="_⊢_⇀⦇_,DELEG⦈_"></a><a id="2943" href="Ledger.Certs.Haskell.html#2943" class="Datatype Operator">_⊢_⇀⦇_,DELEG⦈_</a> <a id="2958" class="Symbol">:</a> <a id="2960" href="Ledger.Certs.Haskell.html#1088" class="Record">DelegEnv</a> <a id="2969" class="Symbol">→</a> <a id="2971" href="Ledger.Certs.Haskell.html#592" class="Record">DState</a> <a id="2978" class="Symbol">→</a> <a id="2980" href="Ledger.Certs.html#1056" class="Datatype">DCert</a> <a id="2986" class="Symbol">→</a> <a id="2988" href="Ledger.Certs.Haskell.html#592" class="Record">DState</a> <a id="2995" class="Symbol">→</a> <a id="2997" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3002" class="Keyword">where</a>
  <a id="_⊢_⇀⦇_,DELEG⦈_.DELEG-delegate"></a><a id="3010" href="Ledger.Certs.Haskell.html#3010" class="InductiveConstructor">DELEG-delegate</a> <a id="3025" class="Symbol">:</a> <a id="3027" class="Keyword">let</a> <a id="3031" class="Keyword">open</a> <a id="3036" href="Ledger.PParams.html#2073" class="Module">PParams</a> <a id="3044" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="3047" class="Keyword">in</a>
    <a id="3054" href="Interface.STS.html#105" class="Function Operator">∙</a> <a id="3056" class="Symbol">(</a><a id="3057" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3059" href="Interface.IsSet.html#480" class="Function Operator">∉</a> <a id="3061" href="Interface.IsSet.html#934" class="Function">dom</a> <a id="3065" href="Ledger.Certs.Haskell.html#2191" class="Generalizable">rwds</a> <a id="3070" class="Symbol">→</a> <a id="3072" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a> <a id="3074" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3076" href="Ledger.PParams.html#2724" class="Function">keyDeposit</a><a id="3086" class="Symbol">)</a>
    <a id="3092" href="Interface.STS.html#131" class="Function Operator">∙</a> <a id="3094" class="Symbol">(</a><a id="3095" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3097" href="Interface.IsSet.html#476" class="Function Operator">∈</a> <a id="3099" href="Interface.IsSet.html#934" class="Function">dom</a> <a id="3103" href="Ledger.Certs.Haskell.html#2191" class="Generalizable">rwds</a> <a id="3108" class="Symbol">→</a> <a id="3110" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a> <a id="3112" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3114" class="Number">0</a><a id="3115" class="Symbol">)</a>
    <a id="3121" href="Interface.STS.html#131" class="Function Operator">∙</a> <a id="3123" href="Ledger.Certs.Haskell.html#2600" class="Generalizable">mkh</a> <a id="3127" href="Interface.IsSet.html#476" class="Function Operator">∈</a> <a id="3129" href="Ledger.Set.Theory.html#413" class="Function">mapˢ</a> <a id="3134" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="3139" class="Symbol">(</a><a id="3140" href="Interface.IsSet.html#934" class="Function">dom</a> <a id="3144" href="Ledger.Certs.Haskell.html#2009" class="Generalizable">pools</a><a id="3149" class="Symbol">)</a> <a id="3151" href="Axiom.Set.html#8665" class="Function Operator">∪</a> <a id="3153" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="3155" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="3163" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a>
      <a id="3171" href="Interface.STS.html#350" class="Function Operator">────────────────────────────────</a>
      <a id="3210" href="Ledger.Certs.Haskell.html#1124" class="InductiveConstructor Operator">⟦</a> <a id="3212" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="3215" href="Ledger.Certs.Haskell.html#1124" class="InductiveConstructor Operator">,</a> <a id="3217" href="Ledger.Certs.Haskell.html#2009" class="Generalizable">pools</a> <a id="3223" href="Ledger.Certs.Haskell.html#1124" class="InductiveConstructor Operator">⟧ᵈᵉ</a> <a id="3227" href="Ledger.Certs.Haskell.html#2943" class="Datatype Operator">⊢</a>
      <a id="3235" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟦</a> <a id="3237" href="Ledger.Certs.Haskell.html#2094" class="Generalizable">vDelegs</a> <a id="3245" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3247" href="Ledger.Certs.Haskell.html#2138" class="Generalizable">sDelegs</a> <a id="3255" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3257" href="Ledger.Certs.Haskell.html#2191" class="Generalizable">rwds</a> <a id="3262" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3264" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a> <a id="3268" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟧ᵈ</a>
      <a id="3277" href="Ledger.Certs.Haskell.html#2943" class="Datatype Operator">⇀⦇</a> <a id="3280" href="Ledger.Certs.html#1077" class="InductiveConstructor">delegate</a> <a id="3289" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3291" href="Ledger.Certs.Haskell.html#2563" class="Generalizable">mv</a> <a id="3294" href="Ledger.Certs.Haskell.html#2600" class="Generalizable">mkh</a> <a id="3298" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a> <a id="3300" href="Ledger.Certs.Haskell.html#2943" class="Datatype Operator">,DELEG⦈</a>
      <a id="3314" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟦</a> <a id="3316" href="Axiom.Set.Map.html#6873" class="Function">insertIfJust</a> <a id="3329" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3331" href="Ledger.Certs.Haskell.html#2563" class="Generalizable">mv</a> <a id="3334" href="Ledger.Certs.Haskell.html#2094" class="Generalizable">vDelegs</a> <a id="3342" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3344" href="Axiom.Set.Map.html#6873" class="Function">insertIfJust</a> <a id="3357" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3359" href="Ledger.Certs.Haskell.html#2600" class="Generalizable">mkh</a> <a id="3363" href="Ledger.Certs.Haskell.html#2138" class="Generalizable">sDelegs</a> <a id="3371" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3373" href="Ledger.Certs.Haskell.html#2191" class="Generalizable">rwds</a> <a id="3378" href="Axiom.Set.Map.html#6390" class="Function Operator">∪ˡ</a> <a id="3381" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="3383" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3385" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3387" class="Number">0</a> <a id="3389" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a>
      <a id="3397" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3399" href="Ledger.Certs.Haskell.html#1716" class="Function">updateCertDeposit</a> <a id="3417" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="3420" class="Symbol">(</a><a id="3421" href="Ledger.Certs.html#1077" class="InductiveConstructor">delegate</a> <a id="3430" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3432" href="Ledger.Certs.Haskell.html#2563" class="Generalizable">mv</a> <a id="3435" href="Ledger.Certs.Haskell.html#2600" class="Generalizable">mkh</a> <a id="3439" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a><a id="3440" class="Symbol">)</a> <a id="3442" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a> <a id="3446" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟧ᵈ</a>

  <a id="_⊢_⇀⦇_,DELEG⦈_.DELEG-dereg"></a><a id="3452" href="Ledger.Certs.Haskell.html#3452" class="InductiveConstructor">DELEG-dereg</a> <a id="3464" class="Symbol">:</a>
    <a id="3470" href="Interface.STS.html#105" class="Function Operator">∙</a> <a id="3472" class="Symbol">(</a><a id="3473" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3475" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3477" class="Number">0</a><a id="3478" class="Symbol">)</a> <a id="3480" href="Interface.IsSet.html#476" class="Function Operator">∈</a> <a id="3482" href="Ledger.Certs.Haskell.html#2191" class="Generalizable">rwds</a>
    <a id="3491" href="Interface.STS.html#131" class="Function Operator">∙</a> <a id="3493" class="Symbol">(</a><a id="3494" href="Ledger.Certs.html#379" class="InductiveConstructor">CredentialDeposit</a> <a id="3512" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3514" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="3516" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a><a id="3517" class="Symbol">)</a> <a id="3519" href="Interface.IsSet.html#476" class="Function Operator">∈</a> <a id="3521" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a>
      <a id="3531" href="Interface.STS.html#350" class="Function Operator">────────────────────────────────</a>
      <a id="3570" href="Ledger.Certs.Haskell.html#1124" class="InductiveConstructor Operator">⟦</a> <a id="3572" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="3575" href="Ledger.Certs.Haskell.html#1124" class="InductiveConstructor Operator">,</a> <a id="3577" href="Ledger.Certs.Haskell.html#2009" class="Generalizable">pools</a> <a id="3583" href="Ledger.Certs.Haskell.html#1124" class="InductiveConstructor Operator">⟧ᵈᵉ</a> <a id="3587" href="Ledger.Certs.Haskell.html#2943" class="Datatype Operator">⊢</a>
      <a id="3595" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟦</a> <a id="3597" href="Ledger.Certs.Haskell.html#2094" class="Generalizable">vDelegs</a> <a id="3605" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3607" href="Ledger.Certs.Haskell.html#2138" class="Generalizable">sDelegs</a> <a id="3615" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3617" href="Ledger.Certs.Haskell.html#2191" class="Generalizable">rwds</a> <a id="3622" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3624" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a> <a id="3628" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟧ᵈ</a>
      <a id="3637" href="Ledger.Certs.Haskell.html#2943" class="Datatype Operator">⇀⦇</a> <a id="3640" href="Ledger.Certs.html#1150" class="InductiveConstructor">dereg</a> <a id="3646" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3648" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a> <a id="3650" href="Ledger.Certs.Haskell.html#2943" class="Datatype Operator">,DELEG⦈</a>
      <a id="3664" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟦</a> <a id="3666" href="Ledger.Certs.Haskell.html#2094" class="Generalizable">vDelegs</a> <a id="3674" href="Axiom.Set.Map.html#10177" class="Function Operator">∣</a> <a id="3676" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="3678" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3680" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a> <a id="3682" href="Axiom.Set.Map.html#10177" class="Function Operator">ᶜ</a> <a id="3684" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3686" href="Ledger.Certs.Haskell.html#2138" class="Generalizable">sDelegs</a> <a id="3694" href="Axiom.Set.Map.html#10177" class="Function Operator">∣</a> <a id="3696" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="3698" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3700" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a> <a id="3702" href="Axiom.Set.Map.html#10177" class="Function Operator">ᶜ</a> <a id="3704" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3706" href="Ledger.Certs.Haskell.html#2191" class="Generalizable">rwds</a> <a id="3711" href="Axiom.Set.Map.html#10177" class="Function Operator">∣</a> <a id="3713" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="3715" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3717" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a> <a id="3719" href="Axiom.Set.Map.html#10177" class="Function Operator">ᶜ</a>
      <a id="3727" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="3729" href="Ledger.Certs.Haskell.html#1716" class="Function">updateCertDeposit</a> <a id="3747" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="3750" class="Symbol">(</a><a id="3751" href="Ledger.Certs.html#1150" class="InductiveConstructor">dereg</a> <a id="3757" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3759" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a><a id="3760" class="Symbol">)</a> <a id="3762" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a> <a id="3766" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟧ᵈ</a>


<a id="3771" class="Keyword">data</a> <a id="_⊢_⇀⦇_,GOVCERT⦈_"></a><a id="3776" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">_⊢_⇀⦇_,GOVCERT⦈_</a> <a id="3793" class="Symbol">:</a> <a id="3795" href="Ledger.Certs.Haskell.html#1200" class="Function">GovCertEnv</a> <a id="3806" class="Symbol">→</a> <a id="3808" href="Ledger.Certs.Haskell.html#797" class="Record">GState</a> <a id="3815" class="Symbol">→</a> <a id="3817" href="Ledger.Certs.html#1056" class="Datatype">DCert</a> <a id="3823" class="Symbol">→</a> <a id="3825" href="Ledger.Certs.Haskell.html#797" class="Record">GState</a> <a id="3832" class="Symbol">→</a> <a id="3834" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="3839" class="Keyword">where</a>
  <a id="_⊢_⇀⦇_,GOVCERT⦈_.GOVCERT-regdrep"></a><a id="3847" href="Ledger.Certs.Haskell.html#3847" class="InductiveConstructor">GOVCERT-regdrep</a> <a id="3863" class="Symbol">:</a> <a id="3865" class="Symbol">∀</a> <a id="3867" class="Symbol">{</a><a id="3868" href="Ledger.Certs.Haskell.html#3868" class="Bound">pp</a><a id="3870" class="Symbol">}</a> <a id="3872" class="Symbol">→</a> <a id="3874" class="Keyword">let</a> <a id="3878" class="Keyword">open</a> <a id="3883" href="Ledger.PParams.html#2073" class="Module">PParams</a> <a id="3891" href="Ledger.Certs.Haskell.html#3868" class="Bound">pp</a> <a id="3894" class="Keyword">in</a>
    <a id="3901" href="Interface.STS.html#105" class="Function Operator">∙</a> <a id="3903" class="Symbol">(</a><a id="3904" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a> <a id="3906" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3908" href="Ledger.PParams.html#3790" class="Field">drepDeposit</a> <a id="3920" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="3922" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3924" href="Interface.IsSet.html#480" class="Function Operator">∉</a> <a id="3926" href="Interface.IsSet.html#934" class="Function">dom</a> <a id="3930" href="Ledger.Certs.Haskell.html#1966" class="Generalizable">dReps</a><a id="3935" class="Symbol">)</a> <a id="3937" href="Data.Sum.Base.html#625" class="Datatype Operator">⊎</a> <a id="3939" class="Symbol">(</a><a id="3940" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a> <a id="3942" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="3944" class="Number">0</a> <a id="3946" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="3948" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="3950" href="Interface.IsSet.html#476" class="Function Operator">∈</a> <a id="3952" href="Interface.IsSet.html#934" class="Function">dom</a> <a id="3956" href="Ledger.Certs.Haskell.html#1966" class="Generalizable">dReps</a><a id="3961" class="Symbol">)</a>
      <a id="3969" href="Interface.STS.html#350" class="Function Operator">────────────────────────────────</a>
      <a id="4008" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">⟦</a> <a id="4010" href="Ledger.Certs.Haskell.html#2501" class="Generalizable">e</a> <a id="4012" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="4014" href="Ledger.Certs.Haskell.html#3868" class="Bound">pp</a> <a id="4017" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="4019" href="Ledger.Certs.Haskell.html#2828" class="Generalizable">vs</a> <a id="4022" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="4024" href="Ledger.Certs.Haskell.html#2900" class="Generalizable">wdrls</a> <a id="4030" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">⟧ᶜ</a> <a id="4033" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">⊢</a>
      <a id="4041" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟦</a> <a id="4043" href="Ledger.Certs.Haskell.html#1966" class="Generalizable">dReps</a> <a id="4049" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4051" href="Ledger.Certs.Haskell.html#2312" class="Generalizable">ccKeys</a> <a id="4058" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4060" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a> <a id="4064" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟧ᵛ</a>
        <a id="4075" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">⇀⦇</a> <a id="4078" href="Ledger.Certs.html#1277" class="InductiveConstructor">regdrep</a> <a id="4086" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="4088" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a> <a id="4090" href="Ledger.Certs.Haskell.html#1935" class="Generalizable">an</a> <a id="4093" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">,GOVCERT⦈</a>
      <a id="4109" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟦</a> <a id="4111" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="4113" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="4115" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4117" href="Ledger.Certs.Haskell.html#2501" class="Generalizable">e</a> <a id="4119" href="Interface.HasAdd.html#135" class="Field Operator">+</a> <a id="4121" href="Ledger.PParams.html#3835" class="Field">drepActivity</a> <a id="4134" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a> <a id="4136" href="Axiom.Set.Map.html#6390" class="Function Operator">∪ˡ</a> <a id="4139" href="Ledger.Certs.Haskell.html#1966" class="Generalizable">dReps</a> <a id="4145" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4147" href="Ledger.Certs.Haskell.html#2312" class="Generalizable">ccKeys</a>
      <a id="4160" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4162" href="Ledger.Certs.Haskell.html#1716" class="Function">updateCertDeposit</a> <a id="4180" href="Ledger.Certs.Haskell.html#3868" class="Bound">pp</a> <a id="4183" class="Symbol">(</a><a id="4184" href="Ledger.Certs.html#1277" class="InductiveConstructor">regdrep</a> <a id="4192" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="4194" href="Ledger.Certs.Haskell.html#2472" class="Generalizable">d</a> <a id="4196" href="Ledger.Certs.Haskell.html#1935" class="Generalizable">an</a> <a id="4199" class="Symbol">)</a> <a id="4201" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a> <a id="4205" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟧ᵛ</a>

  <a id="_⊢_⇀⦇_,GOVCERT⦈_.GOVCERT-deregdrep"></a><a id="4211" href="Ledger.Certs.Haskell.html#4211" class="InductiveConstructor">GOVCERT-deregdrep</a> <a id="4229" class="Symbol">:</a>
    <a id="4235" href="Interface.STS.html#105" class="Function Operator">∙</a> <a id="4237" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="4239" href="Interface.IsSet.html#476" class="Function Operator">∈</a> <a id="4241" href="Interface.IsSet.html#934" class="Function">dom</a> <a id="4245" href="Ledger.Certs.Haskell.html#1966" class="Generalizable">dReps</a>
      <a id="4257" href="Interface.STS.html#350" class="Function Operator">────────────────────────────────</a>
      <a id="4296" href="Ledger.Certs.Haskell.html#2731" class="Generalizable">Γ</a> <a id="4298" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">⊢</a> <a id="4300" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟦</a> <a id="4302" href="Ledger.Certs.Haskell.html#1966" class="Generalizable">dReps</a> <a id="4308" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4310" href="Ledger.Certs.Haskell.html#2312" class="Generalizable">ccKeys</a> <a id="4317" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4319" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a> <a id="4323" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟧ᵛ</a>
          <a id="4336" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">⇀⦇</a> <a id="4339" href="Ledger.Certs.html#1328" class="InductiveConstructor">deregdrep</a> <a id="4349" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="4351" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">,GOVCERT⦈</a>
          <a id="4371" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟦</a> <a id="4373" href="Ledger.Certs.Haskell.html#1966" class="Generalizable">dReps</a> <a id="4379" href="Axiom.Set.Map.html#10177" class="Function Operator">∣</a> <a id="4381" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="4383" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="4385" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a> <a id="4387" href="Axiom.Set.Map.html#10177" class="Function Operator">ᶜ</a> <a id="4389" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4391" href="Ledger.Certs.Haskell.html#2312" class="Generalizable">ccKeys</a> <a id="4398" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4400" href="Ledger.Certs.Haskell.html#1716" class="Function">updateCertDeposit</a> <a id="4418" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="4421" class="Symbol">(</a><a id="4422" href="Ledger.Certs.html#1328" class="InductiveConstructor">deregdrep</a> <a id="4432" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a><a id="4433" class="Symbol">)</a> <a id="4435" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a> <a id="4439" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟧ᵛ</a>

  <a id="_⊢_⇀⦇_,GOVCERT⦈_.GOVCERT-ccreghot"></a><a id="4445" href="Ledger.Certs.Haskell.html#4445" class="InductiveConstructor">GOVCERT-ccreghot</a> <a id="4462" class="Symbol">:</a>
    <a id="4468" href="Interface.STS.html#105" class="Function Operator">∙</a> <a id="4470" class="Symbol">(</a><a id="4471" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="4473" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4475" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a><a id="4482" class="Symbol">)</a> <a id="4484" href="Interface.IsSet.html#480" class="Function Operator">∉</a> <a id="4486" href="Ledger.Certs.Haskell.html#2312" class="Generalizable">ccKeys</a>
      <a id="4499" href="Interface.STS.html#350" class="Function Operator">────────────────────────────────</a>
      <a id="4538" href="Ledger.Certs.Haskell.html#2731" class="Generalizable">Γ</a> <a id="4540" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">⊢</a> <a id="4542" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟦</a> <a id="4544" href="Ledger.Certs.Haskell.html#1966" class="Generalizable">dReps</a> <a id="4550" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4552" href="Ledger.Certs.Haskell.html#2312" class="Generalizable">ccKeys</a> <a id="4559" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4561" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a> <a id="4565" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟧ᵛ</a>
          <a id="4578" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">⇀⦇</a> <a id="4581" href="Ledger.Certs.html#1363" class="InductiveConstructor">ccreghot</a> <a id="4590" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="4592" href="Ledger.Certs.Haskell.html#2431" class="Generalizable">mc</a> <a id="4595" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">,GOVCERT⦈</a>
          <a id="4615" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟦</a> <a id="4617" href="Ledger.Certs.Haskell.html#1966" class="Generalizable">dReps</a> <a id="4623" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4625" href="Interface.HasSingleton.html#348" class="Field Operator">❴</a> <a id="4627" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="4629" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="4631" href="Ledger.Certs.Haskell.html#2431" class="Generalizable">mc</a> <a id="4634" href="Interface.HasSingleton.html#348" class="Field Operator">❵</a> <a id="4636" href="Axiom.Set.Map.html#6390" class="Function Operator">∪ˡ</a> <a id="4639" href="Ledger.Certs.Haskell.html#2312" class="Generalizable">ccKeys</a> <a id="4646" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="4648" href="Ledger.Certs.Haskell.html#1716" class="Function">updateCertDeposit</a> <a id="4666" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="4669" class="Symbol">(</a><a id="4670" href="Ledger.Certs.html#1363" class="InductiveConstructor">ccreghot</a> <a id="4679" href="Ledger.Certs.Haskell.html#2396" class="Generalizable">c</a> <a id="4681" href="Ledger.Certs.Haskell.html#2431" class="Generalizable">mc</a><a id="4683" class="Symbol">)</a> <a id="4685" href="Ledger.Certs.Haskell.html#2795" class="Generalizable">dep</a> <a id="4689" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟧ᵛ</a>

<a id="4693" class="Keyword">data</a> <a id="_⊢_⇀⦇_,CERT⦈_"></a><a id="4698" href="Ledger.Certs.Haskell.html#4698" class="Datatype Operator">_⊢_⇀⦇_,CERT⦈_</a> <a id="4712" class="Symbol">:</a> <a id="4714" href="Ledger.Certs.Haskell.html#424" class="Record">CertEnv</a> <a id="4722" class="Symbol">→</a> <a id="4724" href="Ledger.Certs.Haskell.html#965" class="Record">CertState</a> <a id="4734" class="Symbol">→</a> <a id="4736" href="Ledger.Certs.html#1056" class="Datatype">DCert</a> <a id="4742" class="Symbol">→</a> <a id="4744" href="Ledger.Certs.Haskell.html#965" class="Record">CertState</a> <a id="4754" class="Symbol">→</a> <a id="4756" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="4761" class="Keyword">where</a>
  <a id="_⊢_⇀⦇_,CERT⦈_.CERT-deleg"></a><a id="4769" href="Ledger.Certs.Haskell.html#4769" class="InductiveConstructor">CERT-deleg</a> <a id="4780" class="Symbol">:</a>
    <a id="4786" href="Interface.STS.html#105" class="Function Operator">∙</a> <a id="4788" href="Ledger.Certs.Haskell.html#1124" class="InductiveConstructor Operator">⟦</a> <a id="4790" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="4793" href="Ledger.Certs.Haskell.html#1124" class="InductiveConstructor Operator">,</a> <a id="4795" href="Ledger.Certs.html#2523" class="Field">PState.pools</a> <a id="4808" href="Ledger.Certs.Haskell.html#2700" class="Generalizable">stᵖ</a> <a id="4812" href="Ledger.Certs.Haskell.html#1124" class="InductiveConstructor Operator">⟧ᵈᵉ</a> <a id="4816" href="Ledger.Certs.Haskell.html#2943" class="Datatype Operator">⊢</a> <a id="4818" href="Ledger.Certs.Haskell.html#2669" class="Generalizable">stᵈ</a> <a id="4822" href="Ledger.Certs.Haskell.html#2943" class="Datatype Operator">⇀⦇</a> <a id="4825" href="Ledger.Certs.Haskell.html#2366" class="Generalizable">dCert</a> <a id="4831" href="Ledger.Certs.Haskell.html#2943" class="Datatype Operator">,DELEG⦈</a> <a id="4839" href="Ledger.Certs.Haskell.html#2673" class="Generalizable">stᵈ&#39;</a>
      <a id="4850" href="Interface.STS.html#350" class="Function Operator">────────────────────────────────</a>
      <a id="4889" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">⟦</a> <a id="4891" href="Ledger.Certs.Haskell.html#2501" class="Generalizable">e</a> <a id="4893" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="4895" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="4898" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="4900" href="Ledger.Certs.Haskell.html#2828" class="Generalizable">vs</a> <a id="4903" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="4905" href="Ledger.Certs.Haskell.html#2900" class="Generalizable">wdrls</a> <a id="4911" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">⟧ᶜ</a> <a id="4914" href="Ledger.Certs.Haskell.html#4698" class="Datatype Operator">⊢</a> <a id="4916" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟦</a> <a id="4918" href="Ledger.Certs.Haskell.html#2669" class="Generalizable">stᵈ</a> <a id="4922" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="4924" href="Ledger.Certs.Haskell.html#2700" class="Generalizable">stᵖ</a> <a id="4928" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="4930" href="Ledger.Certs.Haskell.html#2638" class="Generalizable">stᵍ</a> <a id="4934" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟧ᶜˢ</a> <a id="4938" href="Ledger.Certs.Haskell.html#4698" class="Datatype Operator">⇀⦇</a> <a id="4941" href="Ledger.Certs.Haskell.html#2366" class="Generalizable">dCert</a> <a id="4947" href="Ledger.Certs.Haskell.html#4698" class="Datatype Operator">,CERT⦈</a> <a id="4954" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟦</a> <a id="4956" href="Ledger.Certs.Haskell.html#2673" class="Generalizable">stᵈ&#39;</a> <a id="4961" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="4963" href="Ledger.Certs.Haskell.html#2700" class="Generalizable">stᵖ</a> <a id="4967" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="4969" href="Ledger.Certs.Haskell.html#2638" class="Generalizable">stᵍ</a> <a id="4973" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟧ᶜˢ</a>

  <a id="_⊢_⇀⦇_,CERT⦈_.CERT-pool"></a><a id="4980" href="Ledger.Certs.Haskell.html#4980" class="InductiveConstructor">CERT-pool</a> <a id="4990" class="Symbol">:</a>
    <a id="4996" href="Interface.STS.html#105" class="Function Operator">∙</a> <a id="4998" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="5001" href="Ledger.Certs.html#7790" class="Datatype Operator">⊢</a> <a id="5003" href="Ledger.Certs.Haskell.html#2700" class="Generalizable">stᵖ</a> <a id="5007" href="Ledger.Certs.html#7790" class="Datatype Operator">⇀⦇</a> <a id="5010" href="Ledger.Certs.Haskell.html#2366" class="Generalizable">dCert</a> <a id="5016" href="Ledger.Certs.html#7790" class="Datatype Operator">,POOL⦈</a> <a id="5023" href="Ledger.Certs.Haskell.html#2704" class="Generalizable">stᵖ&#39;</a>
      <a id="5034" href="Interface.STS.html#350" class="Function Operator">────────────────────────────────</a>
      <a id="5073" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">⟦</a> <a id="5075" href="Ledger.Certs.Haskell.html#2501" class="Generalizable">e</a> <a id="5077" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="5079" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="5082" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="5084" href="Ledger.Certs.Haskell.html#2828" class="Generalizable">vs</a> <a id="5087" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="5089" href="Ledger.Certs.Haskell.html#2900" class="Generalizable">wdrls</a> <a id="5095" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">⟧ᶜ</a> <a id="5098" href="Ledger.Certs.Haskell.html#4698" class="Datatype Operator">⊢</a> <a id="5100" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟦</a> <a id="5102" href="Ledger.Certs.Haskell.html#2669" class="Generalizable">stᵈ</a> <a id="5106" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="5108" href="Ledger.Certs.Haskell.html#2700" class="Generalizable">stᵖ</a> <a id="5112" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="5114" href="Ledger.Certs.Haskell.html#2638" class="Generalizable">stᵍ</a> <a id="5118" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟧ᶜˢ</a> <a id="5122" href="Ledger.Certs.Haskell.html#4698" class="Datatype Operator">⇀⦇</a> <a id="5125" href="Ledger.Certs.Haskell.html#2366" class="Generalizable">dCert</a> <a id="5131" href="Ledger.Certs.Haskell.html#4698" class="Datatype Operator">,CERT⦈</a> <a id="5138" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟦</a> <a id="5140" href="Ledger.Certs.Haskell.html#2669" class="Generalizable">stᵈ</a> <a id="5144" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="5146" href="Ledger.Certs.Haskell.html#2704" class="Generalizable">stᵖ&#39;</a> <a id="5151" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="5153" href="Ledger.Certs.Haskell.html#2638" class="Generalizable">stᵍ</a> <a id="5157" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟧ᶜˢ</a>

  <a id="_⊢_⇀⦇_,CERT⦈_.CERT-vdel"></a><a id="5164" href="Ledger.Certs.Haskell.html#5164" class="InductiveConstructor">CERT-vdel</a> <a id="5174" class="Symbol">:</a>
    <a id="5180" href="Interface.STS.html#105" class="Function Operator">∙</a> <a id="5182" href="Ledger.Certs.Haskell.html#2731" class="Generalizable">Γ</a> <a id="5184" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">⊢</a> <a id="5186" href="Ledger.Certs.Haskell.html#2638" class="Generalizable">stᵍ</a> <a id="5190" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">⇀⦇</a> <a id="5193" href="Ledger.Certs.Haskell.html#2366" class="Generalizable">dCert</a> <a id="5199" href="Ledger.Certs.Haskell.html#3776" class="Datatype Operator">,GOVCERT⦈</a> <a id="5209" href="Ledger.Certs.Haskell.html#2642" class="Generalizable">stᵍ&#39;</a>
      <a id="5220" href="Interface.STS.html#350" class="Function Operator">────────────────────────────────</a>
      <a id="5259" href="Ledger.Certs.Haskell.html#2731" class="Generalizable">Γ</a> <a id="5261" href="Ledger.Certs.Haskell.html#4698" class="Datatype Operator">⊢</a> <a id="5263" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟦</a> <a id="5265" href="Ledger.Certs.Haskell.html#2669" class="Generalizable">stᵈ</a> <a id="5269" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="5271" href="Ledger.Certs.Haskell.html#2700" class="Generalizable">stᵖ</a> <a id="5275" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="5277" href="Ledger.Certs.Haskell.html#2638" class="Generalizable">stᵍ</a> <a id="5281" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟧ᶜˢ</a> <a id="5285" href="Ledger.Certs.Haskell.html#4698" class="Datatype Operator">⇀⦇</a> <a id="5288" href="Ledger.Certs.Haskell.html#2366" class="Generalizable">dCert</a> <a id="5294" href="Ledger.Certs.Haskell.html#4698" class="Datatype Operator">,CERT⦈</a> <a id="5301" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟦</a> <a id="5303" href="Ledger.Certs.Haskell.html#2669" class="Generalizable">stᵈ</a> <a id="5307" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="5309" href="Ledger.Certs.Haskell.html#2700" class="Generalizable">stᵖ</a> <a id="5313" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="5315" href="Ledger.Certs.Haskell.html#2642" class="Generalizable">stᵍ&#39;</a> <a id="5320" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟧ᶜˢ</a>

<a id="5325" class="Keyword">data</a> <a id="_⊢_⇀⦇_,CERTBASE⦈_"></a><a id="5330" href="Ledger.Certs.Haskell.html#5330" class="Datatype Operator">_⊢_⇀⦇_,CERTBASE⦈_</a> <a id="5348" class="Symbol">:</a> <a id="5350" href="Ledger.Certs.Haskell.html#424" class="Record">CertEnv</a> <a id="5358" class="Symbol">→</a> <a id="5360" href="Ledger.Certs.Haskell.html#965" class="Record">CertState</a> <a id="5370" class="Symbol">→</a> <a id="5372" href="Agda.Builtin.Unit.html#175" class="Record">⊤</a> <a id="5374" class="Symbol">→</a> <a id="5376" href="Ledger.Certs.Haskell.html#965" class="Record">CertState</a> <a id="5386" class="Symbol">→</a> <a id="5388" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="5393" class="Keyword">where</a>
  <a id="_⊢_⇀⦇_,CERTBASE⦈_.CERT-base"></a><a id="5401" href="Ledger.Certs.Haskell.html#5401" class="InductiveConstructor">CERT-base</a> <a id="5411" class="Symbol">:</a>
    <a id="5417" class="Keyword">let</a> <a id="5421" class="Keyword">open</a> <a id="5426" href="Ledger.PParams.html#2073" class="Module">PParams</a> <a id="5434" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a>
        <a id="5445" href="Ledger.Certs.Haskell.html#5445" class="Bound">refresh</a>         <a id="5461" class="Symbol">=</a> <a id="5463" href="Axiom.Set.html#7518" class="Function">mapPartial</a> <a id="5474" href="Ledger.GovernanceActions.html#9448" class="Function">getDRepVote</a> <a id="5486" class="Symbol">(</a><a id="5487" href="Axiom.Set.html#5431" class="Function">fromList</a> <a id="5496" href="Ledger.Certs.Haskell.html#2828" class="Generalizable">vs</a><a id="5498" class="Symbol">)</a>
        <a id="5508" href="Ledger.Certs.Haskell.html#5508" class="Bound">refreshedDReps</a>  <a id="5524" class="Symbol">=</a> <a id="5526" href="Axiom.Set.Map.html#10346" class="Function">mapValueRestricted</a> <a id="5545" class="Symbol">(</a><a id="5546" href="Function.Base.html#725" class="Function">const</a> <a id="5552" class="Symbol">(</a><a id="5553" href="Ledger.Certs.Haskell.html#2501" class="Generalizable">e</a> <a id="5555" href="Interface.HasAdd.html#135" class="Field Operator">+</a> <a id="5557" href="Ledger.PParams.html#3835" class="Function">drepActivity</a><a id="5569" class="Symbol">))</a> <a id="5572" href="Ledger.Certs.Haskell.html#2225" class="Generalizable">dreps</a> <a id="5578" href="Ledger.Certs.Haskell.html#5445" class="Bound">refresh</a>
        <a id="5594" href="Ledger.Certs.Haskell.html#5594" class="Bound">wdrlCreds</a>       <a id="5610" class="Symbol">=</a> <a id="5612" href="Ledger.Set.Theory.html#413" class="Function">mapˢ</a> <a id="5617" href="Ledger.Address.html#1637" class="Field">stake</a> <a id="5623" class="Symbol">(</a><a id="5624" href="Interface.IsSet.html#934" class="Function">dom</a> <a id="5628" href="Ledger.Certs.Haskell.html#2900" class="Generalizable">wdrls</a><a id="5633" class="Symbol">)</a>
    <a id="5639" class="Keyword">in</a>
    <a id="5646" href="Interface.STS.html#105" class="Function Operator">∙</a> <a id="5648" href="Ledger.Certs.Haskell.html#5594" class="Bound">wdrlCreds</a> <a id="5658" href="Axiom.Set.html#1639" class="Function Operator">⊆</a> <a id="5660" href="Interface.IsSet.html#934" class="Function">dom</a> <a id="5664" href="Ledger.Certs.Haskell.html#2268" class="Generalizable">voteDelegs</a>
    <a id="5679" href="Interface.STS.html#131" class="Function Operator">∙</a> <a id="5681" href="Ledger.Set.Theory.html#413" class="Function">mapˢ</a> <a id="5686" class="Symbol">(</a><a id="5687" href="Class.Bifunctor.html#1036" class="Function">map₁</a> <a id="5692" href="Ledger.Address.html#1637" class="Field">stake</a><a id="5697" class="Symbol">)</a> <a id="5699" class="Symbol">(</a><a id="5700" href="Ledger.Certs.Haskell.html#2900" class="Generalizable">wdrls</a> <a id="5706" href="Axiom.Set.Map.html#2282" class="Function Operator">ˢ</a><a id="5707" class="Symbol">)</a> <a id="5709" href="Axiom.Set.html#1639" class="Function Operator">⊆</a> <a id="5711" href="Ledger.Certs.Haskell.html#2183" class="Generalizable">rewards</a> <a id="5719" href="Axiom.Set.Map.html#2282" class="Function Operator">ˢ</a>
      <a id="5727" href="Interface.STS.html#350" class="Function Operator">────────────────────────────────</a>
      <a id="5766" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">⟦</a> <a id="5768" href="Ledger.Certs.Haskell.html#2501" class="Generalizable">e</a> <a id="5770" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="5772" href="Ledger.Certs.Haskell.html#2763" class="Generalizable">pp</a> <a id="5775" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="5777" href="Ledger.Certs.Haskell.html#2828" class="Generalizable">vs</a> <a id="5780" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">,</a> <a id="5782" href="Ledger.Certs.Haskell.html#2900" class="Generalizable">wdrls</a> <a id="5788" href="Ledger.Certs.Haskell.html#459" class="InductiveConstructor Operator">⟧ᶜ</a> <a id="5791" href="Ledger.Certs.Haskell.html#5330" class="Datatype Operator">⊢</a>
      <a id="5799" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟦</a> <a id="5801" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟦</a> <a id="5803" href="Ledger.Certs.Haskell.html#2268" class="Generalizable">voteDelegs</a> <a id="5814" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="5816" href="Ledger.Certs.Haskell.html#2146" class="Generalizable">stakeDelegs</a> <a id="5828" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="5830" href="Ledger.Certs.Haskell.html#2183" class="Generalizable">rewards</a> <a id="5838" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="5840" href="Ledger.Certs.Haskell.html#2804" class="Generalizable">ddep</a> <a id="5845" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟧ᵈ</a>
      <a id="5854" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="5856" href="Ledger.Certs.Haskell.html#2700" class="Generalizable">stᵖ</a>
      <a id="5866" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="5868" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟦</a> <a id="5870" href="Ledger.Certs.Haskell.html#2225" class="Generalizable">dreps</a> <a id="5876" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="5878" href="Ledger.Certs.Haskell.html#2319" class="Generalizable">ccHotKeys</a> <a id="5888" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="5890" href="Ledger.Certs.Haskell.html#2799" class="Generalizable">gdep</a> <a id="5895" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟧ᵛ</a>
      <a id="5904" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟧ᶜˢ</a>
      <a id="5914" href="Ledger.Certs.Haskell.html#5330" class="Datatype Operator">⇀⦇</a> <a id="5917" class="Symbol">_</a> <a id="5919" href="Ledger.Certs.Haskell.html#5330" class="Datatype Operator">,CERTBASE⦈</a>
      <a id="5936" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟦</a> <a id="5938" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟦</a> <a id="5940" href="Ledger.Certs.Haskell.html#2268" class="Generalizable">voteDelegs</a> <a id="5951" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="5953" href="Ledger.Certs.Haskell.html#2146" class="Generalizable">stakeDelegs</a> <a id="5965" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="5967" href="Axiom.Set.Map.html#8835" class="Function">constMap</a> <a id="5976" href="Ledger.Certs.Haskell.html#5594" class="Bound">wdrlCreds</a> <a id="5986" class="Number">0</a> <a id="5988" href="Axiom.Set.Map.html#6390" class="Function Operator">∪ˡ</a> <a id="5991" href="Ledger.Certs.Haskell.html#2183" class="Generalizable">rewards</a> <a id="5999" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">,</a> <a id="6001" href="Ledger.Certs.Haskell.html#2804" class="Generalizable">ddep</a> <a id="6006" href="Ledger.Certs.Haskell.html#626" class="InductiveConstructor Operator">⟧ᵈ</a>
      <a id="6015" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="6017" href="Ledger.Certs.Haskell.html#2700" class="Generalizable">stᵖ</a>
      <a id="6027" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">,</a> <a id="6029" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟦</a> <a id="6031" href="Ledger.Certs.Haskell.html#5508" class="Bound">refreshedDReps</a> <a id="6046" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="6048" href="Ledger.Certs.Haskell.html#2319" class="Generalizable">ccHotKeys</a> <a id="6058" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">,</a> <a id="6060" href="Ledger.Certs.Haskell.html#2799" class="Generalizable">gdep</a> <a id="6065" href="Ledger.Certs.Haskell.html#831" class="InductiveConstructor Operator">⟧ᵛ</a>
      <a id="6074" href="Ledger.Certs.Haskell.html#1002" class="InductiveConstructor Operator">⟧ᶜˢ</a>

<a id="_⊢_⇀⦇_,CERTS⦈_"></a><a id="6079" href="Ledger.Certs.Haskell.html#6079" class="Function Operator">_⊢_⇀⦇_,CERTS⦈_</a>     <a id="6098" class="Symbol">:</a> <a id="6100" href="Ledger.Certs.Haskell.html#424" class="Record">CertEnv</a> <a id="6108" class="Symbol">→</a> <a id="6110" href="Ledger.Certs.Haskell.html#965" class="Record">CertState</a> <a id="6120" class="Symbol">→</a> <a id="6122" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="6127" href="Ledger.Certs.html#1056" class="Datatype">DCert</a> <a id="6133" class="Symbol">→</a> <a id="6135" href="Ledger.Certs.Haskell.html#965" class="Record">CertState</a> <a id="6145" class="Symbol">→</a> <a id="6147" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="6152" href="Ledger.Certs.Haskell.html#6079" class="Function Operator">_⊢_⇀⦇_,CERTS⦈_</a> <a id="6167" class="Symbol">=</a> <a id="6169" href="Interface.STS.html#3353" class="Function">ReflexiveTransitiveClosureᵇ</a> <a id="6197" href="Ledger.Certs.Haskell.html#5330" class="Datatype Operator">_⊢_⇀⦇_,CERTBASE⦈_</a> <a id="6215" href="Ledger.Certs.Haskell.html#4698" class="Datatype Operator">_⊢_⇀⦇_,CERT⦈_</a>
</pre></body></html>