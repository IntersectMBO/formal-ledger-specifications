<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Ledger.Introduction</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Background">\section{Introduction}
</a><a id="24" class="Markup">\begin{code}[hide]</a>
<a id="43" class="Symbol">{-#</a> <a id="47" class="Keyword">OPTIONS</a> <a id="55" class="Pragma">--safe</a> <a id="62" class="Symbol">#-}</a>

<a id="67" class="Keyword">open</a> <a id="72" class="Keyword">import</a> <a id="79" href="Axiom.Set.html" class="Module">Axiom.Set</a> <a id="89" class="Keyword">using</a> <a id="95" class="Symbol">(</a><a id="96" href="Axiom.Set.html#1442" class="Record">Theory</a><a id="102" class="Symbol">)</a>

<a id="105" class="Keyword">module</a> <a id="112" href="Ledger.Introduction.html" class="Module">Ledger.Introduction</a> <a id="132" class="Symbol">(</a><a id="133" href="Ledger.Introduction.html#133" class="Bound">th</a> <a id="136" class="Symbol">:</a> <a id="138" href="Axiom.Set.html#1442" class="Record">Theory</a><a id="144" class="Symbol">)</a> <a id="146" class="Keyword">where</a>

<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="Prelude.html" class="Module">Prelude</a>

<a id="174" class="Keyword">import</a> <a id="181" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="192" class="Symbol">as</a> <a id="195" class="Module">Maybe</a>
<a id="201" class="Keyword">open</a> <a id="206" class="Keyword">import</a> <a id="213" href="Data.Maybe.Properties.html" class="Module">Data.Maybe.Properties</a>
<a id="235" class="Keyword">open</a> <a id="240" class="Keyword">import</a> <a id="247" href="Interface.STS.html" class="Module">Interface.STS</a> <a id="261" class="Keyword">hiding</a> <a id="268" class="Symbol">(</a><a id="269" href="Interface.STS.html#1048" class="Datatype Operator">_⊢_⇀⟦_⟧*_</a><a id="278" class="Symbol">)</a>
<a id="280" class="Keyword">open</a> <a id="285" class="Keyword">import</a> <a id="292" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>

<a id="331" class="Keyword">private</a> <a id="339" class="Keyword">variable</a>
  <a id="350" href="Ledger.Introduction.html#350" class="Generalizable">C</a> <a id="352" href="Ledger.Introduction.html#352" class="Generalizable">S</a> <a id="354" href="Ledger.Introduction.html#354" class="Generalizable">Sig</a> <a id="358" class="Symbol">:</a> <a id="360" href="Agda.Primitive.html#388" class="Primitive">Type</a>
  <a id="367" href="Ledger.Introduction.html#367" class="Generalizable">Γ</a> <a id="369" class="Symbol">:</a> <a id="371" href="Ledger.Introduction.html#350" class="Generalizable">C</a>
  <a id="375" href="Ledger.Introduction.html#375" class="Generalizable">s</a> <a id="377" href="Ledger.Introduction.html#377" class="Generalizable">s&#39;</a> <a id="380" href="Ledger.Introduction.html#380" class="Generalizable">s&#39;&#39;</a> <a id="384" class="Symbol">:</a> <a id="386" href="Ledger.Introduction.html#352" class="Generalizable">S</a>
  <a id="390" href="Ledger.Introduction.html#390" class="Generalizable">b</a> <a id="392" href="Ledger.Introduction.html#392" class="Generalizable">sig</a> <a id="396" class="Symbol">:</a> <a id="398" href="Ledger.Introduction.html#354" class="Generalizable">Sig</a>
  <a id="404" href="Ledger.Introduction.html#404" class="Generalizable">sigs</a> <a id="409" class="Symbol">:</a> <a id="411" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="416" href="Ledger.Introduction.html#354" class="Generalizable">Sig</a>
<a id="420" class="Markup">\end{code}</a><a id="430" class="Background">

\begin{Conway}

This is the specification of the Conway era of the Cardano ledger. As
with previous specifications, this document is an incremental
specification, so everything that isn&#39;t defined here refers to the
most recent definition from an older specification.

Note: As of now, this specification is still a draft. Some details and
explanations may be missing or wrong.

\end{Conway}

\begin{NoConway}
\begin{center}
Repository: \url{https://github.com/IntersectMBO/formal-ledger-specifications}
\end{center}
This is the work-in-progress specification of the Cardano ledger. The
current status of each individual era is described in Table \ref{fig:eras-progress}.

\begin{longtable}[h!]{|l l l l|}
\hline
Era  &amp; Figures &amp; Prose &amp; Cleanup \\
\hline
\endhead
Shelley &amp; Partial &amp; Partial &amp; Not started \\
Shelley-MA &amp; Partial &amp; Partial &amp; Not started \\
Alonzo &amp; Partial &amp; Partial &amp; Not started \\
Babbage &amp; Not started &amp; Not started &amp; Not started \\
Conway \cite{cip1694} &amp; Complete &amp; Partial &amp; Partial \\
\hline
\caption{Specification progress}
\label{fig:eras-progress}
\end{longtable}
\end{NoConway}

\subsection{A Note on Agda}

This specification is written using the Agda programming language and
proof assistant \cite{agda2023}. We have spent a lot of time on making
this document readable for people unfamiliar with Agda (or other proof
assistants, functional programming languages, etc.). However, by the
nature of working in a formal language we have to play by its rules,
meaning that some instances of uncommon notation are very difficult or
impossible to avoid. Some are explained in
Section~\ref{sec:notation}, but there is no guarantee that this
section is complete. Anyone who is confused by the meaning of an
expression, please feel free to open an issue in our
\href{https://github.com/input-output-hk/formal-ledger-specifications/issues}{repository}
with the `notation&#39; label.

\subsection{Separation of Concerns}

The \emph{Cardano Node} consists of three pieces:

\begin{itemize}
  \item Networking layer, which deals with sending messages across the internet;
  \item Consensus layer, which establishes a common order of valid blocks;
  \item Ledger layer, which decides whether a sequence of blocks is valid.
\end{itemize}

Because of this separation, the ledger gets to be a state machine:
\[ s \xrightarrow[X]{b} s&#39; \]

More generally, we will consider state machines with an environment:
\[ Γ ⊢ s \xrightarrow[X]{b} s&#39; \]

These are modelled as 4-ary relations between the environment \(Γ\), an
initial state \(s\), a signal \(b\) and a final state \(s&#39;\). The ledger consists of
25-ish (depending on the version) such relations that depend on each
other, forming a directed graph that is almost a tree.  Thus each such relation
represents the transition rule of the state machine; \(X\) is simply a placeholder
for the name of the transition rule.

\subsection{Reflexive-transitive Closure}

Some STS (state transition system) relations need to be applied as
many times as they can to arrive at a final state. Since we use this
pattern multiple times, we define a closure operation which takes a
STS relation and applies it as many times as possible.

The closure \RTCI of a relation \RTCB is defined in Figure
\ref{fig:rt-closure}. In the remainder of the text, the closure
operation is called \RTC.

\begin{figure*}[h!]
</a><a id="3785" class="Markup">\begin{code}[hide]</a>
<a id="3804" class="Keyword">module</a> <a id="3811" href="Ledger.Introduction.html#3811" class="Module">_</a> <a id="3813" class="Symbol">(</a><a id="3814" href="Ledger.Introduction.html#3814" class="Bound Operator">_⊢_⇀⟦_⟧_</a> <a id="3823" class="Symbol">:</a> <a id="3825" href="Ledger.Introduction.html#350" class="Generalizable">C</a> <a id="3827" class="Symbol">→</a> <a id="3829" href="Ledger.Introduction.html#352" class="Generalizable">S</a> <a id="3831" class="Symbol">→</a> <a id="3833" href="Ledger.Introduction.html#354" class="Generalizable">Sig</a> <a id="3837" class="Symbol">→</a> <a id="3839" href="Ledger.Introduction.html#352" class="Generalizable">S</a> <a id="3841" class="Symbol">→</a> <a id="3843" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="3847" class="Symbol">)</a> <a id="3849" class="Keyword">where</a>
  <a id="3857" class="Keyword">data</a>
<a id="3862" class="Markup">\end{code}</a><a id="3872" class="Background">
\emph{Closure type}
</a><a id="3893" class="Markup">\begin{code}</a>
    <a id="3910" href="Ledger.Introduction.html#3910" class="Datatype Operator">_⊢_⇀⟦_⟧*_</a> <a id="3920" class="Symbol">:</a> <a id="3922" href="Ledger.Introduction.html#3825" class="Bound">C</a> <a id="3924" class="Symbol">→</a> <a id="3926" href="Ledger.Introduction.html#3829" class="Bound">S</a> <a id="3928" class="Symbol">→</a> <a id="3930" href="Agda.Builtin.List.html#147" class="Datatype">List</a> <a id="3935" href="Ledger.Introduction.html#3833" class="Bound">Sig</a> <a id="3939" class="Symbol">→</a> <a id="3941" href="Ledger.Introduction.html#3829" class="Bound">S</a> <a id="3943" class="Symbol">→</a> <a id="3945" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="3950" class="Markup">\end{code}</a><a id="3960" class="Background">
</a><a id="3961" class="Markup">\begin{code}[hide]</a>
    <a id="3984" class="Keyword">where</a>
<a id="3990" class="Markup">\end{code}</a><a id="4000" class="Background">
\emph{Closure rules}
</a><a id="4022" class="Markup">\begin{code}</a>
    <a id="4039" href="Ledger.Introduction.html#4039" class="InductiveConstructor">RTC-base</a> <a id="4048" class="Symbol">:</a>
      <a id="4056" href="Ledger.Introduction.html#367" class="Generalizable">Γ</a> <a id="4058" href="Ledger.Introduction.html#3910" class="Datatype Operator">⊢</a> <a id="4060" href="Ledger.Introduction.html#375" class="Generalizable">s</a> <a id="4062" href="Ledger.Introduction.html#3910" class="Datatype Operator">⇀⟦</a> <a id="4065" href="Agda.Builtin.List.html#184" class="InductiveConstructor">[]</a> <a id="4068" href="Ledger.Introduction.html#3910" class="Datatype Operator">⟧*</a> <a id="4071" href="Ledger.Introduction.html#375" class="Generalizable">s</a>

    <a id="4078" href="Ledger.Introduction.html#4078" class="InductiveConstructor">RTC-ind</a> <a id="4086" class="Symbol">:</a>
      <a id="4094" href="Interface.STS.html#105" class="Function Operator">∙</a> <a id="4096" href="Ledger.Introduction.html#367" class="Generalizable">Γ</a> <a id="4098" href="Ledger.Introduction.html#3814" class="Bound Operator">⊢</a> <a id="4100" href="Ledger.Introduction.html#375" class="Generalizable">s</a>  <a id="4103" href="Ledger.Introduction.html#3814" class="Bound Operator">⇀⟦</a> <a id="4106" href="Ledger.Introduction.html#392" class="Generalizable">sig</a>  <a id="4111" href="Ledger.Introduction.html#3814" class="Bound Operator">⟧</a>  <a id="4114" href="Ledger.Introduction.html#377" class="Generalizable">s&#39;</a>
      <a id="4123" href="Interface.STS.html#131" class="Function Operator">∙</a> <a id="4125" href="Ledger.Introduction.html#367" class="Generalizable">Γ</a> <a id="4127" href="Ledger.Introduction.html#3910" class="Datatype Operator">⊢</a> <a id="4129" href="Ledger.Introduction.html#377" class="Generalizable">s&#39;</a> <a id="4132" href="Ledger.Introduction.html#3910" class="Datatype Operator">⇀⟦</a> <a id="4135" href="Ledger.Introduction.html#404" class="Generalizable">sigs</a> <a id="4140" href="Ledger.Introduction.html#3910" class="Datatype Operator">⟧*</a> <a id="4143" href="Ledger.Introduction.html#380" class="Generalizable">s&#39;&#39;</a>
      <a id="4153" href="Interface.STS.html#659" class="Function Operator">───────────────────────────────────────</a>
      <a id="4199" href="Ledger.Introduction.html#367" class="Generalizable">Γ</a> <a id="4201" href="Ledger.Introduction.html#3910" class="Datatype Operator">⊢</a> <a id="4203" href="Ledger.Introduction.html#375" class="Generalizable">s</a> <a id="4205" href="Ledger.Introduction.html#3910" class="Datatype Operator">⇀⟦</a> <a id="4208" href="Ledger.Introduction.html#392" class="Generalizable">sig</a> <a id="4212" href="Agda.Builtin.List.html#199" class="InductiveConstructor Operator">∷</a> <a id="4214" href="Ledger.Introduction.html#404" class="Generalizable">sigs</a> <a id="4219" href="Ledger.Introduction.html#3910" class="Datatype Operator">⟧*</a> <a id="4222" href="Ledger.Introduction.html#380" class="Generalizable">s&#39;&#39;</a>
<a id="4226" class="Markup">\end{code}</a><a id="4236" class="Background">
\caption{Reflexive transitive closure}
\label{fig:rt-closure}
\end{figure*}

\subsection{Computational}

Since all such state machines need to be evaluated by the nodes and all
nodes should compute the same states, the relations specified by them
should be computable by functions. This can be captured by the
definition in Figure \ref{fig:computational} which is parametrized
over the state transition relation.

\begin{figure*}[h]
\begin{AgdaMultiCode}
</a><a id="4692" class="Markup">\begin{code}</a>
<a id="4705" class="Keyword">record</a> <a id="Computational"></a><a id="4712" href="Ledger.Introduction.html#4712" class="Record">Computational</a> <a id="4726" class="Symbol">(</a><a id="4727" href="Ledger.Introduction.html#4727" class="Bound Operator">_⊢_⇀⦇_,X⦈_</a> <a id="4738" class="Symbol">:</a> <a id="4740" href="Ledger.Introduction.html#350" class="Generalizable">C</a> <a id="4742" class="Symbol">→</a> <a id="4744" href="Ledger.Introduction.html#352" class="Generalizable">S</a> <a id="4746" class="Symbol">→</a> <a id="4748" href="Ledger.Introduction.html#354" class="Generalizable">Sig</a> <a id="4752" class="Symbol">→</a> <a id="4754" href="Ledger.Introduction.html#352" class="Generalizable">S</a> <a id="4756" class="Symbol">→</a> <a id="4758" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="4762" class="Symbol">)</a> <a id="4764" class="Symbol">:</a> <a id="4766" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="4771" class="Keyword">where</a>
<a id="4777" class="Markup">\end{code}</a><a id="4787" class="Background">
</a><a id="4788" class="Markup">\begin{code}[hide]</a>
  <a id="4809" class="Keyword">field</a>
<a id="4815" class="Markup">\end{code}</a><a id="4825" class="Background">
</a><a id="4826" class="Markup">\begin{code}</a>
    <a id="Computational.compute"></a><a id="4843" href="Ledger.Introduction.html#4843" class="Field">compute</a>     <a id="4855" class="Symbol">:</a> <a id="4857" href="Ledger.Introduction.html#4740" class="Bound">C</a> <a id="4859" class="Symbol">→</a> <a id="4861" href="Ledger.Introduction.html#4744" class="Bound">S</a> <a id="4863" class="Symbol">→</a> <a id="4865" href="Ledger.Introduction.html#4748" class="Bound">Sig</a> <a id="4869" class="Symbol">→</a> <a id="4871" href="Agda.Builtin.Maybe.html#135" class="Datatype">Maybe</a> <a id="4877" href="Ledger.Introduction.html#4744" class="Bound">S</a>
    <a id="Computational.≡-just⇔STS"></a><a id="4883" href="Ledger.Introduction.html#4883" class="Field">≡-just⇔STS</a>  <a id="4895" class="Symbol">:</a> <a id="4897" href="Ledger.Introduction.html#4843" class="Field">compute</a> <a id="4905" href="Ledger.Introduction.html#367" class="Generalizable">Γ</a> <a id="4907" href="Ledger.Introduction.html#375" class="Generalizable">s</a> <a id="4909" href="Ledger.Introduction.html#390" class="Generalizable">b</a> <a id="4911" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4913" href="Agda.Builtin.Maybe.html#173" class="InductiveConstructor">just</a> <a id="4918" href="Ledger.Introduction.html#377" class="Generalizable">s&#39;</a> <a id="4921" href="Function.Bundles.html#12039" class="Function Operator">⇔</a> <a id="4923" href="Ledger.Introduction.html#367" class="Generalizable">Γ</a> <a id="4925" href="Ledger.Introduction.html#4727" class="Bound Operator">⊢</a> <a id="4927" href="Ledger.Introduction.html#375" class="Generalizable">s</a> <a id="4929" href="Ledger.Introduction.html#4727" class="Bound Operator">⇀⦇</a> <a id="4932" href="Ledger.Introduction.html#390" class="Generalizable">b</a> <a id="4934" href="Ledger.Introduction.html#4727" class="Bound Operator">,X⦈</a> <a id="4938" href="Ledger.Introduction.html#377" class="Generalizable">s&#39;</a>

  <a id="Computational.nothing⇒∀¬STS"></a><a id="4944" href="Ledger.Introduction.html#4944" class="Function">nothing⇒∀¬STS</a> <a id="4958" class="Symbol">:</a> <a id="4960" href="Ledger.Introduction.html#4843" class="Field">compute</a> <a id="4968" href="Ledger.Introduction.html#367" class="Generalizable">Γ</a> <a id="4970" href="Ledger.Introduction.html#375" class="Generalizable">s</a> <a id="4972" href="Ledger.Introduction.html#390" class="Generalizable">b</a> <a id="4974" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="4976" href="Agda.Builtin.Maybe.html#194" class="InductiveConstructor">nothing</a> <a id="4984" class="Symbol">→</a> <a id="4986" class="Symbol">∀</a> <a id="4988" href="Ledger.Introduction.html#4988" class="Bound">s&#39;</a> <a id="4991" class="Symbol">→</a> <a id="4993" href="Relation.Nullary.Negation.Core.html#698" class="Function Operator">¬</a> <a id="4995" href="Ledger.Introduction.html#367" class="Generalizable">Γ</a> <a id="4997" href="Ledger.Introduction.html#4727" class="Bound Operator">⊢</a> <a id="4999" href="Ledger.Introduction.html#375" class="Generalizable">s</a> <a id="5001" href="Ledger.Introduction.html#4727" class="Bound Operator">⇀⦇</a> <a id="5004" href="Ledger.Introduction.html#390" class="Generalizable">b</a> <a id="5006" href="Ledger.Introduction.html#4727" class="Bound Operator">,X⦈</a> <a id="5010" href="Ledger.Introduction.html#4988" class="Bound">s&#39;</a>
<a id="5013" class="Markup">\end{code}</a><a id="5023" class="Background">
\end{AgdaMultiCode}
\caption{Computational relations}
\label{fig:computational}
\end{figure*}
</a><a id="5118" class="Markup">\begin{code}[hide]</a>
  <a id="5139" href="Ledger.Introduction.html#4944" class="Function">nothing⇒∀¬STS</a> <a id="5153" href="Ledger.Introduction.html#5153" class="Bound">comp≡nothing</a> <a id="5166" href="Ledger.Introduction.html#5166" class="Bound">s&#39;</a> <a id="5169" href="Ledger.Introduction.html#5169" class="Bound">h</a> <a id="5171" class="Keyword">rewrite</a> <a id="5179" href="Ledger.Introduction.html#4883" class="Field">≡-just⇔STS</a> <a id="5190" class="Symbol">.</a><a id="5191" href="Function.Bundles.html#4834" class="Field">Equivalence.from</a> <a id="5208" href="Ledger.Introduction.html#5169" class="Bound">h</a> <a id="5210" class="Symbol">=</a>
    <a id="5216" href="Function.Base.html#4042" class="Function Operator">case</a> <a id="5221" href="Ledger.Introduction.html#5153" class="Bound">comp≡nothing</a> <a id="5234" href="Function.Base.html#4042" class="Function Operator">of</a> <a id="5237" class="Symbol">λ</a> <a id="5239" class="Symbol">()</a>
<a id="5242" class="Markup">\end{code}</a><a id="5252" class="Background">

Unpacking this, we have a \compute function that computes a final
state from a given environment, state and signal. The second piece is
correctness: \compute succeeds with some final state if and only if
that final state is in relation to the inputs.

This has two further implications:

\begin{itemize}

\item Since \compute is a function, the state transition relation is necessarily
a (partial) function; i.e., there is at most one possible final state for each
input data. Otherwise, we could prove that \compute could evaluates to
two different states on the same inputs, which is impossible since it
is a function.

\item The actual definition of \compute is irrelevant---any two
implementations of \compute have to produce the same result on any
input. This is because we can simply chain the equivalences for two
different \compute functions together.

\end{itemize}

What this all means in the end is that if we give a \Computational
instance for every relation defined in the ledger, we also have an
executable version of the rules which is guaranteed to be
correct. This is indeed something we have done, and the same source
code that generates this document also generates a Haskell library
that lets anyone run this code.

\subsection{Sets \&amp; Maps}
\label{sec:sets-maps}

The ledger heavily uses set theory. For various reasons it was
necessary to implement our own set theory (there will be a paper on this
some time in the future). Crucially, the set theory is completely
abstract (in a technical sense---Agda has an abstract keyword) meaning
that implementation details of the set theory are
irrelevant. Additionally, all sets in this specification are finite.

We use this set theory to define maps as seen below, which are used in
many places. We usually think of maps as partial functions
(i.e., functions not necessarily defined everywhere---equivalently, &quot;left-unique&quot;
relations) and we use the harpoon arrow \AgdaFunction{⇀} to
distinguish such maps from standard Agda functions which use \AgdaSymbol{→}.
The figure below also gives notation for the powerset operation, \PowerSet,
used to form a type of sets with elements in a given type,
as well as the subset relation and the equality relation for sets.
\begin{figure*}[h]
</a><a id="7502" class="Markup">\begin{code}[hide]</a>
<a id="7521" class="Keyword">open</a> <a id="7526" href="Axiom.Set.html#1442" class="Module">Theory</a> <a id="7533" href="Ledger.Introduction.html#133" class="Bound">th</a> <a id="7536" class="Keyword">using</a> <a id="7542" class="Symbol">(</a><a id="7543" href="Axiom.Set.html#1556" class="Field Operator">_∈_</a><a id="7546" class="Symbol">)</a> <a id="7548" class="Keyword">renaming</a> <a id="7557" class="Symbol">(</a><a id="7558" href="Axiom.Set.html#1526" class="Field">Set</a> <a id="7562" class="Symbol">to</a> <a id="7565" class="Field">ℙ</a><a id="7566" class="Symbol">)</a>
<a id="7568" class="Keyword">private</a> <a id="7576" class="Keyword">variable</a>
  <a id="7587" href="Ledger.Introduction.html#7587" class="Generalizable">a</a> <a id="7589" href="Ledger.Introduction.html#7589" class="Generalizable">c</a> <a id="7591" class="Symbol">:</a> <a id="7593" href="Agda.Primitive.html#742" class="Postulate">Level</a>
  <a id="7601" href="Ledger.Introduction.html#7601" class="Generalizable">A</a> <a id="7603" class="Symbol">:</a> <a id="7605" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7610" href="Ledger.Introduction.html#7587" class="Generalizable">a</a>
<a id="Σ-syntax&#39;"></a><a id="7612" href="Ledger.Introduction.html#7612" class="Function">Σ-syntax&#39;</a> <a id="7622" class="Symbol">:</a> <a id="7624" class="Symbol">(</a><a id="7625" href="Ledger.Introduction.html#7625" class="Bound">A</a> <a id="7627" class="Symbol">:</a> <a id="7629" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7634" href="Ledger.Introduction.html#7587" class="Generalizable">a</a><a id="7635" class="Symbol">)</a> <a id="7637" class="Symbol">→</a> <a id="7639" class="Symbol">(</a><a id="7640" href="Ledger.Introduction.html#7625" class="Bound">A</a> <a id="7642" class="Symbol">→</a> <a id="7644" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7649" href="Ledger.Introduction.html#7589" class="Generalizable">c</a><a id="7650" class="Symbol">)</a> <a id="7652" class="Symbol">→</a> <a id="7654" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7659" class="Symbol">_</a>
<a id="7661" href="Ledger.Introduction.html#7612" class="Function">Σ-syntax&#39;</a> <a id="7671" class="Symbol">=</a> <a id="7673" href="Agda.Builtin.Sigma.html#165" class="Record">Σ</a>
<a id="7675" class="Keyword">syntax</a> <a id="7682" href="Ledger.Introduction.html#7612" class="Function">Σ-syntax&#39;</a> <a id="7692" class="Bound">A</a> <a id="7694" class="Symbol">(λ</a> <a id="7697" class="Bound">x</a> <a id="7699" class="Symbol">→</a> <a id="7701" class="Bound">B</a><a id="7702" class="Symbol">)</a> <a id="7704" class="Symbol">=</a> <a id="7706" class="Bound">x</a> <a id="7708" class="Function">∈</a> <a id="7710" class="Bound">A</a> <a id="7712" class="Function">﹐</a> <a id="7714" class="Bound">B</a>
<a id="7716" class="Markup">\end{code}</a><a id="7726" class="Background">
</a><a id="7727" class="Markup">\begin{code}</a>
<a id="_⊆_"></a><a id="7740" href="Ledger.Introduction.html#7740" class="Function Operator">_⊆_</a> <a id="7744" class="Symbol">:</a> <a id="7746" class="Symbol">{</a><a id="7747" href="Ledger.Introduction.html#7747" class="Bound">A</a> <a id="7749" class="Symbol">:</a> <a id="7751" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="7755" class="Symbol">}</a> <a id="7757" class="Symbol">→</a> <a id="7759" href="Ledger.Introduction.html#7565" class="Field">ℙ</a> <a id="7761" href="Ledger.Introduction.html#7747" class="Bound">A</a> <a id="7763" class="Symbol">→</a> <a id="7765" href="Ledger.Introduction.html#7565" class="Field">ℙ</a> <a id="7767" href="Ledger.Introduction.html#7747" class="Bound">A</a> <a id="7769" class="Symbol">→</a> <a id="7771" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="7776" href="Ledger.Introduction.html#7776" class="Bound">X</a> <a id="7778" href="Ledger.Introduction.html#7740" class="Function Operator">⊆</a> <a id="7780" href="Ledger.Introduction.html#7780" class="Bound">Y</a> <a id="7782" class="Symbol">=</a> <a id="7784" class="Symbol">∀</a> <a id="7786" class="Symbol">{</a><a id="7787" href="Ledger.Introduction.html#7787" class="Bound">x</a><a id="7788" class="Symbol">}</a> <a id="7790" class="Symbol">→</a> <a id="7792" href="Ledger.Introduction.html#7787" class="Bound">x</a> <a id="7794" href="Axiom.Set.html#1556" class="Field Operator">∈</a> <a id="7796" href="Ledger.Introduction.html#7776" class="Bound">X</a> <a id="7798" class="Symbol">→</a> <a id="7800" href="Ledger.Introduction.html#7787" class="Bound">x</a> <a id="7802" href="Axiom.Set.html#1556" class="Field Operator">∈</a> <a id="7804" href="Ledger.Introduction.html#7780" class="Bound">Y</a>

<a id="_≡ᵉ_"></a><a id="7807" href="Ledger.Introduction.html#7807" class="Function Operator">_≡ᵉ_</a> <a id="7812" class="Symbol">:</a> <a id="7814" class="Symbol">{</a><a id="7815" href="Ledger.Introduction.html#7815" class="Bound">A</a> <a id="7817" class="Symbol">:</a> <a id="7819" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="7823" class="Symbol">}</a> <a id="7825" class="Symbol">→</a> <a id="7827" href="Ledger.Introduction.html#7565" class="Field">ℙ</a> <a id="7829" href="Ledger.Introduction.html#7815" class="Bound">A</a> <a id="7831" class="Symbol">→</a> <a id="7833" href="Ledger.Introduction.html#7565" class="Field">ℙ</a> <a id="7835" href="Ledger.Introduction.html#7815" class="Bound">A</a> <a id="7837" class="Symbol">→</a> <a id="7839" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="7844" href="Ledger.Introduction.html#7844" class="Bound">X</a> <a id="7846" href="Ledger.Introduction.html#7807" class="Function Operator">≡ᵉ</a> <a id="7849" href="Ledger.Introduction.html#7849" class="Bound">Y</a> <a id="7851" class="Symbol">=</a> <a id="7853" href="Ledger.Introduction.html#7844" class="Bound">X</a> <a id="7855" href="Ledger.Introduction.html#7740" class="Function Operator">⊆</a> <a id="7857" href="Ledger.Introduction.html#7849" class="Bound">Y</a> <a id="7859" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7861" href="Ledger.Introduction.html#7849" class="Bound">Y</a> <a id="7863" href="Ledger.Introduction.html#7740" class="Function Operator">⊆</a> <a id="7865" href="Ledger.Introduction.html#7844" class="Bound">X</a>

<a id="Rel"></a><a id="7868" href="Ledger.Introduction.html#7868" class="Function">Rel</a> <a id="7872" class="Symbol">:</a> <a id="7874" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7879" class="Symbol">→</a> <a id="7881" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="7886" class="Symbol">→</a> <a id="7888" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="7893" href="Ledger.Introduction.html#7868" class="Function">Rel</a> <a id="7897" href="Ledger.Introduction.html#7897" class="Bound">A</a> <a id="7899" href="Ledger.Introduction.html#7899" class="Bound">B</a> <a id="7901" class="Symbol">=</a> <a id="7903" href="Ledger.Introduction.html#7565" class="Field">ℙ</a> <a id="7905" class="Symbol">(</a><a id="7906" href="Ledger.Introduction.html#7897" class="Bound">A</a> <a id="7908" href="Data.Product.Base.html#1618" class="Function Operator">×</a> <a id="7910" href="Ledger.Introduction.html#7899" class="Bound">B</a><a id="7911" class="Symbol">)</a>

<a id="left-unique"></a><a id="7914" href="Ledger.Introduction.html#7914" class="Function">left-unique</a> <a id="7926" class="Symbol">:</a> <a id="7928" class="Symbol">{</a><a id="7929" href="Ledger.Introduction.html#7929" class="Bound">A</a> <a id="7931" href="Ledger.Introduction.html#7931" class="Bound">B</a> <a id="7933" class="Symbol">:</a> <a id="7935" href="Agda.Primitive.html#388" class="Primitive">Type</a><a id="7939" class="Symbol">}</a> <a id="7941" class="Symbol">→</a> <a id="7943" href="Ledger.Introduction.html#7868" class="Function">Rel</a> <a id="7947" href="Ledger.Introduction.html#7929" class="Bound">A</a> <a id="7949" href="Ledger.Introduction.html#7931" class="Bound">B</a> <a id="7951" class="Symbol">→</a> <a id="7953" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="7958" href="Ledger.Introduction.html#7914" class="Function">left-unique</a> <a id="7970" href="Ledger.Introduction.html#7970" class="Bound">R</a> <a id="7972" class="Symbol">=</a> <a id="7974" class="Symbol">∀</a> <a id="7976" class="Symbol">{</a><a id="7977" href="Ledger.Introduction.html#7977" class="Bound">a</a> <a id="7979" href="Ledger.Introduction.html#7979" class="Bound">b</a> <a id="7981" href="Ledger.Introduction.html#7981" class="Bound">b&#39;</a><a id="7983" class="Symbol">}</a> <a id="7985" class="Symbol">→</a> <a id="7987" class="Symbol">(</a><a id="7988" href="Ledger.Introduction.html#7977" class="Bound">a</a> <a id="7990" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="7992" href="Ledger.Introduction.html#7979" class="Bound">b</a><a id="7993" class="Symbol">)</a> <a id="7995" href="Axiom.Set.html#1556" class="Field Operator">∈</a> <a id="7997" href="Ledger.Introduction.html#7970" class="Bound">R</a> <a id="7999" class="Symbol">→</a> <a id="8001" class="Symbol">(</a><a id="8002" href="Ledger.Introduction.html#7977" class="Bound">a</a> <a id="8004" href="Agda.Builtin.Sigma.html#235" class="InductiveConstructor Operator">,</a> <a id="8006" href="Ledger.Introduction.html#7981" class="Bound">b&#39;</a><a id="8008" class="Symbol">)</a> <a id="8010" href="Axiom.Set.html#1556" class="Field Operator">∈</a> <a id="8012" href="Ledger.Introduction.html#7970" class="Bound">R</a> <a id="8014" class="Symbol">→</a> <a id="8016" href="Ledger.Introduction.html#7979" class="Bound">b</a> <a id="8018" href="Agda.Builtin.Equality.html#150" class="Datatype Operator">≡</a> <a id="8020" href="Ledger.Introduction.html#7981" class="Bound">b&#39;</a>

<a id="_⇀_"></a><a id="8024" href="Ledger.Introduction.html#8024" class="Function Operator">_⇀_</a> <a id="8028" class="Symbol">:</a> <a id="8030" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="8035" class="Symbol">→</a> <a id="8037" href="Agda.Primitive.html#388" class="Primitive">Type</a> <a id="8042" class="Symbol">→</a> <a id="8044" href="Agda.Primitive.html#388" class="Primitive">Type</a>
<a id="8049" href="Ledger.Introduction.html#8049" class="Bound">A</a> <a id="8051" href="Ledger.Introduction.html#8024" class="Function Operator">⇀</a> <a id="8053" href="Ledger.Introduction.html#8053" class="Bound">B</a> <a id="8055" class="Symbol">=</a> <a id="8057" href="Ledger.Introduction.html#8057" class="Bound">r</a> <a id="8059" href="Ledger.Introduction.html#7612" class="Function">∈</a> <a id="8061" href="Ledger.Introduction.html#7868" class="Function">Rel</a> <a id="8065" href="Ledger.Introduction.html#8049" class="Bound">A</a> <a id="8067" href="Ledger.Introduction.html#8053" class="Bound">B</a> <a id="8069" href="Ledger.Introduction.html#7612" class="Function">﹐</a> <a id="8071" href="Ledger.Introduction.html#7914" class="Function">left-unique</a> <a id="8083" href="Ledger.Introduction.html#8057" class="Bound">r</a>
<a id="8085" class="Markup">\end{code}</a><a id="8095" class="Background">
\end{figure*}

\subsection{Propositions as Types, Properties and Relations}

In type theory we represent propositions as types and proofs of a proposition as
elements of the corresponding type.
A unary predicate is a function that takes each \AgdaBound{x} (of some type \AgdaBound{A}) and
returns a proposition \AgdaFunction{P}(\AgdaBound{x}). Thus, a predicate is a function of type
\AgdaBound{A}~\AgdaSymbol{→}~\Type.
A \textit{binary relation} \AgdaFunction{R} between \AgdaBound{A} and \AgdaBound{B} is a
function that takes a pair of values \AgdaBound{x} and \AgdaBound{y} and returns a proposition
asserting that the relation \AgdaFunction{R} holds between \AgdaBound{x} and \AgdaBound{y}.
Thus, such a relation is a function of type \AgdaBound{A}~\AgdaFunction{×}~\AgdaBound{B}~\AgdaSymbol{→}~\Type
or \AgdaBound{A}~\AgdaSymbol{→}~\AgdaBound{B}~\AgdaSymbol{→}~\Type.

\subsection{Superscripts and Other Special Notations}

In the current version of this specification, superscript letters are
heavily used for things such as disambiguations or type
conversions. These are essentially meaningless, only present for
technical reasons and can safely be ignored. However there are the
two exceptions:
\begin{itemize}
\item \AgdaFunction{∪ˡ} for left-biased union
\item \AgdaFunction{ᶜ} in the context of set restrictions, where it indicates the complement
\end{itemize}
Also, non-letter superscripts do carry meaning.\footnote{At some point in the future we
  hope to be able to remove all those non-essential superscripts.  Since we prefer doing
  this by changing the Agda source code instead of via hiding them in this document, this
  is a non-trivial problem that will take some time to address.}

Finally, there are some \AgdaFunction{?} and \AgdaFunction{¿} operations.
These relate to decision procedures and can also safely be ignored.\footnote{We
  plan on refactoring the code so that these special symbols will also disappear
  from this document.}
</a></pre></body></html>